function vJ(n, e) {
  for (var t = 0; t < e.length; t++) {
    const s = e[t];
    if (typeof s != "string" && !Array.isArray(s)) {
      for (const r in s)
        if (r !== "default" && !(r in n)) {
          const i = Object.getOwnPropertyDescriptor(s, r);
          i &&
            Object.defineProperty(
              n,
              r,
              i.get ? i : { enumerable: !0, get: () => s[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r);
  new MutationObserver((r) => {
    for (const i of r)
      if (i.type === "childList")
        for (const a of i.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && s(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const i = {};
    return (
      r.integrity && (i.integrity = r.integrity),
      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (i.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (i.credentials = "omit")
        : (i.credentials = "same-origin"),
      i
    );
  }
  function s(r) {
    if (r.ep) return;
    r.ep = !0;
    const i = t(r);
    fetch(r.href, i);
  }
})();
var Yn =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function ad(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function yJ(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function s() {
      var r = !1;
      try {
        r = this instanceof s;
      } catch {}
      return r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (s) {
      var r = Object.getOwnPropertyDescriptor(n, s);
      Object.defineProperty(
        t,
        s,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[s];
              },
            }
      );
    }),
    t
  );
}
var T_ = { exports: {} },
  Wm = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var KO;
function bJ() {
  if (KO) return Wm;
  KO = 1;
  var n = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.fragment");
  function t(s, r, i) {
    var a = null;
    if (
      (i !== void 0 && (a = "" + i),
      r.key !== void 0 && (a = "" + r.key),
      "key" in r)
    ) {
      i = {};
      for (var o in r) o !== "key" && (i[o] = r[o]);
    } else i = r;
    return (
      (r = i.ref),
      { $$typeof: n, type: s, key: a, ref: r !== void 0 ? r : null, props: i }
    );
  }
  return (Wm.Fragment = e), (Wm.jsx = t), (Wm.jsxs = t), Wm;
}
var YO;
function xJ() {
  return YO || ((YO = 1), (T_.exports = bJ())), T_.exports;
}
var u = xJ(),
  __ = { exports: {} },
  Km = {},
  A_ = { exports: {} },
  R_ = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var XO;
function wJ() {
  return (
    XO ||
      ((XO = 1),
      (function (n) {
        function e(O, U) {
          var j = O.length;
          O.push(U);
          e: for (; 0 < j; ) {
            var Q = (j - 1) >>> 1,
              M = O[Q];
            if (0 < r(M, U)) (O[Q] = U), (O[j] = M), (j = Q);
            else break e;
          }
        }
        function t(O) {
          return O.length === 0 ? null : O[0];
        }
        function s(O) {
          if (O.length === 0) return null;
          var U = O[0],
            j = O.pop();
          if (j !== U) {
            O[0] = j;
            e: for (var Q = 0, M = O.length, I = M >>> 1; Q < I; ) {
              var F = 2 * (Q + 1) - 1,
                Y = O[F],
                J = F + 1,
                X = O[J];
              if (0 > r(Y, j))
                J < M && 0 > r(X, Y)
                  ? ((O[Q] = X), (O[J] = j), (Q = J))
                  : ((O[Q] = Y), (O[F] = j), (Q = F));
              else if (J < M && 0 > r(X, j)) (O[Q] = X), (O[J] = j), (Q = J);
              else break e;
            }
          }
          return U;
        }
        function r(O, U) {
          var j = O.sortIndex - U.sortIndex;
          return j !== 0 ? j : O.id - U.id;
        }
        if (
          ((n.unstable_now = void 0),
          typeof performance == "object" &&
            typeof performance.now == "function")
        ) {
          var i = performance;
          n.unstable_now = function () {
            return i.now();
          };
        } else {
          var a = Date,
            o = a.now();
          n.unstable_now = function () {
            return a.now() - o;
          };
        }
        var l = [],
          c = [],
          h = 1,
          m = null,
          p = 3,
          g = !1,
          y = !1,
          b = !1,
          w = !1,
          S = typeof setTimeout == "function" ? setTimeout : null,
          A = typeof clearTimeout == "function" ? clearTimeout : null,
          _ = typeof setImmediate < "u" ? setImmediate : null;
        function R(O) {
          for (var U = t(c); U !== null; ) {
            if (U.callback === null) s(c);
            else if (U.startTime <= O)
              s(c), (U.sortIndex = U.expirationTime), e(l, U);
            else break;
            U = t(c);
          }
        }
        function C(O) {
          if (((b = !1), R(O), !y))
            if (t(l) !== null) (y = !0), D || ((D = !0), H());
            else {
              var U = t(c);
              U !== null && q(C, U.startTime - O);
            }
        }
        var D = !1,
          L = -1,
          P = 5,
          V = -1;
        function N() {
          return w ? !0 : !(n.unstable_now() - V < P);
        }
        function W() {
          if (((w = !1), D)) {
            var O = n.unstable_now();
            V = O;
            var U = !0;
            try {
              e: {
                (y = !1), b && ((b = !1), A(L), (L = -1)), (g = !0);
                var j = p;
                try {
                  t: {
                    for (
                      R(O), m = t(l);
                      m !== null && !(m.expirationTime > O && N());

                    ) {
                      var Q = m.callback;
                      if (typeof Q == "function") {
                        (m.callback = null), (p = m.priorityLevel);
                        var M = Q(m.expirationTime <= O);
                        if (((O = n.unstable_now()), typeof M == "function")) {
                          (m.callback = M), R(O), (U = !0);
                          break t;
                        }
                        m === t(l) && s(l), R(O);
                      } else s(l);
                      m = t(l);
                    }
                    if (m !== null) U = !0;
                    else {
                      var I = t(c);
                      I !== null && q(C, I.startTime - O), (U = !1);
                    }
                  }
                  break e;
                } finally {
                  (m = null), (p = j), (g = !1);
                }
                U = void 0;
              }
            } finally {
              U ? H() : (D = !1);
            }
          }
        }
        var H;
        if (typeof _ == "function")
          H = function () {
            _(W);
          };
        else if (typeof MessageChannel < "u") {
          var z = new MessageChannel(),
            B = z.port2;
          (z.port1.onmessage = W),
            (H = function () {
              B.postMessage(null);
            });
        } else
          H = function () {
            S(W, 0);
          };
        function q(O, U) {
          L = S(function () {
            O(n.unstable_now());
          }, U);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (O) {
            O.callback = null;
          }),
          (n.unstable_forceFrameRate = function (O) {
            0 > O || 125 < O
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (P = 0 < O ? Math.floor(1e3 / O) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (n.unstable_next = function (O) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var U = 3;
                break;
              default:
                U = p;
            }
            var j = p;
            p = U;
            try {
              return O();
            } finally {
              p = j;
            }
          }),
          (n.unstable_requestPaint = function () {
            w = !0;
          }),
          (n.unstable_runWithPriority = function (O, U) {
            switch (O) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                O = 3;
            }
            var j = p;
            p = O;
            try {
              return U();
            } finally {
              p = j;
            }
          }),
          (n.unstable_scheduleCallback = function (O, U, j) {
            var Q = n.unstable_now();
            switch (
              (typeof j == "object" && j !== null
                ? ((j = j.delay),
                  (j = typeof j == "number" && 0 < j ? Q + j : Q))
                : (j = Q),
              O)
            ) {
              case 1:
                var M = -1;
                break;
              case 2:
                M = 250;
                break;
              case 5:
                M = 1073741823;
                break;
              case 4:
                M = 1e4;
                break;
              default:
                M = 5e3;
            }
            return (
              (M = j + M),
              (O = {
                id: h++,
                callback: U,
                priorityLevel: O,
                startTime: j,
                expirationTime: M,
                sortIndex: -1,
              }),
              j > Q
                ? ((O.sortIndex = j),
                  e(c, O),
                  t(l) === null &&
                    O === t(c) &&
                    (b ? (A(L), (L = -1)) : (b = !0), q(C, j - Q)))
                : ((O.sortIndex = M),
                  e(l, O),
                  y || g || ((y = !0), D || ((D = !0), H()))),
              O
            );
          }),
          (n.unstable_shouldYield = N),
          (n.unstable_wrapCallback = function (O) {
            var U = p;
            return function () {
              var j = p;
              p = U;
              try {
                return O.apply(this, arguments);
              } finally {
                p = j;
              }
            };
          });
      })(R_)),
    R_
  );
}
var QO;
function EJ() {
  return QO || ((QO = 1), (A_.exports = wJ())), A_.exports;
}
var k_ = { exports: {} },
  Gt = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ZO;
function SJ() {
  if (ZO) return Gt;
  ZO = 1;
  var n = Symbol.for("react.transitional.element"),
    e = Symbol.for("react.portal"),
    t = Symbol.for("react.fragment"),
    s = Symbol.for("react.strict_mode"),
    r = Symbol.for("react.profiler"),
    i = Symbol.for("react.consumer"),
    a = Symbol.for("react.context"),
    o = Symbol.for("react.forward_ref"),
    l = Symbol.for("react.suspense"),
    c = Symbol.for("react.memo"),
    h = Symbol.for("react.lazy"),
    m = Symbol.iterator;
  function p(M) {
    return M === null || typeof M != "object"
      ? null
      : ((M = (m && M[m]) || M["@@iterator"]),
        typeof M == "function" ? M : null);
  }
  var g = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    y = Object.assign,
    b = {};
  function w(M, I, F) {
    (this.props = M),
      (this.context = I),
      (this.refs = b),
      (this.updater = F || g);
  }
  (w.prototype.isReactComponent = {}),
    (w.prototype.setState = function (M, I) {
      if (typeof M != "object" && typeof M != "function" && M != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, M, I, "setState");
    }),
    (w.prototype.forceUpdate = function (M) {
      this.updater.enqueueForceUpdate(this, M, "forceUpdate");
    });
  function S() {}
  S.prototype = w.prototype;
  function A(M, I, F) {
    (this.props = M),
      (this.context = I),
      (this.refs = b),
      (this.updater = F || g);
  }
  var _ = (A.prototype = new S());
  (_.constructor = A), y(_, w.prototype), (_.isPureReactComponent = !0);
  var R = Array.isArray,
    C = { H: null, A: null, T: null, S: null, V: null },
    D = Object.prototype.hasOwnProperty;
  function L(M, I, F, Y, J, X) {
    return (
      (F = X.ref),
      { $$typeof: n, type: M, key: I, ref: F !== void 0 ? F : null, props: X }
    );
  }
  function P(M, I) {
    return L(M.type, I, void 0, void 0, void 0, M.props);
  }
  function V(M) {
    return typeof M == "object" && M !== null && M.$$typeof === n;
  }
  function N(M) {
    var I = { "=": "=0", ":": "=2" };
    return (
      "$" +
      M.replace(/[=:]/g, function (F) {
        return I[F];
      })
    );
  }
  var W = /\/+/g;
  function H(M, I) {
    return typeof M == "object" && M !== null && M.key != null
      ? N("" + M.key)
      : I.toString(36);
  }
  function z() {}
  function B(M) {
    switch (M.status) {
      case "fulfilled":
        return M.value;
      case "rejected":
        throw M.reason;
      default:
        switch (
          (typeof M.status == "string"
            ? M.then(z, z)
            : ((M.status = "pending"),
              M.then(
                function (I) {
                  M.status === "pending" &&
                    ((M.status = "fulfilled"), (M.value = I));
                },
                function (I) {
                  M.status === "pending" &&
                    ((M.status = "rejected"), (M.reason = I));
                }
              )),
          M.status)
        ) {
          case "fulfilled":
            return M.value;
          case "rejected":
            throw M.reason;
        }
    }
    throw M;
  }
  function q(M, I, F, Y, J) {
    var X = typeof M;
    (X === "undefined" || X === "boolean") && (M = null);
    var Z = !1;
    if (M === null) Z = !0;
    else
      switch (X) {
        case "bigint":
        case "string":
        case "number":
          Z = !0;
          break;
        case "object":
          switch (M.$$typeof) {
            case n:
            case e:
              Z = !0;
              break;
            case h:
              return (Z = M._init), q(Z(M._payload), I, F, Y, J);
          }
      }
    if (Z)
      return (
        (J = J(M)),
        (Z = Y === "" ? "." + H(M, 0) : Y),
        R(J)
          ? ((F = ""),
            Z != null && (F = Z.replace(W, "$&/") + "/"),
            q(J, I, F, "", function (pe) {
              return pe;
            }))
          : J != null &&
            (V(J) &&
              (J = P(
                J,
                F +
                  (J.key == null || (M && M.key === J.key)
                    ? ""
                    : ("" + J.key).replace(W, "$&/") + "/") +
                  Z
              )),
            I.push(J)),
        1
      );
    Z = 0;
    var te = Y === "" ? "." : Y + ":";
    if (R(M))
      for (var ce = 0; ce < M.length; ce++)
        (Y = M[ce]), (X = te + H(Y, ce)), (Z += q(Y, I, F, X, J));
    else if (((ce = p(M)), typeof ce == "function"))
      for (M = ce.call(M), ce = 0; !(Y = M.next()).done; )
        (Y = Y.value), (X = te + H(Y, ce++)), (Z += q(Y, I, F, X, J));
    else if (X === "object") {
      if (typeof M.then == "function") return q(B(M), I, F, Y, J);
      throw (
        ((I = String(M)),
        Error(
          "Objects are not valid as a React child (found: " +
            (I === "[object Object]"
              ? "object with keys {" + Object.keys(M).join(", ") + "}"
              : I) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    }
    return Z;
  }
  function O(M, I, F) {
    if (M == null) return M;
    var Y = [],
      J = 0;
    return (
      q(M, Y, "", "", function (X) {
        return I.call(F, X, J++);
      }),
      Y
    );
  }
  function U(M) {
    if (M._status === -1) {
      var I = M._result;
      (I = I()),
        I.then(
          function (F) {
            (M._status === 0 || M._status === -1) &&
              ((M._status = 1), (M._result = F));
          },
          function (F) {
            (M._status === 0 || M._status === -1) &&
              ((M._status = 2), (M._result = F));
          }
        ),
        M._status === -1 && ((M._status = 0), (M._result = I));
    }
    if (M._status === 1) return M._result.default;
    throw M._result;
  }
  var j =
    typeof reportError == "function"
      ? reportError
      : function (M) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var I = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof M == "object" &&
                M !== null &&
                typeof M.message == "string"
                  ? String(M.message)
                  : String(M),
              error: M,
            });
            if (!window.dispatchEvent(I)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", M);
            return;
          }
          console.error(M);
        };
  function Q() {}
  return (
    (Gt.Children = {
      map: O,
      forEach: function (M, I, F) {
        O(
          M,
          function () {
            I.apply(this, arguments);
          },
          F
        );
      },
      count: function (M) {
        var I = 0;
        return (
          O(M, function () {
            I++;
          }),
          I
        );
      },
      toArray: function (M) {
        return (
          O(M, function (I) {
            return I;
          }) || []
        );
      },
      only: function (M) {
        if (!V(M))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return M;
      },
    }),
    (Gt.Component = w),
    (Gt.Fragment = t),
    (Gt.Profiler = r),
    (Gt.PureComponent = A),
    (Gt.StrictMode = s),
    (Gt.Suspense = l),
    (Gt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = C),
    (Gt.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (M) {
        return C.H.useMemoCache(M);
      },
    }),
    (Gt.cache = function (M) {
      return function () {
        return M.apply(null, arguments);
      };
    }),
    (Gt.cloneElement = function (M, I, F) {
      if (M == null)
        throw Error(
          "The argument must be a React element, but you passed " + M + "."
        );
      var Y = y({}, M.props),
        J = M.key,
        X = void 0;
      if (I != null)
        for (Z in (I.ref !== void 0 && (X = void 0),
        I.key !== void 0 && (J = "" + I.key),
        I))
          !D.call(I, Z) ||
            Z === "key" ||
            Z === "__self" ||
            Z === "__source" ||
            (Z === "ref" && I.ref === void 0) ||
            (Y[Z] = I[Z]);
      var Z = arguments.length - 2;
      if (Z === 1) Y.children = F;
      else if (1 < Z) {
        for (var te = Array(Z), ce = 0; ce < Z; ce++)
          te[ce] = arguments[ce + 2];
        Y.children = te;
      }
      return L(M.type, J, void 0, void 0, X, Y);
    }),
    (Gt.createContext = function (M) {
      return (
        (M = {
          $$typeof: a,
          _currentValue: M,
          _currentValue2: M,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        }),
        (M.Provider = M),
        (M.Consumer = { $$typeof: i, _context: M }),
        M
      );
    }),
    (Gt.createElement = function (M, I, F) {
      var Y,
        J = {},
        X = null;
      if (I != null)
        for (Y in (I.key !== void 0 && (X = "" + I.key), I))
          D.call(I, Y) &&
            Y !== "key" &&
            Y !== "__self" &&
            Y !== "__source" &&
            (J[Y] = I[Y]);
      var Z = arguments.length - 2;
      if (Z === 1) J.children = F;
      else if (1 < Z) {
        for (var te = Array(Z), ce = 0; ce < Z; ce++)
          te[ce] = arguments[ce + 2];
        J.children = te;
      }
      if (M && M.defaultProps)
        for (Y in ((Z = M.defaultProps), Z)) J[Y] === void 0 && (J[Y] = Z[Y]);
      return L(M, X, void 0, void 0, null, J);
    }),
    (Gt.createRef = function () {
      return { current: null };
    }),
    (Gt.forwardRef = function (M) {
      return { $$typeof: o, render: M };
    }),
    (Gt.isValidElement = V),
    (Gt.lazy = function (M) {
      return { $$typeof: h, _payload: { _status: -1, _result: M }, _init: U };
    }),
    (Gt.memo = function (M, I) {
      return { $$typeof: c, type: M, compare: I === void 0 ? null : I };
    }),
    (Gt.startTransition = function (M) {
      var I = C.T,
        F = {};
      C.T = F;
      try {
        var Y = M(),
          J = C.S;
        J !== null && J(F, Y),
          typeof Y == "object" &&
            Y !== null &&
            typeof Y.then == "function" &&
            Y.then(Q, j);
      } catch (X) {
        j(X);
      } finally {
        C.T = I;
      }
    }),
    (Gt.unstable_useCacheRefresh = function () {
      return C.H.useCacheRefresh();
    }),
    (Gt.use = function (M) {
      return C.H.use(M);
    }),
    (Gt.useActionState = function (M, I, F) {
      return C.H.useActionState(M, I, F);
    }),
    (Gt.useCallback = function (M, I) {
      return C.H.useCallback(M, I);
    }),
    (Gt.useContext = function (M) {
      return C.H.useContext(M);
    }),
    (Gt.useDebugValue = function () {}),
    (Gt.useDeferredValue = function (M, I) {
      return C.H.useDeferredValue(M, I);
    }),
    (Gt.useEffect = function (M, I, F) {
      var Y = C.H;
      if (typeof F == "function")
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return Y.useEffect(M, I);
    }),
    (Gt.useId = function () {
      return C.H.useId();
    }),
    (Gt.useImperativeHandle = function (M, I, F) {
      return C.H.useImperativeHandle(M, I, F);
    }),
    (Gt.useInsertionEffect = function (M, I) {
      return C.H.useInsertionEffect(M, I);
    }),
    (Gt.useLayoutEffect = function (M, I) {
      return C.H.useLayoutEffect(M, I);
    }),
    (Gt.useMemo = function (M, I) {
      return C.H.useMemo(M, I);
    }),
    (Gt.useOptimistic = function (M, I) {
      return C.H.useOptimistic(M, I);
    }),
    (Gt.useReducer = function (M, I, F) {
      return C.H.useReducer(M, I, F);
    }),
    (Gt.useRef = function (M) {
      return C.H.useRef(M);
    }),
    (Gt.useState = function (M) {
      return C.H.useState(M);
    }),
    (Gt.useSyncExternalStore = function (M, I, F) {
      return C.H.useSyncExternalStore(M, I, F);
    }),
    (Gt.useTransition = function () {
      return C.H.useTransition();
    }),
    (Gt.version = "19.1.1"),
    Gt
  );
}
var JO;
function sE() {
  return JO || ((JO = 1), (k_.exports = SJ())), k_.exports;
}
var C_ = { exports: {} },
  Er = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ej;
function TJ() {
  if (ej) return Er;
  ej = 1;
  var n = sE();
  function e(l) {
    var c = "https://react.dev/errors/" + l;
    if (1 < arguments.length) {
      c += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        c += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return (
      "Minified React error #" +
      l +
      "; visit " +
      c +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function t() {}
  var s = {
      d: {
        f: t,
        r: function () {
          throw Error(e(522));
        },
        D: t,
        C: t,
        L: t,
        m: t,
        X: t,
        S: t,
        M: t,
      },
      p: 0,
      findDOMNode: null,
    },
    r = Symbol.for("react.portal");
  function i(l, c, h) {
    var m =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: r,
      key: m == null ? null : "" + m,
      children: l,
      containerInfo: c,
      implementation: h,
    };
  }
  var a = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function o(l, c) {
    if (l === "font") return "";
    if (typeof c == "string") return c === "use-credentials" ? c : "";
  }
  return (
    (Er.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s),
    (Er.createPortal = function (l, c) {
      var h =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!c || (c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11))
        throw Error(e(299));
      return i(l, c, null, h);
    }),
    (Er.flushSync = function (l) {
      var c = a.T,
        h = s.p;
      try {
        if (((a.T = null), (s.p = 2), l)) return l();
      } finally {
        (a.T = c), (s.p = h), s.d.f();
      }
    }),
    (Er.preconnect = function (l, c) {
      typeof l == "string" &&
        (c
          ? ((c = c.crossOrigin),
            (c =
              typeof c == "string"
                ? c === "use-credentials"
                  ? c
                  : ""
                : void 0))
          : (c = null),
        s.d.C(l, c));
    }),
    (Er.prefetchDNS = function (l) {
      typeof l == "string" && s.d.D(l);
    }),
    (Er.preinit = function (l, c) {
      if (typeof l == "string" && c && typeof c.as == "string") {
        var h = c.as,
          m = o(h, c.crossOrigin),
          p = typeof c.integrity == "string" ? c.integrity : void 0,
          g = typeof c.fetchPriority == "string" ? c.fetchPriority : void 0;
        h === "style"
          ? s.d.S(l, typeof c.precedence == "string" ? c.precedence : void 0, {
              crossOrigin: m,
              integrity: p,
              fetchPriority: g,
            })
          : h === "script" &&
            s.d.X(l, {
              crossOrigin: m,
              integrity: p,
              fetchPriority: g,
              nonce: typeof c.nonce == "string" ? c.nonce : void 0,
            });
      }
    }),
    (Er.preinitModule = function (l, c) {
      if (typeof l == "string")
        if (typeof c == "object" && c !== null) {
          if (c.as == null || c.as === "script") {
            var h = o(c.as, c.crossOrigin);
            s.d.M(l, {
              crossOrigin: h,
              integrity: typeof c.integrity == "string" ? c.integrity : void 0,
              nonce: typeof c.nonce == "string" ? c.nonce : void 0,
            });
          }
        } else c == null && s.d.M(l);
    }),
    (Er.preload = function (l, c) {
      if (
        typeof l == "string" &&
        typeof c == "object" &&
        c !== null &&
        typeof c.as == "string"
      ) {
        var h = c.as,
          m = o(h, c.crossOrigin);
        s.d.L(l, h, {
          crossOrigin: m,
          integrity: typeof c.integrity == "string" ? c.integrity : void 0,
          nonce: typeof c.nonce == "string" ? c.nonce : void 0,
          type: typeof c.type == "string" ? c.type : void 0,
          fetchPriority:
            typeof c.fetchPriority == "string" ? c.fetchPriority : void 0,
          referrerPolicy:
            typeof c.referrerPolicy == "string" ? c.referrerPolicy : void 0,
          imageSrcSet:
            typeof c.imageSrcSet == "string" ? c.imageSrcSet : void 0,
          imageSizes: typeof c.imageSizes == "string" ? c.imageSizes : void 0,
          media: typeof c.media == "string" ? c.media : void 0,
        });
      }
    }),
    (Er.preloadModule = function (l, c) {
      if (typeof l == "string")
        if (c) {
          var h = o(c.as, c.crossOrigin);
          s.d.m(l, {
            as: typeof c.as == "string" && c.as !== "script" ? c.as : void 0,
            crossOrigin: h,
            integrity: typeof c.integrity == "string" ? c.integrity : void 0,
          });
        } else s.d.m(l);
    }),
    (Er.requestFormReset = function (l) {
      s.d.r(l);
    }),
    (Er.unstable_batchedUpdates = function (l, c) {
      return l(c);
    }),
    (Er.useFormState = function (l, c, h) {
      return a.H.useFormState(l, c, h);
    }),
    (Er.useFormStatus = function () {
      return a.H.useHostTransitionStatus();
    }),
    (Er.version = "19.1.1"),
    Er
  );
}
var tj;
function Z5() {
  if (tj) return C_.exports;
  tj = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return n(), (C_.exports = TJ()), C_.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var nj;
function _J() {
  if (nj) return Km;
  nj = 1;
  var n = EJ(),
    e = sE(),
    t = Z5();
  function s(d) {
    var f = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var v = 2; v < arguments.length; v++)
        f += "&args[]=" + encodeURIComponent(arguments[v]);
    }
    return (
      "Minified React error #" +
      d +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  function r(d) {
    return !(!d || (d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11));
  }
  function i(d) {
    var f = d,
      v = d;
    if (d.alternate) for (; f.return; ) f = f.return;
    else {
      d = f;
      do (f = d), (f.flags & 4098) !== 0 && (v = f.return), (d = f.return);
      while (d);
    }
    return f.tag === 3 ? v : null;
  }
  function a(d) {
    if (d.tag === 13) {
      var f = d.memoizedState;
      if (
        (f === null && ((d = d.alternate), d !== null && (f = d.memoizedState)),
        f !== null)
      )
        return f.dehydrated;
    }
    return null;
  }
  function o(d) {
    if (i(d) !== d) throw Error(s(188));
  }
  function l(d) {
    var f = d.alternate;
    if (!f) {
      if (((f = i(d)), f === null)) throw Error(s(188));
      return f !== d ? null : d;
    }
    for (var v = d, x = f; ; ) {
      var T = v.return;
      if (T === null) break;
      var k = T.alternate;
      if (k === null) {
        if (((x = T.return), x !== null)) {
          v = x;
          continue;
        }
        break;
      }
      if (T.child === k.child) {
        for (k = T.child; k; ) {
          if (k === v) return o(T), d;
          if (k === x) return o(T), f;
          k = k.sibling;
        }
        throw Error(s(188));
      }
      if (v.return !== x.return) (v = T), (x = k);
      else {
        for (var G = !1, ee = T.child; ee; ) {
          if (ee === v) {
            (G = !0), (v = T), (x = k);
            break;
          }
          if (ee === x) {
            (G = !0), (x = T), (v = k);
            break;
          }
          ee = ee.sibling;
        }
        if (!G) {
          for (ee = k.child; ee; ) {
            if (ee === v) {
              (G = !0), (v = k), (x = T);
              break;
            }
            if (ee === x) {
              (G = !0), (x = k), (v = T);
              break;
            }
            ee = ee.sibling;
          }
          if (!G) throw Error(s(189));
        }
      }
      if (v.alternate !== x) throw Error(s(190));
    }
    if (v.tag !== 3) throw Error(s(188));
    return v.stateNode.current === v ? d : f;
  }
  function c(d) {
    var f = d.tag;
    if (f === 5 || f === 26 || f === 27 || f === 6) return d;
    for (d = d.child; d !== null; ) {
      if (((f = c(d)), f !== null)) return f;
      d = d.sibling;
    }
    return null;
  }
  var h = Object.assign,
    m = Symbol.for("react.element"),
    p = Symbol.for("react.transitional.element"),
    g = Symbol.for("react.portal"),
    y = Symbol.for("react.fragment"),
    b = Symbol.for("react.strict_mode"),
    w = Symbol.for("react.profiler"),
    S = Symbol.for("react.provider"),
    A = Symbol.for("react.consumer"),
    _ = Symbol.for("react.context"),
    R = Symbol.for("react.forward_ref"),
    C = Symbol.for("react.suspense"),
    D = Symbol.for("react.suspense_list"),
    L = Symbol.for("react.memo"),
    P = Symbol.for("react.lazy"),
    V = Symbol.for("react.activity"),
    N = Symbol.for("react.memo_cache_sentinel"),
    W = Symbol.iterator;
  function H(d) {
    return d === null || typeof d != "object"
      ? null
      : ((d = (W && d[W]) || d["@@iterator"]),
        typeof d == "function" ? d : null);
  }
  var z = Symbol.for("react.client.reference");
  function B(d) {
    if (d == null) return null;
    if (typeof d == "function")
      return d.$$typeof === z ? null : d.displayName || d.name || null;
    if (typeof d == "string") return d;
    switch (d) {
      case y:
        return "Fragment";
      case w:
        return "Profiler";
      case b:
        return "StrictMode";
      case C:
        return "Suspense";
      case D:
        return "SuspenseList";
      case V:
        return "Activity";
    }
    if (typeof d == "object")
      switch (d.$$typeof) {
        case g:
          return "Portal";
        case _:
          return (d.displayName || "Context") + ".Provider";
        case A:
          return (d._context.displayName || "Context") + ".Consumer";
        case R:
          var f = d.render;
          return (
            (d = d.displayName),
            d ||
              ((d = f.displayName || f.name || ""),
              (d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")),
            d
          );
        case L:
          return (
            (f = d.displayName || null), f !== null ? f : B(d.type) || "Memo"
          );
        case P:
          (f = d._payload), (d = d._init);
          try {
            return B(d(f));
          } catch {}
      }
    return null;
  }
  var q = Array.isArray,
    O = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    U = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    j = { pending: !1, data: null, method: null, action: null },
    Q = [],
    M = -1;
  function I(d) {
    return { current: d };
  }
  function F(d) {
    0 > M || ((d.current = Q[M]), (Q[M] = null), M--);
  }
  function Y(d, f) {
    M++, (Q[M] = d.current), (d.current = f);
  }
  var J = I(null),
    X = I(null),
    Z = I(null),
    te = I(null);
  function ce(d, f) {
    switch ((Y(Z, f), Y(X, d), Y(J, null), f.nodeType)) {
      case 9:
      case 11:
        d = (d = f.documentElement) && (d = d.namespaceURI) ? EO(d) : 0;
        break;
      default:
        if (((d = f.tagName), (f = f.namespaceURI)))
          (f = EO(f)), (d = SO(f, d));
        else
          switch (d) {
            case "svg":
              d = 1;
              break;
            case "math":
              d = 2;
              break;
            default:
              d = 0;
          }
    }
    F(J), Y(J, d);
  }
  function pe() {
    F(J), F(X), F(Z);
  }
  function se(d) {
    d.memoizedState !== null && Y(te, d);
    var f = J.current,
      v = SO(f, d.type);
    f !== v && (Y(X, d), Y(J, v));
  }
  function be(d) {
    X.current === d && (F(J), F(X)),
      te.current === d && (F(te), (Hm._currentValue = j));
  }
  var K = Object.prototype.hasOwnProperty,
    ve = n.unstable_scheduleCallback,
    Ee = n.unstable_cancelCallback,
    De = n.unstable_shouldYield,
    ge = n.unstable_requestPaint,
    re = n.unstable_now,
    fe = n.unstable_getCurrentPriorityLevel,
    ke = n.unstable_ImmediatePriority,
    ne = n.unstable_UserBlockingPriority,
    ie = n.unstable_NormalPriority,
    Ne = n.unstable_LowPriority,
    $e = n.unstable_IdlePriority,
    ot = n.log,
    st = n.unstable_setDisableYieldValue,
    ht = null,
    xt = null;
  function _e(d) {
    if (
      (typeof ot == "function" && st(d),
      xt && typeof xt.setStrictMode == "function")
    )
      try {
        xt.setStrictMode(ht, d);
      } catch {}
  }
  var Ue = Math.clz32 ? Math.clz32 : Ze,
    He = Math.log,
    Ve = Math.LN2;
  function Ze(d) {
    return (d >>>= 0), d === 0 ? 32 : (31 - ((He(d) / Ve) | 0)) | 0;
  }
  var ct = 256,
    ft = 4194304;
  function Ye(d) {
    var f = d & 42;
    if (f !== 0) return f;
    switch (d & -d) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return d & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return d;
    }
  }
  function Ot(d, f, v) {
    var x = d.pendingLanes;
    if (x === 0) return 0;
    var T = 0,
      k = d.suspendedLanes,
      G = d.pingedLanes;
    d = d.warmLanes;
    var ee = x & 134217727;
    return (
      ee !== 0
        ? ((x = ee & ~k),
          x !== 0
            ? (T = Ye(x))
            : ((G &= ee),
              G !== 0
                ? (T = Ye(G))
                : v || ((v = ee & ~d), v !== 0 && (T = Ye(v)))))
        : ((ee = x & ~k),
          ee !== 0
            ? (T = Ye(ee))
            : G !== 0
            ? (T = Ye(G))
            : v || ((v = x & ~d), v !== 0 && (T = Ye(v)))),
      T === 0
        ? 0
        : f !== 0 &&
          f !== T &&
          (f & k) === 0 &&
          ((k = T & -T),
          (v = f & -f),
          k >= v || (k === 32 && (v & 4194048) !== 0))
        ? f
        : T
    );
  }
  function $t(d, f) {
    return (d.pendingLanes & ~(d.suspendedLanes & ~d.pingedLanes) & f) === 0;
  }
  function wn(d, f) {
    switch (d) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return f + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Bn() {
    var d = ct;
    return (ct <<= 1), (ct & 4194048) === 0 && (ct = 256), d;
  }
  function Ws() {
    var d = ft;
    return (ft <<= 1), (ft & 62914560) === 0 && (ft = 4194304), d;
  }
  function ts(d) {
    for (var f = [], v = 0; 31 > v; v++) f.push(d);
    return f;
  }
  function Vt(d, f) {
    (d.pendingLanes |= f),
      f !== 268435456 &&
        ((d.suspendedLanes = 0), (d.pingedLanes = 0), (d.warmLanes = 0));
  }
  function Zt(d, f, v, x, T, k) {
    var G = d.pendingLanes;
    (d.pendingLanes = v),
      (d.suspendedLanes = 0),
      (d.pingedLanes = 0),
      (d.warmLanes = 0),
      (d.expiredLanes &= v),
      (d.entangledLanes &= v),
      (d.errorRecoveryDisabledLanes &= v),
      (d.shellSuspendCounter = 0);
    var ee = d.entanglements,
      oe = d.expirationTimes,
      Se = d.hiddenUpdates;
    for (v = G & ~v; 0 < v; ) {
      var Pe = 31 - Ue(v),
        Fe = 1 << Pe;
      (ee[Pe] = 0), (oe[Pe] = -1);
      var Te = Se[Pe];
      if (Te !== null)
        for (Se[Pe] = null, Pe = 0; Pe < Te.length; Pe++) {
          var Ae = Te[Pe];
          Ae !== null && (Ae.lane &= -536870913);
        }
      v &= ~Fe;
    }
    x !== 0 && ln(d, x, 0),
      k !== 0 && T === 0 && d.tag !== 0 && (d.suspendedLanes |= k & ~(G & ~f));
  }
  function ln(d, f, v) {
    (d.pendingLanes |= f), (d.suspendedLanes &= ~f);
    var x = 31 - Ue(f);
    (d.entangledLanes |= f),
      (d.entanglements[x] = d.entanglements[x] | 1073741824 | (v & 4194090));
  }
  function Je(d, f) {
    var v = (d.entangledLanes |= f);
    for (d = d.entanglements; v; ) {
      var x = 31 - Ue(v),
        T = 1 << x;
      (T & f) | (d[x] & f) && (d[x] |= f), (v &= ~T);
    }
  }
  function Ge(d) {
    switch (d) {
      case 2:
        d = 1;
        break;
      case 8:
        d = 4;
        break;
      case 32:
        d = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        d = 128;
        break;
      case 268435456:
        d = 134217728;
        break;
      default:
        d = 0;
    }
    return d;
  }
  function mt(d) {
    return (
      (d &= -d),
      2 < d ? (8 < d ? ((d & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
    );
  }
  function zt() {
    var d = U.p;
    return d !== 0 ? d : ((d = window.event), d === void 0 ? 32 : HO(d.type));
  }
  function an(d, f) {
    var v = U.p;
    try {
      return (U.p = d), f();
    } finally {
      U.p = v;
    }
  }
  var le = Math.random().toString(36).slice(2),
    je = "__reactFiber$" + le,
    Ke = "__reactProps$" + le,
    ut = "__reactContainer$" + le,
    St = "__reactEvents$" + le,
    kt = "__reactListeners$" + le,
    Kt = "__reactHandles$" + le,
    jt = "__reactResources$" + le,
    _n = "__reactMarker$" + le;
  function ws(d) {
    delete d[je], delete d[Ke], delete d[St], delete d[kt], delete d[Kt];
  }
  function Es(d) {
    var f = d[je];
    if (f) return f;
    for (var v = d.parentNode; v; ) {
      if ((f = v[ut] || v[je])) {
        if (
          ((v = f.alternate),
          f.child !== null || (v !== null && v.child !== null))
        )
          for (d = RO(d); d !== null; ) {
            if ((v = d[je])) return v;
            d = RO(d);
          }
        return f;
      }
      (d = v), (v = d.parentNode);
    }
    return null;
  }
  function ur(d) {
    if ((d = d[je] || d[ut])) {
      var f = d.tag;
      if (f === 5 || f === 6 || f === 13 || f === 26 || f === 27 || f === 3)
        return d;
    }
    return null;
  }
  function js(d) {
    var f = d.tag;
    if (f === 5 || f === 26 || f === 27 || f === 6) return d.stateNode;
    throw Error(s(33));
  }
  function Fs(d) {
    var f = d[jt];
    return (
      f ||
        (f = d[jt] =
          { hoistableStyles: new Map(), hoistableScripts: new Map() }),
      f
    );
  }
  function ls(d) {
    d[_n] = !0;
  }
  var hd = new Set(),
    em = {};
  function Zc(d, f) {
    fd(d, f), fd(d + "Capture", f);
  }
  function fd(d, f) {
    for (em[d] = f, d = 0; d < f.length; d++) hd.add(f[d]);
  }
  var cQ = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ),
    fM = {},
    mM = {};
  function uQ(d) {
    return K.call(mM, d)
      ? !0
      : K.call(fM, d)
      ? !1
      : cQ.test(d)
      ? (mM[d] = !0)
      : ((fM[d] = !0), !1);
  }
  function Kv(d, f, v) {
    if (uQ(f))
      if (v === null) d.removeAttribute(f);
      else {
        switch (typeof v) {
          case "undefined":
          case "function":
          case "symbol":
            d.removeAttribute(f);
            return;
          case "boolean":
            var x = f.toLowerCase().slice(0, 5);
            if (x !== "data-" && x !== "aria-") {
              d.removeAttribute(f);
              return;
            }
        }
        d.setAttribute(f, "" + v);
      }
  }
  function Yv(d, f, v) {
    if (v === null) d.removeAttribute(f);
    else {
      switch (typeof v) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          d.removeAttribute(f);
          return;
      }
      d.setAttribute(f, "" + v);
    }
  }
  function jo(d, f, v, x) {
    if (x === null) d.removeAttribute(v);
    else {
      switch (typeof x) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          d.removeAttribute(v);
          return;
      }
      d.setAttributeNS(f, v, "" + x);
    }
  }
  var yS, pM;
  function md(d) {
    if (yS === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        (yS = (f && f[1]) || ""),
          (pM =
            -1 <
            v.stack.indexOf(`
    at`)
              ? " (<anonymous>)"
              : -1 < v.stack.indexOf("@")
              ? "@unknown:0:0"
              : "");
      }
    return (
      `
` +
      yS +
      d +
      pM
    );
  }
  var bS = !1;
  function xS(d, f) {
    if (!d || bS) return "";
    bS = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var x = {
        DetermineComponentFrameRoot: function () {
          try {
            if (f) {
              var Fe = function () {
                throw Error();
              };
              if (
                (Object.defineProperty(Fe.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                typeof Reflect == "object" && Reflect.construct)
              ) {
                try {
                  Reflect.construct(Fe, []);
                } catch (Ae) {
                  var Te = Ae;
                }
                Reflect.construct(d, [], Fe);
              } else {
                try {
                  Fe.call();
                } catch (Ae) {
                  Te = Ae;
                }
                d.call(Fe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Ae) {
                Te = Ae;
              }
              (Fe = d()) &&
                typeof Fe.catch == "function" &&
                Fe.catch(function () {});
            }
          } catch (Ae) {
            if (Ae && Te && typeof Ae.stack == "string")
              return [Ae.stack, Te.stack];
          }
          return [null, null];
        },
      };
      x.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var T = Object.getOwnPropertyDescriptor(
        x.DetermineComponentFrameRoot,
        "name"
      );
      T &&
        T.configurable &&
        Object.defineProperty(x.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot",
        });
      var k = x.DetermineComponentFrameRoot(),
        G = k[0],
        ee = k[1];
      if (G && ee) {
        var oe = G.split(`
`),
          Se = ee.split(`
`);
        for (
          T = x = 0;
          x < oe.length && !oe[x].includes("DetermineComponentFrameRoot");

        )
          x++;
        for (
          ;
          T < Se.length && !Se[T].includes("DetermineComponentFrameRoot");

        )
          T++;
        if (x === oe.length || T === Se.length)
          for (
            x = oe.length - 1, T = Se.length - 1;
            1 <= x && 0 <= T && oe[x] !== Se[T];

          )
            T--;
        for (; 1 <= x && 0 <= T; x--, T--)
          if (oe[x] !== Se[T]) {
            if (x !== 1 || T !== 1)
              do
                if ((x--, T--, 0 > T || oe[x] !== Se[T])) {
                  var Pe =
                    `
` + oe[x].replace(" at new ", " at ");
                  return (
                    d.displayName &&
                      Pe.includes("<anonymous>") &&
                      (Pe = Pe.replace("<anonymous>", d.displayName)),
                    Pe
                  );
                }
              while (1 <= x && 0 <= T);
            break;
          }
      }
    } finally {
      (bS = !1), (Error.prepareStackTrace = v);
    }
    return (v = d ? d.displayName || d.name : "") ? md(v) : "";
  }
  function dQ(d) {
    switch (d.tag) {
      case 26:
      case 27:
      case 5:
        return md(d.type);
      case 16:
        return md("Lazy");
      case 13:
        return md("Suspense");
      case 19:
        return md("SuspenseList");
      case 0:
      case 15:
        return xS(d.type, !1);
      case 11:
        return xS(d.type.render, !1);
      case 1:
        return xS(d.type, !0);
      case 31:
        return md("Activity");
      default:
        return "";
    }
  }
  function gM(d) {
    try {
      var f = "";
      do (f += dQ(d)), (d = d.return);
      while (d);
      return f;
    } catch (v) {
      return (
        `
Error generating stack: ` +
        v.message +
        `
` +
        v.stack
      );
    }
  }
  function Mi(d) {
    switch (typeof d) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return d;
      case "object":
        return d;
      default:
        return "";
    }
  }
  function vM(d) {
    var f = d.type;
    return (
      (d = d.nodeName) &&
      d.toLowerCase() === "input" &&
      (f === "checkbox" || f === "radio")
    );
  }
  function hQ(d) {
    var f = vM(d) ? "checked" : "value",
      v = Object.getOwnPropertyDescriptor(d.constructor.prototype, f),
      x = "" + d[f];
    if (
      !d.hasOwnProperty(f) &&
      typeof v < "u" &&
      typeof v.get == "function" &&
      typeof v.set == "function"
    ) {
      var T = v.get,
        k = v.set;
      return (
        Object.defineProperty(d, f, {
          configurable: !0,
          get: function () {
            return T.call(this);
          },
          set: function (G) {
            (x = "" + G), k.call(this, G);
          },
        }),
        Object.defineProperty(d, f, { enumerable: v.enumerable }),
        {
          getValue: function () {
            return x;
          },
          setValue: function (G) {
            x = "" + G;
          },
          stopTracking: function () {
            (d._valueTracker = null), delete d[f];
          },
        }
      );
    }
  }
  function Xv(d) {
    d._valueTracker || (d._valueTracker = hQ(d));
  }
  function yM(d) {
    if (!d) return !1;
    var f = d._valueTracker;
    if (!f) return !0;
    var v = f.getValue(),
      x = "";
    return (
      d && (x = vM(d) ? (d.checked ? "true" : "false") : d.value),
      (d = x),
      d !== v ? (f.setValue(d), !0) : !1
    );
  }
  function Qv(d) {
    if (
      ((d = d || (typeof document < "u" ? document : void 0)), typeof d > "u")
    )
      return null;
    try {
      return d.activeElement || d.body;
    } catch {
      return d.body;
    }
  }
  var fQ = /[\n"\\]/g;
  function Ni(d) {
    return d.replace(fQ, function (f) {
      return "\\" + f.charCodeAt(0).toString(16) + " ";
    });
  }
  function wS(d, f, v, x, T, k, G, ee) {
    (d.name = ""),
      G != null &&
      typeof G != "function" &&
      typeof G != "symbol" &&
      typeof G != "boolean"
        ? (d.type = G)
        : d.removeAttribute("type"),
      f != null
        ? G === "number"
          ? ((f === 0 && d.value === "") || d.value != f) &&
            (d.value = "" + Mi(f))
          : d.value !== "" + Mi(f) && (d.value = "" + Mi(f))
        : (G !== "submit" && G !== "reset") || d.removeAttribute("value"),
      f != null
        ? ES(d, G, Mi(f))
        : v != null
        ? ES(d, G, Mi(v))
        : x != null && d.removeAttribute("value"),
      T == null && k != null && (d.defaultChecked = !!k),
      T != null &&
        (d.checked = T && typeof T != "function" && typeof T != "symbol"),
      ee != null &&
      typeof ee != "function" &&
      typeof ee != "symbol" &&
      typeof ee != "boolean"
        ? (d.name = "" + Mi(ee))
        : d.removeAttribute("name");
  }
  function bM(d, f, v, x, T, k, G, ee) {
    if (
      (k != null &&
        typeof k != "function" &&
        typeof k != "symbol" &&
        typeof k != "boolean" &&
        (d.type = k),
      f != null || v != null)
    ) {
      if (!((k !== "submit" && k !== "reset") || f != null)) return;
      (v = v != null ? "" + Mi(v) : ""),
        (f = f != null ? "" + Mi(f) : v),
        ee || f === d.value || (d.value = f),
        (d.defaultValue = f);
    }
    (x = x ?? T),
      (x = typeof x != "function" && typeof x != "symbol" && !!x),
      (d.checked = ee ? d.checked : !!x),
      (d.defaultChecked = !!x),
      G != null &&
        typeof G != "function" &&
        typeof G != "symbol" &&
        typeof G != "boolean" &&
        (d.name = G);
  }
  function ES(d, f, v) {
    (f === "number" && Qv(d.ownerDocument) === d) ||
      d.defaultValue === "" + v ||
      (d.defaultValue = "" + v);
  }
  function pd(d, f, v, x) {
    if (((d = d.options), f)) {
      f = {};
      for (var T = 0; T < v.length; T++) f["$" + v[T]] = !0;
      for (v = 0; v < d.length; v++)
        (T = f.hasOwnProperty("$" + d[v].value)),
          d[v].selected !== T && (d[v].selected = T),
          T && x && (d[v].defaultSelected = !0);
    } else {
      for (v = "" + Mi(v), f = null, T = 0; T < d.length; T++) {
        if (d[T].value === v) {
          (d[T].selected = !0), x && (d[T].defaultSelected = !0);
          return;
        }
        f !== null || d[T].disabled || (f = d[T]);
      }
      f !== null && (f.selected = !0);
    }
  }
  function xM(d, f, v) {
    if (
      f != null &&
      ((f = "" + Mi(f)), f !== d.value && (d.value = f), v == null)
    ) {
      d.defaultValue !== f && (d.defaultValue = f);
      return;
    }
    d.defaultValue = v != null ? "" + Mi(v) : "";
  }
  function wM(d, f, v, x) {
    if (f == null) {
      if (x != null) {
        if (v != null) throw Error(s(92));
        if (q(x)) {
          if (1 < x.length) throw Error(s(93));
          x = x[0];
        }
        v = x;
      }
      v == null && (v = ""), (f = v);
    }
    (v = Mi(f)),
      (d.defaultValue = v),
      (x = d.textContent),
      x === v && x !== "" && x !== null && (d.value = x);
  }
  function gd(d, f) {
    if (f) {
      var v = d.firstChild;
      if (v && v === d.lastChild && v.nodeType === 3) {
        v.nodeValue = f;
        return;
      }
    }
    d.textContent = f;
  }
  var mQ = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function EM(d, f, v) {
    var x = f.indexOf("--") === 0;
    v == null || typeof v == "boolean" || v === ""
      ? x
        ? d.setProperty(f, "")
        : f === "float"
        ? (d.cssFloat = "")
        : (d[f] = "")
      : x
      ? d.setProperty(f, v)
      : typeof v != "number" || v === 0 || mQ.has(f)
      ? f === "float"
        ? (d.cssFloat = v)
        : (d[f] = ("" + v).trim())
      : (d[f] = v + "px");
  }
  function SM(d, f, v) {
    if (f != null && typeof f != "object") throw Error(s(62));
    if (((d = d.style), v != null)) {
      for (var x in v)
        !v.hasOwnProperty(x) ||
          (f != null && f.hasOwnProperty(x)) ||
          (x.indexOf("--") === 0
            ? d.setProperty(x, "")
            : x === "float"
            ? (d.cssFloat = "")
            : (d[x] = ""));
      for (var T in f)
        (x = f[T]), f.hasOwnProperty(T) && v[T] !== x && EM(d, T, x);
    } else for (var k in f) f.hasOwnProperty(k) && EM(d, k, f[k]);
  }
  function SS(d) {
    if (d.indexOf("-") === -1) return !1;
    switch (d) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var pQ = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"],
    ]),
    gQ =
      /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Zv(d) {
    return gQ.test("" + d)
      ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
      : d;
  }
  var TS = null;
  function _S(d) {
    return (
      (d = d.target || d.srcElement || window),
      d.correspondingUseElement && (d = d.correspondingUseElement),
      d.nodeType === 3 ? d.parentNode : d
    );
  }
  var vd = null,
    yd = null;
  function TM(d) {
    var f = ur(d);
    if (f && (d = f.stateNode)) {
      var v = d[Ke] || null;
      e: switch (((d = f.stateNode), f.type)) {
        case "input":
          if (
            (wS(
              d,
              v.value,
              v.defaultValue,
              v.defaultValue,
              v.checked,
              v.defaultChecked,
              v.type,
              v.name
            ),
            (f = v.name),
            v.type === "radio" && f != null)
          ) {
            for (v = d; v.parentNode; ) v = v.parentNode;
            for (
              v = v.querySelectorAll(
                'input[name="' + Ni("" + f) + '"][type="radio"]'
              ),
                f = 0;
              f < v.length;
              f++
            ) {
              var x = v[f];
              if (x !== d && x.form === d.form) {
                var T = x[Ke] || null;
                if (!T) throw Error(s(90));
                wS(
                  x,
                  T.value,
                  T.defaultValue,
                  T.defaultValue,
                  T.checked,
                  T.defaultChecked,
                  T.type,
                  T.name
                );
              }
            }
            for (f = 0; f < v.length; f++)
              (x = v[f]), x.form === d.form && yM(x);
          }
          break e;
        case "textarea":
          xM(d, v.value, v.defaultValue);
          break e;
        case "select":
          (f = v.value), f != null && pd(d, !!v.multiple, f, !1);
      }
    }
  }
  var AS = !1;
  function _M(d, f, v) {
    if (AS) return d(f, v);
    AS = !0;
    try {
      var x = d(f);
      return x;
    } finally {
      if (
        ((AS = !1),
        (vd !== null || yd !== null) &&
          (j0(), vd && ((f = vd), (d = yd), (yd = vd = null), TM(f), d)))
      )
        for (f = 0; f < d.length; f++) TM(d[f]);
    }
  }
  function tm(d, f) {
    var v = d.stateNode;
    if (v === null) return null;
    var x = v[Ke] || null;
    if (x === null) return null;
    v = x[f];
    e: switch (f) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (x = !x.disabled) ||
          ((d = d.type),
          (x = !(
            d === "button" ||
            d === "input" ||
            d === "select" ||
            d === "textarea"
          ))),
          (d = !x);
        break e;
      default:
        d = !1;
    }
    if (d) return null;
    if (v && typeof v != "function") throw Error(s(231, f, typeof v));
    return v;
  }
  var Fo = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    RS = !1;
  if (Fo)
    try {
      var nm = {};
      Object.defineProperty(nm, "passive", {
        get: function () {
          RS = !0;
        },
      }),
        window.addEventListener("test", nm, nm),
        window.removeEventListener("test", nm, nm);
    } catch {
      RS = !1;
    }
  var Ll = null,
    kS = null,
    Jv = null;
  function AM() {
    if (Jv) return Jv;
    var d,
      f = kS,
      v = f.length,
      x,
      T = "value" in Ll ? Ll.value : Ll.textContent,
      k = T.length;
    for (d = 0; d < v && f[d] === T[d]; d++);
    var G = v - d;
    for (x = 1; x <= G && f[v - x] === T[k - x]; x++);
    return (Jv = T.slice(d, 1 < x ? 1 - x : void 0));
  }
  function e0(d) {
    var f = d.keyCode;
    return (
      "charCode" in d
        ? ((d = d.charCode), d === 0 && f === 13 && (d = 13))
        : (d = f),
      d === 10 && (d = 13),
      32 <= d || d === 13 ? d : 0
    );
  }
  function t0() {
    return !0;
  }
  function RM() {
    return !1;
  }
  function Vr(d) {
    function f(v, x, T, k, G) {
      (this._reactName = v),
        (this._targetInst = T),
        (this.type = x),
        (this.nativeEvent = k),
        (this.target = G),
        (this.currentTarget = null);
      for (var ee in d)
        d.hasOwnProperty(ee) && ((v = d[ee]), (this[ee] = v ? v(k) : k[ee]));
      return (
        (this.isDefaultPrevented = (
          k.defaultPrevented != null ? k.defaultPrevented : k.returnValue === !1
        )
          ? t0
          : RM),
        (this.isPropagationStopped = RM),
        this
      );
    }
    return (
      h(f.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          v &&
            (v.preventDefault
              ? v.preventDefault()
              : typeof v.returnValue != "unknown" && (v.returnValue = !1),
            (this.isDefaultPrevented = t0));
        },
        stopPropagation: function () {
          var v = this.nativeEvent;
          v &&
            (v.stopPropagation
              ? v.stopPropagation()
              : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0),
            (this.isPropagationStopped = t0));
        },
        persist: function () {},
        isPersistent: t0,
      }),
      f
    );
  }
  var Jc = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (d) {
        return d.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    n0 = Vr(Jc),
    sm = h({}, Jc, { view: 0, detail: 0 }),
    vQ = Vr(sm),
    CS,
    IS,
    rm,
    s0 = h({}, sm, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: DS,
      button: 0,
      buttons: 0,
      relatedTarget: function (d) {
        return d.relatedTarget === void 0
          ? d.fromElement === d.srcElement
            ? d.toElement
            : d.fromElement
          : d.relatedTarget;
      },
      movementX: function (d) {
        return "movementX" in d
          ? d.movementX
          : (d !== rm &&
              (rm && d.type === "mousemove"
                ? ((CS = d.screenX - rm.screenX), (IS = d.screenY - rm.screenY))
                : (IS = CS = 0),
              (rm = d)),
            CS);
      },
      movementY: function (d) {
        return "movementY" in d ? d.movementY : IS;
      },
    }),
    kM = Vr(s0),
    yQ = h({}, s0, { dataTransfer: 0 }),
    bQ = Vr(yQ),
    xQ = h({}, sm, { relatedTarget: 0 }),
    LS = Vr(xQ),
    wQ = h({}, Jc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    EQ = Vr(wQ),
    SQ = h({}, Jc, {
      clipboardData: function (d) {
        return "clipboardData" in d ? d.clipboardData : window.clipboardData;
      },
    }),
    TQ = Vr(SQ),
    _Q = h({}, Jc, { data: 0 }),
    CM = Vr(_Q),
    AQ = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    RQ = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    kQ = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function CQ(d) {
    var f = this.nativeEvent;
    return f.getModifierState
      ? f.getModifierState(d)
      : (d = kQ[d])
      ? !!f[d]
      : !1;
  }
  function DS() {
    return CQ;
  }
  var IQ = h({}, sm, {
      key: function (d) {
        if (d.key) {
          var f = AQ[d.key] || d.key;
          if (f !== "Unidentified") return f;
        }
        return d.type === "keypress"
          ? ((d = e0(d)), d === 13 ? "Enter" : String.fromCharCode(d))
          : d.type === "keydown" || d.type === "keyup"
          ? RQ[d.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: DS,
      charCode: function (d) {
        return d.type === "keypress" ? e0(d) : 0;
      },
      keyCode: function (d) {
        return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
      },
      which: function (d) {
        return d.type === "keypress"
          ? e0(d)
          : d.type === "keydown" || d.type === "keyup"
          ? d.keyCode
          : 0;
      },
    }),
    LQ = Vr(IQ),
    DQ = h({}, s0, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    IM = Vr(DQ),
    PQ = h({}, sm, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: DS,
    }),
    MQ = Vr(PQ),
    NQ = h({}, Jc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    OQ = Vr(NQ),
    jQ = h({}, s0, {
      deltaX: function (d) {
        return "deltaX" in d
          ? d.deltaX
          : "wheelDeltaX" in d
          ? -d.wheelDeltaX
          : 0;
      },
      deltaY: function (d) {
        return "deltaY" in d
          ? d.deltaY
          : "wheelDeltaY" in d
          ? -d.wheelDeltaY
          : "wheelDelta" in d
          ? -d.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    FQ = Vr(jQ),
    UQ = h({}, Jc, { newState: 0, oldState: 0 }),
    $Q = Vr(UQ),
    BQ = [9, 13, 27, 32],
    PS = Fo && "CompositionEvent" in window,
    im = null;
  Fo && "documentMode" in document && (im = document.documentMode);
  var HQ = Fo && "TextEvent" in window && !im,
    LM = Fo && (!PS || (im && 8 < im && 11 >= im)),
    DM = " ",
    PM = !1;
  function MM(d, f) {
    switch (d) {
      case "keyup":
        return BQ.indexOf(f.keyCode) !== -1;
      case "keydown":
        return f.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function NM(d) {
    return (d = d.detail), typeof d == "object" && "data" in d ? d.data : null;
  }
  var bd = !1;
  function VQ(d, f) {
    switch (d) {
      case "compositionend":
        return NM(f);
      case "keypress":
        return f.which !== 32 ? null : ((PM = !0), DM);
      case "textInput":
        return (d = f.data), d === DM && PM ? null : d;
      default:
        return null;
    }
  }
  function zQ(d, f) {
    if (bd)
      return d === "compositionend" || (!PS && MM(d, f))
        ? ((d = AM()), (Jv = kS = Ll = null), (bd = !1), d)
        : null;
    switch (d) {
      case "paste":
        return null;
      case "keypress":
        if (!(f.ctrlKey || f.altKey || f.metaKey) || (f.ctrlKey && f.altKey)) {
          if (f.char && 1 < f.char.length) return f.char;
          if (f.which) return String.fromCharCode(f.which);
        }
        return null;
      case "compositionend":
        return LM && f.locale !== "ko" ? null : f.data;
      default:
        return null;
    }
  }
  var GQ = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function OM(d) {
    var f = d && d.nodeName && d.nodeName.toLowerCase();
    return f === "input" ? !!GQ[d.type] : f === "textarea";
  }
  function jM(d, f, v, x) {
    vd ? (yd ? yd.push(x) : (yd = [x])) : (vd = x),
      (f = V0(f, "onChange")),
      0 < f.length &&
        ((v = new n0("onChange", "change", null, v, x)),
        d.push({ event: v, listeners: f }));
  }
  var am = null,
    om = null;
  function qQ(d) {
    vO(d, 0);
  }
  function r0(d) {
    var f = js(d);
    if (yM(f)) return d;
  }
  function FM(d, f) {
    if (d === "change") return f;
  }
  var UM = !1;
  if (Fo) {
    var MS;
    if (Fo) {
      var NS = "oninput" in document;
      if (!NS) {
        var $M = document.createElement("div");
        $M.setAttribute("oninput", "return;"),
          (NS = typeof $M.oninput == "function");
      }
      MS = NS;
    } else MS = !1;
    UM = MS && (!document.documentMode || 9 < document.documentMode);
  }
  function BM() {
    am && (am.detachEvent("onpropertychange", HM), (om = am = null));
  }
  function HM(d) {
    if (d.propertyName === "value" && r0(om)) {
      var f = [];
      jM(f, om, d, _S(d)), _M(qQ, f);
    }
  }
  function WQ(d, f, v) {
    d === "focusin"
      ? (BM(), (am = f), (om = v), am.attachEvent("onpropertychange", HM))
      : d === "focusout" && BM();
  }
  function KQ(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown")
      return r0(om);
  }
  function YQ(d, f) {
    if (d === "click") return r0(f);
  }
  function XQ(d, f) {
    if (d === "input" || d === "change") return r0(f);
  }
  function QQ(d, f) {
    return (d === f && (d !== 0 || 1 / d === 1 / f)) || (d !== d && f !== f);
  }
  var di = typeof Object.is == "function" ? Object.is : QQ;
  function lm(d, f) {
    if (di(d, f)) return !0;
    if (
      typeof d != "object" ||
      d === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var v = Object.keys(d),
      x = Object.keys(f);
    if (v.length !== x.length) return !1;
    for (x = 0; x < v.length; x++) {
      var T = v[x];
      if (!K.call(f, T) || !di(d[T], f[T])) return !1;
    }
    return !0;
  }
  function VM(d) {
    for (; d && d.firstChild; ) d = d.firstChild;
    return d;
  }
  function zM(d, f) {
    var v = VM(d);
    d = 0;
    for (var x; v; ) {
      if (v.nodeType === 3) {
        if (((x = d + v.textContent.length), d <= f && x >= f))
          return { node: v, offset: f - d };
        d = x;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = VM(v);
    }
  }
  function GM(d, f) {
    return d && f
      ? d === f
        ? !0
        : d && d.nodeType === 3
        ? !1
        : f && f.nodeType === 3
        ? GM(d, f.parentNode)
        : "contains" in d
        ? d.contains(f)
        : d.compareDocumentPosition
        ? !!(d.compareDocumentPosition(f) & 16)
        : !1
      : !1;
  }
  function qM(d) {
    d =
      d != null &&
      d.ownerDocument != null &&
      d.ownerDocument.defaultView != null
        ? d.ownerDocument.defaultView
        : window;
    for (var f = Qv(d.document); f instanceof d.HTMLIFrameElement; ) {
      try {
        var v = typeof f.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v) d = f.contentWindow;
      else break;
      f = Qv(d.document);
    }
    return f;
  }
  function OS(d) {
    var f = d && d.nodeName && d.nodeName.toLowerCase();
    return (
      f &&
      ((f === "input" &&
        (d.type === "text" ||
          d.type === "search" ||
          d.type === "tel" ||
          d.type === "url" ||
          d.type === "password")) ||
        f === "textarea" ||
        d.contentEditable === "true")
    );
  }
  var ZQ = Fo && "documentMode" in document && 11 >= document.documentMode,
    xd = null,
    jS = null,
    cm = null,
    FS = !1;
  function WM(d, f, v) {
    var x =
      v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    FS ||
      xd == null ||
      xd !== Qv(x) ||
      ((x = xd),
      "selectionStart" in x && OS(x)
        ? (x = { start: x.selectionStart, end: x.selectionEnd })
        : ((x = (
            (x.ownerDocument && x.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (x = {
            anchorNode: x.anchorNode,
            anchorOffset: x.anchorOffset,
            focusNode: x.focusNode,
            focusOffset: x.focusOffset,
          })),
      (cm && lm(cm, x)) ||
        ((cm = x),
        (x = V0(jS, "onSelect")),
        0 < x.length &&
          ((f = new n0("onSelect", "select", null, f, v)),
          d.push({ event: f, listeners: x }),
          (f.target = xd))));
  }
  function eu(d, f) {
    var v = {};
    return (
      (v[d.toLowerCase()] = f.toLowerCase()),
      (v["Webkit" + d] = "webkit" + f),
      (v["Moz" + d] = "moz" + f),
      v
    );
  }
  var wd = {
      animationend: eu("Animation", "AnimationEnd"),
      animationiteration: eu("Animation", "AnimationIteration"),
      animationstart: eu("Animation", "AnimationStart"),
      transitionrun: eu("Transition", "TransitionRun"),
      transitionstart: eu("Transition", "TransitionStart"),
      transitioncancel: eu("Transition", "TransitionCancel"),
      transitionend: eu("Transition", "TransitionEnd"),
    },
    US = {},
    KM = {};
  Fo &&
    ((KM = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete wd.animationend.animation,
      delete wd.animationiteration.animation,
      delete wd.animationstart.animation),
    "TransitionEvent" in window || delete wd.transitionend.transition);
  function tu(d) {
    if (US[d]) return US[d];
    if (!wd[d]) return d;
    var f = wd[d],
      v;
    for (v in f) if (f.hasOwnProperty(v) && v in KM) return (US[d] = f[v]);
    return d;
  }
  var YM = tu("animationend"),
    XM = tu("animationiteration"),
    QM = tu("animationstart"),
    JQ = tu("transitionrun"),
    eZ = tu("transitionstart"),
    tZ = tu("transitioncancel"),
    ZM = tu("transitionend"),
    JM = new Map(),
    $S =
      "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  $S.push("scrollEnd");
  function fa(d, f) {
    JM.set(d, f), Zc(f, [d]);
  }
  var e2 = new WeakMap();
  function Oi(d, f) {
    if (typeof d == "object" && d !== null) {
      var v = e2.get(d);
      return v !== void 0
        ? v
        : ((f = { value: d, source: f, stack: gM(f) }), e2.set(d, f), f);
    }
    return { value: d, source: f, stack: gM(f) };
  }
  var ji = [],
    Ed = 0,
    BS = 0;
  function i0() {
    for (var d = Ed, f = (BS = Ed = 0); f < d; ) {
      var v = ji[f];
      ji[f++] = null;
      var x = ji[f];
      ji[f++] = null;
      var T = ji[f];
      ji[f++] = null;
      var k = ji[f];
      if (((ji[f++] = null), x !== null && T !== null)) {
        var G = x.pending;
        G === null ? (T.next = T) : ((T.next = G.next), (G.next = T)),
          (x.pending = T);
      }
      k !== 0 && t2(v, T, k);
    }
  }
  function a0(d, f, v, x) {
    (ji[Ed++] = d),
      (ji[Ed++] = f),
      (ji[Ed++] = v),
      (ji[Ed++] = x),
      (BS |= x),
      (d.lanes |= x),
      (d = d.alternate),
      d !== null && (d.lanes |= x);
  }
  function HS(d, f, v, x) {
    return a0(d, f, v, x), o0(d);
  }
  function Sd(d, f) {
    return a0(d, null, null, f), o0(d);
  }
  function t2(d, f, v) {
    d.lanes |= v;
    var x = d.alternate;
    x !== null && (x.lanes |= v);
    for (var T = !1, k = d.return; k !== null; )
      (k.childLanes |= v),
        (x = k.alternate),
        x !== null && (x.childLanes |= v),
        k.tag === 22 &&
          ((d = k.stateNode), d === null || d._visibility & 1 || (T = !0)),
        (d = k),
        (k = k.return);
    return d.tag === 3
      ? ((k = d.stateNode),
        T &&
          f !== null &&
          ((T = 31 - Ue(v)),
          (d = k.hiddenUpdates),
          (x = d[T]),
          x === null ? (d[T] = [f]) : x.push(f),
          (f.lane = v | 536870912)),
        k)
      : null;
  }
  function o0(d) {
    if (50 < Mm) throw ((Mm = 0), (KT = null), Error(s(185)));
    for (var f = d.return; f !== null; ) (d = f), (f = d.return);
    return d.tag === 3 ? d.stateNode : null;
  }
  var Td = {};
  function nZ(d, f, v, x) {
    (this.tag = d),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.refCleanup = this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = x),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function hi(d, f, v, x) {
    return new nZ(d, f, v, x);
  }
  function VS(d) {
    return (d = d.prototype), !(!d || !d.isReactComponent);
  }
  function Uo(d, f) {
    var v = d.alternate;
    return (
      v === null
        ? ((v = hi(d.tag, f, d.key, d.mode)),
          (v.elementType = d.elementType),
          (v.type = d.type),
          (v.stateNode = d.stateNode),
          (v.alternate = d),
          (d.alternate = v))
        : ((v.pendingProps = f),
          (v.type = d.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = d.flags & 65011712),
      (v.childLanes = d.childLanes),
      (v.lanes = d.lanes),
      (v.child = d.child),
      (v.memoizedProps = d.memoizedProps),
      (v.memoizedState = d.memoizedState),
      (v.updateQueue = d.updateQueue),
      (f = d.dependencies),
      (v.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (v.sibling = d.sibling),
      (v.index = d.index),
      (v.ref = d.ref),
      (v.refCleanup = d.refCleanup),
      v
    );
  }
  function n2(d, f) {
    d.flags &= 65011714;
    var v = d.alternate;
    return (
      v === null
        ? ((d.childLanes = 0),
          (d.lanes = f),
          (d.child = null),
          (d.subtreeFlags = 0),
          (d.memoizedProps = null),
          (d.memoizedState = null),
          (d.updateQueue = null),
          (d.dependencies = null),
          (d.stateNode = null))
        : ((d.childLanes = v.childLanes),
          (d.lanes = v.lanes),
          (d.child = v.child),
          (d.subtreeFlags = 0),
          (d.deletions = null),
          (d.memoizedProps = v.memoizedProps),
          (d.memoizedState = v.memoizedState),
          (d.updateQueue = v.updateQueue),
          (d.type = v.type),
          (f = v.dependencies),
          (d.dependencies =
            f === null
              ? null
              : { lanes: f.lanes, firstContext: f.firstContext })),
      d
    );
  }
  function l0(d, f, v, x, T, k) {
    var G = 0;
    if (((x = d), typeof d == "function")) VS(d) && (G = 1);
    else if (typeof d == "string")
      G = rJ(d, v, J.current)
        ? 26
        : d === "html" || d === "head" || d === "body"
        ? 27
        : 5;
    else
      e: switch (d) {
        case V:
          return (d = hi(31, v, f, T)), (d.elementType = V), (d.lanes = k), d;
        case y:
          return nu(v.children, T, k, f);
        case b:
          (G = 8), (T |= 24);
          break;
        case w:
          return (
            (d = hi(12, v, f, T | 2)), (d.elementType = w), (d.lanes = k), d
          );
        case C:
          return (d = hi(13, v, f, T)), (d.elementType = C), (d.lanes = k), d;
        case D:
          return (d = hi(19, v, f, T)), (d.elementType = D), (d.lanes = k), d;
        default:
          if (typeof d == "object" && d !== null)
            switch (d.$$typeof) {
              case S:
              case _:
                G = 10;
                break e;
              case A:
                G = 9;
                break e;
              case R:
                G = 11;
                break e;
              case L:
                G = 14;
                break e;
              case P:
                (G = 16), (x = null);
                break e;
            }
          (G = 29),
            (v = Error(s(130, d === null ? "null" : typeof d, ""))),
            (x = null);
      }
    return (
      (f = hi(G, v, f, T)), (f.elementType = d), (f.type = x), (f.lanes = k), f
    );
  }
  function nu(d, f, v, x) {
    return (d = hi(7, d, x, f)), (d.lanes = v), d;
  }
  function zS(d, f, v) {
    return (d = hi(6, d, null, f)), (d.lanes = v), d;
  }
  function GS(d, f, v) {
    return (
      (f = hi(4, d.children !== null ? d.children : [], d.key, f)),
      (f.lanes = v),
      (f.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation,
      }),
      f
    );
  }
  var _d = [],
    Ad = 0,
    c0 = null,
    u0 = 0,
    Fi = [],
    Ui = 0,
    su = null,
    $o = 1,
    Bo = "";
  function ru(d, f) {
    (_d[Ad++] = u0), (_d[Ad++] = c0), (c0 = d), (u0 = f);
  }
  function s2(d, f, v) {
    (Fi[Ui++] = $o), (Fi[Ui++] = Bo), (Fi[Ui++] = su), (su = d);
    var x = $o;
    d = Bo;
    var T = 32 - Ue(x) - 1;
    (x &= ~(1 << T)), (v += 1);
    var k = 32 - Ue(f) + T;
    if (30 < k) {
      var G = T - (T % 5);
      (k = (x & ((1 << G) - 1)).toString(32)),
        (x >>= G),
        (T -= G),
        ($o = (1 << (32 - Ue(f) + T)) | (v << T) | x),
        (Bo = k + d);
    } else ($o = (1 << k) | (v << T) | x), (Bo = d);
  }
  function qS(d) {
    d.return !== null && (ru(d, 1), s2(d, 1, 0));
  }
  function WS(d) {
    for (; d === c0; )
      (c0 = _d[--Ad]), (_d[Ad] = null), (u0 = _d[--Ad]), (_d[Ad] = null);
    for (; d === su; )
      (su = Fi[--Ui]),
        (Fi[Ui] = null),
        (Bo = Fi[--Ui]),
        (Fi[Ui] = null),
        ($o = Fi[--Ui]),
        (Fi[Ui] = null);
  }
  var Or = null,
    cs = null,
    gn = !1,
    iu = null,
    Ga = !1,
    KS = Error(s(519));
  function au(d) {
    var f = Error(s(418, ""));
    throw (hm(Oi(f, d)), KS);
  }
  function r2(d) {
    var f = d.stateNode,
      v = d.type,
      x = d.memoizedProps;
    switch (((f[je] = d), (f[Ke] = x), v)) {
      case "dialog":
        nn("cancel", f), nn("close", f);
        break;
      case "iframe":
      case "object":
      case "embed":
        nn("load", f);
        break;
      case "video":
      case "audio":
        for (v = 0; v < Om.length; v++) nn(Om[v], f);
        break;
      case "source":
        nn("error", f);
        break;
      case "img":
      case "image":
      case "link":
        nn("error", f), nn("load", f);
        break;
      case "details":
        nn("toggle", f);
        break;
      case "input":
        nn("invalid", f),
          bM(
            f,
            x.value,
            x.defaultValue,
            x.checked,
            x.defaultChecked,
            x.type,
            x.name,
            !0
          ),
          Xv(f);
        break;
      case "select":
        nn("invalid", f);
        break;
      case "textarea":
        nn("invalid", f), wM(f, x.value, x.defaultValue, x.children), Xv(f);
    }
    (v = x.children),
      (typeof v != "string" && typeof v != "number" && typeof v != "bigint") ||
      f.textContent === "" + v ||
      x.suppressHydrationWarning === !0 ||
      wO(f.textContent, v)
        ? (x.popover != null && (nn("beforetoggle", f), nn("toggle", f)),
          x.onScroll != null && nn("scroll", f),
          x.onScrollEnd != null && nn("scrollend", f),
          x.onClick != null && (f.onclick = z0),
          (f = !0))
        : (f = !1),
      f || au(d);
  }
  function i2(d) {
    for (Or = d.return; Or; )
      switch (Or.tag) {
        case 5:
        case 13:
          Ga = !1;
          return;
        case 27:
        case 3:
          Ga = !0;
          return;
        default:
          Or = Or.return;
      }
  }
  function um(d) {
    if (d !== Or) return !1;
    if (!gn) return i2(d), (gn = !0), !1;
    var f = d.tag,
      v;
    if (
      ((v = f !== 3 && f !== 27) &&
        ((v = f === 5) &&
          ((v = d.type),
          (v =
            !(v !== "form" && v !== "button") || u_(d.type, d.memoizedProps))),
        (v = !v)),
      v && cs && au(d),
      i2(d),
      f === 13)
    ) {
      if (((d = d.memoizedState), (d = d !== null ? d.dehydrated : null), !d))
        throw Error(s(317));
      e: {
        for (d = d.nextSibling, f = 0; d; ) {
          if (d.nodeType === 8)
            if (((v = d.data), v === "/$")) {
              if (f === 0) {
                cs = pa(d.nextSibling);
                break e;
              }
              f--;
            } else (v !== "$" && v !== "$!" && v !== "$?") || f++;
          d = d.nextSibling;
        }
        cs = null;
      }
    } else
      f === 27
        ? ((f = cs), Wl(d.type) ? ((d = m_), (m_ = null), (cs = d)) : (cs = f))
        : (cs = Or ? pa(d.stateNode.nextSibling) : null);
    return !0;
  }
  function dm() {
    (cs = Or = null), (gn = !1);
  }
  function a2() {
    var d = iu;
    return (
      d !== null &&
        (qr === null ? (qr = d) : qr.push.apply(qr, d), (iu = null)),
      d
    );
  }
  function hm(d) {
    iu === null ? (iu = [d]) : iu.push(d);
  }
  var YS = I(null),
    ou = null,
    Ho = null;
  function Dl(d, f, v) {
    Y(YS, f._currentValue), (f._currentValue = v);
  }
  function Vo(d) {
    (d._currentValue = YS.current), F(YS);
  }
  function XS(d, f, v) {
    for (; d !== null; ) {
      var x = d.alternate;
      if (
        ((d.childLanes & f) !== f
          ? ((d.childLanes |= f), x !== null && (x.childLanes |= f))
          : x !== null && (x.childLanes & f) !== f && (x.childLanes |= f),
        d === v)
      )
        break;
      d = d.return;
    }
  }
  function QS(d, f, v, x) {
    var T = d.child;
    for (T !== null && (T.return = d); T !== null; ) {
      var k = T.dependencies;
      if (k !== null) {
        var G = T.child;
        k = k.firstContext;
        e: for (; k !== null; ) {
          var ee = k;
          k = T;
          for (var oe = 0; oe < f.length; oe++)
            if (ee.context === f[oe]) {
              (k.lanes |= v),
                (ee = k.alternate),
                ee !== null && (ee.lanes |= v),
                XS(k.return, v, d),
                x || (G = null);
              break e;
            }
          k = ee.next;
        }
      } else if (T.tag === 18) {
        if (((G = T.return), G === null)) throw Error(s(341));
        (G.lanes |= v),
          (k = G.alternate),
          k !== null && (k.lanes |= v),
          XS(G, v, d),
          (G = null);
      } else G = T.child;
      if (G !== null) G.return = T;
      else
        for (G = T; G !== null; ) {
          if (G === d) {
            G = null;
            break;
          }
          if (((T = G.sibling), T !== null)) {
            (T.return = G.return), (G = T);
            break;
          }
          G = G.return;
        }
      T = G;
    }
  }
  function fm(d, f, v, x) {
    d = null;
    for (var T = f, k = !1; T !== null; ) {
      if (!k) {
        if ((T.flags & 524288) !== 0) k = !0;
        else if ((T.flags & 262144) !== 0) break;
      }
      if (T.tag === 10) {
        var G = T.alternate;
        if (G === null) throw Error(s(387));
        if (((G = G.memoizedProps), G !== null)) {
          var ee = T.type;
          di(T.pendingProps.value, G.value) ||
            (d !== null ? d.push(ee) : (d = [ee]));
        }
      } else if (T === te.current) {
        if (((G = T.alternate), G === null)) throw Error(s(387));
        G.memoizedState.memoizedState !== T.memoizedState.memoizedState &&
          (d !== null ? d.push(Hm) : (d = [Hm]));
      }
      T = T.return;
    }
    d !== null && QS(f, d, v, x), (f.flags |= 262144);
  }
  function d0(d) {
    for (d = d.firstContext; d !== null; ) {
      if (!di(d.context._currentValue, d.memoizedValue)) return !0;
      d = d.next;
    }
    return !1;
  }
  function lu(d) {
    (ou = d),
      (Ho = null),
      (d = d.dependencies),
      d !== null && (d.firstContext = null);
  }
  function wr(d) {
    return o2(ou, d);
  }
  function h0(d, f) {
    return ou === null && lu(d), o2(d, f);
  }
  function o2(d, f) {
    var v = f._currentValue;
    if (((f = { context: f, memoizedValue: v, next: null }), Ho === null)) {
      if (d === null) throw Error(s(308));
      (Ho = f),
        (d.dependencies = { lanes: 0, firstContext: f }),
        (d.flags |= 524288);
    } else Ho = Ho.next = f;
    return v;
  }
  var sZ =
      typeof AbortController < "u"
        ? AbortController
        : function () {
            var d = [],
              f = (this.signal = {
                aborted: !1,
                addEventListener: function (v, x) {
                  d.push(x);
                },
              });
            this.abort = function () {
              (f.aborted = !0),
                d.forEach(function (v) {
                  return v();
                });
            };
          },
    rZ = n.unstable_scheduleCallback,
    iZ = n.unstable_NormalPriority,
    Us = {
      $$typeof: _,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
    };
  function ZS() {
    return { controller: new sZ(), data: new Map(), refCount: 0 };
  }
  function mm(d) {
    d.refCount--,
      d.refCount === 0 &&
        rZ(iZ, function () {
          d.controller.abort();
        });
  }
  var pm = null,
    JS = 0,
    Rd = 0,
    kd = null;
  function aZ(d, f) {
    if (pm === null) {
      var v = (pm = []);
      (JS = 0),
        (Rd = t_()),
        (kd = {
          status: "pending",
          value: void 0,
          then: function (x) {
            v.push(x);
          },
        });
    }
    return JS++, f.then(l2, l2), f;
  }
  function l2() {
    if (--JS === 0 && pm !== null) {
      kd !== null && (kd.status = "fulfilled");
      var d = pm;
      (pm = null), (Rd = 0), (kd = null);
      for (var f = 0; f < d.length; f++) (0, d[f])();
    }
  }
  function oZ(d, f) {
    var v = [],
      x = {
        status: "pending",
        value: null,
        reason: null,
        then: function (T) {
          v.push(T);
        },
      };
    return (
      d.then(
        function () {
          (x.status = "fulfilled"), (x.value = f);
          for (var T = 0; T < v.length; T++) (0, v[T])(f);
        },
        function (T) {
          for (x.status = "rejected", x.reason = T, T = 0; T < v.length; T++)
            (0, v[T])(void 0);
        }
      ),
      x
    );
  }
  var c2 = O.S;
  O.S = function (d, f) {
    typeof f == "object" &&
      f !== null &&
      typeof f.then == "function" &&
      aZ(d, f),
      c2 !== null && c2(d, f);
  };
  var cu = I(null);
  function eT() {
    var d = cu.current;
    return d !== null ? d : Fn.pooledCache;
  }
  function f0(d, f) {
    f === null ? Y(cu, cu.current) : Y(cu, f.pool);
  }
  function u2() {
    var d = eT();
    return d === null ? null : { parent: Us._currentValue, pool: d };
  }
  var gm = Error(s(460)),
    d2 = Error(s(474)),
    m0 = Error(s(542)),
    tT = { then: function () {} };
  function h2(d) {
    return (d = d.status), d === "fulfilled" || d === "rejected";
  }
  function p0() {}
  function f2(d, f, v) {
    switch (
      ((v = d[v]),
      v === void 0 ? d.push(f) : v !== f && (f.then(p0, p0), (f = v)),
      f.status)
    ) {
      case "fulfilled":
        return f.value;
      case "rejected":
        throw ((d = f.reason), p2(d), d);
      default:
        if (typeof f.status == "string") f.then(p0, p0);
        else {
          if (((d = Fn), d !== null && 100 < d.shellSuspendCounter))
            throw Error(s(482));
          (d = f),
            (d.status = "pending"),
            d.then(
              function (x) {
                if (f.status === "pending") {
                  var T = f;
                  (T.status = "fulfilled"), (T.value = x);
                }
              },
              function (x) {
                if (f.status === "pending") {
                  var T = f;
                  (T.status = "rejected"), (T.reason = x);
                }
              }
            );
        }
        switch (f.status) {
          case "fulfilled":
            return f.value;
          case "rejected":
            throw ((d = f.reason), p2(d), d);
        }
        throw ((vm = f), gm);
    }
  }
  var vm = null;
  function m2() {
    if (vm === null) throw Error(s(459));
    var d = vm;
    return (vm = null), d;
  }
  function p2(d) {
    if (d === gm || d === m0) throw Error(s(483));
  }
  var Pl = !1;
  function nT(d) {
    d.updateQueue = {
      baseState: d.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null,
    };
  }
  function sT(d, f) {
    (d = d.updateQueue),
      f.updateQueue === d &&
        (f.updateQueue = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          callbacks: null,
        });
  }
  function Ml(d) {
    return { lane: d, tag: 0, payload: null, callback: null, next: null };
  }
  function Nl(d, f, v) {
    var x = d.updateQueue;
    if (x === null) return null;
    if (((x = x.shared), (En & 2) !== 0)) {
      var T = x.pending;
      return (
        T === null ? (f.next = f) : ((f.next = T.next), (T.next = f)),
        (x.pending = f),
        (f = o0(d)),
        t2(d, null, v),
        f
      );
    }
    return a0(d, x, f, v), o0(d);
  }
  function ym(d, f, v) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (v & 4194048) !== 0))
    ) {
      var x = f.lanes;
      (x &= d.pendingLanes), (v |= x), (f.lanes = v), Je(d, v);
    }
  }
  function rT(d, f) {
    var v = d.updateQueue,
      x = d.alternate;
    if (x !== null && ((x = x.updateQueue), v === x)) {
      var T = null,
        k = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var G = {
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: null,
            next: null,
          };
          k === null ? (T = k = G) : (k = k.next = G), (v = v.next);
        } while (v !== null);
        k === null ? (T = k = f) : (k = k.next = f);
      } else T = k = f;
      (v = {
        baseState: x.baseState,
        firstBaseUpdate: T,
        lastBaseUpdate: k,
        shared: x.shared,
        callbacks: x.callbacks,
      }),
        (d.updateQueue = v);
      return;
    }
    (d = v.lastBaseUpdate),
      d === null ? (v.firstBaseUpdate = f) : (d.next = f),
      (v.lastBaseUpdate = f);
  }
  var iT = !1;
  function bm() {
    if (iT) {
      var d = kd;
      if (d !== null) throw d;
    }
  }
  function xm(d, f, v, x) {
    iT = !1;
    var T = d.updateQueue;
    Pl = !1;
    var k = T.firstBaseUpdate,
      G = T.lastBaseUpdate,
      ee = T.shared.pending;
    if (ee !== null) {
      T.shared.pending = null;
      var oe = ee,
        Se = oe.next;
      (oe.next = null), G === null ? (k = Se) : (G.next = Se), (G = oe);
      var Pe = d.alternate;
      Pe !== null &&
        ((Pe = Pe.updateQueue),
        (ee = Pe.lastBaseUpdate),
        ee !== G &&
          (ee === null ? (Pe.firstBaseUpdate = Se) : (ee.next = Se),
          (Pe.lastBaseUpdate = oe)));
    }
    if (k !== null) {
      var Fe = T.baseState;
      (G = 0), (Pe = Se = oe = null), (ee = k);
      do {
        var Te = ee.lane & -536870913,
          Ae = Te !== ee.lane;
        if (Ae ? (cn & Te) === Te : (x & Te) === Te) {
          Te !== 0 && Te === Rd && (iT = !0),
            Pe !== null &&
              (Pe = Pe.next =
                {
                  lane: 0,
                  tag: ee.tag,
                  payload: ee.payload,
                  callback: null,
                  next: null,
                });
          e: {
            var Ct = d,
              _t = ee;
            Te = f;
            var kn = v;
            switch (_t.tag) {
              case 1:
                if (((Ct = _t.payload), typeof Ct == "function")) {
                  Fe = Ct.call(kn, Fe, Te);
                  break e;
                }
                Fe = Ct;
                break e;
              case 3:
                Ct.flags = (Ct.flags & -65537) | 128;
              case 0:
                if (
                  ((Ct = _t.payload),
                  (Te = typeof Ct == "function" ? Ct.call(kn, Fe, Te) : Ct),
                  Te == null)
                )
                  break e;
                Fe = h({}, Fe, Te);
                break e;
              case 2:
                Pl = !0;
            }
          }
          (Te = ee.callback),
            Te !== null &&
              ((d.flags |= 64),
              Ae && (d.flags |= 8192),
              (Ae = T.callbacks),
              Ae === null ? (T.callbacks = [Te]) : Ae.push(Te));
        } else
          (Ae = {
            lane: Te,
            tag: ee.tag,
            payload: ee.payload,
            callback: ee.callback,
            next: null,
          }),
            Pe === null ? ((Se = Pe = Ae), (oe = Fe)) : (Pe = Pe.next = Ae),
            (G |= Te);
        if (((ee = ee.next), ee === null)) {
          if (((ee = T.shared.pending), ee === null)) break;
          (Ae = ee),
            (ee = Ae.next),
            (Ae.next = null),
            (T.lastBaseUpdate = Ae),
            (T.shared.pending = null);
        }
      } while (!0);
      Pe === null && (oe = Fe),
        (T.baseState = oe),
        (T.firstBaseUpdate = Se),
        (T.lastBaseUpdate = Pe),
        k === null && (T.shared.lanes = 0),
        (Vl |= G),
        (d.lanes = G),
        (d.memoizedState = Fe);
    }
  }
  function g2(d, f) {
    if (typeof d != "function") throw Error(s(191, d));
    d.call(f);
  }
  function v2(d, f) {
    var v = d.callbacks;
    if (v !== null)
      for (d.callbacks = null, d = 0; d < v.length; d++) g2(v[d], f);
  }
  var Cd = I(null),
    g0 = I(0);
  function y2(d, f) {
    (d = Xo), Y(g0, d), Y(Cd, f), (Xo = d | f.baseLanes);
  }
  function aT() {
    Y(g0, Xo), Y(Cd, Cd.current);
  }
  function oT() {
    (Xo = g0.current), F(Cd), F(g0);
  }
  var Ol = 0,
    Yt = null,
    An = null,
    Cs = null,
    v0 = !1,
    Id = !1,
    uu = !1,
    y0 = 0,
    wm = 0,
    Ld = null,
    lZ = 0;
  function Ss() {
    throw Error(s(321));
  }
  function lT(d, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < d.length; v++)
      if (!di(d[v], f[v])) return !1;
    return !0;
  }
  function cT(d, f, v, x, T, k) {
    return (
      (Ol = k),
      (Yt = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (O.H = d === null || d.memoizedState === null ? tN : nN),
      (uu = !1),
      (k = v(x, T)),
      (uu = !1),
      Id && (k = x2(f, v, x, T)),
      b2(d),
      k
    );
  }
  function b2(d) {
    O.H = T0;
    var f = An !== null && An.next !== null;
    if (((Ol = 0), (Cs = An = Yt = null), (v0 = !1), (wm = 0), (Ld = null), f))
      throw Error(s(300));
    d === null ||
      Ks ||
      ((d = d.dependencies), d !== null && d0(d) && (Ks = !0));
  }
  function x2(d, f, v, x) {
    Yt = d;
    var T = 0;
    do {
      if ((Id && (Ld = null), (wm = 0), (Id = !1), 25 <= T))
        throw Error(s(301));
      if (((T += 1), (Cs = An = null), d.updateQueue != null)) {
        var k = d.updateQueue;
        (k.lastEffect = null),
          (k.events = null),
          (k.stores = null),
          k.memoCache != null && (k.memoCache.index = 0);
      }
      (O.H = pZ), (k = f(v, x));
    } while (Id);
    return k;
  }
  function cZ() {
    var d = O.H,
      f = d.useState()[0];
    return (
      (f = typeof f.then == "function" ? Em(f) : f),
      (d = d.useState()[0]),
      (An !== null ? An.memoizedState : null) !== d && (Yt.flags |= 1024),
      f
    );
  }
  function uT() {
    var d = y0 !== 0;
    return (y0 = 0), d;
  }
  function dT(d, f, v) {
    (f.updateQueue = d.updateQueue), (f.flags &= -2053), (d.lanes &= ~v);
  }
  function hT(d) {
    if (v0) {
      for (d = d.memoizedState; d !== null; ) {
        var f = d.queue;
        f !== null && (f.pending = null), (d = d.next);
      }
      v0 = !1;
    }
    (Ol = 0), (Cs = An = Yt = null), (Id = !1), (wm = y0 = 0), (Ld = null);
  }
  function zr() {
    var d = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Cs === null ? (Yt.memoizedState = Cs = d) : (Cs = Cs.next = d), Cs;
  }
  function Is() {
    if (An === null) {
      var d = Yt.alternate;
      d = d !== null ? d.memoizedState : null;
    } else d = An.next;
    var f = Cs === null ? Yt.memoizedState : Cs.next;
    if (f !== null) (Cs = f), (An = d);
    else {
      if (d === null)
        throw Yt.alternate === null ? Error(s(467)) : Error(s(310));
      (An = d),
        (d = {
          memoizedState: An.memoizedState,
          baseState: An.baseState,
          baseQueue: An.baseQueue,
          queue: An.queue,
          next: null,
        }),
        Cs === null ? (Yt.memoizedState = Cs = d) : (Cs = Cs.next = d);
    }
    return Cs;
  }
  function fT() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Em(d) {
    var f = wm;
    return (
      (wm += 1),
      Ld === null && (Ld = []),
      (d = f2(Ld, d, f)),
      (f = Yt),
      (Cs === null ? f.memoizedState : Cs.next) === null &&
        ((f = f.alternate),
        (O.H = f === null || f.memoizedState === null ? tN : nN)),
      d
    );
  }
  function b0(d) {
    if (d !== null && typeof d == "object") {
      if (typeof d.then == "function") return Em(d);
      if (d.$$typeof === _) return wr(d);
    }
    throw Error(s(438, String(d)));
  }
  function mT(d) {
    var f = null,
      v = Yt.updateQueue;
    if ((v !== null && (f = v.memoCache), f == null)) {
      var x = Yt.alternate;
      x !== null &&
        ((x = x.updateQueue),
        x !== null &&
          ((x = x.memoCache),
          x != null &&
            (f = {
              data: x.data.map(function (T) {
                return T.slice();
              }),
              index: 0,
            })));
    }
    if (
      (f == null && (f = { data: [], index: 0 }),
      v === null && ((v = fT()), (Yt.updateQueue = v)),
      (v.memoCache = f),
      (v = f.data[f.index]),
      v === void 0)
    )
      for (v = f.data[f.index] = Array(d), x = 0; x < d; x++) v[x] = N;
    return f.index++, v;
  }
  function zo(d, f) {
    return typeof f == "function" ? f(d) : f;
  }
  function x0(d) {
    var f = Is();
    return pT(f, An, d);
  }
  function pT(d, f, v) {
    var x = d.queue;
    if (x === null) throw Error(s(311));
    x.lastRenderedReducer = v;
    var T = d.baseQueue,
      k = x.pending;
    if (k !== null) {
      if (T !== null) {
        var G = T.next;
        (T.next = k.next), (k.next = G);
      }
      (f.baseQueue = T = k), (x.pending = null);
    }
    if (((k = d.baseState), T === null)) d.memoizedState = k;
    else {
      f = T.next;
      var ee = (G = null),
        oe = null,
        Se = f,
        Pe = !1;
      do {
        var Fe = Se.lane & -536870913;
        if (Fe !== Se.lane ? (cn & Fe) === Fe : (Ol & Fe) === Fe) {
          var Te = Se.revertLane;
          if (Te === 0)
            oe !== null &&
              (oe = oe.next =
                {
                  lane: 0,
                  revertLane: 0,
                  action: Se.action,
                  hasEagerState: Se.hasEagerState,
                  eagerState: Se.eagerState,
                  next: null,
                }),
              Fe === Rd && (Pe = !0);
          else if ((Ol & Te) === Te) {
            (Se = Se.next), Te === Rd && (Pe = !0);
            continue;
          } else
            (Fe = {
              lane: 0,
              revertLane: Se.revertLane,
              action: Se.action,
              hasEagerState: Se.hasEagerState,
              eagerState: Se.eagerState,
              next: null,
            }),
              oe === null ? ((ee = oe = Fe), (G = k)) : (oe = oe.next = Fe),
              (Yt.lanes |= Te),
              (Vl |= Te);
          (Fe = Se.action),
            uu && v(k, Fe),
            (k = Se.hasEagerState ? Se.eagerState : v(k, Fe));
        } else
          (Te = {
            lane: Fe,
            revertLane: Se.revertLane,
            action: Se.action,
            hasEagerState: Se.hasEagerState,
            eagerState: Se.eagerState,
            next: null,
          }),
            oe === null ? ((ee = oe = Te), (G = k)) : (oe = oe.next = Te),
            (Yt.lanes |= Fe),
            (Vl |= Fe);
        Se = Se.next;
      } while (Se !== null && Se !== f);
      if (
        (oe === null ? (G = k) : (oe.next = ee),
        !di(k, d.memoizedState) && ((Ks = !0), Pe && ((v = kd), v !== null)))
      )
        throw v;
      (d.memoizedState = k),
        (d.baseState = G),
        (d.baseQueue = oe),
        (x.lastRenderedState = k);
    }
    return T === null && (x.lanes = 0), [d.memoizedState, x.dispatch];
  }
  function gT(d) {
    var f = Is(),
      v = f.queue;
    if (v === null) throw Error(s(311));
    v.lastRenderedReducer = d;
    var x = v.dispatch,
      T = v.pending,
      k = f.memoizedState;
    if (T !== null) {
      v.pending = null;
      var G = (T = T.next);
      do (k = d(k, G.action)), (G = G.next);
      while (G !== T);
      di(k, f.memoizedState) || (Ks = !0),
        (f.memoizedState = k),
        f.baseQueue === null && (f.baseState = k),
        (v.lastRenderedState = k);
    }
    return [k, x];
  }
  function w2(d, f, v) {
    var x = Yt,
      T = Is(),
      k = gn;
    if (k) {
      if (v === void 0) throw Error(s(407));
      v = v();
    } else v = f();
    var G = !di((An || T).memoizedState, v);
    G && ((T.memoizedState = v), (Ks = !0)), (T = T.queue);
    var ee = T2.bind(null, x, T, d);
    if (
      (Sm(2048, 8, ee, [d]),
      T.getSnapshot !== f || G || (Cs !== null && Cs.memoizedState.tag & 1))
    ) {
      if (
        ((x.flags |= 2048),
        Dd(9, w0(), S2.bind(null, x, T, v, f), null),
        Fn === null)
      )
        throw Error(s(349));
      k || (Ol & 124) !== 0 || E2(x, f, v);
    }
    return v;
  }
  function E2(d, f, v) {
    (d.flags |= 16384),
      (d = { getSnapshot: f, value: v }),
      (f = Yt.updateQueue),
      f === null
        ? ((f = fT()), (Yt.updateQueue = f), (f.stores = [d]))
        : ((v = f.stores), v === null ? (f.stores = [d]) : v.push(d));
  }
  function S2(d, f, v, x) {
    (f.value = v), (f.getSnapshot = x), _2(f) && A2(d);
  }
  function T2(d, f, v) {
    return v(function () {
      _2(f) && A2(d);
    });
  }
  function _2(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var v = f();
      return !di(d, v);
    } catch {
      return !0;
    }
  }
  function A2(d) {
    var f = Sd(d, 2);
    f !== null && vi(f, d, 2);
  }
  function vT(d) {
    var f = zr();
    if (typeof d == "function") {
      var v = d;
      if (((d = v()), uu)) {
        _e(!0);
        try {
          v();
        } finally {
          _e(!1);
        }
      }
    }
    return (
      (f.memoizedState = f.baseState = d),
      (f.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: d,
      }),
      f
    );
  }
  function R2(d, f, v, x) {
    return (d.baseState = v), pT(d, An, typeof x == "function" ? x : zo);
  }
  function uZ(d, f, v, x, T) {
    if (S0(d)) throw Error(s(485));
    if (((d = f.action), d !== null)) {
      var k = {
        payload: T,
        action: d,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (G) {
          k.listeners.push(G);
        },
      };
      O.T !== null ? v(!0) : (k.isTransition = !1),
        x(k),
        (v = f.pending),
        v === null
          ? ((k.next = f.pending = k), k2(f, k))
          : ((k.next = v.next), (f.pending = v.next = k));
    }
  }
  function k2(d, f) {
    var v = f.action,
      x = f.payload,
      T = d.state;
    if (f.isTransition) {
      var k = O.T,
        G = {};
      O.T = G;
      try {
        var ee = v(T, x),
          oe = O.S;
        oe !== null && oe(G, ee), C2(d, f, ee);
      } catch (Se) {
        yT(d, f, Se);
      } finally {
        O.T = k;
      }
    } else
      try {
        (k = v(T, x)), C2(d, f, k);
      } catch (Se) {
        yT(d, f, Se);
      }
  }
  function C2(d, f, v) {
    v !== null && typeof v == "object" && typeof v.then == "function"
      ? v.then(
          function (x) {
            I2(d, f, x);
          },
          function (x) {
            return yT(d, f, x);
          }
        )
      : I2(d, f, v);
  }
  function I2(d, f, v) {
    (f.status = "fulfilled"),
      (f.value = v),
      L2(f),
      (d.state = v),
      (f = d.pending),
      f !== null &&
        ((v = f.next),
        v === f ? (d.pending = null) : ((v = v.next), (f.next = v), k2(d, v)));
  }
  function yT(d, f, v) {
    var x = d.pending;
    if (((d.pending = null), x !== null)) {
      x = x.next;
      do (f.status = "rejected"), (f.reason = v), L2(f), (f = f.next);
      while (f !== x);
    }
    d.action = null;
  }
  function L2(d) {
    d = d.listeners;
    for (var f = 0; f < d.length; f++) (0, d[f])();
  }
  function D2(d, f) {
    return f;
  }
  function P2(d, f) {
    if (gn) {
      var v = Fn.formState;
      if (v !== null) {
        e: {
          var x = Yt;
          if (gn) {
            if (cs) {
              t: {
                for (var T = cs, k = Ga; T.nodeType !== 8; ) {
                  if (!k) {
                    T = null;
                    break t;
                  }
                  if (((T = pa(T.nextSibling)), T === null)) {
                    T = null;
                    break t;
                  }
                }
                (k = T.data), (T = k === "F!" || k === "F" ? T : null);
              }
              if (T) {
                (cs = pa(T.nextSibling)), (x = T.data === "F!");
                break e;
              }
            }
            au(x);
          }
          x = !1;
        }
        x && (f = v[0]);
      }
    }
    return (
      (v = zr()),
      (v.memoizedState = v.baseState = f),
      (x = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: D2,
        lastRenderedState: f,
      }),
      (v.queue = x),
      (v = Z2.bind(null, Yt, x)),
      (x.dispatch = v),
      (x = vT(!1)),
      (k = ST.bind(null, Yt, !1, x.queue)),
      (x = zr()),
      (T = { state: f, dispatch: null, action: d, pending: null }),
      (x.queue = T),
      (v = uZ.bind(null, Yt, T, k, v)),
      (T.dispatch = v),
      (x.memoizedState = d),
      [f, v, !1]
    );
  }
  function M2(d) {
    var f = Is();
    return N2(f, An, d);
  }
  function N2(d, f, v) {
    if (
      ((f = pT(d, f, D2)[0]),
      (d = x0(zo)[0]),
      typeof f == "object" && f !== null && typeof f.then == "function")
    )
      try {
        var x = Em(f);
      } catch (G) {
        throw G === gm ? m0 : G;
      }
    else x = f;
    f = Is();
    var T = f.queue,
      k = T.dispatch;
    return (
      v !== f.memoizedState &&
        ((Yt.flags |= 2048), Dd(9, w0(), dZ.bind(null, T, v), null)),
      [x, k, d]
    );
  }
  function dZ(d, f) {
    d.action = f;
  }
  function O2(d) {
    var f = Is(),
      v = An;
    if (v !== null) return N2(f, v, d);
    Is(), (f = f.memoizedState), (v = Is());
    var x = v.queue.dispatch;
    return (v.memoizedState = d), [f, x, !1];
  }
  function Dd(d, f, v, x) {
    return (
      (d = { tag: d, create: v, deps: x, inst: f, next: null }),
      (f = Yt.updateQueue),
      f === null && ((f = fT()), (Yt.updateQueue = f)),
      (v = f.lastEffect),
      v === null
        ? (f.lastEffect = d.next = d)
        : ((x = v.next), (v.next = d), (d.next = x), (f.lastEffect = d)),
      d
    );
  }
  function w0() {
    return { destroy: void 0, resource: void 0 };
  }
  function j2() {
    return Is().memoizedState;
  }
  function E0(d, f, v, x) {
    var T = zr();
    (x = x === void 0 ? null : x),
      (Yt.flags |= d),
      (T.memoizedState = Dd(1 | f, w0(), v, x));
  }
  function Sm(d, f, v, x) {
    var T = Is();
    x = x === void 0 ? null : x;
    var k = T.memoizedState.inst;
    An !== null && x !== null && lT(x, An.memoizedState.deps)
      ? (T.memoizedState = Dd(f, k, v, x))
      : ((Yt.flags |= d), (T.memoizedState = Dd(1 | f, k, v, x)));
  }
  function F2(d, f) {
    E0(8390656, 8, d, f);
  }
  function U2(d, f) {
    Sm(2048, 8, d, f);
  }
  function $2(d, f) {
    return Sm(4, 2, d, f);
  }
  function B2(d, f) {
    return Sm(4, 4, d, f);
  }
  function H2(d, f) {
    if (typeof f == "function") {
      d = d();
      var v = f(d);
      return function () {
        typeof v == "function" ? v() : f(null);
      };
    }
    if (f != null)
      return (
        (d = d()),
        (f.current = d),
        function () {
          f.current = null;
        }
      );
  }
  function V2(d, f, v) {
    (v = v != null ? v.concat([d]) : null), Sm(4, 4, H2.bind(null, f, d), v);
  }
  function bT() {}
  function z2(d, f) {
    var v = Is();
    f = f === void 0 ? null : f;
    var x = v.memoizedState;
    return f !== null && lT(f, x[1]) ? x[0] : ((v.memoizedState = [d, f]), d);
  }
  function G2(d, f) {
    var v = Is();
    f = f === void 0 ? null : f;
    var x = v.memoizedState;
    if (f !== null && lT(f, x[1])) return x[0];
    if (((x = d()), uu)) {
      _e(!0);
      try {
        d();
      } finally {
        _e(!1);
      }
    }
    return (v.memoizedState = [x, f]), x;
  }
  function xT(d, f, v) {
    return v === void 0 || (Ol & 1073741824) !== 0
      ? (d.memoizedState = f)
      : ((d.memoizedState = v), (d = KN()), (Yt.lanes |= d), (Vl |= d), v);
  }
  function q2(d, f, v, x) {
    return di(v, f)
      ? v
      : Cd.current !== null
      ? ((d = xT(d, v, x)), di(d, f) || (Ks = !0), d)
      : (Ol & 42) === 0
      ? ((Ks = !0), (d.memoizedState = v))
      : ((d = KN()), (Yt.lanes |= d), (Vl |= d), f);
  }
  function W2(d, f, v, x, T) {
    var k = U.p;
    U.p = k !== 0 && 8 > k ? k : 8;
    var G = O.T,
      ee = {};
    (O.T = ee), ST(d, !1, f, v);
    try {
      var oe = T(),
        Se = O.S;
      if (
        (Se !== null && Se(ee, oe),
        oe !== null && typeof oe == "object" && typeof oe.then == "function")
      ) {
        var Pe = oZ(oe, x);
        Tm(d, f, Pe, gi(d));
      } else Tm(d, f, x, gi(d));
    } catch (Fe) {
      Tm(d, f, { then: function () {}, status: "rejected", reason: Fe }, gi());
    } finally {
      (U.p = k), (O.T = G);
    }
  }
  function hZ() {}
  function wT(d, f, v, x) {
    if (d.tag !== 5) throw Error(s(476));
    var T = K2(d).queue;
    W2(
      d,
      T,
      f,
      j,
      v === null
        ? hZ
        : function () {
            return Y2(d), v(x);
          }
    );
  }
  function K2(d) {
    var f = d.memoizedState;
    if (f !== null) return f;
    f = {
      memoizedState: j,
      baseState: j,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: j,
      },
      next: null,
    };
    var v = {};
    return (
      (f.next = {
        memoizedState: v,
        baseState: v,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: zo,
          lastRenderedState: v,
        },
        next: null,
      }),
      (d.memoizedState = f),
      (d = d.alternate),
      d !== null && (d.memoizedState = f),
      f
    );
  }
  function Y2(d) {
    var f = K2(d).next.queue;
    Tm(d, f, {}, gi());
  }
  function ET() {
    return wr(Hm);
  }
  function X2() {
    return Is().memoizedState;
  }
  function Q2() {
    return Is().memoizedState;
  }
  function fZ(d) {
    for (var f = d.return; f !== null; ) {
      switch (f.tag) {
        case 24:
        case 3:
          var v = gi();
          d = Ml(v);
          var x = Nl(f, d, v);
          x !== null && (vi(x, f, v), ym(x, f, v)),
            (f = { cache: ZS() }),
            (d.payload = f);
          return;
      }
      f = f.return;
    }
  }
  function mZ(d, f, v) {
    var x = gi();
    (v = {
      lane: x,
      revertLane: 0,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      S0(d)
        ? J2(f, v)
        : ((v = HS(d, f, v, x)), v !== null && (vi(v, d, x), eN(v, f, x)));
  }
  function Z2(d, f, v) {
    var x = gi();
    Tm(d, f, v, x);
  }
  function Tm(d, f, v, x) {
    var T = {
      lane: x,
      revertLane: 0,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
    if (S0(d)) J2(f, T);
    else {
      var k = d.alternate;
      if (
        d.lanes === 0 &&
        (k === null || k.lanes === 0) &&
        ((k = f.lastRenderedReducer), k !== null)
      )
        try {
          var G = f.lastRenderedState,
            ee = k(G, v);
          if (((T.hasEagerState = !0), (T.eagerState = ee), di(ee, G)))
            return a0(d, f, T, 0), Fn === null && i0(), !1;
        } catch {
        } finally {
        }
      if (((v = HS(d, f, T, x)), v !== null))
        return vi(v, d, x), eN(v, f, x), !0;
    }
    return !1;
  }
  function ST(d, f, v, x) {
    if (
      ((x = {
        lane: 2,
        revertLane: t_(),
        action: x,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      S0(d))
    ) {
      if (f) throw Error(s(479));
    } else (f = HS(d, v, x, 2)), f !== null && vi(f, d, 2);
  }
  function S0(d) {
    var f = d.alternate;
    return d === Yt || (f !== null && f === Yt);
  }
  function J2(d, f) {
    Id = v0 = !0;
    var v = d.pending;
    v === null ? (f.next = f) : ((f.next = v.next), (v.next = f)),
      (d.pending = f);
  }
  function eN(d, f, v) {
    if ((v & 4194048) !== 0) {
      var x = f.lanes;
      (x &= d.pendingLanes), (v |= x), (f.lanes = v), Je(d, v);
    }
  }
  var T0 = {
      readContext: wr,
      use: b0,
      useCallback: Ss,
      useContext: Ss,
      useEffect: Ss,
      useImperativeHandle: Ss,
      useLayoutEffect: Ss,
      useInsertionEffect: Ss,
      useMemo: Ss,
      useReducer: Ss,
      useRef: Ss,
      useState: Ss,
      useDebugValue: Ss,
      useDeferredValue: Ss,
      useTransition: Ss,
      useSyncExternalStore: Ss,
      useId: Ss,
      useHostTransitionStatus: Ss,
      useFormState: Ss,
      useActionState: Ss,
      useOptimistic: Ss,
      useMemoCache: Ss,
      useCacheRefresh: Ss,
    },
    tN = {
      readContext: wr,
      use: b0,
      useCallback: function (d, f) {
        return (zr().memoizedState = [d, f === void 0 ? null : f]), d;
      },
      useContext: wr,
      useEffect: F2,
      useImperativeHandle: function (d, f, v) {
        (v = v != null ? v.concat([d]) : null),
          E0(4194308, 4, H2.bind(null, f, d), v);
      },
      useLayoutEffect: function (d, f) {
        return E0(4194308, 4, d, f);
      },
      useInsertionEffect: function (d, f) {
        E0(4, 2, d, f);
      },
      useMemo: function (d, f) {
        var v = zr();
        f = f === void 0 ? null : f;
        var x = d();
        if (uu) {
          _e(!0);
          try {
            d();
          } finally {
            _e(!1);
          }
        }
        return (v.memoizedState = [x, f]), x;
      },
      useReducer: function (d, f, v) {
        var x = zr();
        if (v !== void 0) {
          var T = v(f);
          if (uu) {
            _e(!0);
            try {
              v(f);
            } finally {
              _e(!1);
            }
          }
        } else T = f;
        return (
          (x.memoizedState = x.baseState = T),
          (d = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: d,
            lastRenderedState: T,
          }),
          (x.queue = d),
          (d = d.dispatch = mZ.bind(null, Yt, d)),
          [x.memoizedState, d]
        );
      },
      useRef: function (d) {
        var f = zr();
        return (d = { current: d }), (f.memoizedState = d);
      },
      useState: function (d) {
        d = vT(d);
        var f = d.queue,
          v = Z2.bind(null, Yt, f);
        return (f.dispatch = v), [d.memoizedState, v];
      },
      useDebugValue: bT,
      useDeferredValue: function (d, f) {
        var v = zr();
        return xT(v, d, f);
      },
      useTransition: function () {
        var d = vT(!1);
        return (
          (d = W2.bind(null, Yt, d.queue, !0, !1)),
          (zr().memoizedState = d),
          [!1, d]
        );
      },
      useSyncExternalStore: function (d, f, v) {
        var x = Yt,
          T = zr();
        if (gn) {
          if (v === void 0) throw Error(s(407));
          v = v();
        } else {
          if (((v = f()), Fn === null)) throw Error(s(349));
          (cn & 124) !== 0 || E2(x, f, v);
        }
        T.memoizedState = v;
        var k = { value: v, getSnapshot: f };
        return (
          (T.queue = k),
          F2(T2.bind(null, x, k, d), [d]),
          (x.flags |= 2048),
          Dd(9, w0(), S2.bind(null, x, k, v, f), null),
          v
        );
      },
      useId: function () {
        var d = zr(),
          f = Fn.identifierPrefix;
        if (gn) {
          var v = Bo,
            x = $o;
          (v = (x & ~(1 << (32 - Ue(x) - 1))).toString(32) + v),
            (f = "" + f + "R" + v),
            (v = y0++),
            0 < v && (f += "H" + v.toString(32)),
            (f += "");
        } else (v = lZ++), (f = "" + f + "r" + v.toString(32) + "");
        return (d.memoizedState = f);
      },
      useHostTransitionStatus: ET,
      useFormState: P2,
      useActionState: P2,
      useOptimistic: function (d) {
        var f = zr();
        f.memoizedState = f.baseState = d;
        var v = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null,
        };
        return (
          (f.queue = v),
          (f = ST.bind(null, Yt, !0, v)),
          (v.dispatch = f),
          [d, f]
        );
      },
      useMemoCache: mT,
      useCacheRefresh: function () {
        return (zr().memoizedState = fZ.bind(null, Yt));
      },
    },
    nN = {
      readContext: wr,
      use: b0,
      useCallback: z2,
      useContext: wr,
      useEffect: U2,
      useImperativeHandle: V2,
      useInsertionEffect: $2,
      useLayoutEffect: B2,
      useMemo: G2,
      useReducer: x0,
      useRef: j2,
      useState: function () {
        return x0(zo);
      },
      useDebugValue: bT,
      useDeferredValue: function (d, f) {
        var v = Is();
        return q2(v, An.memoizedState, d, f);
      },
      useTransition: function () {
        var d = x0(zo)[0],
          f = Is().memoizedState;
        return [typeof d == "boolean" ? d : Em(d), f];
      },
      useSyncExternalStore: w2,
      useId: X2,
      useHostTransitionStatus: ET,
      useFormState: M2,
      useActionState: M2,
      useOptimistic: function (d, f) {
        var v = Is();
        return R2(v, An, d, f);
      },
      useMemoCache: mT,
      useCacheRefresh: Q2,
    },
    pZ = {
      readContext: wr,
      use: b0,
      useCallback: z2,
      useContext: wr,
      useEffect: U2,
      useImperativeHandle: V2,
      useInsertionEffect: $2,
      useLayoutEffect: B2,
      useMemo: G2,
      useReducer: gT,
      useRef: j2,
      useState: function () {
        return gT(zo);
      },
      useDebugValue: bT,
      useDeferredValue: function (d, f) {
        var v = Is();
        return An === null ? xT(v, d, f) : q2(v, An.memoizedState, d, f);
      },
      useTransition: function () {
        var d = gT(zo)[0],
          f = Is().memoizedState;
        return [typeof d == "boolean" ? d : Em(d), f];
      },
      useSyncExternalStore: w2,
      useId: X2,
      useHostTransitionStatus: ET,
      useFormState: O2,
      useActionState: O2,
      useOptimistic: function (d, f) {
        var v = Is();
        return An !== null
          ? R2(v, An, d, f)
          : ((v.baseState = d), [d, v.queue.dispatch]);
      },
      useMemoCache: mT,
      useCacheRefresh: Q2,
    },
    Pd = null,
    _m = 0;
  function _0(d) {
    var f = _m;
    return (_m += 1), Pd === null && (Pd = []), f2(Pd, d, f);
  }
  function Am(d, f) {
    (f = f.props.ref), (d.ref = f !== void 0 ? f : null);
  }
  function A0(d, f) {
    throw f.$$typeof === m
      ? Error(s(525))
      : ((d = Object.prototype.toString.call(f)),
        Error(
          s(
            31,
            d === "[object Object]"
              ? "object with keys {" + Object.keys(f).join(", ") + "}"
              : d
          )
        ));
  }
  function sN(d) {
    var f = d._init;
    return f(d._payload);
  }
  function rN(d) {
    function f(me, ue) {
      if (d) {
        var xe = me.deletions;
        xe === null ? ((me.deletions = [ue]), (me.flags |= 16)) : xe.push(ue);
      }
    }
    function v(me, ue) {
      if (!d) return null;
      for (; ue !== null; ) f(me, ue), (ue = ue.sibling);
      return null;
    }
    function x(me) {
      for (var ue = new Map(); me !== null; )
        me.key !== null ? ue.set(me.key, me) : ue.set(me.index, me),
          (me = me.sibling);
      return ue;
    }
    function T(me, ue) {
      return (me = Uo(me, ue)), (me.index = 0), (me.sibling = null), me;
    }
    function k(me, ue, xe) {
      return (
        (me.index = xe),
        d
          ? ((xe = me.alternate),
            xe !== null
              ? ((xe = xe.index), xe < ue ? ((me.flags |= 67108866), ue) : xe)
              : ((me.flags |= 67108866), ue))
          : ((me.flags |= 1048576), ue)
      );
    }
    function G(me) {
      return d && me.alternate === null && (me.flags |= 67108866), me;
    }
    function ee(me, ue, xe, Oe) {
      return ue === null || ue.tag !== 6
        ? ((ue = zS(xe, me.mode, Oe)), (ue.return = me), ue)
        : ((ue = T(ue, xe)), (ue.return = me), ue);
    }
    function oe(me, ue, xe, Oe) {
      var dt = xe.type;
      return dt === y
        ? Pe(me, ue, xe.props.children, Oe, xe.key)
        : ue !== null &&
          (ue.elementType === dt ||
            (typeof dt == "object" &&
              dt !== null &&
              dt.$$typeof === P &&
              sN(dt) === ue.type))
        ? ((ue = T(ue, xe.props)), Am(ue, xe), (ue.return = me), ue)
        : ((ue = l0(xe.type, xe.key, xe.props, null, me.mode, Oe)),
          Am(ue, xe),
          (ue.return = me),
          ue);
    }
    function Se(me, ue, xe, Oe) {
      return ue === null ||
        ue.tag !== 4 ||
        ue.stateNode.containerInfo !== xe.containerInfo ||
        ue.stateNode.implementation !== xe.implementation
        ? ((ue = GS(xe, me.mode, Oe)), (ue.return = me), ue)
        : ((ue = T(ue, xe.children || [])), (ue.return = me), ue);
    }
    function Pe(me, ue, xe, Oe, dt) {
      return ue === null || ue.tag !== 7
        ? ((ue = nu(xe, me.mode, Oe, dt)), (ue.return = me), ue)
        : ((ue = T(ue, xe)), (ue.return = me), ue);
    }
    function Fe(me, ue, xe) {
      if (
        (typeof ue == "string" && ue !== "") ||
        typeof ue == "number" ||
        typeof ue == "bigint"
      )
        return (ue = zS("" + ue, me.mode, xe)), (ue.return = me), ue;
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case p:
            return (
              (xe = l0(ue.type, ue.key, ue.props, null, me.mode, xe)),
              Am(xe, ue),
              (xe.return = me),
              xe
            );
          case g:
            return (ue = GS(ue, me.mode, xe)), (ue.return = me), ue;
          case P:
            var Oe = ue._init;
            return (ue = Oe(ue._payload)), Fe(me, ue, xe);
        }
        if (q(ue) || H(ue))
          return (ue = nu(ue, me.mode, xe, null)), (ue.return = me), ue;
        if (typeof ue.then == "function") return Fe(me, _0(ue), xe);
        if (ue.$$typeof === _) return Fe(me, h0(me, ue), xe);
        A0(me, ue);
      }
      return null;
    }
    function Te(me, ue, xe, Oe) {
      var dt = ue !== null ? ue.key : null;
      if (
        (typeof xe == "string" && xe !== "") ||
        typeof xe == "number" ||
        typeof xe == "bigint"
      )
        return dt !== null ? null : ee(me, ue, "" + xe, Oe);
      if (typeof xe == "object" && xe !== null) {
        switch (xe.$$typeof) {
          case p:
            return xe.key === dt ? oe(me, ue, xe, Oe) : null;
          case g:
            return xe.key === dt ? Se(me, ue, xe, Oe) : null;
          case P:
            return (dt = xe._init), (xe = dt(xe._payload)), Te(me, ue, xe, Oe);
        }
        if (q(xe) || H(xe))
          return dt !== null ? null : Pe(me, ue, xe, Oe, null);
        if (typeof xe.then == "function") return Te(me, ue, _0(xe), Oe);
        if (xe.$$typeof === _) return Te(me, ue, h0(me, xe), Oe);
        A0(me, xe);
      }
      return null;
    }
    function Ae(me, ue, xe, Oe, dt) {
      if (
        (typeof Oe == "string" && Oe !== "") ||
        typeof Oe == "number" ||
        typeof Oe == "bigint"
      )
        return (me = me.get(xe) || null), ee(ue, me, "" + Oe, dt);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case p:
            return (
              (me = me.get(Oe.key === null ? xe : Oe.key) || null),
              oe(ue, me, Oe, dt)
            );
          case g:
            return (
              (me = me.get(Oe.key === null ? xe : Oe.key) || null),
              Se(ue, me, Oe, dt)
            );
          case P:
            var Jt = Oe._init;
            return (Oe = Jt(Oe._payload)), Ae(me, ue, xe, Oe, dt);
        }
        if (q(Oe) || H(Oe))
          return (me = me.get(xe) || null), Pe(ue, me, Oe, dt, null);
        if (typeof Oe.then == "function") return Ae(me, ue, xe, _0(Oe), dt);
        if (Oe.$$typeof === _) return Ae(me, ue, xe, h0(ue, Oe), dt);
        A0(ue, Oe);
      }
      return null;
    }
    function Ct(me, ue, xe, Oe) {
      for (
        var dt = null, Jt = null, wt = ue, Rt = (ue = 0), Xs = null;
        wt !== null && Rt < xe.length;
        Rt++
      ) {
        wt.index > Rt ? ((Xs = wt), (wt = null)) : (Xs = wt.sibling);
        var fn = Te(me, wt, xe[Rt], Oe);
        if (fn === null) {
          wt === null && (wt = Xs);
          break;
        }
        d && wt && fn.alternate === null && f(me, wt),
          (ue = k(fn, ue, Rt)),
          Jt === null ? (dt = fn) : (Jt.sibling = fn),
          (Jt = fn),
          (wt = Xs);
      }
      if (Rt === xe.length) return v(me, wt), gn && ru(me, Rt), dt;
      if (wt === null) {
        for (; Rt < xe.length; Rt++)
          (wt = Fe(me, xe[Rt], Oe)),
            wt !== null &&
              ((ue = k(wt, ue, Rt)),
              Jt === null ? (dt = wt) : (Jt.sibling = wt),
              (Jt = wt));
        return gn && ru(me, Rt), dt;
      }
      for (wt = x(wt); Rt < xe.length; Rt++)
        (Xs = Ae(wt, me, Rt, xe[Rt], Oe)),
          Xs !== null &&
            (d &&
              Xs.alternate !== null &&
              wt.delete(Xs.key === null ? Rt : Xs.key),
            (ue = k(Xs, ue, Rt)),
            Jt === null ? (dt = Xs) : (Jt.sibling = Xs),
            (Jt = Xs));
      return (
        d &&
          wt.forEach(function (Zl) {
            return f(me, Zl);
          }),
        gn && ru(me, Rt),
        dt
      );
    }
    function _t(me, ue, xe, Oe) {
      if (xe == null) throw Error(s(151));
      for (
        var dt = null,
          Jt = null,
          wt = ue,
          Rt = (ue = 0),
          Xs = null,
          fn = xe.next();
        wt !== null && !fn.done;
        Rt++, fn = xe.next()
      ) {
        wt.index > Rt ? ((Xs = wt), (wt = null)) : (Xs = wt.sibling);
        var Zl = Te(me, wt, fn.value, Oe);
        if (Zl === null) {
          wt === null && (wt = Xs);
          break;
        }
        d && wt && Zl.alternate === null && f(me, wt),
          (ue = k(Zl, ue, Rt)),
          Jt === null ? (dt = Zl) : (Jt.sibling = Zl),
          (Jt = Zl),
          (wt = Xs);
      }
      if (fn.done) return v(me, wt), gn && ru(me, Rt), dt;
      if (wt === null) {
        for (; !fn.done; Rt++, fn = xe.next())
          (fn = Fe(me, fn.value, Oe)),
            fn !== null &&
              ((ue = k(fn, ue, Rt)),
              Jt === null ? (dt = fn) : (Jt.sibling = fn),
              (Jt = fn));
        return gn && ru(me, Rt), dt;
      }
      for (wt = x(wt); !fn.done; Rt++, fn = xe.next())
        (fn = Ae(wt, me, Rt, fn.value, Oe)),
          fn !== null &&
            (d &&
              fn.alternate !== null &&
              wt.delete(fn.key === null ? Rt : fn.key),
            (ue = k(fn, ue, Rt)),
            Jt === null ? (dt = fn) : (Jt.sibling = fn),
            (Jt = fn));
      return (
        d &&
          wt.forEach(function (gJ) {
            return f(me, gJ);
          }),
        gn && ru(me, Rt),
        dt
      );
    }
    function kn(me, ue, xe, Oe) {
      if (
        (typeof xe == "object" &&
          xe !== null &&
          xe.type === y &&
          xe.key === null &&
          (xe = xe.props.children),
        typeof xe == "object" && xe !== null)
      ) {
        switch (xe.$$typeof) {
          case p:
            e: {
              for (var dt = xe.key; ue !== null; ) {
                if (ue.key === dt) {
                  if (((dt = xe.type), dt === y)) {
                    if (ue.tag === 7) {
                      v(me, ue.sibling),
                        (Oe = T(ue, xe.props.children)),
                        (Oe.return = me),
                        (me = Oe);
                      break e;
                    }
                  } else if (
                    ue.elementType === dt ||
                    (typeof dt == "object" &&
                      dt !== null &&
                      dt.$$typeof === P &&
                      sN(dt) === ue.type)
                  ) {
                    v(me, ue.sibling),
                      (Oe = T(ue, xe.props)),
                      Am(Oe, xe),
                      (Oe.return = me),
                      (me = Oe);
                    break e;
                  }
                  v(me, ue);
                  break;
                } else f(me, ue);
                ue = ue.sibling;
              }
              xe.type === y
                ? ((Oe = nu(xe.props.children, me.mode, Oe, xe.key)),
                  (Oe.return = me),
                  (me = Oe))
                : ((Oe = l0(xe.type, xe.key, xe.props, null, me.mode, Oe)),
                  Am(Oe, xe),
                  (Oe.return = me),
                  (me = Oe));
            }
            return G(me);
          case g:
            e: {
              for (dt = xe.key; ue !== null; ) {
                if (ue.key === dt)
                  if (
                    ue.tag === 4 &&
                    ue.stateNode.containerInfo === xe.containerInfo &&
                    ue.stateNode.implementation === xe.implementation
                  ) {
                    v(me, ue.sibling),
                      (Oe = T(ue, xe.children || [])),
                      (Oe.return = me),
                      (me = Oe);
                    break e;
                  } else {
                    v(me, ue);
                    break;
                  }
                else f(me, ue);
                ue = ue.sibling;
              }
              (Oe = GS(xe, me.mode, Oe)), (Oe.return = me), (me = Oe);
            }
            return G(me);
          case P:
            return (dt = xe._init), (xe = dt(xe._payload)), kn(me, ue, xe, Oe);
        }
        if (q(xe)) return Ct(me, ue, xe, Oe);
        if (H(xe)) {
          if (((dt = H(xe)), typeof dt != "function")) throw Error(s(150));
          return (xe = dt.call(xe)), _t(me, ue, xe, Oe);
        }
        if (typeof xe.then == "function") return kn(me, ue, _0(xe), Oe);
        if (xe.$$typeof === _) return kn(me, ue, h0(me, xe), Oe);
        A0(me, xe);
      }
      return (typeof xe == "string" && xe !== "") ||
        typeof xe == "number" ||
        typeof xe == "bigint"
        ? ((xe = "" + xe),
          ue !== null && ue.tag === 6
            ? (v(me, ue.sibling), (Oe = T(ue, xe)), (Oe.return = me), (me = Oe))
            : (v(me, ue),
              (Oe = zS(xe, me.mode, Oe)),
              (Oe.return = me),
              (me = Oe)),
          G(me))
        : v(me, ue);
    }
    return function (me, ue, xe, Oe) {
      try {
        _m = 0;
        var dt = kn(me, ue, xe, Oe);
        return (Pd = null), dt;
      } catch (wt) {
        if (wt === gm || wt === m0) throw wt;
        var Jt = hi(29, wt, null, me.mode);
        return (Jt.lanes = Oe), (Jt.return = me), Jt;
      } finally {
      }
    };
  }
  var Md = rN(!0),
    iN = rN(!1),
    $i = I(null),
    qa = null;
  function jl(d) {
    var f = d.alternate;
    Y($s, $s.current & 1),
      Y($i, d),
      qa === null &&
        (f === null || Cd.current !== null || f.memoizedState !== null) &&
        (qa = d);
  }
  function aN(d) {
    if (d.tag === 22) {
      if ((Y($s, $s.current), Y($i, d), qa === null)) {
        var f = d.alternate;
        f !== null && f.memoizedState !== null && (qa = d);
      }
    } else Fl();
  }
  function Fl() {
    Y($s, $s.current), Y($i, $i.current);
  }
  function Go(d) {
    F($i), qa === d && (qa = null), F($s);
  }
  var $s = I(0);
  function R0(d) {
    for (var f = d; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (
          v !== null &&
          ((v = v.dehydrated), v === null || v.data === "$?" || f_(v))
        )
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if ((f.flags & 128) !== 0) return f;
      } else if (f.child !== null) {
        (f.child.return = f), (f = f.child);
        continue;
      }
      if (f === d) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === d) return null;
        f = f.return;
      }
      (f.sibling.return = f.return), (f = f.sibling);
    }
    return null;
  }
  function TT(d, f, v, x) {
    (f = d.memoizedState),
      (v = v(x, f)),
      (v = v == null ? f : h({}, f, v)),
      (d.memoizedState = v),
      d.lanes === 0 && (d.updateQueue.baseState = v);
  }
  var _T = {
    enqueueSetState: function (d, f, v) {
      d = d._reactInternals;
      var x = gi(),
        T = Ml(x);
      (T.payload = f),
        v != null && (T.callback = v),
        (f = Nl(d, T, x)),
        f !== null && (vi(f, d, x), ym(f, d, x));
    },
    enqueueReplaceState: function (d, f, v) {
      d = d._reactInternals;
      var x = gi(),
        T = Ml(x);
      (T.tag = 1),
        (T.payload = f),
        v != null && (T.callback = v),
        (f = Nl(d, T, x)),
        f !== null && (vi(f, d, x), ym(f, d, x));
    },
    enqueueForceUpdate: function (d, f) {
      d = d._reactInternals;
      var v = gi(),
        x = Ml(v);
      (x.tag = 2),
        f != null && (x.callback = f),
        (f = Nl(d, x, v)),
        f !== null && (vi(f, d, v), ym(f, d, v));
    },
  };
  function oN(d, f, v, x, T, k, G) {
    return (
      (d = d.stateNode),
      typeof d.shouldComponentUpdate == "function"
        ? d.shouldComponentUpdate(x, k, G)
        : f.prototype && f.prototype.isPureReactComponent
        ? !lm(v, x) || !lm(T, k)
        : !0
    );
  }
  function lN(d, f, v, x) {
    (d = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(v, x),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(v, x),
      f.state !== d && _T.enqueueReplaceState(f, f.state, null);
  }
  function du(d, f) {
    var v = f;
    if ("ref" in f) {
      v = {};
      for (var x in f) x !== "ref" && (v[x] = f[x]);
    }
    if ((d = d.defaultProps)) {
      v === f && (v = h({}, v));
      for (var T in d) v[T] === void 0 && (v[T] = d[T]);
    }
    return v;
  }
  var k0 =
    typeof reportError == "function"
      ? reportError
      : function (d) {
          if (
            typeof window == "object" &&
            typeof window.ErrorEvent == "function"
          ) {
            var f = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                typeof d == "object" &&
                d !== null &&
                typeof d.message == "string"
                  ? String(d.message)
                  : String(d),
              error: d,
            });
            if (!window.dispatchEvent(f)) return;
          } else if (
            typeof process == "object" &&
            typeof process.emit == "function"
          ) {
            process.emit("uncaughtException", d);
            return;
          }
          console.error(d);
        };
  function cN(d) {
    k0(d);
  }
  function uN(d) {
    console.error(d);
  }
  function dN(d) {
    k0(d);
  }
  function C0(d, f) {
    try {
      var v = d.onUncaughtError;
      v(f.value, { componentStack: f.stack });
    } catch (x) {
      setTimeout(function () {
        throw x;
      });
    }
  }
  function hN(d, f, v) {
    try {
      var x = d.onCaughtError;
      x(v.value, {
        componentStack: v.stack,
        errorBoundary: f.tag === 1 ? f.stateNode : null,
      });
    } catch (T) {
      setTimeout(function () {
        throw T;
      });
    }
  }
  function AT(d, f, v) {
    return (
      (v = Ml(v)),
      (v.tag = 3),
      (v.payload = { element: null }),
      (v.callback = function () {
        C0(d, f);
      }),
      v
    );
  }
  function fN(d) {
    return (d = Ml(d)), (d.tag = 3), d;
  }
  function mN(d, f, v, x) {
    var T = v.type.getDerivedStateFromError;
    if (typeof T == "function") {
      var k = x.value;
      (d.payload = function () {
        return T(k);
      }),
        (d.callback = function () {
          hN(f, v, x);
        });
    }
    var G = v.stateNode;
    G !== null &&
      typeof G.componentDidCatch == "function" &&
      (d.callback = function () {
        hN(f, v, x),
          typeof T != "function" &&
            (zl === null ? (zl = new Set([this])) : zl.add(this));
        var ee = x.stack;
        this.componentDidCatch(x.value, {
          componentStack: ee !== null ? ee : "",
        });
      });
  }
  function gZ(d, f, v, x, T) {
    if (
      ((v.flags |= 32768),
      x !== null && typeof x == "object" && typeof x.then == "function")
    ) {
      if (
        ((f = v.alternate),
        f !== null && fm(f, v, T, !0),
        (v = $i.current),
        v !== null)
      ) {
        switch (v.tag) {
          case 13:
            return (
              qa === null ? XT() : v.alternate === null && us === 0 && (us = 3),
              (v.flags &= -257),
              (v.flags |= 65536),
              (v.lanes = T),
              x === tT
                ? (v.flags |= 16384)
                : ((f = v.updateQueue),
                  f === null ? (v.updateQueue = new Set([x])) : f.add(x),
                  ZT(d, x, T)),
              !1
            );
          case 22:
            return (
              (v.flags |= 65536),
              x === tT
                ? (v.flags |= 16384)
                : ((f = v.updateQueue),
                  f === null
                    ? ((f = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([x]),
                      }),
                      (v.updateQueue = f))
                    : ((v = f.retryQueue),
                      v === null ? (f.retryQueue = new Set([x])) : v.add(x)),
                  ZT(d, x, T)),
              !1
            );
        }
        throw Error(s(435, v.tag));
      }
      return ZT(d, x, T), XT(), !1;
    }
    if (gn)
      return (
        (f = $i.current),
        f !== null
          ? ((f.flags & 65536) === 0 && (f.flags |= 256),
            (f.flags |= 65536),
            (f.lanes = T),
            x !== KS && ((d = Error(s(422), { cause: x })), hm(Oi(d, v))))
          : (x !== KS && ((f = Error(s(423), { cause: x })), hm(Oi(f, v))),
            (d = d.current.alternate),
            (d.flags |= 65536),
            (T &= -T),
            (d.lanes |= T),
            (x = Oi(x, v)),
            (T = AT(d.stateNode, x, T)),
            rT(d, T),
            us !== 4 && (us = 2)),
        !1
      );
    var k = Error(s(520), { cause: x });
    if (
      ((k = Oi(k, v)),
      Pm === null ? (Pm = [k]) : Pm.push(k),
      us !== 4 && (us = 2),
      f === null)
    )
      return !0;
    (x = Oi(x, v)), (v = f);
    do {
      switch (v.tag) {
        case 3:
          return (
            (v.flags |= 65536),
            (d = T & -T),
            (v.lanes |= d),
            (d = AT(v.stateNode, x, d)),
            rT(v, d),
            !1
          );
        case 1:
          if (
            ((f = v.type),
            (k = v.stateNode),
            (v.flags & 128) === 0 &&
              (typeof f.getDerivedStateFromError == "function" ||
                (k !== null &&
                  typeof k.componentDidCatch == "function" &&
                  (zl === null || !zl.has(k)))))
          )
            return (
              (v.flags |= 65536),
              (T &= -T),
              (v.lanes |= T),
              (T = fN(T)),
              mN(T, d, v, x),
              rT(v, T),
              !1
            );
      }
      v = v.return;
    } while (v !== null);
    return !1;
  }
  var pN = Error(s(461)),
    Ks = !1;
  function dr(d, f, v, x) {
    f.child = d === null ? iN(f, null, v, x) : Md(f, d.child, v, x);
  }
  function gN(d, f, v, x, T) {
    v = v.render;
    var k = f.ref;
    if ("ref" in x) {
      var G = {};
      for (var ee in x) ee !== "ref" && (G[ee] = x[ee]);
    } else G = x;
    return (
      lu(f),
      (x = cT(d, f, v, G, k, T)),
      (ee = uT()),
      d !== null && !Ks
        ? (dT(d, f, T), qo(d, f, T))
        : (gn && ee && qS(f), (f.flags |= 1), dr(d, f, x, T), f.child)
    );
  }
  function vN(d, f, v, x, T) {
    if (d === null) {
      var k = v.type;
      return typeof k == "function" &&
        !VS(k) &&
        k.defaultProps === void 0 &&
        v.compare === null
        ? ((f.tag = 15), (f.type = k), yN(d, f, k, x, T))
        : ((d = l0(v.type, null, x, f, f.mode, T)),
          (d.ref = f.ref),
          (d.return = f),
          (f.child = d));
    }
    if (((k = d.child), !MT(d, T))) {
      var G = k.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : lm), v(G, x) && d.ref === f.ref)
      )
        return qo(d, f, T);
    }
    return (
      (f.flags |= 1),
      (d = Uo(k, x)),
      (d.ref = f.ref),
      (d.return = f),
      (f.child = d)
    );
  }
  function yN(d, f, v, x, T) {
    if (d !== null) {
      var k = d.memoizedProps;
      if (lm(k, x) && d.ref === f.ref)
        if (((Ks = !1), (f.pendingProps = x = k), MT(d, T)))
          (d.flags & 131072) !== 0 && (Ks = !0);
        else return (f.lanes = d.lanes), qo(d, f, T);
    }
    return RT(d, f, v, x, T);
  }
  function bN(d, f, v) {
    var x = f.pendingProps,
      T = x.children,
      k = d !== null ? d.memoizedState : null;
    if (x.mode === "hidden") {
      if ((f.flags & 128) !== 0) {
        if (((x = k !== null ? k.baseLanes | v : v), d !== null)) {
          for (T = f.child = d.child, k = 0; T !== null; )
            (k = k | T.lanes | T.childLanes), (T = T.sibling);
          f.childLanes = k & ~x;
        } else (f.childLanes = 0), (f.child = null);
        return xN(d, f, x, v);
      }
      if ((v & 536870912) !== 0)
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          d !== null && f0(f, k !== null ? k.cachePool : null),
          k !== null ? y2(f, k) : aT(),
          aN(f);
      else
        return (
          (f.lanes = f.childLanes = 536870912),
          xN(d, f, k !== null ? k.baseLanes | v : v, v)
        );
    } else
      k !== null
        ? (f0(f, k.cachePool), y2(f, k), Fl(), (f.memoizedState = null))
        : (d !== null && f0(f, null), aT(), Fl());
    return dr(d, f, T, v), f.child;
  }
  function xN(d, f, v, x) {
    var T = eT();
    return (
      (T = T === null ? null : { parent: Us._currentValue, pool: T }),
      (f.memoizedState = { baseLanes: v, cachePool: T }),
      d !== null && f0(f, null),
      aT(),
      aN(f),
      d !== null && fm(d, f, x, !0),
      null
    );
  }
  function I0(d, f) {
    var v = f.ref;
    if (v === null) d !== null && d.ref !== null && (f.flags |= 4194816);
    else {
      if (typeof v != "function" && typeof v != "object") throw Error(s(284));
      (d === null || d.ref !== v) && (f.flags |= 4194816);
    }
  }
  function RT(d, f, v, x, T) {
    return (
      lu(f),
      (v = cT(d, f, v, x, void 0, T)),
      (x = uT()),
      d !== null && !Ks
        ? (dT(d, f, T), qo(d, f, T))
        : (gn && x && qS(f), (f.flags |= 1), dr(d, f, v, T), f.child)
    );
  }
  function wN(d, f, v, x, T, k) {
    return (
      lu(f),
      (f.updateQueue = null),
      (v = x2(f, x, v, T)),
      b2(d),
      (x = uT()),
      d !== null && !Ks
        ? (dT(d, f, k), qo(d, f, k))
        : (gn && x && qS(f), (f.flags |= 1), dr(d, f, v, k), f.child)
    );
  }
  function EN(d, f, v, x, T) {
    if ((lu(f), f.stateNode === null)) {
      var k = Td,
        G = v.contextType;
      typeof G == "object" && G !== null && (k = wr(G)),
        (k = new v(x, k)),
        (f.memoizedState =
          k.state !== null && k.state !== void 0 ? k.state : null),
        (k.updater = _T),
        (f.stateNode = k),
        (k._reactInternals = f),
        (k = f.stateNode),
        (k.props = x),
        (k.state = f.memoizedState),
        (k.refs = {}),
        nT(f),
        (G = v.contextType),
        (k.context = typeof G == "object" && G !== null ? wr(G) : Td),
        (k.state = f.memoizedState),
        (G = v.getDerivedStateFromProps),
        typeof G == "function" && (TT(f, v, G, x), (k.state = f.memoizedState)),
        typeof v.getDerivedStateFromProps == "function" ||
          typeof k.getSnapshotBeforeUpdate == "function" ||
          (typeof k.UNSAFE_componentWillMount != "function" &&
            typeof k.componentWillMount != "function") ||
          ((G = k.state),
          typeof k.componentWillMount == "function" && k.componentWillMount(),
          typeof k.UNSAFE_componentWillMount == "function" &&
            k.UNSAFE_componentWillMount(),
          G !== k.state && _T.enqueueReplaceState(k, k.state, null),
          xm(f, x, k, T),
          bm(),
          (k.state = f.memoizedState)),
        typeof k.componentDidMount == "function" && (f.flags |= 4194308),
        (x = !0);
    } else if (d === null) {
      k = f.stateNode;
      var ee = f.memoizedProps,
        oe = du(v, ee);
      k.props = oe;
      var Se = k.context,
        Pe = v.contextType;
      (G = Td), typeof Pe == "object" && Pe !== null && (G = wr(Pe));
      var Fe = v.getDerivedStateFromProps;
      (Pe =
        typeof Fe == "function" ||
        typeof k.getSnapshotBeforeUpdate == "function"),
        (ee = f.pendingProps !== ee),
        Pe ||
          (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
            typeof k.componentWillReceiveProps != "function") ||
          ((ee || Se !== G) && lN(f, k, x, G)),
        (Pl = !1);
      var Te = f.memoizedState;
      (k.state = Te),
        xm(f, x, k, T),
        bm(),
        (Se = f.memoizedState),
        ee || Te !== Se || Pl
          ? (typeof Fe == "function" &&
              (TT(f, v, Fe, x), (Se = f.memoizedState)),
            (oe = Pl || oN(f, v, oe, x, Te, Se, G))
              ? (Pe ||
                  (typeof k.UNSAFE_componentWillMount != "function" &&
                    typeof k.componentWillMount != "function") ||
                  (typeof k.componentWillMount == "function" &&
                    k.componentWillMount(),
                  typeof k.UNSAFE_componentWillMount == "function" &&
                    k.UNSAFE_componentWillMount()),
                typeof k.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof k.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = x),
                (f.memoizedState = Se)),
            (k.props = x),
            (k.state = Se),
            (k.context = G),
            (x = oe))
          : (typeof k.componentDidMount == "function" && (f.flags |= 4194308),
            (x = !1));
    } else {
      (k = f.stateNode),
        sT(d, f),
        (G = f.memoizedProps),
        (Pe = du(v, G)),
        (k.props = Pe),
        (Fe = f.pendingProps),
        (Te = k.context),
        (Se = v.contextType),
        (oe = Td),
        typeof Se == "object" && Se !== null && (oe = wr(Se)),
        (ee = v.getDerivedStateFromProps),
        (Se =
          typeof ee == "function" ||
          typeof k.getSnapshotBeforeUpdate == "function") ||
          (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
            typeof k.componentWillReceiveProps != "function") ||
          ((G !== Fe || Te !== oe) && lN(f, k, x, oe)),
        (Pl = !1),
        (Te = f.memoizedState),
        (k.state = Te),
        xm(f, x, k, T),
        bm();
      var Ae = f.memoizedState;
      G !== Fe ||
      Te !== Ae ||
      Pl ||
      (d !== null && d.dependencies !== null && d0(d.dependencies))
        ? (typeof ee == "function" && (TT(f, v, ee, x), (Ae = f.memoizedState)),
          (Pe =
            Pl ||
            oN(f, v, Pe, x, Te, Ae, oe) ||
            (d !== null && d.dependencies !== null && d0(d.dependencies)))
            ? (Se ||
                (typeof k.UNSAFE_componentWillUpdate != "function" &&
                  typeof k.componentWillUpdate != "function") ||
                (typeof k.componentWillUpdate == "function" &&
                  k.componentWillUpdate(x, Ae, oe),
                typeof k.UNSAFE_componentWillUpdate == "function" &&
                  k.UNSAFE_componentWillUpdate(x, Ae, oe)),
              typeof k.componentDidUpdate == "function" && (f.flags |= 4),
              typeof k.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof k.componentDidUpdate != "function" ||
                (G === d.memoizedProps && Te === d.memoizedState) ||
                (f.flags |= 4),
              typeof k.getSnapshotBeforeUpdate != "function" ||
                (G === d.memoizedProps && Te === d.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = x),
              (f.memoizedState = Ae)),
          (k.props = x),
          (k.state = Ae),
          (k.context = oe),
          (x = Pe))
        : (typeof k.componentDidUpdate != "function" ||
            (G === d.memoizedProps && Te === d.memoizedState) ||
            (f.flags |= 4),
          typeof k.getSnapshotBeforeUpdate != "function" ||
            (G === d.memoizedProps && Te === d.memoizedState) ||
            (f.flags |= 1024),
          (x = !1));
    }
    return (
      (k = x),
      I0(d, f),
      (x = (f.flags & 128) !== 0),
      k || x
        ? ((k = f.stateNode),
          (v =
            x && typeof v.getDerivedStateFromError != "function"
              ? null
              : k.render()),
          (f.flags |= 1),
          d !== null && x
            ? ((f.child = Md(f, d.child, null, T)),
              (f.child = Md(f, null, v, T)))
            : dr(d, f, v, T),
          (f.memoizedState = k.state),
          (d = f.child))
        : (d = qo(d, f, T)),
      d
    );
  }
  function SN(d, f, v, x) {
    return dm(), (f.flags |= 256), dr(d, f, v, x), f.child;
  }
  var kT = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null,
  };
  function CT(d) {
    return { baseLanes: d, cachePool: u2() };
  }
  function IT(d, f, v) {
    return (d = d !== null ? d.childLanes & ~v : 0), f && (d |= Bi), d;
  }
  function TN(d, f, v) {
    var x = f.pendingProps,
      T = !1,
      k = (f.flags & 128) !== 0,
      G;
    if (
      ((G = k) ||
        (G =
          d !== null && d.memoizedState === null ? !1 : ($s.current & 2) !== 0),
      G && ((T = !0), (f.flags &= -129)),
      (G = (f.flags & 32) !== 0),
      (f.flags &= -33),
      d === null)
    ) {
      if (gn) {
        if ((T ? jl(f) : Fl(), gn)) {
          var ee = cs,
            oe;
          if ((oe = ee)) {
            e: {
              for (oe = ee, ee = Ga; oe.nodeType !== 8; ) {
                if (!ee) {
                  ee = null;
                  break e;
                }
                if (((oe = pa(oe.nextSibling)), oe === null)) {
                  ee = null;
                  break e;
                }
              }
              ee = oe;
            }
            ee !== null
              ? ((f.memoizedState = {
                  dehydrated: ee,
                  treeContext: su !== null ? { id: $o, overflow: Bo } : null,
                  retryLane: 536870912,
                  hydrationErrors: null,
                }),
                (oe = hi(18, null, null, 0)),
                (oe.stateNode = ee),
                (oe.return = f),
                (f.child = oe),
                (Or = f),
                (cs = null),
                (oe = !0))
              : (oe = !1);
          }
          oe || au(f);
        }
        if (
          ((ee = f.memoizedState),
          ee !== null && ((ee = ee.dehydrated), ee !== null))
        )
          return f_(ee) ? (f.lanes = 32) : (f.lanes = 536870912), null;
        Go(f);
      }
      return (
        (ee = x.children),
        (x = x.fallback),
        T
          ? (Fl(),
            (T = f.mode),
            (ee = L0({ mode: "hidden", children: ee }, T)),
            (x = nu(x, T, v, null)),
            (ee.return = f),
            (x.return = f),
            (ee.sibling = x),
            (f.child = ee),
            (T = f.child),
            (T.memoizedState = CT(v)),
            (T.childLanes = IT(d, G, v)),
            (f.memoizedState = kT),
            x)
          : (jl(f), LT(f, ee))
      );
    }
    if (
      ((oe = d.memoizedState),
      oe !== null && ((ee = oe.dehydrated), ee !== null))
    ) {
      if (k)
        f.flags & 256
          ? (jl(f), (f.flags &= -257), (f = DT(d, f, v)))
          : f.memoizedState !== null
          ? (Fl(), (f.child = d.child), (f.flags |= 128), (f = null))
          : (Fl(),
            (T = x.fallback),
            (ee = f.mode),
            (x = L0({ mode: "visible", children: x.children }, ee)),
            (T = nu(T, ee, v, null)),
            (T.flags |= 2),
            (x.return = f),
            (T.return = f),
            (x.sibling = T),
            (f.child = x),
            Md(f, d.child, null, v),
            (x = f.child),
            (x.memoizedState = CT(v)),
            (x.childLanes = IT(d, G, v)),
            (f.memoizedState = kT),
            (f = T));
      else if ((jl(f), f_(ee))) {
        if (((G = ee.nextSibling && ee.nextSibling.dataset), G))
          var Se = G.dgst;
        (G = Se),
          (x = Error(s(419))),
          (x.stack = ""),
          (x.digest = G),
          hm({ value: x, source: null, stack: null }),
          (f = DT(d, f, v));
      } else if (
        (Ks || fm(d, f, v, !1), (G = (v & d.childLanes) !== 0), Ks || G)
      ) {
        if (
          ((G = Fn),
          G !== null &&
            ((x = v & -v),
            (x = (x & 42) !== 0 ? 1 : Ge(x)),
            (x = (x & (G.suspendedLanes | v)) !== 0 ? 0 : x),
            x !== 0 && x !== oe.retryLane))
        )
          throw ((oe.retryLane = x), Sd(d, x), vi(G, d, x), pN);
        ee.data === "$?" || XT(), (f = DT(d, f, v));
      } else
        ee.data === "$?"
          ? ((f.flags |= 192), (f.child = d.child), (f = null))
          : ((d = oe.treeContext),
            (cs = pa(ee.nextSibling)),
            (Or = f),
            (gn = !0),
            (iu = null),
            (Ga = !1),
            d !== null &&
              ((Fi[Ui++] = $o),
              (Fi[Ui++] = Bo),
              (Fi[Ui++] = su),
              ($o = d.id),
              (Bo = d.overflow),
              (su = f)),
            (f = LT(f, x.children)),
            (f.flags |= 4096));
      return f;
    }
    return T
      ? (Fl(),
        (T = x.fallback),
        (ee = f.mode),
        (oe = d.child),
        (Se = oe.sibling),
        (x = Uo(oe, { mode: "hidden", children: x.children })),
        (x.subtreeFlags = oe.subtreeFlags & 65011712),
        Se !== null
          ? (T = Uo(Se, T))
          : ((T = nu(T, ee, v, null)), (T.flags |= 2)),
        (T.return = f),
        (x.return = f),
        (x.sibling = T),
        (f.child = x),
        (x = T),
        (T = f.child),
        (ee = d.child.memoizedState),
        ee === null
          ? (ee = CT(v))
          : ((oe = ee.cachePool),
            oe !== null
              ? ((Se = Us._currentValue),
                (oe = oe.parent !== Se ? { parent: Se, pool: Se } : oe))
              : (oe = u2()),
            (ee = { baseLanes: ee.baseLanes | v, cachePool: oe })),
        (T.memoizedState = ee),
        (T.childLanes = IT(d, G, v)),
        (f.memoizedState = kT),
        x)
      : (jl(f),
        (v = d.child),
        (d = v.sibling),
        (v = Uo(v, { mode: "visible", children: x.children })),
        (v.return = f),
        (v.sibling = null),
        d !== null &&
          ((G = f.deletions),
          G === null ? ((f.deletions = [d]), (f.flags |= 16)) : G.push(d)),
        (f.child = v),
        (f.memoizedState = null),
        v);
  }
  function LT(d, f) {
    return (
      (f = L0({ mode: "visible", children: f }, d.mode)),
      (f.return = d),
      (d.child = f)
    );
  }
  function L0(d, f) {
    return (
      (d = hi(22, d, null, f)),
      (d.lanes = 0),
      (d.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
      }),
      d
    );
  }
  function DT(d, f, v) {
    return (
      Md(f, d.child, null, v),
      (d = LT(f, f.pendingProps.children)),
      (d.flags |= 2),
      (f.memoizedState = null),
      d
    );
  }
  function _N(d, f, v) {
    d.lanes |= f;
    var x = d.alternate;
    x !== null && (x.lanes |= f), XS(d.return, f, v);
  }
  function PT(d, f, v, x, T) {
    var k = d.memoizedState;
    k === null
      ? (d.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: x,
          tail: v,
          tailMode: T,
        })
      : ((k.isBackwards = f),
        (k.rendering = null),
        (k.renderingStartTime = 0),
        (k.last = x),
        (k.tail = v),
        (k.tailMode = T));
  }
  function AN(d, f, v) {
    var x = f.pendingProps,
      T = x.revealOrder,
      k = x.tail;
    if ((dr(d, f, x.children, v), (x = $s.current), (x & 2) !== 0))
      (x = (x & 1) | 2), (f.flags |= 128);
    else {
      if (d !== null && (d.flags & 128) !== 0)
        e: for (d = f.child; d !== null; ) {
          if (d.tag === 13) d.memoizedState !== null && _N(d, v, f);
          else if (d.tag === 19) _N(d, v, f);
          else if (d.child !== null) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === f) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === f) break e;
            d = d.return;
          }
          (d.sibling.return = d.return), (d = d.sibling);
        }
      x &= 1;
    }
    switch ((Y($s, x), T)) {
      case "forwards":
        for (v = f.child, T = null; v !== null; )
          (d = v.alternate),
            d !== null && R0(d) === null && (T = v),
            (v = v.sibling);
        (v = T),
          v === null
            ? ((T = f.child), (f.child = null))
            : ((T = v.sibling), (v.sibling = null)),
          PT(f, !1, T, v, k);
        break;
      case "backwards":
        for (v = null, T = f.child, f.child = null; T !== null; ) {
          if (((d = T.alternate), d !== null && R0(d) === null)) {
            f.child = T;
            break;
          }
          (d = T.sibling), (T.sibling = v), (v = T), (T = d);
        }
        PT(f, !0, v, null, k);
        break;
      case "together":
        PT(f, !1, null, null, void 0);
        break;
      default:
        f.memoizedState = null;
    }
    return f.child;
  }
  function qo(d, f, v) {
    if (
      (d !== null && (f.dependencies = d.dependencies),
      (Vl |= f.lanes),
      (v & f.childLanes) === 0)
    )
      if (d !== null) {
        if ((fm(d, f, v, !1), (v & f.childLanes) === 0)) return null;
      } else return null;
    if (d !== null && f.child !== d.child) throw Error(s(153));
    if (f.child !== null) {
      for (
        d = f.child, v = Uo(d, d.pendingProps), f.child = v, v.return = f;
        d.sibling !== null;

      )
        (d = d.sibling),
          (v = v.sibling = Uo(d, d.pendingProps)),
          (v.return = f);
      v.sibling = null;
    }
    return f.child;
  }
  function MT(d, f) {
    return (d.lanes & f) !== 0
      ? !0
      : ((d = d.dependencies), !!(d !== null && d0(d)));
  }
  function vZ(d, f, v) {
    switch (f.tag) {
      case 3:
        ce(f, f.stateNode.containerInfo),
          Dl(f, Us, d.memoizedState.cache),
          dm();
        break;
      case 27:
      case 5:
        se(f);
        break;
      case 4:
        ce(f, f.stateNode.containerInfo);
        break;
      case 10:
        Dl(f, f.type, f.memoizedProps.value);
        break;
      case 13:
        var x = f.memoizedState;
        if (x !== null)
          return x.dehydrated !== null
            ? (jl(f), (f.flags |= 128), null)
            : (v & f.child.childLanes) !== 0
            ? TN(d, f, v)
            : (jl(f), (d = qo(d, f, v)), d !== null ? d.sibling : null);
        jl(f);
        break;
      case 19:
        var T = (d.flags & 128) !== 0;
        if (
          ((x = (v & f.childLanes) !== 0),
          x || (fm(d, f, v, !1), (x = (v & f.childLanes) !== 0)),
          T)
        ) {
          if (x) return AN(d, f, v);
          f.flags |= 128;
        }
        if (
          ((T = f.memoizedState),
          T !== null &&
            ((T.rendering = null), (T.tail = null), (T.lastEffect = null)),
          Y($s, $s.current),
          x)
        )
          break;
        return null;
      case 22:
      case 23:
        return (f.lanes = 0), bN(d, f, v);
      case 24:
        Dl(f, Us, d.memoizedState.cache);
    }
    return qo(d, f, v);
  }
  function RN(d, f, v) {
    if (d !== null)
      if (d.memoizedProps !== f.pendingProps) Ks = !0;
      else {
        if (!MT(d, v) && (f.flags & 128) === 0) return (Ks = !1), vZ(d, f, v);
        Ks = (d.flags & 131072) !== 0;
      }
    else (Ks = !1), gn && (f.flags & 1048576) !== 0 && s2(f, u0, f.index);
    switch (((f.lanes = 0), f.tag)) {
      case 16:
        e: {
          d = f.pendingProps;
          var x = f.elementType,
            T = x._init;
          if (((x = T(x._payload)), (f.type = x), typeof x == "function"))
            VS(x)
              ? ((d = du(x, d)), (f.tag = 1), (f = EN(null, f, x, d, v)))
              : ((f.tag = 0), (f = RT(null, f, x, d, v)));
          else {
            if (x != null) {
              if (((T = x.$$typeof), T === R)) {
                (f.tag = 11), (f = gN(null, f, x, d, v));
                break e;
              } else if (T === L) {
                (f.tag = 14), (f = vN(null, f, x, d, v));
                break e;
              }
            }
            throw ((f = B(x) || x), Error(s(306, f, "")));
          }
        }
        return f;
      case 0:
        return RT(d, f, f.type, f.pendingProps, v);
      case 1:
        return (x = f.type), (T = du(x, f.pendingProps)), EN(d, f, x, T, v);
      case 3:
        e: {
          if ((ce(f, f.stateNode.containerInfo), d === null))
            throw Error(s(387));
          x = f.pendingProps;
          var k = f.memoizedState;
          (T = k.element), sT(d, f), xm(f, x, null, v);
          var G = f.memoizedState;
          if (
            ((x = G.cache),
            Dl(f, Us, x),
            x !== k.cache && QS(f, [Us], v, !0),
            bm(),
            (x = G.element),
            k.isDehydrated)
          )
            if (
              ((k = { element: x, isDehydrated: !1, cache: G.cache }),
              (f.updateQueue.baseState = k),
              (f.memoizedState = k),
              f.flags & 256)
            ) {
              f = SN(d, f, x, v);
              break e;
            } else if (x !== T) {
              (T = Oi(Error(s(424)), f)), hm(T), (f = SN(d, f, x, v));
              break e;
            } else {
              switch (((d = f.stateNode.containerInfo), d.nodeType)) {
                case 9:
                  d = d.body;
                  break;
                default:
                  d = d.nodeName === "HTML" ? d.ownerDocument.body : d;
              }
              for (
                cs = pa(d.firstChild),
                  Or = f,
                  gn = !0,
                  iu = null,
                  Ga = !0,
                  v = iN(f, null, x, v),
                  f.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
            }
          else {
            if ((dm(), x === T)) {
              f = qo(d, f, v);
              break e;
            }
            dr(d, f, x, v);
          }
          f = f.child;
        }
        return f;
      case 26:
        return (
          I0(d, f),
          d === null
            ? (v = LO(f.type, null, f.pendingProps, null))
              ? (f.memoizedState = v)
              : gn ||
                ((v = f.type),
                (d = f.pendingProps),
                (x = G0(Z.current).createElement(v)),
                (x[je] = f),
                (x[Ke] = d),
                fr(x, v, d),
                ls(x),
                (f.stateNode = x))
            : (f.memoizedState = LO(
                f.type,
                d.memoizedProps,
                f.pendingProps,
                d.memoizedState
              )),
          null
        );
      case 27:
        return (
          se(f),
          d === null &&
            gn &&
            ((x = f.stateNode = kO(f.type, f.pendingProps, Z.current)),
            (Or = f),
            (Ga = !0),
            (T = cs),
            Wl(f.type) ? ((m_ = T), (cs = pa(x.firstChild))) : (cs = T)),
          dr(d, f, f.pendingProps.children, v),
          I0(d, f),
          d === null && (f.flags |= 4194304),
          f.child
        );
      case 5:
        return (
          d === null &&
            gn &&
            ((T = x = cs) &&
              ((x = GZ(x, f.type, f.pendingProps, Ga)),
              x !== null
                ? ((f.stateNode = x),
                  (Or = f),
                  (cs = pa(x.firstChild)),
                  (Ga = !1),
                  (T = !0))
                : (T = !1)),
            T || au(f)),
          se(f),
          (T = f.type),
          (k = f.pendingProps),
          (G = d !== null ? d.memoizedProps : null),
          (x = k.children),
          u_(T, k) ? (x = null) : G !== null && u_(T, G) && (f.flags |= 32),
          f.memoizedState !== null &&
            ((T = cT(d, f, cZ, null, null, v)), (Hm._currentValue = T)),
          I0(d, f),
          dr(d, f, x, v),
          f.child
        );
      case 6:
        return (
          d === null &&
            gn &&
            ((d = v = cs) &&
              ((v = qZ(v, f.pendingProps, Ga)),
              v !== null
                ? ((f.stateNode = v), (Or = f), (cs = null), (d = !0))
                : (d = !1)),
            d || au(f)),
          null
        );
      case 13:
        return TN(d, f, v);
      case 4:
        return (
          ce(f, f.stateNode.containerInfo),
          (x = f.pendingProps),
          d === null ? (f.child = Md(f, null, x, v)) : dr(d, f, x, v),
          f.child
        );
      case 11:
        return gN(d, f, f.type, f.pendingProps, v);
      case 7:
        return dr(d, f, f.pendingProps, v), f.child;
      case 8:
        return dr(d, f, f.pendingProps.children, v), f.child;
      case 12:
        return dr(d, f, f.pendingProps.children, v), f.child;
      case 10:
        return (
          (x = f.pendingProps),
          Dl(f, f.type, x.value),
          dr(d, f, x.children, v),
          f.child
        );
      case 9:
        return (
          (T = f.type._context),
          (x = f.pendingProps.children),
          lu(f),
          (T = wr(T)),
          (x = x(T)),
          (f.flags |= 1),
          dr(d, f, x, v),
          f.child
        );
      case 14:
        return vN(d, f, f.type, f.pendingProps, v);
      case 15:
        return yN(d, f, f.type, f.pendingProps, v);
      case 19:
        return AN(d, f, v);
      case 31:
        return (
          (x = f.pendingProps),
          (v = f.mode),
          (x = { mode: x.mode, children: x.children }),
          d === null
            ? ((v = L0(x, v)),
              (v.ref = f.ref),
              (f.child = v),
              (v.return = f),
              (f = v))
            : ((v = Uo(d.child, x)),
              (v.ref = f.ref),
              (f.child = v),
              (v.return = f),
              (f = v)),
          f
        );
      case 22:
        return bN(d, f, v);
      case 24:
        return (
          lu(f),
          (x = wr(Us)),
          d === null
            ? ((T = eT()),
              T === null &&
                ((T = Fn),
                (k = ZS()),
                (T.pooledCache = k),
                k.refCount++,
                k !== null && (T.pooledCacheLanes |= v),
                (T = k)),
              (f.memoizedState = { parent: x, cache: T }),
              nT(f),
              Dl(f, Us, T))
            : ((d.lanes & v) !== 0 && (sT(d, f), xm(f, null, null, v), bm()),
              (T = d.memoizedState),
              (k = f.memoizedState),
              T.parent !== x
                ? ((T = { parent: x, cache: x }),
                  (f.memoizedState = T),
                  f.lanes === 0 &&
                    (f.memoizedState = f.updateQueue.baseState = T),
                  Dl(f, Us, x))
                : ((x = k.cache),
                  Dl(f, Us, x),
                  x !== T.cache && QS(f, [Us], v, !0))),
          dr(d, f, f.pendingProps.children, v),
          f.child
        );
      case 29:
        throw f.pendingProps;
    }
    throw Error(s(156, f.tag));
  }
  function Wo(d) {
    d.flags |= 4;
  }
  function kN(d, f) {
    if (f.type !== "stylesheet" || (f.state.loading & 4) !== 0)
      d.flags &= -16777217;
    else if (((d.flags |= 16777216), !OO(f))) {
      if (
        ((f = $i.current),
        f !== null &&
          ((cn & 4194048) === cn
            ? qa !== null
            : ((cn & 62914560) !== cn && (cn & 536870912) === 0) || f !== qa))
      )
        throw ((vm = tT), d2);
      d.flags |= 8192;
    }
  }
  function D0(d, f) {
    f !== null && (d.flags |= 4),
      d.flags & 16384 &&
        ((f = d.tag !== 22 ? Ws() : 536870912), (d.lanes |= f), (Fd |= f));
  }
  function Rm(d, f) {
    if (!gn)
      switch (d.tailMode) {
        case "hidden":
          f = d.tail;
          for (var v = null; f !== null; )
            f.alternate !== null && (v = f), (f = f.sibling);
          v === null ? (d.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = d.tail;
          for (var x = null; v !== null; )
            v.alternate !== null && (x = v), (v = v.sibling);
          x === null
            ? f || d.tail === null
              ? (d.tail = null)
              : (d.tail.sibling = null)
            : (x.sibling = null);
      }
  }
  function ns(d) {
    var f = d.alternate !== null && d.alternate.child === d.child,
      v = 0,
      x = 0;
    if (f)
      for (var T = d.child; T !== null; )
        (v |= T.lanes | T.childLanes),
          (x |= T.subtreeFlags & 65011712),
          (x |= T.flags & 65011712),
          (T.return = d),
          (T = T.sibling);
    else
      for (T = d.child; T !== null; )
        (v |= T.lanes | T.childLanes),
          (x |= T.subtreeFlags),
          (x |= T.flags),
          (T.return = d),
          (T = T.sibling);
    return (d.subtreeFlags |= x), (d.childLanes = v), f;
  }
  function yZ(d, f, v) {
    var x = f.pendingProps;
    switch ((WS(f), f.tag)) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ns(f), null;
      case 1:
        return ns(f), null;
      case 3:
        return (
          (v = f.stateNode),
          (x = null),
          d !== null && (x = d.memoizedState.cache),
          f.memoizedState.cache !== x && (f.flags |= 2048),
          Vo(Us),
          pe(),
          v.pendingContext &&
            ((v.context = v.pendingContext), (v.pendingContext = null)),
          (d === null || d.child === null) &&
            (um(f)
              ? Wo(f)
              : d === null ||
                (d.memoizedState.isDehydrated && (f.flags & 256) === 0) ||
                ((f.flags |= 1024), a2())),
          ns(f),
          null
        );
      case 26:
        return (
          (v = f.memoizedState),
          d === null
            ? (Wo(f),
              v !== null ? (ns(f), kN(f, v)) : (ns(f), (f.flags &= -16777217)))
            : v
            ? v !== d.memoizedState
              ? (Wo(f), ns(f), kN(f, v))
              : (ns(f), (f.flags &= -16777217))
            : (d.memoizedProps !== x && Wo(f), ns(f), (f.flags &= -16777217)),
          null
        );
      case 27:
        be(f), (v = Z.current);
        var T = f.type;
        if (d !== null && f.stateNode != null) d.memoizedProps !== x && Wo(f);
        else {
          if (!x) {
            if (f.stateNode === null) throw Error(s(166));
            return ns(f), null;
          }
          (d = J.current),
            um(f) ? r2(f) : ((d = kO(T, x, v)), (f.stateNode = d), Wo(f));
        }
        return ns(f), null;
      case 5:
        if ((be(f), (v = f.type), d !== null && f.stateNode != null))
          d.memoizedProps !== x && Wo(f);
        else {
          if (!x) {
            if (f.stateNode === null) throw Error(s(166));
            return ns(f), null;
          }
          if (((d = J.current), um(f))) r2(f);
          else {
            switch (((T = G0(Z.current)), d)) {
              case 1:
                d = T.createElementNS("http://www.w3.org/2000/svg", v);
                break;
              case 2:
                d = T.createElementNS("http://www.w3.org/1998/Math/MathML", v);
                break;
              default:
                switch (v) {
                  case "svg":
                    d = T.createElementNS("http://www.w3.org/2000/svg", v);
                    break;
                  case "math":
                    d = T.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      v
                    );
                    break;
                  case "script":
                    (d = T.createElement("div")),
                      (d.innerHTML = "<script></script>"),
                      (d = d.removeChild(d.firstChild));
                    break;
                  case "select":
                    (d =
                      typeof x.is == "string"
                        ? T.createElement("select", { is: x.is })
                        : T.createElement("select")),
                      x.multiple
                        ? (d.multiple = !0)
                        : x.size && (d.size = x.size);
                    break;
                  default:
                    d =
                      typeof x.is == "string"
                        ? T.createElement(v, { is: x.is })
                        : T.createElement(v);
                }
            }
            (d[je] = f), (d[Ke] = x);
            e: for (T = f.child; T !== null; ) {
              if (T.tag === 5 || T.tag === 6) d.appendChild(T.stateNode);
              else if (T.tag !== 4 && T.tag !== 27 && T.child !== null) {
                (T.child.return = T), (T = T.child);
                continue;
              }
              if (T === f) break e;
              for (; T.sibling === null; ) {
                if (T.return === null || T.return === f) break e;
                T = T.return;
              }
              (T.sibling.return = T.return), (T = T.sibling);
            }
            f.stateNode = d;
            e: switch ((fr(d, v, x), v)) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!x.autoFocus;
                break e;
              case "img":
                d = !0;
                break e;
              default:
                d = !1;
            }
            d && Wo(f);
          }
        }
        return ns(f), (f.flags &= -16777217), null;
      case 6:
        if (d && f.stateNode != null) d.memoizedProps !== x && Wo(f);
        else {
          if (typeof x != "string" && f.stateNode === null) throw Error(s(166));
          if (((d = Z.current), um(f))) {
            if (
              ((d = f.stateNode),
              (v = f.memoizedProps),
              (x = null),
              (T = Or),
              T !== null)
            )
              switch (T.tag) {
                case 27:
                case 5:
                  x = T.memoizedProps;
              }
            (d[je] = f),
              (d = !!(
                d.nodeValue === v ||
                (x !== null && x.suppressHydrationWarning === !0) ||
                wO(d.nodeValue, v)
              )),
              d || au(f);
          } else (d = G0(d).createTextNode(x)), (d[je] = f), (f.stateNode = d);
        }
        return ns(f), null;
      case 13:
        if (
          ((x = f.memoizedState),
          d === null ||
            (d.memoizedState !== null && d.memoizedState.dehydrated !== null))
        ) {
          if (((T = um(f)), x !== null && x.dehydrated !== null)) {
            if (d === null) {
              if (!T) throw Error(s(318));
              if (
                ((T = f.memoizedState),
                (T = T !== null ? T.dehydrated : null),
                !T)
              )
                throw Error(s(317));
              T[je] = f;
            } else
              dm(),
                (f.flags & 128) === 0 && (f.memoizedState = null),
                (f.flags |= 4);
            ns(f), (T = !1);
          } else
            (T = a2()),
              d !== null &&
                d.memoizedState !== null &&
                (d.memoizedState.hydrationErrors = T),
              (T = !0);
          if (!T) return f.flags & 256 ? (Go(f), f) : (Go(f), null);
        }
        if ((Go(f), (f.flags & 128) !== 0)) return (f.lanes = v), f;
        if (
          ((v = x !== null), (d = d !== null && d.memoizedState !== null), v)
        ) {
          (x = f.child),
            (T = null),
            x.alternate !== null &&
              x.alternate.memoizedState !== null &&
              x.alternate.memoizedState.cachePool !== null &&
              (T = x.alternate.memoizedState.cachePool.pool);
          var k = null;
          x.memoizedState !== null &&
            x.memoizedState.cachePool !== null &&
            (k = x.memoizedState.cachePool.pool),
            k !== T && (x.flags |= 2048);
        }
        return (
          v !== d && v && (f.child.flags |= 8192),
          D0(f, f.updateQueue),
          ns(f),
          null
        );
      case 4:
        return pe(), d === null && i_(f.stateNode.containerInfo), ns(f), null;
      case 10:
        return Vo(f.type), ns(f), null;
      case 19:
        if ((F($s), (T = f.memoizedState), T === null)) return ns(f), null;
        if (((x = (f.flags & 128) !== 0), (k = T.rendering), k === null))
          if (x) Rm(T, !1);
          else {
            if (us !== 0 || (d !== null && (d.flags & 128) !== 0))
              for (d = f.child; d !== null; ) {
                if (((k = R0(d)), k !== null)) {
                  for (
                    f.flags |= 128,
                      Rm(T, !1),
                      d = k.updateQueue,
                      f.updateQueue = d,
                      D0(f, d),
                      f.subtreeFlags = 0,
                      d = v,
                      v = f.child;
                    v !== null;

                  )
                    n2(v, d), (v = v.sibling);
                  return Y($s, ($s.current & 1) | 2), f.child;
                }
                d = d.sibling;
              }
            T.tail !== null &&
              re() > N0 &&
              ((f.flags |= 128), (x = !0), Rm(T, !1), (f.lanes = 4194304));
          }
        else {
          if (!x)
            if (((d = R0(k)), d !== null)) {
              if (
                ((f.flags |= 128),
                (x = !0),
                (d = d.updateQueue),
                (f.updateQueue = d),
                D0(f, d),
                Rm(T, !0),
                T.tail === null &&
                  T.tailMode === "hidden" &&
                  !k.alternate &&
                  !gn)
              )
                return ns(f), null;
            } else
              2 * re() - T.renderingStartTime > N0 &&
                v !== 536870912 &&
                ((f.flags |= 128), (x = !0), Rm(T, !1), (f.lanes = 4194304));
          T.isBackwards
            ? ((k.sibling = f.child), (f.child = k))
            : ((d = T.last),
              d !== null ? (d.sibling = k) : (f.child = k),
              (T.last = k));
        }
        return T.tail !== null
          ? ((f = T.tail),
            (T.rendering = f),
            (T.tail = f.sibling),
            (T.renderingStartTime = re()),
            (f.sibling = null),
            (d = $s.current),
            Y($s, x ? (d & 1) | 2 : d & 1),
            f)
          : (ns(f), null);
      case 22:
      case 23:
        return (
          Go(f),
          oT(),
          (x = f.memoizedState !== null),
          d !== null
            ? (d.memoizedState !== null) !== x && (f.flags |= 8192)
            : x && (f.flags |= 8192),
          x
            ? (v & 536870912) !== 0 &&
              (f.flags & 128) === 0 &&
              (ns(f), f.subtreeFlags & 6 && (f.flags |= 8192))
            : ns(f),
          (v = f.updateQueue),
          v !== null && D0(f, v.retryQueue),
          (v = null),
          d !== null &&
            d.memoizedState !== null &&
            d.memoizedState.cachePool !== null &&
            (v = d.memoizedState.cachePool.pool),
          (x = null),
          f.memoizedState !== null &&
            f.memoizedState.cachePool !== null &&
            (x = f.memoizedState.cachePool.pool),
          x !== v && (f.flags |= 2048),
          d !== null && F(cu),
          null
        );
      case 24:
        return (
          (v = null),
          d !== null && (v = d.memoizedState.cache),
          f.memoizedState.cache !== v && (f.flags |= 2048),
          Vo(Us),
          ns(f),
          null
        );
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(s(156, f.tag));
  }
  function bZ(d, f) {
    switch ((WS(f), f.tag)) {
      case 1:
        return (
          (d = f.flags), d & 65536 ? ((f.flags = (d & -65537) | 128), f) : null
        );
      case 3:
        return (
          Vo(Us),
          pe(),
          (d = f.flags),
          (d & 65536) !== 0 && (d & 128) === 0
            ? ((f.flags = (d & -65537) | 128), f)
            : null
        );
      case 26:
      case 27:
      case 5:
        return be(f), null;
      case 13:
        if (
          (Go(f), (d = f.memoizedState), d !== null && d.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(s(340));
          dm();
        }
        return (
          (d = f.flags), d & 65536 ? ((f.flags = (d & -65537) | 128), f) : null
        );
      case 19:
        return F($s), null;
      case 4:
        return pe(), null;
      case 10:
        return Vo(f.type), null;
      case 22:
      case 23:
        return (
          Go(f),
          oT(),
          d !== null && F(cu),
          (d = f.flags),
          d & 65536 ? ((f.flags = (d & -65537) | 128), f) : null
        );
      case 24:
        return Vo(Us), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function CN(d, f) {
    switch ((WS(f), f.tag)) {
      case 3:
        Vo(Us), pe();
        break;
      case 26:
      case 27:
      case 5:
        be(f);
        break;
      case 4:
        pe();
        break;
      case 13:
        Go(f);
        break;
      case 19:
        F($s);
        break;
      case 10:
        Vo(f.type);
        break;
      case 22:
      case 23:
        Go(f), oT(), d !== null && F(cu);
        break;
      case 24:
        Vo(Us);
    }
  }
  function km(d, f) {
    try {
      var v = f.updateQueue,
        x = v !== null ? v.lastEffect : null;
      if (x !== null) {
        var T = x.next;
        v = T;
        do {
          if ((v.tag & d) === d) {
            x = void 0;
            var k = v.create,
              G = v.inst;
            (x = k()), (G.destroy = x);
          }
          v = v.next;
        } while (v !== T);
      }
    } catch (ee) {
      Mn(f, f.return, ee);
    }
  }
  function Ul(d, f, v) {
    try {
      var x = f.updateQueue,
        T = x !== null ? x.lastEffect : null;
      if (T !== null) {
        var k = T.next;
        x = k;
        do {
          if ((x.tag & d) === d) {
            var G = x.inst,
              ee = G.destroy;
            if (ee !== void 0) {
              (G.destroy = void 0), (T = f);
              var oe = v,
                Se = ee;
              try {
                Se();
              } catch (Pe) {
                Mn(T, oe, Pe);
              }
            }
          }
          x = x.next;
        } while (x !== k);
      }
    } catch (Pe) {
      Mn(f, f.return, Pe);
    }
  }
  function IN(d) {
    var f = d.updateQueue;
    if (f !== null) {
      var v = d.stateNode;
      try {
        v2(f, v);
      } catch (x) {
        Mn(d, d.return, x);
      }
    }
  }
  function LN(d, f, v) {
    (v.props = du(d.type, d.memoizedProps)), (v.state = d.memoizedState);
    try {
      v.componentWillUnmount();
    } catch (x) {
      Mn(d, f, x);
    }
  }
  function Cm(d, f) {
    try {
      var v = d.ref;
      if (v !== null) {
        switch (d.tag) {
          case 26:
          case 27:
          case 5:
            var x = d.stateNode;
            break;
          case 30:
            x = d.stateNode;
            break;
          default:
            x = d.stateNode;
        }
        typeof v == "function" ? (d.refCleanup = v(x)) : (v.current = x);
      }
    } catch (T) {
      Mn(d, f, T);
    }
  }
  function Wa(d, f) {
    var v = d.ref,
      x = d.refCleanup;
    if (v !== null)
      if (typeof x == "function")
        try {
          x();
        } catch (T) {
          Mn(d, f, T);
        } finally {
          (d.refCleanup = null),
            (d = d.alternate),
            d != null && (d.refCleanup = null);
        }
      else if (typeof v == "function")
        try {
          v(null);
        } catch (T) {
          Mn(d, f, T);
        }
      else v.current = null;
  }
  function DN(d) {
    var f = d.type,
      v = d.memoizedProps,
      x = d.stateNode;
    try {
      e: switch (f) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          v.autoFocus && x.focus();
          break e;
        case "img":
          v.src ? (x.src = v.src) : v.srcSet && (x.srcset = v.srcSet);
      }
    } catch (T) {
      Mn(d, d.return, T);
    }
  }
  function NT(d, f, v) {
    try {
      var x = d.stateNode;
      $Z(x, d.type, v, f), (x[Ke] = f);
    } catch (T) {
      Mn(d, d.return, T);
    }
  }
  function PN(d) {
    return (
      d.tag === 5 ||
      d.tag === 3 ||
      d.tag === 26 ||
      (d.tag === 27 && Wl(d.type)) ||
      d.tag === 4
    );
  }
  function OT(d) {
    e: for (;;) {
      for (; d.sibling === null; ) {
        if (d.return === null || PN(d.return)) return null;
        d = d.return;
      }
      for (
        d.sibling.return = d.return, d = d.sibling;
        d.tag !== 5 && d.tag !== 6 && d.tag !== 18;

      ) {
        if (
          (d.tag === 27 && Wl(d.type)) ||
          d.flags & 2 ||
          d.child === null ||
          d.tag === 4
        )
          continue e;
        (d.child.return = d), (d = d.child);
      }
      if (!(d.flags & 2)) return d.stateNode;
    }
  }
  function jT(d, f, v) {
    var x = d.tag;
    if (x === 5 || x === 6)
      (d = d.stateNode),
        f
          ? (v.nodeType === 9
              ? v.body
              : v.nodeName === "HTML"
              ? v.ownerDocument.body
              : v
            ).insertBefore(d, f)
          : ((f =
              v.nodeType === 9
                ? v.body
                : v.nodeName === "HTML"
                ? v.ownerDocument.body
                : v),
            f.appendChild(d),
            (v = v._reactRootContainer),
            v != null || f.onclick !== null || (f.onclick = z0));
    else if (
      x !== 4 &&
      (x === 27 && Wl(d.type) && ((v = d.stateNode), (f = null)),
      (d = d.child),
      d !== null)
    )
      for (jT(d, f, v), d = d.sibling; d !== null; )
        jT(d, f, v), (d = d.sibling);
  }
  function P0(d, f, v) {
    var x = d.tag;
    if (x === 5 || x === 6)
      (d = d.stateNode), f ? v.insertBefore(d, f) : v.appendChild(d);
    else if (
      x !== 4 &&
      (x === 27 && Wl(d.type) && (v = d.stateNode), (d = d.child), d !== null)
    )
      for (P0(d, f, v), d = d.sibling; d !== null; )
        P0(d, f, v), (d = d.sibling);
  }
  function MN(d) {
    var f = d.stateNode,
      v = d.memoizedProps;
    try {
      for (var x = d.type, T = f.attributes; T.length; )
        f.removeAttributeNode(T[0]);
      fr(f, x, v), (f[je] = d), (f[Ke] = v);
    } catch (k) {
      Mn(d, d.return, k);
    }
  }
  var Ko = !1,
    Ts = !1,
    FT = !1,
    NN = typeof WeakSet == "function" ? WeakSet : Set,
    Ys = null;
  function xZ(d, f) {
    if (((d = d.containerInfo), (l_ = Q0), (d = qM(d)), OS(d))) {
      if ("selectionStart" in d)
        var v = { start: d.selectionStart, end: d.selectionEnd };
      else
        e: {
          v = ((v = d.ownerDocument) && v.defaultView) || window;
          var x = v.getSelection && v.getSelection();
          if (x && x.rangeCount !== 0) {
            v = x.anchorNode;
            var T = x.anchorOffset,
              k = x.focusNode;
            x = x.focusOffset;
            try {
              v.nodeType, k.nodeType;
            } catch {
              v = null;
              break e;
            }
            var G = 0,
              ee = -1,
              oe = -1,
              Se = 0,
              Pe = 0,
              Fe = d,
              Te = null;
            t: for (;;) {
              for (
                var Ae;
                Fe !== v || (T !== 0 && Fe.nodeType !== 3) || (ee = G + T),
                  Fe !== k || (x !== 0 && Fe.nodeType !== 3) || (oe = G + x),
                  Fe.nodeType === 3 && (G += Fe.nodeValue.length),
                  (Ae = Fe.firstChild) !== null;

              )
                (Te = Fe), (Fe = Ae);
              for (;;) {
                if (Fe === d) break t;
                if (
                  (Te === v && ++Se === T && (ee = G),
                  Te === k && ++Pe === x && (oe = G),
                  (Ae = Fe.nextSibling) !== null)
                )
                  break;
                (Fe = Te), (Te = Fe.parentNode);
              }
              Fe = Ae;
            }
            v = ee === -1 || oe === -1 ? null : { start: ee, end: oe };
          } else v = null;
        }
      v = v || { start: 0, end: 0 };
    } else v = null;
    for (
      c_ = { focusedElem: d, selectionRange: v }, Q0 = !1, Ys = f;
      Ys !== null;

    )
      if (
        ((f = Ys), (d = f.child), (f.subtreeFlags & 1024) !== 0 && d !== null)
      )
        (d.return = f), (Ys = d);
      else
        for (; Ys !== null; ) {
          switch (((f = Ys), (k = f.alternate), (d = f.flags), f.tag)) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((d & 1024) !== 0 && k !== null) {
                (d = void 0),
                  (v = f),
                  (T = k.memoizedProps),
                  (k = k.memoizedState),
                  (x = v.stateNode);
                try {
                  var Ct = du(v.type, T, v.elementType === v.type);
                  (d = x.getSnapshotBeforeUpdate(Ct, k)),
                    (x.__reactInternalSnapshotBeforeUpdate = d);
                } catch (_t) {
                  Mn(v, v.return, _t);
                }
              }
              break;
            case 3:
              if ((d & 1024) !== 0) {
                if (
                  ((d = f.stateNode.containerInfo), (v = d.nodeType), v === 9)
                )
                  h_(d);
                else if (v === 1)
                  switch (d.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      h_(d);
                      break;
                    default:
                      d.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((d & 1024) !== 0) throw Error(s(163));
          }
          if (((d = f.sibling), d !== null)) {
            (d.return = f.return), (Ys = d);
            break;
          }
          Ys = f.return;
        }
  }
  function ON(d, f, v) {
    var x = v.flags;
    switch (v.tag) {
      case 0:
      case 11:
      case 15:
        $l(d, v), x & 4 && km(5, v);
        break;
      case 1:
        if (($l(d, v), x & 4))
          if (((d = v.stateNode), f === null))
            try {
              d.componentDidMount();
            } catch (G) {
              Mn(v, v.return, G);
            }
          else {
            var T = du(v.type, f.memoizedProps);
            f = f.memoizedState;
            try {
              d.componentDidUpdate(T, f, d.__reactInternalSnapshotBeforeUpdate);
            } catch (G) {
              Mn(v, v.return, G);
            }
          }
        x & 64 && IN(v), x & 512 && Cm(v, v.return);
        break;
      case 3:
        if (($l(d, v), x & 64 && ((d = v.updateQueue), d !== null))) {
          if (((f = null), v.child !== null))
            switch (v.child.tag) {
              case 27:
              case 5:
                f = v.child.stateNode;
                break;
              case 1:
                f = v.child.stateNode;
            }
          try {
            v2(d, f);
          } catch (G) {
            Mn(v, v.return, G);
          }
        }
        break;
      case 27:
        f === null && x & 4 && MN(v);
      case 26:
      case 5:
        $l(d, v), f === null && x & 4 && DN(v), x & 512 && Cm(v, v.return);
        break;
      case 12:
        $l(d, v);
        break;
      case 13:
        $l(d, v),
          x & 4 && UN(d, v),
          x & 64 &&
            ((d = v.memoizedState),
            d !== null &&
              ((d = d.dehydrated),
              d !== null && ((v = CZ.bind(null, v)), WZ(d, v))));
        break;
      case 22:
        if (((x = v.memoizedState !== null || Ko), !x)) {
          (f = (f !== null && f.memoizedState !== null) || Ts), (T = Ko);
          var k = Ts;
          (Ko = x),
            (Ts = f) && !k ? Bl(d, v, (v.subtreeFlags & 8772) !== 0) : $l(d, v),
            (Ko = T),
            (Ts = k);
        }
        break;
      case 30:
        break;
      default:
        $l(d, v);
    }
  }
  function jN(d) {
    var f = d.alternate;
    f !== null && ((d.alternate = null), jN(f)),
      (d.child = null),
      (d.deletions = null),
      (d.sibling = null),
      d.tag === 5 && ((f = d.stateNode), f !== null && ws(f)),
      (d.stateNode = null),
      (d.return = null),
      (d.dependencies = null),
      (d.memoizedProps = null),
      (d.memoizedState = null),
      (d.pendingProps = null),
      (d.stateNode = null),
      (d.updateQueue = null);
  }
  var Kn = null,
    Gr = !1;
  function Yo(d, f, v) {
    for (v = v.child; v !== null; ) FN(d, f, v), (v = v.sibling);
  }
  function FN(d, f, v) {
    if (xt && typeof xt.onCommitFiberUnmount == "function")
      try {
        xt.onCommitFiberUnmount(ht, v);
      } catch {}
    switch (v.tag) {
      case 26:
        Ts || Wa(v, f),
          Yo(d, f, v),
          v.memoizedState
            ? v.memoizedState.count--
            : v.stateNode && ((v = v.stateNode), v.parentNode.removeChild(v));
        break;
      case 27:
        Ts || Wa(v, f);
        var x = Kn,
          T = Gr;
        Wl(v.type) && ((Kn = v.stateNode), (Gr = !1)),
          Yo(d, f, v),
          Fm(v.stateNode),
          (Kn = x),
          (Gr = T);
        break;
      case 5:
        Ts || Wa(v, f);
      case 6:
        if (
          ((x = Kn),
          (T = Gr),
          (Kn = null),
          Yo(d, f, v),
          (Kn = x),
          (Gr = T),
          Kn !== null)
        )
          if (Gr)
            try {
              (Kn.nodeType === 9
                ? Kn.body
                : Kn.nodeName === "HTML"
                ? Kn.ownerDocument.body
                : Kn
              ).removeChild(v.stateNode);
            } catch (k) {
              Mn(v, f, k);
            }
          else
            try {
              Kn.removeChild(v.stateNode);
            } catch (k) {
              Mn(v, f, k);
            }
        break;
      case 18:
        Kn !== null &&
          (Gr
            ? ((d = Kn),
              AO(
                d.nodeType === 9
                  ? d.body
                  : d.nodeName === "HTML"
                  ? d.ownerDocument.body
                  : d,
                v.stateNode
              ),
              qm(d))
            : AO(Kn, v.stateNode));
        break;
      case 4:
        (x = Kn),
          (T = Gr),
          (Kn = v.stateNode.containerInfo),
          (Gr = !0),
          Yo(d, f, v),
          (Kn = x),
          (Gr = T);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ts || Ul(2, v, f), Ts || Ul(4, v, f), Yo(d, f, v);
        break;
      case 1:
        Ts ||
          (Wa(v, f),
          (x = v.stateNode),
          typeof x.componentWillUnmount == "function" && LN(v, f, x)),
          Yo(d, f, v);
        break;
      case 21:
        Yo(d, f, v);
        break;
      case 22:
        (Ts = (x = Ts) || v.memoizedState !== null), Yo(d, f, v), (Ts = x);
        break;
      default:
        Yo(d, f, v);
    }
  }
  function UN(d, f) {
    if (
      f.memoizedState === null &&
      ((d = f.alternate),
      d !== null &&
        ((d = d.memoizedState), d !== null && ((d = d.dehydrated), d !== null)))
    )
      try {
        qm(d);
      } catch (v) {
        Mn(f, f.return, v);
      }
  }
  function wZ(d) {
    switch (d.tag) {
      case 13:
      case 19:
        var f = d.stateNode;
        return f === null && (f = d.stateNode = new NN()), f;
      case 22:
        return (
          (d = d.stateNode),
          (f = d._retryCache),
          f === null && (f = d._retryCache = new NN()),
          f
        );
      default:
        throw Error(s(435, d.tag));
    }
  }
  function UT(d, f) {
    var v = wZ(d);
    f.forEach(function (x) {
      var T = IZ.bind(null, d, x);
      v.has(x) || (v.add(x), x.then(T, T));
    });
  }
  function fi(d, f) {
    var v = f.deletions;
    if (v !== null)
      for (var x = 0; x < v.length; x++) {
        var T = v[x],
          k = d,
          G = f,
          ee = G;
        e: for (; ee !== null; ) {
          switch (ee.tag) {
            case 27:
              if (Wl(ee.type)) {
                (Kn = ee.stateNode), (Gr = !1);
                break e;
              }
              break;
            case 5:
              (Kn = ee.stateNode), (Gr = !1);
              break e;
            case 3:
            case 4:
              (Kn = ee.stateNode.containerInfo), (Gr = !0);
              break e;
          }
          ee = ee.return;
        }
        if (Kn === null) throw Error(s(160));
        FN(k, G, T),
          (Kn = null),
          (Gr = !1),
          (k = T.alternate),
          k !== null && (k.return = null),
          (T.return = null);
      }
    if (f.subtreeFlags & 13878)
      for (f = f.child; f !== null; ) $N(f, d), (f = f.sibling);
  }
  var ma = null;
  function $N(d, f) {
    var v = d.alternate,
      x = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        fi(f, d),
          mi(d),
          x & 4 && (Ul(3, d, d.return), km(3, d), Ul(5, d, d.return));
        break;
      case 1:
        fi(f, d),
          mi(d),
          x & 512 && (Ts || v === null || Wa(v, v.return)),
          x & 64 &&
            Ko &&
            ((d = d.updateQueue),
            d !== null &&
              ((x = d.callbacks),
              x !== null &&
                ((v = d.shared.hiddenCallbacks),
                (d.shared.hiddenCallbacks = v === null ? x : v.concat(x)))));
        break;
      case 26:
        var T = ma;
        if (
          (fi(f, d),
          mi(d),
          x & 512 && (Ts || v === null || Wa(v, v.return)),
          x & 4)
        ) {
          var k = v !== null ? v.memoizedState : null;
          if (((x = d.memoizedState), v === null))
            if (x === null)
              if (d.stateNode === null) {
                e: {
                  (x = d.type),
                    (v = d.memoizedProps),
                    (T = T.ownerDocument || T);
                  t: switch (x) {
                    case "title":
                      (k = T.getElementsByTagName("title")[0]),
                        (!k ||
                          k[_n] ||
                          k[je] ||
                          k.namespaceURI === "http://www.w3.org/2000/svg" ||
                          k.hasAttribute("itemprop")) &&
                          ((k = T.createElement(x)),
                          T.head.insertBefore(
                            k,
                            T.querySelector("head > title")
                          )),
                        fr(k, x, v),
                        (k[je] = d),
                        ls(k),
                        (x = k);
                      break e;
                    case "link":
                      var G = MO("link", "href", T).get(x + (v.href || ""));
                      if (G) {
                        for (var ee = 0; ee < G.length; ee++)
                          if (
                            ((k = G[ee]),
                            k.getAttribute("href") ===
                              (v.href == null || v.href === ""
                                ? null
                                : v.href) &&
                              k.getAttribute("rel") ===
                                (v.rel == null ? null : v.rel) &&
                              k.getAttribute("title") ===
                                (v.title == null ? null : v.title) &&
                              k.getAttribute("crossorigin") ===
                                (v.crossOrigin == null ? null : v.crossOrigin))
                          ) {
                            G.splice(ee, 1);
                            break t;
                          }
                      }
                      (k = T.createElement(x)),
                        fr(k, x, v),
                        T.head.appendChild(k);
                      break;
                    case "meta":
                      if (
                        (G = MO("meta", "content", T).get(
                          x + (v.content || "")
                        ))
                      ) {
                        for (ee = 0; ee < G.length; ee++)
                          if (
                            ((k = G[ee]),
                            k.getAttribute("content") ===
                              (v.content == null ? null : "" + v.content) &&
                              k.getAttribute("name") ===
                                (v.name == null ? null : v.name) &&
                              k.getAttribute("property") ===
                                (v.property == null ? null : v.property) &&
                              k.getAttribute("http-equiv") ===
                                (v.httpEquiv == null ? null : v.httpEquiv) &&
                              k.getAttribute("charset") ===
                                (v.charSet == null ? null : v.charSet))
                          ) {
                            G.splice(ee, 1);
                            break t;
                          }
                      }
                      (k = T.createElement(x)),
                        fr(k, x, v),
                        T.head.appendChild(k);
                      break;
                    default:
                      throw Error(s(468, x));
                  }
                  (k[je] = d), ls(k), (x = k);
                }
                d.stateNode = x;
              } else NO(T, d.type, d.stateNode);
            else d.stateNode = PO(T, x, d.memoizedProps);
          else
            k !== x
              ? (k === null
                  ? v.stateNode !== null &&
                    ((v = v.stateNode), v.parentNode.removeChild(v))
                  : k.count--,
                x === null
                  ? NO(T, d.type, d.stateNode)
                  : PO(T, x, d.memoizedProps))
              : x === null &&
                d.stateNode !== null &&
                NT(d, d.memoizedProps, v.memoizedProps);
        }
        break;
      case 27:
        fi(f, d),
          mi(d),
          x & 512 && (Ts || v === null || Wa(v, v.return)),
          v !== null && x & 4 && NT(d, d.memoizedProps, v.memoizedProps);
        break;
      case 5:
        if (
          (fi(f, d),
          mi(d),
          x & 512 && (Ts || v === null || Wa(v, v.return)),
          d.flags & 32)
        ) {
          T = d.stateNode;
          try {
            gd(T, "");
          } catch (Ae) {
            Mn(d, d.return, Ae);
          }
        }
        x & 4 &&
          d.stateNode != null &&
          ((T = d.memoizedProps), NT(d, T, v !== null ? v.memoizedProps : T)),
          x & 1024 && (FT = !0);
        break;
      case 6:
        if ((fi(f, d), mi(d), x & 4)) {
          if (d.stateNode === null) throw Error(s(162));
          (x = d.memoizedProps), (v = d.stateNode);
          try {
            v.nodeValue = x;
          } catch (Ae) {
            Mn(d, d.return, Ae);
          }
        }
        break;
      case 3:
        if (
          ((K0 = null),
          (T = ma),
          (ma = q0(f.containerInfo)),
          fi(f, d),
          (ma = T),
          mi(d),
          x & 4 && v !== null && v.memoizedState.isDehydrated)
        )
          try {
            qm(f.containerInfo);
          } catch (Ae) {
            Mn(d, d.return, Ae);
          }
        FT && ((FT = !1), BN(d));
        break;
      case 4:
        (x = ma),
          (ma = q0(d.stateNode.containerInfo)),
          fi(f, d),
          mi(d),
          (ma = x);
        break;
      case 12:
        fi(f, d), mi(d);
        break;
      case 13:
        fi(f, d),
          mi(d),
          d.child.flags & 8192 &&
            (d.memoizedState !== null) !=
              (v !== null && v.memoizedState !== null) &&
            (GT = re()),
          x & 4 &&
            ((x = d.updateQueue),
            x !== null && ((d.updateQueue = null), UT(d, x)));
        break;
      case 22:
        T = d.memoizedState !== null;
        var oe = v !== null && v.memoizedState !== null,
          Se = Ko,
          Pe = Ts;
        if (
          ((Ko = Se || T),
          (Ts = Pe || oe),
          fi(f, d),
          (Ts = Pe),
          (Ko = Se),
          mi(d),
          x & 8192)
        )
          e: for (
            f = d.stateNode,
              f._visibility = T ? f._visibility & -2 : f._visibility | 1,
              T && (v === null || oe || Ko || Ts || hu(d)),
              v = null,
              f = d;
            ;

          ) {
            if (f.tag === 5 || f.tag === 26) {
              if (v === null) {
                oe = v = f;
                try {
                  if (((k = oe.stateNode), T))
                    (G = k.style),
                      typeof G.setProperty == "function"
                        ? G.setProperty("display", "none", "important")
                        : (G.display = "none");
                  else {
                    ee = oe.stateNode;
                    var Fe = oe.memoizedProps.style,
                      Te =
                        Fe != null && Fe.hasOwnProperty("display")
                          ? Fe.display
                          : null;
                    ee.style.display =
                      Te == null || typeof Te == "boolean"
                        ? ""
                        : ("" + Te).trim();
                  }
                } catch (Ae) {
                  Mn(oe, oe.return, Ae);
                }
              }
            } else if (f.tag === 6) {
              if (v === null) {
                oe = f;
                try {
                  oe.stateNode.nodeValue = T ? "" : oe.memoizedProps;
                } catch (Ae) {
                  Mn(oe, oe.return, Ae);
                }
              }
            } else if (
              ((f.tag !== 22 && f.tag !== 23) ||
                f.memoizedState === null ||
                f === d) &&
              f.child !== null
            ) {
              (f.child.return = f), (f = f.child);
              continue;
            }
            if (f === d) break e;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === d) break e;
              v === f && (v = null), (f = f.return);
            }
            v === f && (v = null),
              (f.sibling.return = f.return),
              (f = f.sibling);
          }
        x & 4 &&
          ((x = d.updateQueue),
          x !== null &&
            ((v = x.retryQueue),
            v !== null && ((x.retryQueue = null), UT(d, v))));
        break;
      case 19:
        fi(f, d),
          mi(d),
          x & 4 &&
            ((x = d.updateQueue),
            x !== null && ((d.updateQueue = null), UT(d, x)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        fi(f, d), mi(d);
    }
  }
  function mi(d) {
    var f = d.flags;
    if (f & 2) {
      try {
        for (var v, x = d.return; x !== null; ) {
          if (PN(x)) {
            v = x;
            break;
          }
          x = x.return;
        }
        if (v == null) throw Error(s(160));
        switch (v.tag) {
          case 27:
            var T = v.stateNode,
              k = OT(d);
            P0(d, k, T);
            break;
          case 5:
            var G = v.stateNode;
            v.flags & 32 && (gd(G, ""), (v.flags &= -33));
            var ee = OT(d);
            P0(d, ee, G);
            break;
          case 3:
          case 4:
            var oe = v.stateNode.containerInfo,
              Se = OT(d);
            jT(d, Se, oe);
            break;
          default:
            throw Error(s(161));
        }
      } catch (Pe) {
        Mn(d, d.return, Pe);
      }
      d.flags &= -3;
    }
    f & 4096 && (d.flags &= -4097);
  }
  function BN(d) {
    if (d.subtreeFlags & 1024)
      for (d = d.child; d !== null; ) {
        var f = d;
        BN(f),
          f.tag === 5 && f.flags & 1024 && f.stateNode.reset(),
          (d = d.sibling);
      }
  }
  function $l(d, f) {
    if (f.subtreeFlags & 8772)
      for (f = f.child; f !== null; ) ON(d, f.alternate, f), (f = f.sibling);
  }
  function hu(d) {
    for (d = d.child; d !== null; ) {
      var f = d;
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ul(4, f, f.return), hu(f);
          break;
        case 1:
          Wa(f, f.return);
          var v = f.stateNode;
          typeof v.componentWillUnmount == "function" && LN(f, f.return, v),
            hu(f);
          break;
        case 27:
          Fm(f.stateNode);
        case 26:
        case 5:
          Wa(f, f.return), hu(f);
          break;
        case 22:
          f.memoizedState === null && hu(f);
          break;
        case 30:
          hu(f);
          break;
        default:
          hu(f);
      }
      d = d.sibling;
    }
  }
  function Bl(d, f, v) {
    for (v = v && (f.subtreeFlags & 8772) !== 0, f = f.child; f !== null; ) {
      var x = f.alternate,
        T = d,
        k = f,
        G = k.flags;
      switch (k.tag) {
        case 0:
        case 11:
        case 15:
          Bl(T, k, v), km(4, k);
          break;
        case 1:
          if (
            (Bl(T, k, v),
            (x = k),
            (T = x.stateNode),
            typeof T.componentDidMount == "function")
          )
            try {
              T.componentDidMount();
            } catch (Se) {
              Mn(x, x.return, Se);
            }
          if (((x = k), (T = x.updateQueue), T !== null)) {
            var ee = x.stateNode;
            try {
              var oe = T.shared.hiddenCallbacks;
              if (oe !== null)
                for (T.shared.hiddenCallbacks = null, T = 0; T < oe.length; T++)
                  g2(oe[T], ee);
            } catch (Se) {
              Mn(x, x.return, Se);
            }
          }
          v && G & 64 && IN(k), Cm(k, k.return);
          break;
        case 27:
          MN(k);
        case 26:
        case 5:
          Bl(T, k, v), v && x === null && G & 4 && DN(k), Cm(k, k.return);
          break;
        case 12:
          Bl(T, k, v);
          break;
        case 13:
          Bl(T, k, v), v && G & 4 && UN(T, k);
          break;
        case 22:
          k.memoizedState === null && Bl(T, k, v), Cm(k, k.return);
          break;
        case 30:
          break;
        default:
          Bl(T, k, v);
      }
      f = f.sibling;
    }
  }
  function $T(d, f) {
    var v = null;
    d !== null &&
      d.memoizedState !== null &&
      d.memoizedState.cachePool !== null &&
      (v = d.memoizedState.cachePool.pool),
      (d = null),
      f.memoizedState !== null &&
        f.memoizedState.cachePool !== null &&
        (d = f.memoizedState.cachePool.pool),
      d !== v && (d != null && d.refCount++, v != null && mm(v));
  }
  function BT(d, f) {
    (d = null),
      f.alternate !== null && (d = f.alternate.memoizedState.cache),
      (f = f.memoizedState.cache),
      f !== d && (f.refCount++, d != null && mm(d));
  }
  function Ka(d, f, v, x) {
    if (f.subtreeFlags & 10256)
      for (f = f.child; f !== null; ) HN(d, f, v, x), (f = f.sibling);
  }
  function HN(d, f, v, x) {
    var T = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 15:
        Ka(d, f, v, x), T & 2048 && km(9, f);
        break;
      case 1:
        Ka(d, f, v, x);
        break;
      case 3:
        Ka(d, f, v, x),
          T & 2048 &&
            ((d = null),
            f.alternate !== null && (d = f.alternate.memoizedState.cache),
            (f = f.memoizedState.cache),
            f !== d && (f.refCount++, d != null && mm(d)));
        break;
      case 12:
        if (T & 2048) {
          Ka(d, f, v, x), (d = f.stateNode);
          try {
            var k = f.memoizedProps,
              G = k.id,
              ee = k.onPostCommit;
            typeof ee == "function" &&
              ee(
                G,
                f.alternate === null ? "mount" : "update",
                d.passiveEffectDuration,
                -0
              );
          } catch (oe) {
            Mn(f, f.return, oe);
          }
        } else Ka(d, f, v, x);
        break;
      case 13:
        Ka(d, f, v, x);
        break;
      case 23:
        break;
      case 22:
        (k = f.stateNode),
          (G = f.alternate),
          f.memoizedState !== null
            ? k._visibility & 2
              ? Ka(d, f, v, x)
              : Im(d, f)
            : k._visibility & 2
            ? Ka(d, f, v, x)
            : ((k._visibility |= 2),
              Nd(d, f, v, x, (f.subtreeFlags & 10256) !== 0)),
          T & 2048 && $T(G, f);
        break;
      case 24:
        Ka(d, f, v, x), T & 2048 && BT(f.alternate, f);
        break;
      default:
        Ka(d, f, v, x);
    }
  }
  function Nd(d, f, v, x, T) {
    for (T = T && (f.subtreeFlags & 10256) !== 0, f = f.child; f !== null; ) {
      var k = d,
        G = f,
        ee = v,
        oe = x,
        Se = G.flags;
      switch (G.tag) {
        case 0:
        case 11:
        case 15:
          Nd(k, G, ee, oe, T), km(8, G);
          break;
        case 23:
          break;
        case 22:
          var Pe = G.stateNode;
          G.memoizedState !== null
            ? Pe._visibility & 2
              ? Nd(k, G, ee, oe, T)
              : Im(k, G)
            : ((Pe._visibility |= 2), Nd(k, G, ee, oe, T)),
            T && Se & 2048 && $T(G.alternate, G);
          break;
        case 24:
          Nd(k, G, ee, oe, T), T && Se & 2048 && BT(G.alternate, G);
          break;
        default:
          Nd(k, G, ee, oe, T);
      }
      f = f.sibling;
    }
  }
  function Im(d, f) {
    if (f.subtreeFlags & 10256)
      for (f = f.child; f !== null; ) {
        var v = d,
          x = f,
          T = x.flags;
        switch (x.tag) {
          case 22:
            Im(v, x), T & 2048 && $T(x.alternate, x);
            break;
          case 24:
            Im(v, x), T & 2048 && BT(x.alternate, x);
            break;
          default:
            Im(v, x);
        }
        f = f.sibling;
      }
  }
  var Lm = 8192;
  function Od(d) {
    if (d.subtreeFlags & Lm)
      for (d = d.child; d !== null; ) VN(d), (d = d.sibling);
  }
  function VN(d) {
    switch (d.tag) {
      case 26:
        Od(d),
          d.flags & Lm &&
            d.memoizedState !== null &&
            aJ(ma, d.memoizedState, d.memoizedProps);
        break;
      case 5:
        Od(d);
        break;
      case 3:
      case 4:
        var f = ma;
        (ma = q0(d.stateNode.containerInfo)), Od(d), (ma = f);
        break;
      case 22:
        d.memoizedState === null &&
          ((f = d.alternate),
          f !== null && f.memoizedState !== null
            ? ((f = Lm), (Lm = 16777216), Od(d), (Lm = f))
            : Od(d));
        break;
      default:
        Od(d);
    }
  }
  function zN(d) {
    var f = d.alternate;
    if (f !== null && ((d = f.child), d !== null)) {
      f.child = null;
      do (f = d.sibling), (d.sibling = null), (d = f);
      while (d !== null);
    }
  }
  function Dm(d) {
    var f = d.deletions;
    if ((d.flags & 16) !== 0) {
      if (f !== null)
        for (var v = 0; v < f.length; v++) {
          var x = f[v];
          (Ys = x), qN(x, d);
        }
      zN(d);
    }
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; ) GN(d), (d = d.sibling);
  }
  function GN(d) {
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        Dm(d), d.flags & 2048 && Ul(9, d, d.return);
        break;
      case 3:
        Dm(d);
        break;
      case 12:
        Dm(d);
        break;
      case 22:
        var f = d.stateNode;
        d.memoizedState !== null &&
        f._visibility & 2 &&
        (d.return === null || d.return.tag !== 13)
          ? ((f._visibility &= -3), M0(d))
          : Dm(d);
        break;
      default:
        Dm(d);
    }
  }
  function M0(d) {
    var f = d.deletions;
    if ((d.flags & 16) !== 0) {
      if (f !== null)
        for (var v = 0; v < f.length; v++) {
          var x = f[v];
          (Ys = x), qN(x, d);
        }
      zN(d);
    }
    for (d = d.child; d !== null; ) {
      switch (((f = d), f.tag)) {
        case 0:
        case 11:
        case 15:
          Ul(8, f, f.return), M0(f);
          break;
        case 22:
          (v = f.stateNode),
            v._visibility & 2 && ((v._visibility &= -3), M0(f));
          break;
        default:
          M0(f);
      }
      d = d.sibling;
    }
  }
  function qN(d, f) {
    for (; Ys !== null; ) {
      var v = Ys;
      switch (v.tag) {
        case 0:
        case 11:
        case 15:
          Ul(8, v, f);
          break;
        case 23:
        case 22:
          if (v.memoizedState !== null && v.memoizedState.cachePool !== null) {
            var x = v.memoizedState.cachePool.pool;
            x != null && x.refCount++;
          }
          break;
        case 24:
          mm(v.memoizedState.cache);
      }
      if (((x = v.child), x !== null)) (x.return = v), (Ys = x);
      else
        e: for (v = d; Ys !== null; ) {
          x = Ys;
          var T = x.sibling,
            k = x.return;
          if ((jN(x), x === v)) {
            Ys = null;
            break e;
          }
          if (T !== null) {
            (T.return = k), (Ys = T);
            break e;
          }
          Ys = k;
        }
    }
  }
  var EZ = {
      getCacheForType: function (d) {
        var f = wr(Us),
          v = f.data.get(d);
        return v === void 0 && ((v = d()), f.data.set(d, v)), v;
      },
    },
    SZ = typeof WeakMap == "function" ? WeakMap : Map,
    En = 0,
    Fn = null,
    tn = null,
    cn = 0,
    Sn = 0,
    pi = null,
    Hl = !1,
    jd = !1,
    HT = !1,
    Xo = 0,
    us = 0,
    Vl = 0,
    fu = 0,
    VT = 0,
    Bi = 0,
    Fd = 0,
    Pm = null,
    qr = null,
    zT = !1,
    GT = 0,
    N0 = 1 / 0,
    O0 = null,
    zl = null,
    hr = 0,
    Gl = null,
    Ud = null,
    $d = 0,
    qT = 0,
    WT = null,
    WN = null,
    Mm = 0,
    KT = null;
  function gi() {
    if ((En & 2) !== 0 && cn !== 0) return cn & -cn;
    if (O.T !== null) {
      var d = Rd;
      return d !== 0 ? d : t_();
    }
    return zt();
  }
  function KN() {
    Bi === 0 && (Bi = (cn & 536870912) === 0 || gn ? Bn() : 536870912);
    var d = $i.current;
    return d !== null && (d.flags |= 32), Bi;
  }
  function vi(d, f, v) {
    ((d === Fn && (Sn === 2 || Sn === 9)) || d.cancelPendingCommit !== null) &&
      (Bd(d, 0), ql(d, cn, Bi, !1)),
      Vt(d, v),
      ((En & 2) === 0 || d !== Fn) &&
        (d === Fn &&
          ((En & 2) === 0 && (fu |= v), us === 4 && ql(d, cn, Bi, !1)),
        Ya(d));
  }
  function YN(d, f, v) {
    if ((En & 6) !== 0) throw Error(s(327));
    var x = (!v && (f & 124) === 0 && (f & d.expiredLanes) === 0) || $t(d, f),
      T = x ? AZ(d, f) : QT(d, f, !0),
      k = x;
    do {
      if (T === 0) {
        jd && !x && ql(d, f, 0, !1);
        break;
      } else {
        if (((v = d.current.alternate), k && !TZ(v))) {
          (T = QT(d, f, !1)), (k = !1);
          continue;
        }
        if (T === 2) {
          if (((k = f), d.errorRecoveryDisabledLanes & k)) var G = 0;
          else
            (G = d.pendingLanes & -536870913),
              (G = G !== 0 ? G : G & 536870912 ? 536870912 : 0);
          if (G !== 0) {
            f = G;
            e: {
              var ee = d;
              T = Pm;
              var oe = ee.current.memoizedState.isDehydrated;
              if (
                (oe && (Bd(ee, G).flags |= 256), (G = QT(ee, G, !1)), G !== 2)
              ) {
                if (HT && !oe) {
                  (ee.errorRecoveryDisabledLanes |= k), (fu |= k), (T = 4);
                  break e;
                }
                (k = qr),
                  (qr = T),
                  k !== null && (qr === null ? (qr = k) : qr.push.apply(qr, k));
              }
              T = G;
            }
            if (((k = !1), T !== 2)) continue;
          }
        }
        if (T === 1) {
          Bd(d, 0), ql(d, f, 0, !0);
          break;
        }
        e: {
          switch (((x = d), (k = T), k)) {
            case 0:
            case 1:
              throw Error(s(345));
            case 4:
              if ((f & 4194048) !== f) break;
            case 6:
              ql(x, f, Bi, !Hl);
              break e;
            case 2:
              qr = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(s(329));
          }
          if ((f & 62914560) === f && ((T = GT + 300 - re()), 10 < T)) {
            if ((ql(x, f, Bi, !Hl), Ot(x, 0, !0) !== 0)) break e;
            x.timeoutHandle = TO(
              XN.bind(null, x, v, qr, O0, zT, f, Bi, fu, Fd, Hl, k, 2, -0, 0),
              T
            );
            break e;
          }
          XN(x, v, qr, O0, zT, f, Bi, fu, Fd, Hl, k, 0, -0, 0);
        }
      }
      break;
    } while (!0);
    Ya(d);
  }
  function XN(d, f, v, x, T, k, G, ee, oe, Se, Pe, Fe, Te, Ae) {
    if (
      ((d.timeoutHandle = -1),
      (Fe = f.subtreeFlags),
      (Fe & 8192 || (Fe & 16785408) === 16785408) &&
        ((Bm = { stylesheets: null, count: 0, unsuspend: iJ }),
        VN(f),
        (Fe = oJ()),
        Fe !== null))
    ) {
      (d.cancelPendingCommit = Fe(
        sO.bind(null, d, f, k, v, x, T, G, ee, oe, Pe, 1, Te, Ae)
      )),
        ql(d, k, G, !Se);
      return;
    }
    sO(d, f, k, v, x, T, G, ee, oe);
  }
  function TZ(d) {
    for (var f = d; ; ) {
      var v = f.tag;
      if (
        (v === 0 || v === 11 || v === 15) &&
        f.flags & 16384 &&
        ((v = f.updateQueue), v !== null && ((v = v.stores), v !== null))
      )
        for (var x = 0; x < v.length; x++) {
          var T = v[x],
            k = T.getSnapshot;
          T = T.value;
          try {
            if (!di(k(), T)) return !1;
          } catch {
            return !1;
          }
        }
      if (((v = f.child), f.subtreeFlags & 16384 && v !== null))
        (v.return = f), (f = v);
      else {
        if (f === d) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === d) return !0;
          f = f.return;
        }
        (f.sibling.return = f.return), (f = f.sibling);
      }
    }
    return !0;
  }
  function ql(d, f, v, x) {
    (f &= ~VT),
      (f &= ~fu),
      (d.suspendedLanes |= f),
      (d.pingedLanes &= ~f),
      x && (d.warmLanes |= f),
      (x = d.expirationTimes);
    for (var T = f; 0 < T; ) {
      var k = 31 - Ue(T),
        G = 1 << k;
      (x[k] = -1), (T &= ~G);
    }
    v !== 0 && ln(d, v, f);
  }
  function j0() {
    return (En & 6) === 0 ? (Nm(0), !1) : !0;
  }
  function YT() {
    if (tn !== null) {
      if (Sn === 0) var d = tn.return;
      else (d = tn), (Ho = ou = null), hT(d), (Pd = null), (_m = 0), (d = tn);
      for (; d !== null; ) CN(d.alternate, d), (d = d.return);
      tn = null;
    }
  }
  function Bd(d, f) {
    var v = d.timeoutHandle;
    v !== -1 && ((d.timeoutHandle = -1), HZ(v)),
      (v = d.cancelPendingCommit),
      v !== null && ((d.cancelPendingCommit = null), v()),
      YT(),
      (Fn = d),
      (tn = v = Uo(d.current, null)),
      (cn = f),
      (Sn = 0),
      (pi = null),
      (Hl = !1),
      (jd = $t(d, f)),
      (HT = !1),
      (Fd = Bi = VT = fu = Vl = us = 0),
      (qr = Pm = null),
      (zT = !1),
      (f & 8) !== 0 && (f |= f & 32);
    var x = d.entangledLanes;
    if (x !== 0)
      for (d = d.entanglements, x &= f; 0 < x; ) {
        var T = 31 - Ue(x),
          k = 1 << T;
        (f |= d[T]), (x &= ~k);
      }
    return (Xo = f), i0(), v;
  }
  function QN(d, f) {
    (Yt = null),
      (O.H = T0),
      f === gm || f === m0
        ? ((f = m2()), (Sn = 3))
        : f === d2
        ? ((f = m2()), (Sn = 4))
        : (Sn =
            f === pN
              ? 8
              : f !== null &&
                typeof f == "object" &&
                typeof f.then == "function"
              ? 6
              : 1),
      (pi = f),
      tn === null && ((us = 1), C0(d, Oi(f, d.current)));
  }
  function ZN() {
    var d = O.H;
    return (O.H = T0), d === null ? T0 : d;
  }
  function JN() {
    var d = O.A;
    return (O.A = EZ), d;
  }
  function XT() {
    (us = 4),
      Hl || ((cn & 4194048) !== cn && $i.current !== null) || (jd = !0),
      ((Vl & 134217727) === 0 && (fu & 134217727) === 0) ||
        Fn === null ||
        ql(Fn, cn, Bi, !1);
  }
  function QT(d, f, v) {
    var x = En;
    En |= 2;
    var T = ZN(),
      k = JN();
    (Fn !== d || cn !== f) && ((O0 = null), Bd(d, f)), (f = !1);
    var G = us;
    e: do
      try {
        if (Sn !== 0 && tn !== null) {
          var ee = tn,
            oe = pi;
          switch (Sn) {
            case 8:
              YT(), (G = 6);
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              $i.current === null && (f = !0);
              var Se = Sn;
              if (((Sn = 0), (pi = null), Hd(d, ee, oe, Se), v && jd)) {
                G = 0;
                break e;
              }
              break;
            default:
              (Se = Sn), (Sn = 0), (pi = null), Hd(d, ee, oe, Se);
          }
        }
        _Z(), (G = us);
        break;
      } catch (Pe) {
        QN(d, Pe);
      }
    while (!0);
    return (
      f && d.shellSuspendCounter++,
      (Ho = ou = null),
      (En = x),
      (O.H = T),
      (O.A = k),
      tn === null && ((Fn = null), (cn = 0), i0()),
      G
    );
  }
  function _Z() {
    for (; tn !== null; ) eO(tn);
  }
  function AZ(d, f) {
    var v = En;
    En |= 2;
    var x = ZN(),
      T = JN();
    Fn !== d || cn !== f
      ? ((O0 = null), (N0 = re() + 500), Bd(d, f))
      : (jd = $t(d, f));
    e: do
      try {
        if (Sn !== 0 && tn !== null) {
          f = tn;
          var k = pi;
          t: switch (Sn) {
            case 1:
              (Sn = 0), (pi = null), Hd(d, f, k, 1);
              break;
            case 2:
            case 9:
              if (h2(k)) {
                (Sn = 0), (pi = null), tO(f);
                break;
              }
              (f = function () {
                (Sn !== 2 && Sn !== 9) || Fn !== d || (Sn = 7), Ya(d);
              }),
                k.then(f, f);
              break e;
            case 3:
              Sn = 7;
              break e;
            case 4:
              Sn = 5;
              break e;
            case 7:
              h2(k)
                ? ((Sn = 0), (pi = null), tO(f))
                : ((Sn = 0), (pi = null), Hd(d, f, k, 7));
              break;
            case 5:
              var G = null;
              switch (tn.tag) {
                case 26:
                  G = tn.memoizedState;
                case 5:
                case 27:
                  var ee = tn;
                  if (!G || OO(G)) {
                    (Sn = 0), (pi = null);
                    var oe = ee.sibling;
                    if (oe !== null) tn = oe;
                    else {
                      var Se = ee.return;
                      Se !== null ? ((tn = Se), F0(Se)) : (tn = null);
                    }
                    break t;
                  }
              }
              (Sn = 0), (pi = null), Hd(d, f, k, 5);
              break;
            case 6:
              (Sn = 0), (pi = null), Hd(d, f, k, 6);
              break;
            case 8:
              YT(), (us = 6);
              break e;
            default:
              throw Error(s(462));
          }
        }
        RZ();
        break;
      } catch (Pe) {
        QN(d, Pe);
      }
    while (!0);
    return (
      (Ho = ou = null),
      (O.H = x),
      (O.A = T),
      (En = v),
      tn !== null ? 0 : ((Fn = null), (cn = 0), i0(), us)
    );
  }
  function RZ() {
    for (; tn !== null && !De(); ) eO(tn);
  }
  function eO(d) {
    var f = RN(d.alternate, d, Xo);
    (d.memoizedProps = d.pendingProps), f === null ? F0(d) : (tn = f);
  }
  function tO(d) {
    var f = d,
      v = f.alternate;
    switch (f.tag) {
      case 15:
      case 0:
        f = wN(v, f, f.pendingProps, f.type, void 0, cn);
        break;
      case 11:
        f = wN(v, f, f.pendingProps, f.type.render, f.ref, cn);
        break;
      case 5:
        hT(f);
      default:
        CN(v, f), (f = tn = n2(f, Xo)), (f = RN(v, f, Xo));
    }
    (d.memoizedProps = d.pendingProps), f === null ? F0(d) : (tn = f);
  }
  function Hd(d, f, v, x) {
    (Ho = ou = null), hT(f), (Pd = null), (_m = 0);
    var T = f.return;
    try {
      if (gZ(d, T, f, v, cn)) {
        (us = 1), C0(d, Oi(v, d.current)), (tn = null);
        return;
      }
    } catch (k) {
      if (T !== null) throw ((tn = T), k);
      (us = 1), C0(d, Oi(v, d.current)), (tn = null);
      return;
    }
    f.flags & 32768
      ? (gn || x === 1
          ? (d = !0)
          : jd || (cn & 536870912) !== 0
          ? (d = !1)
          : ((Hl = d = !0),
            (x === 2 || x === 9 || x === 3 || x === 6) &&
              ((x = $i.current),
              x !== null && x.tag === 13 && (x.flags |= 16384))),
        nO(f, d))
      : F0(f);
  }
  function F0(d) {
    var f = d;
    do {
      if ((f.flags & 32768) !== 0) {
        nO(f, Hl);
        return;
      }
      d = f.return;
      var v = yZ(f.alternate, f, Xo);
      if (v !== null) {
        tn = v;
        return;
      }
      if (((f = f.sibling), f !== null)) {
        tn = f;
        return;
      }
      tn = f = d;
    } while (f !== null);
    us === 0 && (us = 5);
  }
  function nO(d, f) {
    do {
      var v = bZ(d.alternate, d);
      if (v !== null) {
        (v.flags &= 32767), (tn = v);
        return;
      }
      if (
        ((v = d.return),
        v !== null &&
          ((v.flags |= 32768), (v.subtreeFlags = 0), (v.deletions = null)),
        !f && ((d = d.sibling), d !== null))
      ) {
        tn = d;
        return;
      }
      tn = d = v;
    } while (d !== null);
    (us = 6), (tn = null);
  }
  function sO(d, f, v, x, T, k, G, ee, oe) {
    d.cancelPendingCommit = null;
    do U0();
    while (hr !== 0);
    if ((En & 6) !== 0) throw Error(s(327));
    if (f !== null) {
      if (f === d.current) throw Error(s(177));
      if (
        ((k = f.lanes | f.childLanes),
        (k |= BS),
        Zt(d, v, k, G, ee, oe),
        d === Fn && ((tn = Fn = null), (cn = 0)),
        (Ud = f),
        (Gl = d),
        ($d = v),
        (qT = k),
        (WT = T),
        (WN = x),
        (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0
          ? ((d.callbackNode = null),
            (d.callbackPriority = 0),
            LZ(ie, function () {
              return lO(), null;
            }))
          : ((d.callbackNode = null), (d.callbackPriority = 0)),
        (x = (f.flags & 13878) !== 0),
        (f.subtreeFlags & 13878) !== 0 || x)
      ) {
        (x = O.T), (O.T = null), (T = U.p), (U.p = 2), (G = En), (En |= 4);
        try {
          xZ(d, f, v);
        } finally {
          (En = G), (U.p = T), (O.T = x);
        }
      }
      (hr = 1), rO(), iO(), aO();
    }
  }
  function rO() {
    if (hr === 1) {
      hr = 0;
      var d = Gl,
        f = Ud,
        v = (f.flags & 13878) !== 0;
      if ((f.subtreeFlags & 13878) !== 0 || v) {
        (v = O.T), (O.T = null);
        var x = U.p;
        U.p = 2;
        var T = En;
        En |= 4;
        try {
          $N(f, d);
          var k = c_,
            G = qM(d.containerInfo),
            ee = k.focusedElem,
            oe = k.selectionRange;
          if (
            G !== ee &&
            ee &&
            ee.ownerDocument &&
            GM(ee.ownerDocument.documentElement, ee)
          ) {
            if (oe !== null && OS(ee)) {
              var Se = oe.start,
                Pe = oe.end;
              if ((Pe === void 0 && (Pe = Se), "selectionStart" in ee))
                (ee.selectionStart = Se),
                  (ee.selectionEnd = Math.min(Pe, ee.value.length));
              else {
                var Fe = ee.ownerDocument || document,
                  Te = (Fe && Fe.defaultView) || window;
                if (Te.getSelection) {
                  var Ae = Te.getSelection(),
                    Ct = ee.textContent.length,
                    _t = Math.min(oe.start, Ct),
                    kn = oe.end === void 0 ? _t : Math.min(oe.end, Ct);
                  !Ae.extend && _t > kn && ((G = kn), (kn = _t), (_t = G));
                  var me = zM(ee, _t),
                    ue = zM(ee, kn);
                  if (
                    me &&
                    ue &&
                    (Ae.rangeCount !== 1 ||
                      Ae.anchorNode !== me.node ||
                      Ae.anchorOffset !== me.offset ||
                      Ae.focusNode !== ue.node ||
                      Ae.focusOffset !== ue.offset)
                  ) {
                    var xe = Fe.createRange();
                    xe.setStart(me.node, me.offset),
                      Ae.removeAllRanges(),
                      _t > kn
                        ? (Ae.addRange(xe), Ae.extend(ue.node, ue.offset))
                        : (xe.setEnd(ue.node, ue.offset), Ae.addRange(xe));
                  }
                }
              }
            }
            for (Fe = [], Ae = ee; (Ae = Ae.parentNode); )
              Ae.nodeType === 1 &&
                Fe.push({
                  element: Ae,
                  left: Ae.scrollLeft,
                  top: Ae.scrollTop,
                });
            for (
              typeof ee.focus == "function" && ee.focus(), ee = 0;
              ee < Fe.length;
              ee++
            ) {
              var Oe = Fe[ee];
              (Oe.element.scrollLeft = Oe.left),
                (Oe.element.scrollTop = Oe.top);
            }
          }
          (Q0 = !!l_), (c_ = l_ = null);
        } finally {
          (En = T), (U.p = x), (O.T = v);
        }
      }
      (d.current = f), (hr = 2);
    }
  }
  function iO() {
    if (hr === 2) {
      hr = 0;
      var d = Gl,
        f = Ud,
        v = (f.flags & 8772) !== 0;
      if ((f.subtreeFlags & 8772) !== 0 || v) {
        (v = O.T), (O.T = null);
        var x = U.p;
        U.p = 2;
        var T = En;
        En |= 4;
        try {
          ON(d, f.alternate, f);
        } finally {
          (En = T), (U.p = x), (O.T = v);
        }
      }
      hr = 3;
    }
  }
  function aO() {
    if (hr === 4 || hr === 3) {
      (hr = 0), ge();
      var d = Gl,
        f = Ud,
        v = $d,
        x = WN;
      (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0
        ? (hr = 5)
        : ((hr = 0), (Ud = Gl = null), oO(d, d.pendingLanes));
      var T = d.pendingLanes;
      if (
        (T === 0 && (zl = null),
        mt(v),
        (f = f.stateNode),
        xt && typeof xt.onCommitFiberRoot == "function")
      )
        try {
          xt.onCommitFiberRoot(ht, f, void 0, (f.current.flags & 128) === 128);
        } catch {}
      if (x !== null) {
        (f = O.T), (T = U.p), (U.p = 2), (O.T = null);
        try {
          for (var k = d.onRecoverableError, G = 0; G < x.length; G++) {
            var ee = x[G];
            k(ee.value, { componentStack: ee.stack });
          }
        } finally {
          (O.T = f), (U.p = T);
        }
      }
      ($d & 3) !== 0 && U0(),
        Ya(d),
        (T = d.pendingLanes),
        (v & 4194090) !== 0 && (T & 42) !== 0
          ? d === KT
            ? Mm++
            : ((Mm = 0), (KT = d))
          : (Mm = 0),
        Nm(0);
    }
  }
  function oO(d, f) {
    (d.pooledCacheLanes &= f) === 0 &&
      ((f = d.pooledCache), f != null && ((d.pooledCache = null), mm(f)));
  }
  function U0(d) {
    return rO(), iO(), aO(), lO();
  }
  function lO() {
    if (hr !== 5) return !1;
    var d = Gl,
      f = qT;
    qT = 0;
    var v = mt($d),
      x = O.T,
      T = U.p;
    try {
      (U.p = 32 > v ? 32 : v), (O.T = null), (v = WT), (WT = null);
      var k = Gl,
        G = $d;
      if (((hr = 0), (Ud = Gl = null), ($d = 0), (En & 6) !== 0))
        throw Error(s(331));
      var ee = En;
      if (
        ((En |= 4),
        GN(k.current),
        HN(k, k.current, G, v),
        (En = ee),
        Nm(0, !1),
        xt && typeof xt.onPostCommitFiberRoot == "function")
      )
        try {
          xt.onPostCommitFiberRoot(ht, k);
        } catch {}
      return !0;
    } finally {
      (U.p = T), (O.T = x), oO(d, f);
    }
  }
  function cO(d, f, v) {
    (f = Oi(v, f)),
      (f = AT(d.stateNode, f, 2)),
      (d = Nl(d, f, 2)),
      d !== null && (Vt(d, 2), Ya(d));
  }
  function Mn(d, f, v) {
    if (d.tag === 3) cO(d, d, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          cO(f, d, v);
          break;
        } else if (f.tag === 1) {
          var x = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof x.componentDidCatch == "function" &&
              (zl === null || !zl.has(x)))
          ) {
            (d = Oi(v, d)),
              (v = fN(2)),
              (x = Nl(f, v, 2)),
              x !== null && (mN(v, x, f, d), Vt(x, 2), Ya(x));
            break;
          }
        }
        f = f.return;
      }
  }
  function ZT(d, f, v) {
    var x = d.pingCache;
    if (x === null) {
      x = d.pingCache = new SZ();
      var T = new Set();
      x.set(f, T);
    } else (T = x.get(f)), T === void 0 && ((T = new Set()), x.set(f, T));
    T.has(v) ||
      ((HT = !0), T.add(v), (d = kZ.bind(null, d, f, v)), f.then(d, d));
  }
  function kZ(d, f, v) {
    var x = d.pingCache;
    x !== null && x.delete(f),
      (d.pingedLanes |= d.suspendedLanes & v),
      (d.warmLanes &= ~v),
      Fn === d &&
        (cn & v) === v &&
        (us === 4 || (us === 3 && (cn & 62914560) === cn && 300 > re() - GT)
          ? (En & 2) === 0 && Bd(d, 0)
          : (VT |= v),
        Fd === cn && (Fd = 0)),
      Ya(d);
  }
  function uO(d, f) {
    f === 0 && (f = Ws()), (d = Sd(d, f)), d !== null && (Vt(d, f), Ya(d));
  }
  function CZ(d) {
    var f = d.memoizedState,
      v = 0;
    f !== null && (v = f.retryLane), uO(d, v);
  }
  function IZ(d, f) {
    var v = 0;
    switch (d.tag) {
      case 13:
        var x = d.stateNode,
          T = d.memoizedState;
        T !== null && (v = T.retryLane);
        break;
      case 19:
        x = d.stateNode;
        break;
      case 22:
        x = d.stateNode._retryCache;
        break;
      default:
        throw Error(s(314));
    }
    x !== null && x.delete(f), uO(d, v);
  }
  function LZ(d, f) {
    return ve(d, f);
  }
  var $0 = null,
    Vd = null,
    JT = !1,
    B0 = !1,
    e_ = !1,
    mu = 0;
  function Ya(d) {
    d !== Vd &&
      d.next === null &&
      (Vd === null ? ($0 = Vd = d) : (Vd = Vd.next = d)),
      (B0 = !0),
      JT || ((JT = !0), PZ());
  }
  function Nm(d, f) {
    if (!e_ && B0) {
      e_ = !0;
      do
        for (var v = !1, x = $0; x !== null; ) {
          if (d !== 0) {
            var T = x.pendingLanes;
            if (T === 0) var k = 0;
            else {
              var G = x.suspendedLanes,
                ee = x.pingedLanes;
              (k = (1 << (31 - Ue(42 | d) + 1)) - 1),
                (k &= T & ~(G & ~ee)),
                (k = k & 201326741 ? (k & 201326741) | 1 : k ? k | 2 : 0);
            }
            k !== 0 && ((v = !0), mO(x, k));
          } else
            (k = cn),
              (k = Ot(
                x,
                x === Fn ? k : 0,
                x.cancelPendingCommit !== null || x.timeoutHandle !== -1
              )),
              (k & 3) === 0 || $t(x, k) || ((v = !0), mO(x, k));
          x = x.next;
        }
      while (v);
      e_ = !1;
    }
  }
  function DZ() {
    dO();
  }
  function dO() {
    B0 = JT = !1;
    var d = 0;
    mu !== 0 && (BZ() && (d = mu), (mu = 0));
    for (var f = re(), v = null, x = $0; x !== null; ) {
      var T = x.next,
        k = hO(x, f);
      k === 0
        ? ((x.next = null),
          v === null ? ($0 = T) : (v.next = T),
          T === null && (Vd = v))
        : ((v = x), (d !== 0 || (k & 3) !== 0) && (B0 = !0)),
        (x = T);
    }
    Nm(d);
  }
  function hO(d, f) {
    for (
      var v = d.suspendedLanes,
        x = d.pingedLanes,
        T = d.expirationTimes,
        k = d.pendingLanes & -62914561;
      0 < k;

    ) {
      var G = 31 - Ue(k),
        ee = 1 << G,
        oe = T[G];
      oe === -1
        ? ((ee & v) === 0 || (ee & x) !== 0) && (T[G] = wn(ee, f))
        : oe <= f && (d.expiredLanes |= ee),
        (k &= ~ee);
    }
    if (
      ((f = Fn),
      (v = cn),
      (v = Ot(
        d,
        d === f ? v : 0,
        d.cancelPendingCommit !== null || d.timeoutHandle !== -1
      )),
      (x = d.callbackNode),
      v === 0 ||
        (d === f && (Sn === 2 || Sn === 9)) ||
        d.cancelPendingCommit !== null)
    )
      return (
        x !== null && x !== null && Ee(x),
        (d.callbackNode = null),
        (d.callbackPriority = 0)
      );
    if ((v & 3) === 0 || $t(d, v)) {
      if (((f = v & -v), f === d.callbackPriority)) return f;
      switch ((x !== null && Ee(x), mt(v))) {
        case 2:
        case 8:
          v = ne;
          break;
        case 32:
          v = ie;
          break;
        case 268435456:
          v = $e;
          break;
        default:
          v = ie;
      }
      return (
        (x = fO.bind(null, d)),
        (v = ve(v, x)),
        (d.callbackPriority = f),
        (d.callbackNode = v),
        f
      );
    }
    return (
      x !== null && x !== null && Ee(x),
      (d.callbackPriority = 2),
      (d.callbackNode = null),
      2
    );
  }
  function fO(d, f) {
    if (hr !== 0 && hr !== 5)
      return (d.callbackNode = null), (d.callbackPriority = 0), null;
    var v = d.callbackNode;
    if (U0() && d.callbackNode !== v) return null;
    var x = cn;
    return (
      (x = Ot(
        d,
        d === Fn ? x : 0,
        d.cancelPendingCommit !== null || d.timeoutHandle !== -1
      )),
      x === 0
        ? null
        : (YN(d, x, f),
          hO(d, re()),
          d.callbackNode != null && d.callbackNode === v
            ? fO.bind(null, d)
            : null)
    );
  }
  function mO(d, f) {
    if (U0()) return null;
    YN(d, f, !0);
  }
  function PZ() {
    VZ(function () {
      (En & 6) !== 0 ? ve(ke, DZ) : dO();
    });
  }
  function t_() {
    return mu === 0 && (mu = Bn()), mu;
  }
  function pO(d) {
    return d == null || typeof d == "symbol" || typeof d == "boolean"
      ? null
      : typeof d == "function"
      ? d
      : Zv("" + d);
  }
  function gO(d, f) {
    var v = f.ownerDocument.createElement("input");
    return (
      (v.name = f.name),
      (v.value = f.value),
      d.id && v.setAttribute("form", d.id),
      f.parentNode.insertBefore(v, f),
      (d = new FormData(d)),
      v.parentNode.removeChild(v),
      d
    );
  }
  function MZ(d, f, v, x, T) {
    if (f === "submit" && v && v.stateNode === T) {
      var k = pO((T[Ke] || null).action),
        G = x.submitter;
      G &&
        ((f = (f = G[Ke] || null)
          ? pO(f.formAction)
          : G.getAttribute("formAction")),
        f !== null && ((k = f), (G = null)));
      var ee = new n0("action", "action", null, x, T);
      d.push({
        event: ee,
        listeners: [
          {
            instance: null,
            listener: function () {
              if (x.defaultPrevented) {
                if (mu !== 0) {
                  var oe = G ? gO(T, G) : new FormData(T);
                  wT(
                    v,
                    { pending: !0, data: oe, method: T.method, action: k },
                    null,
                    oe
                  );
                }
              } else
                typeof k == "function" &&
                  (ee.preventDefault(),
                  (oe = G ? gO(T, G) : new FormData(T)),
                  wT(
                    v,
                    { pending: !0, data: oe, method: T.method, action: k },
                    k,
                    oe
                  ));
            },
            currentTarget: T,
          },
        ],
      });
    }
  }
  for (var n_ = 0; n_ < $S.length; n_++) {
    var s_ = $S[n_],
      NZ = s_.toLowerCase(),
      OZ = s_[0].toUpperCase() + s_.slice(1);
    fa(NZ, "on" + OZ);
  }
  fa(YM, "onAnimationEnd"),
    fa(XM, "onAnimationIteration"),
    fa(QM, "onAnimationStart"),
    fa("dblclick", "onDoubleClick"),
    fa("focusin", "onFocus"),
    fa("focusout", "onBlur"),
    fa(JQ, "onTransitionRun"),
    fa(eZ, "onTransitionStart"),
    fa(tZ, "onTransitionCancel"),
    fa(ZM, "onTransitionEnd"),
    fd("onMouseEnter", ["mouseout", "mouseover"]),
    fd("onMouseLeave", ["mouseout", "mouseover"]),
    fd("onPointerEnter", ["pointerout", "pointerover"]),
    fd("onPointerLeave", ["pointerout", "pointerover"]),
    Zc(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    Zc(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    Zc("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    Zc(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    Zc(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    Zc(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var Om =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    jZ = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle"
        .split(" ")
        .concat(Om)
    );
  function vO(d, f) {
    f = (f & 4) !== 0;
    for (var v = 0; v < d.length; v++) {
      var x = d[v],
        T = x.event;
      x = x.listeners;
      e: {
        var k = void 0;
        if (f)
          for (var G = x.length - 1; 0 <= G; G--) {
            var ee = x[G],
              oe = ee.instance,
              Se = ee.currentTarget;
            if (((ee = ee.listener), oe !== k && T.isPropagationStopped()))
              break e;
            (k = ee), (T.currentTarget = Se);
            try {
              k(T);
            } catch (Pe) {
              k0(Pe);
            }
            (T.currentTarget = null), (k = oe);
          }
        else
          for (G = 0; G < x.length; G++) {
            if (
              ((ee = x[G]),
              (oe = ee.instance),
              (Se = ee.currentTarget),
              (ee = ee.listener),
              oe !== k && T.isPropagationStopped())
            )
              break e;
            (k = ee), (T.currentTarget = Se);
            try {
              k(T);
            } catch (Pe) {
              k0(Pe);
            }
            (T.currentTarget = null), (k = oe);
          }
      }
    }
  }
  function nn(d, f) {
    var v = f[St];
    v === void 0 && (v = f[St] = new Set());
    var x = d + "__bubble";
    v.has(x) || (yO(f, d, 2, !1), v.add(x));
  }
  function r_(d, f, v) {
    var x = 0;
    f && (x |= 4), yO(v, d, x, f);
  }
  var H0 = "_reactListening" + Math.random().toString(36).slice(2);
  function i_(d) {
    if (!d[H0]) {
      (d[H0] = !0),
        hd.forEach(function (v) {
          v !== "selectionchange" && (jZ.has(v) || r_(v, !1, d), r_(v, !0, d));
        });
      var f = d.nodeType === 9 ? d : d.ownerDocument;
      f === null || f[H0] || ((f[H0] = !0), r_("selectionchange", !1, f));
    }
  }
  function yO(d, f, v, x) {
    switch (HO(f)) {
      case 2:
        var T = uJ;
        break;
      case 8:
        T = dJ;
        break;
      default:
        T = b_;
    }
    (v = T.bind(null, f, v, d)),
      (T = void 0),
      !RS ||
        (f !== "touchstart" && f !== "touchmove" && f !== "wheel") ||
        (T = !0),
      x
        ? T !== void 0
          ? d.addEventListener(f, v, { capture: !0, passive: T })
          : d.addEventListener(f, v, !0)
        : T !== void 0
        ? d.addEventListener(f, v, { passive: T })
        : d.addEventListener(f, v, !1);
  }
  function a_(d, f, v, x, T) {
    var k = x;
    if ((f & 1) === 0 && (f & 2) === 0 && x !== null)
      e: for (;;) {
        if (x === null) return;
        var G = x.tag;
        if (G === 3 || G === 4) {
          var ee = x.stateNode.containerInfo;
          if (ee === T) break;
          if (G === 4)
            for (G = x.return; G !== null; ) {
              var oe = G.tag;
              if ((oe === 3 || oe === 4) && G.stateNode.containerInfo === T)
                return;
              G = G.return;
            }
          for (; ee !== null; ) {
            if (((G = Es(ee)), G === null)) return;
            if (
              ((oe = G.tag), oe === 5 || oe === 6 || oe === 26 || oe === 27)
            ) {
              x = k = G;
              continue e;
            }
            ee = ee.parentNode;
          }
        }
        x = x.return;
      }
    _M(function () {
      var Se = k,
        Pe = _S(v),
        Fe = [];
      e: {
        var Te = JM.get(d);
        if (Te !== void 0) {
          var Ae = n0,
            Ct = d;
          switch (d) {
            case "keypress":
              if (e0(v) === 0) break e;
            case "keydown":
            case "keyup":
              Ae = LQ;
              break;
            case "focusin":
              (Ct = "focus"), (Ae = LS);
              break;
            case "focusout":
              (Ct = "blur"), (Ae = LS);
              break;
            case "beforeblur":
            case "afterblur":
              Ae = LS;
              break;
            case "click":
              if (v.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Ae = kM;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Ae = bQ;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Ae = MQ;
              break;
            case YM:
            case XM:
            case QM:
              Ae = EQ;
              break;
            case ZM:
              Ae = OQ;
              break;
            case "scroll":
            case "scrollend":
              Ae = vQ;
              break;
            case "wheel":
              Ae = FQ;
              break;
            case "copy":
            case "cut":
            case "paste":
              Ae = TQ;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Ae = IM;
              break;
            case "toggle":
            case "beforetoggle":
              Ae = $Q;
          }
          var _t = (f & 4) !== 0,
            kn = !_t && (d === "scroll" || d === "scrollend"),
            me = _t ? (Te !== null ? Te + "Capture" : null) : Te;
          _t = [];
          for (var ue = Se, xe; ue !== null; ) {
            var Oe = ue;
            if (
              ((xe = Oe.stateNode),
              (Oe = Oe.tag),
              (Oe !== 5 && Oe !== 26 && Oe !== 27) ||
                xe === null ||
                me === null ||
                ((Oe = tm(ue, me)), Oe != null && _t.push(jm(ue, Oe, xe))),
              kn)
            )
              break;
            ue = ue.return;
          }
          0 < _t.length &&
            ((Te = new Ae(Te, Ct, null, v, Pe)),
            Fe.push({ event: Te, listeners: _t }));
        }
      }
      if ((f & 7) === 0) {
        e: {
          if (
            ((Te = d === "mouseover" || d === "pointerover"),
            (Ae = d === "mouseout" || d === "pointerout"),
            Te &&
              v !== TS &&
              (Ct = v.relatedTarget || v.fromElement) &&
              (Es(Ct) || Ct[ut]))
          )
            break e;
          if (
            (Ae || Te) &&
            ((Te =
              Pe.window === Pe
                ? Pe
                : (Te = Pe.ownerDocument)
                ? Te.defaultView || Te.parentWindow
                : window),
            Ae
              ? ((Ct = v.relatedTarget || v.toElement),
                (Ae = Se),
                (Ct = Ct ? Es(Ct) : null),
                Ct !== null &&
                  ((kn = i(Ct)),
                  (_t = Ct.tag),
                  Ct !== kn || (_t !== 5 && _t !== 27 && _t !== 6)) &&
                  (Ct = null))
              : ((Ae = null), (Ct = Se)),
            Ae !== Ct)
          ) {
            if (
              ((_t = kM),
              (Oe = "onMouseLeave"),
              (me = "onMouseEnter"),
              (ue = "mouse"),
              (d === "pointerout" || d === "pointerover") &&
                ((_t = IM),
                (Oe = "onPointerLeave"),
                (me = "onPointerEnter"),
                (ue = "pointer")),
              (kn = Ae == null ? Te : js(Ae)),
              (xe = Ct == null ? Te : js(Ct)),
              (Te = new _t(Oe, ue + "leave", Ae, v, Pe)),
              (Te.target = kn),
              (Te.relatedTarget = xe),
              (Oe = null),
              Es(Pe) === Se &&
                ((_t = new _t(me, ue + "enter", Ct, v, Pe)),
                (_t.target = xe),
                (_t.relatedTarget = kn),
                (Oe = _t)),
              (kn = Oe),
              Ae && Ct)
            )
              t: {
                for (_t = Ae, me = Ct, ue = 0, xe = _t; xe; xe = zd(xe)) ue++;
                for (xe = 0, Oe = me; Oe; Oe = zd(Oe)) xe++;
                for (; 0 < ue - xe; ) (_t = zd(_t)), ue--;
                for (; 0 < xe - ue; ) (me = zd(me)), xe--;
                for (; ue--; ) {
                  if (_t === me || (me !== null && _t === me.alternate))
                    break t;
                  (_t = zd(_t)), (me = zd(me));
                }
                _t = null;
              }
            else _t = null;
            Ae !== null && bO(Fe, Te, Ae, _t, !1),
              Ct !== null && kn !== null && bO(Fe, kn, Ct, _t, !0);
          }
        }
        e: {
          if (
            ((Te = Se ? js(Se) : window),
            (Ae = Te.nodeName && Te.nodeName.toLowerCase()),
            Ae === "select" || (Ae === "input" && Te.type === "file"))
          )
            var dt = FM;
          else if (OM(Te))
            if (UM) dt = XQ;
            else {
              dt = KQ;
              var Jt = WQ;
            }
          else
            (Ae = Te.nodeName),
              !Ae ||
              Ae.toLowerCase() !== "input" ||
              (Te.type !== "checkbox" && Te.type !== "radio")
                ? Se && SS(Se.elementType) && (dt = FM)
                : (dt = YQ);
          if (dt && (dt = dt(d, Se))) {
            jM(Fe, dt, v, Pe);
            break e;
          }
          Jt && Jt(d, Te, Se),
            d === "focusout" &&
              Se &&
              Te.type === "number" &&
              Se.memoizedProps.value != null &&
              ES(Te, "number", Te.value);
        }
        switch (((Jt = Se ? js(Se) : window), d)) {
          case "focusin":
            (OM(Jt) || Jt.contentEditable === "true") &&
              ((xd = Jt), (jS = Se), (cm = null));
            break;
          case "focusout":
            cm = jS = xd = null;
            break;
          case "mousedown":
            FS = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (FS = !1), WM(Fe, v, Pe);
            break;
          case "selectionchange":
            if (ZQ) break;
          case "keydown":
          case "keyup":
            WM(Fe, v, Pe);
        }
        var wt;
        if (PS)
          e: {
            switch (d) {
              case "compositionstart":
                var Rt = "onCompositionStart";
                break e;
              case "compositionend":
                Rt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Rt = "onCompositionUpdate";
                break e;
            }
            Rt = void 0;
          }
        else
          bd
            ? MM(d, v) && (Rt = "onCompositionEnd")
            : d === "keydown" &&
              v.keyCode === 229 &&
              (Rt = "onCompositionStart");
        Rt &&
          (LM &&
            v.locale !== "ko" &&
            (bd || Rt !== "onCompositionStart"
              ? Rt === "onCompositionEnd" && bd && (wt = AM())
              : ((Ll = Pe),
                (kS = "value" in Ll ? Ll.value : Ll.textContent),
                (bd = !0))),
          (Jt = V0(Se, Rt)),
          0 < Jt.length &&
            ((Rt = new CM(Rt, d, null, v, Pe)),
            Fe.push({ event: Rt, listeners: Jt }),
            wt
              ? (Rt.data = wt)
              : ((wt = NM(v)), wt !== null && (Rt.data = wt)))),
          (wt = HQ ? VQ(d, v) : zQ(d, v)) &&
            ((Rt = V0(Se, "onBeforeInput")),
            0 < Rt.length &&
              ((Jt = new CM("onBeforeInput", "beforeinput", null, v, Pe)),
              Fe.push({ event: Jt, listeners: Rt }),
              (Jt.data = wt))),
          MZ(Fe, d, Se, v, Pe);
      }
      vO(Fe, f);
    });
  }
  function jm(d, f, v) {
    return { instance: d, listener: f, currentTarget: v };
  }
  function V0(d, f) {
    for (var v = f + "Capture", x = []; d !== null; ) {
      var T = d,
        k = T.stateNode;
      if (
        ((T = T.tag),
        (T !== 5 && T !== 26 && T !== 27) ||
          k === null ||
          ((T = tm(d, v)),
          T != null && x.unshift(jm(d, T, k)),
          (T = tm(d, f)),
          T != null && x.push(jm(d, T, k))),
        d.tag === 3)
      )
        return x;
      d = d.return;
    }
    return [];
  }
  function zd(d) {
    if (d === null) return null;
    do d = d.return;
    while (d && d.tag !== 5 && d.tag !== 27);
    return d || null;
  }
  function bO(d, f, v, x, T) {
    for (var k = f._reactName, G = []; v !== null && v !== x; ) {
      var ee = v,
        oe = ee.alternate,
        Se = ee.stateNode;
      if (((ee = ee.tag), oe !== null && oe === x)) break;
      (ee !== 5 && ee !== 26 && ee !== 27) ||
        Se === null ||
        ((oe = Se),
        T
          ? ((Se = tm(v, k)), Se != null && G.unshift(jm(v, Se, oe)))
          : T || ((Se = tm(v, k)), Se != null && G.push(jm(v, Se, oe)))),
        (v = v.return);
    }
    G.length !== 0 && d.push({ event: f, listeners: G });
  }
  var FZ = /\r\n?/g,
    UZ = /\u0000|\uFFFD/g;
  function xO(d) {
    return (typeof d == "string" ? d : "" + d)
      .replace(
        FZ,
        `
`
      )
      .replace(UZ, "");
  }
  function wO(d, f) {
    return (f = xO(f)), xO(d) === f;
  }
  function z0() {}
  function Rn(d, f, v, x, T, k) {
    switch (v) {
      case "children":
        typeof x == "string"
          ? f === "body" || (f === "textarea" && x === "") || gd(d, x)
          : (typeof x == "number" || typeof x == "bigint") &&
            f !== "body" &&
            gd(d, "" + x);
        break;
      case "className":
        Yv(d, "class", x);
        break;
      case "tabIndex":
        Yv(d, "tabindex", x);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Yv(d, v, x);
        break;
      case "style":
        SM(d, x, k);
        break;
      case "data":
        if (f !== "object") {
          Yv(d, "data", x);
          break;
        }
      case "src":
      case "href":
        if (x === "" && (f !== "a" || v !== "href")) {
          d.removeAttribute(v);
          break;
        }
        if (
          x == null ||
          typeof x == "function" ||
          typeof x == "symbol" ||
          typeof x == "boolean"
        ) {
          d.removeAttribute(v);
          break;
        }
        (x = Zv("" + x)), d.setAttribute(v, x);
        break;
      case "action":
      case "formAction":
        if (typeof x == "function") {
          d.setAttribute(
            v,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof k == "function" &&
            (v === "formAction"
              ? (f !== "input" && Rn(d, f, "name", T.name, T, null),
                Rn(d, f, "formEncType", T.formEncType, T, null),
                Rn(d, f, "formMethod", T.formMethod, T, null),
                Rn(d, f, "formTarget", T.formTarget, T, null))
              : (Rn(d, f, "encType", T.encType, T, null),
                Rn(d, f, "method", T.method, T, null),
                Rn(d, f, "target", T.target, T, null)));
        if (x == null || typeof x == "symbol" || typeof x == "boolean") {
          d.removeAttribute(v);
          break;
        }
        (x = Zv("" + x)), d.setAttribute(v, x);
        break;
      case "onClick":
        x != null && (d.onclick = z0);
        break;
      case "onScroll":
        x != null && nn("scroll", d);
        break;
      case "onScrollEnd":
        x != null && nn("scrollend", d);
        break;
      case "dangerouslySetInnerHTML":
        if (x != null) {
          if (typeof x != "object" || !("__html" in x)) throw Error(s(61));
          if (((v = x.__html), v != null)) {
            if (T.children != null) throw Error(s(60));
            d.innerHTML = v;
          }
        }
        break;
      case "multiple":
        d.multiple = x && typeof x != "function" && typeof x != "symbol";
        break;
      case "muted":
        d.muted = x && typeof x != "function" && typeof x != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (
          x == null ||
          typeof x == "function" ||
          typeof x == "boolean" ||
          typeof x == "symbol"
        ) {
          d.removeAttribute("xlink:href");
          break;
        }
        (v = Zv("" + x)),
          d.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", v);
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        x != null && typeof x != "function" && typeof x != "symbol"
          ? d.setAttribute(v, "" + x)
          : d.removeAttribute(v);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        x && typeof x != "function" && typeof x != "symbol"
          ? d.setAttribute(v, "")
          : d.removeAttribute(v);
        break;
      case "capture":
      case "download":
        x === !0
          ? d.setAttribute(v, "")
          : x !== !1 &&
            x != null &&
            typeof x != "function" &&
            typeof x != "symbol"
          ? d.setAttribute(v, x)
          : d.removeAttribute(v);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        x != null &&
        typeof x != "function" &&
        typeof x != "symbol" &&
        !isNaN(x) &&
        1 <= x
          ? d.setAttribute(v, x)
          : d.removeAttribute(v);
        break;
      case "rowSpan":
      case "start":
        x == null || typeof x == "function" || typeof x == "symbol" || isNaN(x)
          ? d.removeAttribute(v)
          : d.setAttribute(v, x);
        break;
      case "popover":
        nn("beforetoggle", d), nn("toggle", d), Kv(d, "popover", x);
        break;
      case "xlinkActuate":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:actuate", x);
        break;
      case "xlinkArcrole":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:arcrole", x);
        break;
      case "xlinkRole":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:role", x);
        break;
      case "xlinkShow":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:show", x);
        break;
      case "xlinkTitle":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:title", x);
        break;
      case "xlinkType":
        jo(d, "http://www.w3.org/1999/xlink", "xlink:type", x);
        break;
      case "xmlBase":
        jo(d, "http://www.w3.org/XML/1998/namespace", "xml:base", x);
        break;
      case "xmlLang":
        jo(d, "http://www.w3.org/XML/1998/namespace", "xml:lang", x);
        break;
      case "xmlSpace":
        jo(d, "http://www.w3.org/XML/1998/namespace", "xml:space", x);
        break;
      case "is":
        Kv(d, "is", x);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < v.length) ||
          (v[0] !== "o" && v[0] !== "O") ||
          (v[1] !== "n" && v[1] !== "N")) &&
          ((v = pQ.get(v) || v), Kv(d, v, x));
    }
  }
  function o_(d, f, v, x, T, k) {
    switch (v) {
      case "style":
        SM(d, x, k);
        break;
      case "dangerouslySetInnerHTML":
        if (x != null) {
          if (typeof x != "object" || !("__html" in x)) throw Error(s(61));
          if (((v = x.__html), v != null)) {
            if (T.children != null) throw Error(s(60));
            d.innerHTML = v;
          }
        }
        break;
      case "children":
        typeof x == "string"
          ? gd(d, x)
          : (typeof x == "number" || typeof x == "bigint") && gd(d, "" + x);
        break;
      case "onScroll":
        x != null && nn("scroll", d);
        break;
      case "onScrollEnd":
        x != null && nn("scrollend", d);
        break;
      case "onClick":
        x != null && (d.onclick = z0);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!em.hasOwnProperty(v))
          e: {
            if (
              v[0] === "o" &&
              v[1] === "n" &&
              ((T = v.endsWith("Capture")),
              (f = v.slice(2, T ? v.length - 7 : void 0)),
              (k = d[Ke] || null),
              (k = k != null ? k[v] : null),
              typeof k == "function" && d.removeEventListener(f, k, T),
              typeof x == "function")
            ) {
              typeof k != "function" &&
                k !== null &&
                (v in d
                  ? (d[v] = null)
                  : d.hasAttribute(v) && d.removeAttribute(v)),
                d.addEventListener(f, x, T);
              break e;
            }
            v in d
              ? (d[v] = x)
              : x === !0
              ? d.setAttribute(v, "")
              : Kv(d, v, x);
          }
    }
  }
  function fr(d, f, v) {
    switch (f) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        nn("error", d), nn("load", d);
        var x = !1,
          T = !1,
          k;
        for (k in v)
          if (v.hasOwnProperty(k)) {
            var G = v[k];
            if (G != null)
              switch (k) {
                case "src":
                  x = !0;
                  break;
                case "srcSet":
                  T = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(s(137, f));
                default:
                  Rn(d, f, k, G, v, null);
              }
          }
        T && Rn(d, f, "srcSet", v.srcSet, v, null),
          x && Rn(d, f, "src", v.src, v, null);
        return;
      case "input":
        nn("invalid", d);
        var ee = (k = G = T = null),
          oe = null,
          Se = null;
        for (x in v)
          if (v.hasOwnProperty(x)) {
            var Pe = v[x];
            if (Pe != null)
              switch (x) {
                case "name":
                  T = Pe;
                  break;
                case "type":
                  G = Pe;
                  break;
                case "checked":
                  oe = Pe;
                  break;
                case "defaultChecked":
                  Se = Pe;
                  break;
                case "value":
                  k = Pe;
                  break;
                case "defaultValue":
                  ee = Pe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Pe != null) throw Error(s(137, f));
                  break;
                default:
                  Rn(d, f, x, Pe, v, null);
              }
          }
        bM(d, k, ee, oe, Se, G, T, !1), Xv(d);
        return;
      case "select":
        nn("invalid", d), (x = G = k = null);
        for (T in v)
          if (v.hasOwnProperty(T) && ((ee = v[T]), ee != null))
            switch (T) {
              case "value":
                k = ee;
                break;
              case "defaultValue":
                G = ee;
                break;
              case "multiple":
                x = ee;
              default:
                Rn(d, f, T, ee, v, null);
            }
        (f = k),
          (v = G),
          (d.multiple = !!x),
          f != null ? pd(d, !!x, f, !1) : v != null && pd(d, !!x, v, !0);
        return;
      case "textarea":
        nn("invalid", d), (k = T = x = null);
        for (G in v)
          if (v.hasOwnProperty(G) && ((ee = v[G]), ee != null))
            switch (G) {
              case "value":
                x = ee;
                break;
              case "defaultValue":
                T = ee;
                break;
              case "children":
                k = ee;
                break;
              case "dangerouslySetInnerHTML":
                if (ee != null) throw Error(s(91));
                break;
              default:
                Rn(d, f, G, ee, v, null);
            }
        wM(d, x, T, k), Xv(d);
        return;
      case "option":
        for (oe in v)
          if (v.hasOwnProperty(oe) && ((x = v[oe]), x != null))
            switch (oe) {
              case "selected":
                d.selected =
                  x && typeof x != "function" && typeof x != "symbol";
                break;
              default:
                Rn(d, f, oe, x, v, null);
            }
        return;
      case "dialog":
        nn("beforetoggle", d), nn("toggle", d), nn("cancel", d), nn("close", d);
        break;
      case "iframe":
      case "object":
        nn("load", d);
        break;
      case "video":
      case "audio":
        for (x = 0; x < Om.length; x++) nn(Om[x], d);
        break;
      case "image":
        nn("error", d), nn("load", d);
        break;
      case "details":
        nn("toggle", d);
        break;
      case "embed":
      case "source":
      case "link":
        nn("error", d), nn("load", d);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Se in v)
          if (v.hasOwnProperty(Se) && ((x = v[Se]), x != null))
            switch (Se) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(s(137, f));
              default:
                Rn(d, f, Se, x, v, null);
            }
        return;
      default:
        if (SS(f)) {
          for (Pe in v)
            v.hasOwnProperty(Pe) &&
              ((x = v[Pe]), x !== void 0 && o_(d, f, Pe, x, v, void 0));
          return;
        }
    }
    for (ee in v)
      v.hasOwnProperty(ee) &&
        ((x = v[ee]), x != null && Rn(d, f, ee, x, v, null));
  }
  function $Z(d, f, v, x) {
    switch (f) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var T = null,
          k = null,
          G = null,
          ee = null,
          oe = null,
          Se = null,
          Pe = null;
        for (Ae in v) {
          var Fe = v[Ae];
          if (v.hasOwnProperty(Ae) && Fe != null)
            switch (Ae) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                oe = Fe;
              default:
                x.hasOwnProperty(Ae) || Rn(d, f, Ae, null, x, Fe);
            }
        }
        for (var Te in x) {
          var Ae = x[Te];
          if (
            ((Fe = v[Te]), x.hasOwnProperty(Te) && (Ae != null || Fe != null))
          )
            switch (Te) {
              case "type":
                k = Ae;
                break;
              case "name":
                T = Ae;
                break;
              case "checked":
                Se = Ae;
                break;
              case "defaultChecked":
                Pe = Ae;
                break;
              case "value":
                G = Ae;
                break;
              case "defaultValue":
                ee = Ae;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Ae != null) throw Error(s(137, f));
                break;
              default:
                Ae !== Fe && Rn(d, f, Te, Ae, x, Fe);
            }
        }
        wS(d, G, ee, oe, Se, Pe, k, T);
        return;
      case "select":
        Ae = G = ee = Te = null;
        for (k in v)
          if (((oe = v[k]), v.hasOwnProperty(k) && oe != null))
            switch (k) {
              case "value":
                break;
              case "multiple":
                Ae = oe;
              default:
                x.hasOwnProperty(k) || Rn(d, f, k, null, x, oe);
            }
        for (T in x)
          if (
            ((k = x[T]),
            (oe = v[T]),
            x.hasOwnProperty(T) && (k != null || oe != null))
          )
            switch (T) {
              case "value":
                Te = k;
                break;
              case "defaultValue":
                ee = k;
                break;
              case "multiple":
                G = k;
              default:
                k !== oe && Rn(d, f, T, k, x, oe);
            }
        (f = ee),
          (v = G),
          (x = Ae),
          Te != null
            ? pd(d, !!v, Te, !1)
            : !!x != !!v &&
              (f != null ? pd(d, !!v, f, !0) : pd(d, !!v, v ? [] : "", !1));
        return;
      case "textarea":
        Ae = Te = null;
        for (ee in v)
          if (
            ((T = v[ee]),
            v.hasOwnProperty(ee) && T != null && !x.hasOwnProperty(ee))
          )
            switch (ee) {
              case "value":
                break;
              case "children":
                break;
              default:
                Rn(d, f, ee, null, x, T);
            }
        for (G in x)
          if (
            ((T = x[G]),
            (k = v[G]),
            x.hasOwnProperty(G) && (T != null || k != null))
          )
            switch (G) {
              case "value":
                Te = T;
                break;
              case "defaultValue":
                Ae = T;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (T != null) throw Error(s(91));
                break;
              default:
                T !== k && Rn(d, f, G, T, x, k);
            }
        xM(d, Te, Ae);
        return;
      case "option":
        for (var Ct in v)
          if (
            ((Te = v[Ct]),
            v.hasOwnProperty(Ct) && Te != null && !x.hasOwnProperty(Ct))
          )
            switch (Ct) {
              case "selected":
                d.selected = !1;
                break;
              default:
                Rn(d, f, Ct, null, x, Te);
            }
        for (oe in x)
          if (
            ((Te = x[oe]),
            (Ae = v[oe]),
            x.hasOwnProperty(oe) && Te !== Ae && (Te != null || Ae != null))
          )
            switch (oe) {
              case "selected":
                d.selected =
                  Te && typeof Te != "function" && typeof Te != "symbol";
                break;
              default:
                Rn(d, f, oe, Te, x, Ae);
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var _t in v)
          (Te = v[_t]),
            v.hasOwnProperty(_t) &&
              Te != null &&
              !x.hasOwnProperty(_t) &&
              Rn(d, f, _t, null, x, Te);
        for (Se in x)
          if (
            ((Te = x[Se]),
            (Ae = v[Se]),
            x.hasOwnProperty(Se) && Te !== Ae && (Te != null || Ae != null))
          )
            switch (Se) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Te != null) throw Error(s(137, f));
                break;
              default:
                Rn(d, f, Se, Te, x, Ae);
            }
        return;
      default:
        if (SS(f)) {
          for (var kn in v)
            (Te = v[kn]),
              v.hasOwnProperty(kn) &&
                Te !== void 0 &&
                !x.hasOwnProperty(kn) &&
                o_(d, f, kn, void 0, x, Te);
          for (Pe in x)
            (Te = x[Pe]),
              (Ae = v[Pe]),
              !x.hasOwnProperty(Pe) ||
                Te === Ae ||
                (Te === void 0 && Ae === void 0) ||
                o_(d, f, Pe, Te, x, Ae);
          return;
        }
    }
    for (var me in v)
      (Te = v[me]),
        v.hasOwnProperty(me) &&
          Te != null &&
          !x.hasOwnProperty(me) &&
          Rn(d, f, me, null, x, Te);
    for (Fe in x)
      (Te = x[Fe]),
        (Ae = v[Fe]),
        !x.hasOwnProperty(Fe) ||
          Te === Ae ||
          (Te == null && Ae == null) ||
          Rn(d, f, Fe, Te, x, Ae);
  }
  var l_ = null,
    c_ = null;
  function G0(d) {
    return d.nodeType === 9 ? d : d.ownerDocument;
  }
  function EO(d) {
    switch (d) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function SO(d, f) {
    if (d === 0)
      switch (f) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return d === 1 && f === "foreignObject" ? 0 : d;
  }
  function u_(d, f) {
    return (
      d === "textarea" ||
      d === "noscript" ||
      typeof f.children == "string" ||
      typeof f.children == "number" ||
      typeof f.children == "bigint" ||
      (typeof f.dangerouslySetInnerHTML == "object" &&
        f.dangerouslySetInnerHTML !== null &&
        f.dangerouslySetInnerHTML.__html != null)
    );
  }
  var d_ = null;
  function BZ() {
    var d = window.event;
    return d && d.type === "popstate"
      ? d === d_
        ? !1
        : ((d_ = d), !0)
      : ((d_ = null), !1);
  }
  var TO = typeof setTimeout == "function" ? setTimeout : void 0,
    HZ = typeof clearTimeout == "function" ? clearTimeout : void 0,
    _O = typeof Promise == "function" ? Promise : void 0,
    VZ =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof _O < "u"
        ? function (d) {
            return _O.resolve(null).then(d).catch(zZ);
          }
        : TO;
  function zZ(d) {
    setTimeout(function () {
      throw d;
    });
  }
  function Wl(d) {
    return d === "head";
  }
  function AO(d, f) {
    var v = f,
      x = 0,
      T = 0;
    do {
      var k = v.nextSibling;
      if ((d.removeChild(v), k && k.nodeType === 8))
        if (((v = k.data), v === "/$")) {
          if (0 < x && 8 > x) {
            v = x;
            var G = d.ownerDocument;
            if ((v & 1 && Fm(G.documentElement), v & 2 && Fm(G.body), v & 4))
              for (v = G.head, Fm(v), G = v.firstChild; G; ) {
                var ee = G.nextSibling,
                  oe = G.nodeName;
                G[_n] ||
                  oe === "SCRIPT" ||
                  oe === "STYLE" ||
                  (oe === "LINK" && G.rel.toLowerCase() === "stylesheet") ||
                  v.removeChild(G),
                  (G = ee);
              }
          }
          if (T === 0) {
            d.removeChild(k), qm(f);
            return;
          }
          T--;
        } else
          v === "$" || v === "$?" || v === "$!"
            ? T++
            : (x = v.charCodeAt(0) - 48);
      else x = 0;
      v = k;
    } while (v);
    qm(f);
  }
  function h_(d) {
    var f = d.firstChild;
    for (f && f.nodeType === 10 && (f = f.nextSibling); f; ) {
      var v = f;
      switch (((f = f.nextSibling), v.nodeName)) {
        case "HTML":
        case "HEAD":
        case "BODY":
          h_(v), ws(v);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (v.rel.toLowerCase() === "stylesheet") continue;
      }
      d.removeChild(v);
    }
  }
  function GZ(d, f, v, x) {
    for (; d.nodeType === 1; ) {
      var T = v;
      if (d.nodeName.toLowerCase() !== f.toLowerCase()) {
        if (!x && (d.nodeName !== "INPUT" || d.type !== "hidden")) break;
      } else if (x) {
        if (!d[_n])
          switch (f) {
            case "meta":
              if (!d.hasAttribute("itemprop")) break;
              return d;
            case "link":
              if (
                ((k = d.getAttribute("rel")),
                k === "stylesheet" && d.hasAttribute("data-precedence"))
              )
                break;
              if (
                k !== T.rel ||
                d.getAttribute("href") !==
                  (T.href == null || T.href === "" ? null : T.href) ||
                d.getAttribute("crossorigin") !==
                  (T.crossOrigin == null ? null : T.crossOrigin) ||
                d.getAttribute("title") !== (T.title == null ? null : T.title)
              )
                break;
              return d;
            case "style":
              if (d.hasAttribute("data-precedence")) break;
              return d;
            case "script":
              if (
                ((k = d.getAttribute("src")),
                (k !== (T.src == null ? null : T.src) ||
                  d.getAttribute("type") !== (T.type == null ? null : T.type) ||
                  d.getAttribute("crossorigin") !==
                    (T.crossOrigin == null ? null : T.crossOrigin)) &&
                  k &&
                  d.hasAttribute("async") &&
                  !d.hasAttribute("itemprop"))
              )
                break;
              return d;
            default:
              return d;
          }
      } else if (f === "input" && d.type === "hidden") {
        var k = T.name == null ? null : "" + T.name;
        if (T.type === "hidden" && d.getAttribute("name") === k) return d;
      } else return d;
      if (((d = pa(d.nextSibling)), d === null)) break;
    }
    return null;
  }
  function qZ(d, f, v) {
    if (f === "") return null;
    for (; d.nodeType !== 3; )
      if (
        ((d.nodeType !== 1 || d.nodeName !== "INPUT" || d.type !== "hidden") &&
          !v) ||
        ((d = pa(d.nextSibling)), d === null)
      )
        return null;
    return d;
  }
  function f_(d) {
    return (
      d.data === "$!" ||
      (d.data === "$?" && d.ownerDocument.readyState === "complete")
    );
  }
  function WZ(d, f) {
    var v = d.ownerDocument;
    if (d.data !== "$?" || v.readyState === "complete") f();
    else {
      var x = function () {
        f(), v.removeEventListener("DOMContentLoaded", x);
      };
      v.addEventListener("DOMContentLoaded", x), (d._reactRetry = x);
    }
  }
  function pa(d) {
    for (; d != null; d = d.nextSibling) {
      var f = d.nodeType;
      if (f === 1 || f === 3) break;
      if (f === 8) {
        if (
          ((f = d.data),
          f === "$" || f === "$!" || f === "$?" || f === "F!" || f === "F")
        )
          break;
        if (f === "/$") return null;
      }
    }
    return d;
  }
  var m_ = null;
  function RO(d) {
    d = d.previousSibling;
    for (var f = 0; d; ) {
      if (d.nodeType === 8) {
        var v = d.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (f === 0) return d;
          f--;
        } else v === "/$" && f++;
      }
      d = d.previousSibling;
    }
    return null;
  }
  function kO(d, f, v) {
    switch (((f = G0(v)), d)) {
      case "html":
        if (((d = f.documentElement), !d)) throw Error(s(452));
        return d;
      case "head":
        if (((d = f.head), !d)) throw Error(s(453));
        return d;
      case "body":
        if (((d = f.body), !d)) throw Error(s(454));
        return d;
      default:
        throw Error(s(451));
    }
  }
  function Fm(d) {
    for (var f = d.attributes; f.length; ) d.removeAttributeNode(f[0]);
    ws(d);
  }
  var Hi = new Map(),
    CO = new Set();
  function q0(d) {
    return typeof d.getRootNode == "function"
      ? d.getRootNode()
      : d.nodeType === 9
      ? d
      : d.ownerDocument;
  }
  var Qo = U.d;
  U.d = { f: KZ, r: YZ, D: XZ, C: QZ, L: ZZ, m: JZ, X: tJ, S: eJ, M: nJ };
  function KZ() {
    var d = Qo.f(),
      f = j0();
    return d || f;
  }
  function YZ(d) {
    var f = ur(d);
    f !== null && f.tag === 5 && f.type === "form" ? Y2(f) : Qo.r(d);
  }
  var Gd = typeof document > "u" ? null : document;
  function IO(d, f, v) {
    var x = Gd;
    if (x && typeof f == "string" && f) {
      var T = Ni(f);
      (T = 'link[rel="' + d + '"][href="' + T + '"]'),
        typeof v == "string" && (T += '[crossorigin="' + v + '"]'),
        CO.has(T) ||
          (CO.add(T),
          (d = { rel: d, crossOrigin: v, href: f }),
          x.querySelector(T) === null &&
            ((f = x.createElement("link")),
            fr(f, "link", d),
            ls(f),
            x.head.appendChild(f)));
    }
  }
  function XZ(d) {
    Qo.D(d), IO("dns-prefetch", d, null);
  }
  function QZ(d, f) {
    Qo.C(d, f), IO("preconnect", d, f);
  }
  function ZZ(d, f, v) {
    Qo.L(d, f, v);
    var x = Gd;
    if (x && d && f) {
      var T = 'link[rel="preload"][as="' + Ni(f) + '"]';
      f === "image" && v && v.imageSrcSet
        ? ((T += '[imagesrcset="' + Ni(v.imageSrcSet) + '"]'),
          typeof v.imageSizes == "string" &&
            (T += '[imagesizes="' + Ni(v.imageSizes) + '"]'))
        : (T += '[href="' + Ni(d) + '"]');
      var k = T;
      switch (f) {
        case "style":
          k = qd(d);
          break;
        case "script":
          k = Wd(d);
      }
      Hi.has(k) ||
        ((d = h(
          {
            rel: "preload",
            href: f === "image" && v && v.imageSrcSet ? void 0 : d,
            as: f,
          },
          v
        )),
        Hi.set(k, d),
        x.querySelector(T) !== null ||
          (f === "style" && x.querySelector(Um(k))) ||
          (f === "script" && x.querySelector($m(k))) ||
          ((f = x.createElement("link")),
          fr(f, "link", d),
          ls(f),
          x.head.appendChild(f)));
    }
  }
  function JZ(d, f) {
    Qo.m(d, f);
    var v = Gd;
    if (v && d) {
      var x = f && typeof f.as == "string" ? f.as : "script",
        T =
          'link[rel="modulepreload"][as="' + Ni(x) + '"][href="' + Ni(d) + '"]',
        k = T;
      switch (x) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          k = Wd(d);
      }
      if (
        !Hi.has(k) &&
        ((d = h({ rel: "modulepreload", href: d }, f)),
        Hi.set(k, d),
        v.querySelector(T) === null)
      ) {
        switch (x) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (v.querySelector($m(k))) return;
        }
        (x = v.createElement("link")),
          fr(x, "link", d),
          ls(x),
          v.head.appendChild(x);
      }
    }
  }
  function eJ(d, f, v) {
    Qo.S(d, f, v);
    var x = Gd;
    if (x && d) {
      var T = Fs(x).hoistableStyles,
        k = qd(d);
      f = f || "default";
      var G = T.get(k);
      if (!G) {
        var ee = { loading: 0, preload: null };
        if ((G = x.querySelector(Um(k)))) ee.loading = 5;
        else {
          (d = h({ rel: "stylesheet", href: d, "data-precedence": f }, v)),
            (v = Hi.get(k)) && p_(d, v);
          var oe = (G = x.createElement("link"));
          ls(oe),
            fr(oe, "link", d),
            (oe._p = new Promise(function (Se, Pe) {
              (oe.onload = Se), (oe.onerror = Pe);
            })),
            oe.addEventListener("load", function () {
              ee.loading |= 1;
            }),
            oe.addEventListener("error", function () {
              ee.loading |= 2;
            }),
            (ee.loading |= 4),
            W0(G, f, x);
        }
        (G = { type: "stylesheet", instance: G, count: 1, state: ee }),
          T.set(k, G);
      }
    }
  }
  function tJ(d, f) {
    Qo.X(d, f);
    var v = Gd;
    if (v && d) {
      var x = Fs(v).hoistableScripts,
        T = Wd(d),
        k = x.get(T);
      k ||
        ((k = v.querySelector($m(T))),
        k ||
          ((d = h({ src: d, async: !0 }, f)),
          (f = Hi.get(T)) && g_(d, f),
          (k = v.createElement("script")),
          ls(k),
          fr(k, "link", d),
          v.head.appendChild(k)),
        (k = { type: "script", instance: k, count: 1, state: null }),
        x.set(T, k));
    }
  }
  function nJ(d, f) {
    Qo.M(d, f);
    var v = Gd;
    if (v && d) {
      var x = Fs(v).hoistableScripts,
        T = Wd(d),
        k = x.get(T);
      k ||
        ((k = v.querySelector($m(T))),
        k ||
          ((d = h({ src: d, async: !0, type: "module" }, f)),
          (f = Hi.get(T)) && g_(d, f),
          (k = v.createElement("script")),
          ls(k),
          fr(k, "link", d),
          v.head.appendChild(k)),
        (k = { type: "script", instance: k, count: 1, state: null }),
        x.set(T, k));
    }
  }
  function LO(d, f, v, x) {
    var T = (T = Z.current) ? q0(T) : null;
    if (!T) throw Error(s(446));
    switch (d) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof v.precedence == "string" && typeof v.href == "string"
          ? ((f = qd(v.href)),
            (v = Fs(T).hoistableStyles),
            (x = v.get(f)),
            x ||
              ((x = { type: "style", instance: null, count: 0, state: null }),
              v.set(f, x)),
            x)
          : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (
          v.rel === "stylesheet" &&
          typeof v.href == "string" &&
          typeof v.precedence == "string"
        ) {
          d = qd(v.href);
          var k = Fs(T).hoistableStyles,
            G = k.get(d);
          if (
            (G ||
              ((T = T.ownerDocument || T),
              (G = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null },
              }),
              k.set(d, G),
              (k = T.querySelector(Um(d))) &&
                !k._p &&
                ((G.instance = k), (G.state.loading = 5)),
              Hi.has(d) ||
                ((v = {
                  rel: "preload",
                  as: "style",
                  href: v.href,
                  crossOrigin: v.crossOrigin,
                  integrity: v.integrity,
                  media: v.media,
                  hrefLang: v.hrefLang,
                  referrerPolicy: v.referrerPolicy,
                }),
                Hi.set(d, v),
                k || sJ(T, d, v, G.state))),
            f && x === null)
          )
            throw Error(s(528, ""));
          return G;
        }
        if (f && x !== null) throw Error(s(529, ""));
        return null;
      case "script":
        return (
          (f = v.async),
          (v = v.src),
          typeof v == "string" &&
          f &&
          typeof f != "function" &&
          typeof f != "symbol"
            ? ((f = Wd(v)),
              (v = Fs(T).hoistableScripts),
              (x = v.get(f)),
              x ||
                ((x = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null,
                }),
                v.set(f, x)),
              x)
            : { type: "void", instance: null, count: 0, state: null }
        );
      default:
        throw Error(s(444, d));
    }
  }
  function qd(d) {
    return 'href="' + Ni(d) + '"';
  }
  function Um(d) {
    return 'link[rel="stylesheet"][' + d + "]";
  }
  function DO(d) {
    return h({}, d, { "data-precedence": d.precedence, precedence: null });
  }
  function sJ(d, f, v, x) {
    d.querySelector('link[rel="preload"][as="style"][' + f + "]")
      ? (x.loading = 1)
      : ((f = d.createElement("link")),
        (x.preload = f),
        f.addEventListener("load", function () {
          return (x.loading |= 1);
        }),
        f.addEventListener("error", function () {
          return (x.loading |= 2);
        }),
        fr(f, "link", v),
        ls(f),
        d.head.appendChild(f));
  }
  function Wd(d) {
    return '[src="' + Ni(d) + '"]';
  }
  function $m(d) {
    return "script[async]" + d;
  }
  function PO(d, f, v) {
    if ((f.count++, f.instance === null))
      switch (f.type) {
        case "style":
          var x = d.querySelector('style[data-href~="' + Ni(v.href) + '"]');
          if (x) return (f.instance = x), ls(x), x;
          var T = h({}, v, {
            "data-href": v.href,
            "data-precedence": v.precedence,
            href: null,
            precedence: null,
          });
          return (
            (x = (d.ownerDocument || d).createElement("style")),
            ls(x),
            fr(x, "style", T),
            W0(x, v.precedence, d),
            (f.instance = x)
          );
        case "stylesheet":
          T = qd(v.href);
          var k = d.querySelector(Um(T));
          if (k) return (f.state.loading |= 4), (f.instance = k), ls(k), k;
          (x = DO(v)),
            (T = Hi.get(T)) && p_(x, T),
            (k = (d.ownerDocument || d).createElement("link")),
            ls(k);
          var G = k;
          return (
            (G._p = new Promise(function (ee, oe) {
              (G.onload = ee), (G.onerror = oe);
            })),
            fr(k, "link", x),
            (f.state.loading |= 4),
            W0(k, v.precedence, d),
            (f.instance = k)
          );
        case "script":
          return (
            (k = Wd(v.src)),
            (T = d.querySelector($m(k)))
              ? ((f.instance = T), ls(T), T)
              : ((x = v),
                (T = Hi.get(k)) && ((x = h({}, v)), g_(x, T)),
                (d = d.ownerDocument || d),
                (T = d.createElement("script")),
                ls(T),
                fr(T, "link", x),
                d.head.appendChild(T),
                (f.instance = T))
          );
        case "void":
          return null;
        default:
          throw Error(s(443, f.type));
      }
    else
      f.type === "stylesheet" &&
        (f.state.loading & 4) === 0 &&
        ((x = f.instance), (f.state.loading |= 4), W0(x, v.precedence, d));
    return f.instance;
  }
  function W0(d, f, v) {
    for (
      var x = v.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ),
        T = x.length ? x[x.length - 1] : null,
        k = T,
        G = 0;
      G < x.length;
      G++
    ) {
      var ee = x[G];
      if (ee.dataset.precedence === f) k = ee;
      else if (k !== T) break;
    }
    k
      ? k.parentNode.insertBefore(d, k.nextSibling)
      : ((f = v.nodeType === 9 ? v.head : v), f.insertBefore(d, f.firstChild));
  }
  function p_(d, f) {
    d.crossOrigin == null && (d.crossOrigin = f.crossOrigin),
      d.referrerPolicy == null && (d.referrerPolicy = f.referrerPolicy),
      d.title == null && (d.title = f.title);
  }
  function g_(d, f) {
    d.crossOrigin == null && (d.crossOrigin = f.crossOrigin),
      d.referrerPolicy == null && (d.referrerPolicy = f.referrerPolicy),
      d.integrity == null && (d.integrity = f.integrity);
  }
  var K0 = null;
  function MO(d, f, v) {
    if (K0 === null) {
      var x = new Map(),
        T = (K0 = new Map());
      T.set(v, x);
    } else (T = K0), (x = T.get(v)), x || ((x = new Map()), T.set(v, x));
    if (x.has(d)) return x;
    for (
      x.set(d, null), v = v.getElementsByTagName(d), T = 0;
      T < v.length;
      T++
    ) {
      var k = v[T];
      if (
        !(
          k[_n] ||
          k[je] ||
          (d === "link" && k.getAttribute("rel") === "stylesheet")
        ) &&
        k.namespaceURI !== "http://www.w3.org/2000/svg"
      ) {
        var G = k.getAttribute(f) || "";
        G = d + G;
        var ee = x.get(G);
        ee ? ee.push(k) : x.set(G, [k]);
      }
    }
    return x;
  }
  function NO(d, f, v) {
    (d = d.ownerDocument || d),
      d.head.insertBefore(
        v,
        f === "title" ? d.querySelector("head > title") : null
      );
  }
  function rJ(d, f, v) {
    if (v === 1 || f.itemProp != null) return !1;
    switch (d) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (
          typeof f.precedence != "string" ||
          typeof f.href != "string" ||
          f.href === ""
        )
          break;
        return !0;
      case "link":
        if (
          typeof f.rel != "string" ||
          typeof f.href != "string" ||
          f.href === "" ||
          f.onLoad ||
          f.onError
        )
          break;
        switch (f.rel) {
          case "stylesheet":
            return (
              (d = f.disabled), typeof f.precedence == "string" && d == null
            );
          default:
            return !0;
        }
      case "script":
        if (
          f.async &&
          typeof f.async != "function" &&
          typeof f.async != "symbol" &&
          !f.onLoad &&
          !f.onError &&
          f.src &&
          typeof f.src == "string"
        )
          return !0;
    }
    return !1;
  }
  function OO(d) {
    return !(d.type === "stylesheet" && (d.state.loading & 3) === 0);
  }
  var Bm = null;
  function iJ() {}
  function aJ(d, f, v) {
    if (Bm === null) throw Error(s(475));
    var x = Bm;
    if (
      f.type === "stylesheet" &&
      (typeof v.media != "string" || matchMedia(v.media).matches !== !1) &&
      (f.state.loading & 4) === 0
    ) {
      if (f.instance === null) {
        var T = qd(v.href),
          k = d.querySelector(Um(T));
        if (k) {
          (d = k._p),
            d !== null &&
              typeof d == "object" &&
              typeof d.then == "function" &&
              (x.count++, (x = Y0.bind(x)), d.then(x, x)),
            (f.state.loading |= 4),
            (f.instance = k),
            ls(k);
          return;
        }
        (k = d.ownerDocument || d),
          (v = DO(v)),
          (T = Hi.get(T)) && p_(v, T),
          (k = k.createElement("link")),
          ls(k);
        var G = k;
        (G._p = new Promise(function (ee, oe) {
          (G.onload = ee), (G.onerror = oe);
        })),
          fr(k, "link", v),
          (f.instance = k);
      }
      x.stylesheets === null && (x.stylesheets = new Map()),
        x.stylesheets.set(f, d),
        (d = f.state.preload) &&
          (f.state.loading & 3) === 0 &&
          (x.count++,
          (f = Y0.bind(x)),
          d.addEventListener("load", f),
          d.addEventListener("error", f));
    }
  }
  function oJ() {
    if (Bm === null) throw Error(s(475));
    var d = Bm;
    return (
      d.stylesheets && d.count === 0 && v_(d, d.stylesheets),
      0 < d.count
        ? function (f) {
            var v = setTimeout(function () {
              if ((d.stylesheets && v_(d, d.stylesheets), d.unsuspend)) {
                var x = d.unsuspend;
                (d.unsuspend = null), x();
              }
            }, 6e4);
            return (
              (d.unsuspend = f),
              function () {
                (d.unsuspend = null), clearTimeout(v);
              }
            );
          }
        : null
    );
  }
  function Y0() {
    if ((this.count--, this.count === 0)) {
      if (this.stylesheets) v_(this, this.stylesheets);
      else if (this.unsuspend) {
        var d = this.unsuspend;
        (this.unsuspend = null), d();
      }
    }
  }
  var X0 = null;
  function v_(d, f) {
    (d.stylesheets = null),
      d.unsuspend !== null &&
        (d.count++,
        (X0 = new Map()),
        f.forEach(lJ, d),
        (X0 = null),
        Y0.call(d));
  }
  function lJ(d, f) {
    if (!(f.state.loading & 4)) {
      var v = X0.get(d);
      if (v) var x = v.get(null);
      else {
        (v = new Map()), X0.set(d, v);
        for (
          var T = d.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ),
            k = 0;
          k < T.length;
          k++
        ) {
          var G = T[k];
          (G.nodeName === "LINK" || G.getAttribute("media") !== "not all") &&
            (v.set(G.dataset.precedence, G), (x = G));
        }
        x && v.set(null, x);
      }
      (T = f.instance),
        (G = T.getAttribute("data-precedence")),
        (k = v.get(G) || x),
        k === x && v.set(null, T),
        v.set(G, T),
        this.count++,
        (x = Y0.bind(this)),
        T.addEventListener("load", x),
        T.addEventListener("error", x),
        k
          ? k.parentNode.insertBefore(T, k.nextSibling)
          : ((d = d.nodeType === 9 ? d.head : d),
            d.insertBefore(T, d.firstChild)),
        (f.state.loading |= 4);
    }
  }
  var Hm = {
    $$typeof: _,
    Provider: null,
    Consumer: null,
    _currentValue: j,
    _currentValue2: j,
    _threadCount: 0,
  };
  function cJ(d, f, v, x, T, k, G, ee) {
    (this.tag = 1),
      (this.containerInfo = d),
      (this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.callbackNode =
        this.next =
        this.pendingContext =
        this.context =
        this.cancelPendingCommit =
          null),
      (this.callbackPriority = 0),
      (this.expirationTimes = ts(-1)),
      (this.entangledLanes =
        this.shellSuspendCounter =
        this.errorRecoveryDisabledLanes =
        this.expiredLanes =
        this.warmLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = ts(0)),
      (this.hiddenUpdates = ts(null)),
      (this.identifierPrefix = x),
      (this.onUncaughtError = T),
      (this.onCaughtError = k),
      (this.onRecoverableError = G),
      (this.pooledCache = null),
      (this.pooledCacheLanes = 0),
      (this.formState = ee),
      (this.incompleteTransitions = new Map());
  }
  function jO(d, f, v, x, T, k, G, ee, oe, Se, Pe, Fe) {
    return (
      (d = new cJ(d, f, v, G, ee, oe, Se, Fe)),
      (f = 1),
      k === !0 && (f |= 24),
      (k = hi(3, null, null, f)),
      (d.current = k),
      (k.stateNode = d),
      (f = ZS()),
      f.refCount++,
      (d.pooledCache = f),
      f.refCount++,
      (k.memoizedState = { element: x, isDehydrated: v, cache: f }),
      nT(k),
      d
    );
  }
  function FO(d) {
    return d ? ((d = Td), d) : Td;
  }
  function UO(d, f, v, x, T, k) {
    (T = FO(T)),
      x.context === null ? (x.context = T) : (x.pendingContext = T),
      (x = Ml(f)),
      (x.payload = { element: v }),
      (k = k === void 0 ? null : k),
      k !== null && (x.callback = k),
      (v = Nl(d, x, f)),
      v !== null && (vi(v, d, f), ym(v, d, f));
  }
  function $O(d, f) {
    if (((d = d.memoizedState), d !== null && d.dehydrated !== null)) {
      var v = d.retryLane;
      d.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function y_(d, f) {
    $O(d, f), (d = d.alternate) && $O(d, f);
  }
  function BO(d) {
    if (d.tag === 13) {
      var f = Sd(d, 67108864);
      f !== null && vi(f, d, 67108864), y_(d, 67108864);
    }
  }
  var Q0 = !0;
  function uJ(d, f, v, x) {
    var T = O.T;
    O.T = null;
    var k = U.p;
    try {
      (U.p = 2), b_(d, f, v, x);
    } finally {
      (U.p = k), (O.T = T);
    }
  }
  function dJ(d, f, v, x) {
    var T = O.T;
    O.T = null;
    var k = U.p;
    try {
      (U.p = 8), b_(d, f, v, x);
    } finally {
      (U.p = k), (O.T = T);
    }
  }
  function b_(d, f, v, x) {
    if (Q0) {
      var T = x_(x);
      if (T === null) a_(d, f, x, Z0, v), VO(d, x);
      else if (fJ(T, d, f, v, x)) x.stopPropagation();
      else if ((VO(d, x), f & 4 && -1 < hJ.indexOf(d))) {
        for (; T !== null; ) {
          var k = ur(T);
          if (k !== null)
            switch (k.tag) {
              case 3:
                if (((k = k.stateNode), k.current.memoizedState.isDehydrated)) {
                  var G = Ye(k.pendingLanes);
                  if (G !== 0) {
                    var ee = k;
                    for (ee.pendingLanes |= 2, ee.entangledLanes |= 2; G; ) {
                      var oe = 1 << (31 - Ue(G));
                      (ee.entanglements[1] |= oe), (G &= ~oe);
                    }
                    Ya(k), (En & 6) === 0 && ((N0 = re() + 500), Nm(0));
                  }
                }
                break;
              case 13:
                (ee = Sd(k, 2)), ee !== null && vi(ee, k, 2), j0(), y_(k, 2);
            }
          if (((k = x_(x)), k === null && a_(d, f, x, Z0, v), k === T)) break;
          T = k;
        }
        T !== null && x.stopPropagation();
      } else a_(d, f, x, null, v);
    }
  }
  function x_(d) {
    return (d = _S(d)), w_(d);
  }
  var Z0 = null;
  function w_(d) {
    if (((Z0 = null), (d = Es(d)), d !== null)) {
      var f = i(d);
      if (f === null) d = null;
      else {
        var v = f.tag;
        if (v === 13) {
          if (((d = a(f)), d !== null)) return d;
          d = null;
        } else if (v === 3) {
          if (f.stateNode.current.memoizedState.isDehydrated)
            return f.tag === 3 ? f.stateNode.containerInfo : null;
          d = null;
        } else f !== d && (d = null);
      }
    }
    return (Z0 = d), null;
  }
  function HO(d) {
    switch (d) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (fe()) {
          case ke:
            return 2;
          case ne:
            return 8;
          case ie:
          case Ne:
            return 32;
          case $e:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var E_ = !1,
    Kl = null,
    Yl = null,
    Xl = null,
    Vm = new Map(),
    zm = new Map(),
    Ql = [],
    hJ =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
  function VO(d, f) {
    switch (d) {
      case "focusin":
      case "focusout":
        Kl = null;
        break;
      case "dragenter":
      case "dragleave":
        Yl = null;
        break;
      case "mouseover":
      case "mouseout":
        Xl = null;
        break;
      case "pointerover":
      case "pointerout":
        Vm.delete(f.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        zm.delete(f.pointerId);
    }
  }
  function Gm(d, f, v, x, T, k) {
    return d === null || d.nativeEvent !== k
      ? ((d = {
          blockedOn: f,
          domEventName: v,
          eventSystemFlags: x,
          nativeEvent: k,
          targetContainers: [T],
        }),
        f !== null && ((f = ur(f)), f !== null && BO(f)),
        d)
      : ((d.eventSystemFlags |= x),
        (f = d.targetContainers),
        T !== null && f.indexOf(T) === -1 && f.push(T),
        d);
  }
  function fJ(d, f, v, x, T) {
    switch (f) {
      case "focusin":
        return (Kl = Gm(Kl, d, f, v, x, T)), !0;
      case "dragenter":
        return (Yl = Gm(Yl, d, f, v, x, T)), !0;
      case "mouseover":
        return (Xl = Gm(Xl, d, f, v, x, T)), !0;
      case "pointerover":
        var k = T.pointerId;
        return Vm.set(k, Gm(Vm.get(k) || null, d, f, v, x, T)), !0;
      case "gotpointercapture":
        return (
          (k = T.pointerId), zm.set(k, Gm(zm.get(k) || null, d, f, v, x, T)), !0
        );
    }
    return !1;
  }
  function zO(d) {
    var f = Es(d.target);
    if (f !== null) {
      var v = i(f);
      if (v !== null) {
        if (((f = v.tag), f === 13)) {
          if (((f = a(v)), f !== null)) {
            (d.blockedOn = f),
              an(d.priority, function () {
                if (v.tag === 13) {
                  var x = gi();
                  x = Ge(x);
                  var T = Sd(v, x);
                  T !== null && vi(T, v, x), y_(v, x);
                }
              });
            return;
          }
        } else if (f === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          d.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    d.blockedOn = null;
  }
  function J0(d) {
    if (d.blockedOn !== null) return !1;
    for (var f = d.targetContainers; 0 < f.length; ) {
      var v = x_(d.nativeEvent);
      if (v === null) {
        v = d.nativeEvent;
        var x = new v.constructor(v.type, v);
        (TS = x), v.target.dispatchEvent(x), (TS = null);
      } else return (f = ur(v)), f !== null && BO(f), (d.blockedOn = v), !1;
      f.shift();
    }
    return !0;
  }
  function GO(d, f, v) {
    J0(d) && v.delete(f);
  }
  function mJ() {
    (E_ = !1),
      Kl !== null && J0(Kl) && (Kl = null),
      Yl !== null && J0(Yl) && (Yl = null),
      Xl !== null && J0(Xl) && (Xl = null),
      Vm.forEach(GO),
      zm.forEach(GO);
  }
  function ey(d, f) {
    d.blockedOn === f &&
      ((d.blockedOn = null),
      E_ ||
        ((E_ = !0),
        n.unstable_scheduleCallback(n.unstable_NormalPriority, mJ)));
  }
  var ty = null;
  function qO(d) {
    ty !== d &&
      ((ty = d),
      n.unstable_scheduleCallback(n.unstable_NormalPriority, function () {
        ty === d && (ty = null);
        for (var f = 0; f < d.length; f += 3) {
          var v = d[f],
            x = d[f + 1],
            T = d[f + 2];
          if (typeof x != "function") {
            if (w_(x || v) === null) continue;
            break;
          }
          var k = ur(v);
          k !== null &&
            (d.splice(f, 3),
            (f -= 3),
            wT(k, { pending: !0, data: T, method: v.method, action: x }, x, T));
        }
      }));
  }
  function qm(d) {
    function f(oe) {
      return ey(oe, d);
    }
    Kl !== null && ey(Kl, d),
      Yl !== null && ey(Yl, d),
      Xl !== null && ey(Xl, d),
      Vm.forEach(f),
      zm.forEach(f);
    for (var v = 0; v < Ql.length; v++) {
      var x = Ql[v];
      x.blockedOn === d && (x.blockedOn = null);
    }
    for (; 0 < Ql.length && ((v = Ql[0]), v.blockedOn === null); )
      zO(v), v.blockedOn === null && Ql.shift();
    if (((v = (d.ownerDocument || d).$$reactFormReplay), v != null))
      for (x = 0; x < v.length; x += 3) {
        var T = v[x],
          k = v[x + 1],
          G = T[Ke] || null;
        if (typeof k == "function") G || qO(v);
        else if (G) {
          var ee = null;
          if (k && k.hasAttribute("formAction")) {
            if (((T = k), (G = k[Ke] || null))) ee = G.formAction;
            else if (w_(T) !== null) continue;
          } else ee = G.action;
          typeof ee == "function"
            ? (v[x + 1] = ee)
            : (v.splice(x, 3), (x -= 3)),
            qO(v);
        }
      }
  }
  function S_(d) {
    this._internalRoot = d;
  }
  (ny.prototype.render = S_.prototype.render =
    function (d) {
      var f = this._internalRoot;
      if (f === null) throw Error(s(409));
      var v = f.current,
        x = gi();
      UO(v, x, d, f, null, null);
    }),
    (ny.prototype.unmount = S_.prototype.unmount =
      function () {
        var d = this._internalRoot;
        if (d !== null) {
          this._internalRoot = null;
          var f = d.containerInfo;
          UO(d.current, 2, null, d, null, null), j0(), (f[ut] = null);
        }
      });
  function ny(d) {
    this._internalRoot = d;
  }
  ny.prototype.unstable_scheduleHydration = function (d) {
    if (d) {
      var f = zt();
      d = { blockedOn: null, target: d, priority: f };
      for (var v = 0; v < Ql.length && f !== 0 && f < Ql[v].priority; v++);
      Ql.splice(v, 0, d), v === 0 && zO(d);
    }
  };
  var WO = e.version;
  if (WO !== "19.1.1") throw Error(s(527, WO, "19.1.1"));
  U.findDOMNode = function (d) {
    var f = d._reactInternals;
    if (f === void 0)
      throw typeof d.render == "function"
        ? Error(s(188))
        : ((d = Object.keys(d).join(",")), Error(s(268, d)));
    return (
      (d = l(f)),
      (d = d !== null ? c(d) : null),
      (d = d === null ? null : d.stateNode),
      d
    );
  };
  var pJ = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: O,
    reconcilerVersion: "19.1.1",
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var sy = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!sy.isDisabled && sy.supportsFiber)
      try {
        (ht = sy.inject(pJ)), (xt = sy);
      } catch {}
  }
  return (
    (Km.createRoot = function (d, f) {
      if (!r(d)) throw Error(s(299));
      var v = !1,
        x = "",
        T = cN,
        k = uN,
        G = dN,
        ee = null;
      return (
        f != null &&
          (f.unstable_strictMode === !0 && (v = !0),
          f.identifierPrefix !== void 0 && (x = f.identifierPrefix),
          f.onUncaughtError !== void 0 && (T = f.onUncaughtError),
          f.onCaughtError !== void 0 && (k = f.onCaughtError),
          f.onRecoverableError !== void 0 && (G = f.onRecoverableError),
          f.unstable_transitionCallbacks !== void 0 &&
            (ee = f.unstable_transitionCallbacks)),
        (f = jO(d, 1, !1, null, null, v, x, T, k, G, ee, null)),
        (d[ut] = f.current),
        i_(d),
        new S_(f)
      );
    }),
    (Km.hydrateRoot = function (d, f, v) {
      if (!r(d)) throw Error(s(299));
      var x = !1,
        T = "",
        k = cN,
        G = uN,
        ee = dN,
        oe = null,
        Se = null;
      return (
        v != null &&
          (v.unstable_strictMode === !0 && (x = !0),
          v.identifierPrefix !== void 0 && (T = v.identifierPrefix),
          v.onUncaughtError !== void 0 && (k = v.onUncaughtError),
          v.onCaughtError !== void 0 && (G = v.onCaughtError),
          v.onRecoverableError !== void 0 && (ee = v.onRecoverableError),
          v.unstable_transitionCallbacks !== void 0 &&
            (oe = v.unstable_transitionCallbacks),
          v.formState !== void 0 && (Se = v.formState)),
        (f = jO(d, 1, !0, f, v ?? null, x, T, k, G, ee, oe, Se)),
        (f.context = FO(null)),
        (v = f.current),
        (x = gi()),
        (x = Ge(x)),
        (T = Ml(x)),
        (T.callback = null),
        Nl(v, T, x),
        (v = x),
        (f.current.lanes = v),
        Vt(f, v),
        Ya(f),
        (d[ut] = f.current),
        i_(d),
        new ny(f)
      );
    }),
    (Km.version = "19.1.1"),
    Km
  );
}
var sj;
function AJ() {
  if (sj) return __.exports;
  sj = 1;
  function n() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
  }
  return n(), (__.exports = _J()), __.exports;
}
var RJ = AJ(),
  E = sE();
const de = ad(E),
  J5 = vJ({ __proto__: null, default: de }, [E]);
var I_, rj;
function kJ() {
  if (rj) return I_;
  rj = 1;
  var n = typeof Element < "u",
    e = typeof Map == "function",
    t = typeof Set == "function",
    s = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function r(i, a) {
    if (i === a) return !0;
    if (i && a && typeof i == "object" && typeof a == "object") {
      if (i.constructor !== a.constructor) return !1;
      var o, l, c;
      if (Array.isArray(i)) {
        if (((o = i.length), o != a.length)) return !1;
        for (l = o; l-- !== 0; ) if (!r(i[l], a[l])) return !1;
        return !0;
      }
      var h;
      if (e && i instanceof Map && a instanceof Map) {
        if (i.size !== a.size) return !1;
        for (h = i.entries(); !(l = h.next()).done; )
          if (!a.has(l.value[0])) return !1;
        for (h = i.entries(); !(l = h.next()).done; )
          if (!r(l.value[1], a.get(l.value[0]))) return !1;
        return !0;
      }
      if (t && i instanceof Set && a instanceof Set) {
        if (i.size !== a.size) return !1;
        for (h = i.entries(); !(l = h.next()).done; )
          if (!a.has(l.value[0])) return !1;
        return !0;
      }
      if (s && ArrayBuffer.isView(i) && ArrayBuffer.isView(a)) {
        if (((o = i.length), o != a.length)) return !1;
        for (l = o; l-- !== 0; ) if (i[l] !== a[l]) return !1;
        return !0;
      }
      if (i.constructor === RegExp)
        return i.source === a.source && i.flags === a.flags;
      if (
        i.valueOf !== Object.prototype.valueOf &&
        typeof i.valueOf == "function" &&
        typeof a.valueOf == "function"
      )
        return i.valueOf() === a.valueOf();
      if (
        i.toString !== Object.prototype.toString &&
        typeof i.toString == "function" &&
        typeof a.toString == "function"
      )
        return i.toString() === a.toString();
      if (((c = Object.keys(i)), (o = c.length), o !== Object.keys(a).length))
        return !1;
      for (l = o; l-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(a, c[l])) return !1;
      if (n && i instanceof Element) return !1;
      for (l = o; l-- !== 0; )
        if (
          !(
            (c[l] === "_owner" || c[l] === "__v" || c[l] === "__o") &&
            i.$$typeof
          ) &&
          !r(i[c[l]], a[c[l]])
        )
          return !1;
      return !0;
    }
    return i !== i && a !== a;
  }
  return (
    (I_ = function (a, o) {
      try {
        return r(a, o);
      } catch (l) {
        if ((l.message || "").match(/stack|recursion/i))
          return (
            console.warn("react-fast-compare cannot handle circular refs"), !1
          );
        throw l;
      }
    }),
    I_
  );
}
var CJ = kJ();
const IJ = ad(CJ);
var L_, ij;
function LJ() {
  if (ij) return L_;
  ij = 1;
  var n = function (e, t, s, r, i, a, o, l) {
    if (!e) {
      var c;
      if (t === void 0)
        c = new Error(
          "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
        );
      else {
        var h = [s, r, i, a, o, l],
          m = 0;
        (c = new Error(
          t.replace(/%s/g, function () {
            return h[m++];
          })
        )),
          (c.name = "Invariant Violation");
      }
      throw ((c.framesToPop = 1), c);
    }
  };
  return (L_ = n), L_;
}
var DJ = LJ();
const aj = ad(DJ);
var D_, oj;
function PJ() {
  return (
    oj ||
      ((oj = 1),
      (D_ = function (e, t, s, r) {
        var i = s ? s.call(r, e, t) : void 0;
        if (i !== void 0) return !!i;
        if (e === t) return !0;
        if (typeof e != "object" || !e || typeof t != "object" || !t) return !1;
        var a = Object.keys(e),
          o = Object.keys(t);
        if (a.length !== o.length) return !1;
        for (
          var l = Object.prototype.hasOwnProperty.bind(t), c = 0;
          c < a.length;
          c++
        ) {
          var h = a[c];
          if (!l(h)) return !1;
          var m = e[h],
            p = t[h];
          if (
            ((i = s ? s.call(r, m, p, h) : void 0),
            i === !1 || (i === void 0 && m !== p))
          )
            return !1;
        }
        return !0;
      })),
    D_
  );
}
var MJ = PJ();
const NJ = ad(MJ);
var e6 = ((n) => (
    (n.BASE = "base"),
    (n.BODY = "body"),
    (n.HEAD = "head"),
    (n.HTML = "html"),
    (n.LINK = "link"),
    (n.META = "meta"),
    (n.NOSCRIPT = "noscript"),
    (n.SCRIPT = "script"),
    (n.STYLE = "style"),
    (n.TITLE = "title"),
    (n.FRAGMENT = "Symbol(react.fragment)"),
    n
  ))(e6 || {}),
  P_ = {
    link: { rel: ["amphtml", "canonical", "alternate"] },
    script: { type: ["application/ld+json"] },
    meta: {
      charset: "",
      name: ["generator", "robots", "description"],
      property: [
        "og:type",
        "og:title",
        "og:url",
        "og:image",
        "og:image:alt",
        "og:description",
        "twitter:url",
        "twitter:title",
        "twitter:description",
        "twitter:image",
        "twitter:image:alt",
        "twitter:card",
        "twitter:site",
      ],
    },
  },
  lj = Object.values(e6),
  kI = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex",
  },
  OJ = Object.entries(kI).reduce((n, [e, t]) => ((n[t] = e), n), {}),
  Ia = "data-rh",
  Zh = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate",
    PRIORITIZE_SEO_TAGS: "prioritizeSeoTags",
  },
  Jh = (n, e) => {
    for (let t = n.length - 1; t >= 0; t -= 1) {
      const s = n[t];
      if (Object.prototype.hasOwnProperty.call(s, e)) return s[e];
    }
    return null;
  },
  jJ = (n) => {
    let e = Jh(n, "title");
    const t = Jh(n, Zh.TITLE_TEMPLATE);
    if ((Array.isArray(e) && (e = e.join("")), t && e))
      return t.replace(/%s/g, () => e);
    const s = Jh(n, Zh.DEFAULT_TITLE);
    return e || s || void 0;
  },
  FJ = (n) => Jh(n, Zh.ON_CHANGE_CLIENT_STATE) || (() => {}),
  M_ = (n, e) =>
    e
      .filter((t) => typeof t[n] < "u")
      .map((t) => t[n])
      .reduce((t, s) => ({ ...t, ...s }), {}),
  UJ = (n, e) =>
    e
      .filter((t) => typeof t.base < "u")
      .map((t) => t.base)
      .reverse()
      .reduce((t, s) => {
        if (!t.length) {
          const r = Object.keys(s);
          for (let i = 0; i < r.length; i += 1) {
            const o = r[i].toLowerCase();
            if (n.indexOf(o) !== -1 && s[o]) return t.concat(s);
          }
        }
        return t;
      }, []),
  $J = (n) => console && typeof console.warn == "function" && console.warn(n),
  Ym = (n, e, t) => {
    const s = {};
    return t
      .filter((r) =>
        Array.isArray(r[n])
          ? !0
          : (typeof r[n] < "u" &&
              $J(
                `Helmet: ${n} should be of type "Array". Instead found type "${typeof r[
                  n
                ]}"`
              ),
            !1)
      )
      .map((r) => r[n])
      .reverse()
      .reduce((r, i) => {
        const a = {};
        i.filter((l) => {
          let c;
          const h = Object.keys(l);
          for (let p = 0; p < h.length; p += 1) {
            const g = h[p],
              y = g.toLowerCase();
            e.indexOf(y) !== -1 &&
              !(c === "rel" && l[c].toLowerCase() === "canonical") &&
              !(y === "rel" && l[y].toLowerCase() === "stylesheet") &&
              (c = y),
              e.indexOf(g) !== -1 &&
                (g === "innerHTML" || g === "cssText" || g === "itemprop") &&
                (c = g);
          }
          if (!c || !l[c]) return !1;
          const m = l[c].toLowerCase();
          return (
            s[c] || (s[c] = {}),
            a[c] || (a[c] = {}),
            s[c][m] ? !1 : ((a[c][m] = !0), !0)
          );
        })
          .reverse()
          .forEach((l) => r.push(l));
        const o = Object.keys(a);
        for (let l = 0; l < o.length; l += 1) {
          const c = o[l],
            h = { ...s[c], ...a[c] };
          s[c] = h;
        }
        return r;
      }, [])
      .reverse();
  },
  BJ = (n, e) => {
    if (Array.isArray(n) && n.length) {
      for (let t = 0; t < n.length; t += 1) if (n[t][e]) return !0;
    }
    return !1;
  },
  HJ = (n) => ({
    baseTag: UJ(["href"], n),
    bodyAttributes: M_("bodyAttributes", n),
    defer: Jh(n, Zh.DEFER),
    encode: Jh(n, Zh.ENCODE_SPECIAL_CHARACTERS),
    htmlAttributes: M_("htmlAttributes", n),
    linkTags: Ym("link", ["rel", "href"], n),
    metaTags: Ym(
      "meta",
      ["name", "charset", "http-equiv", "property", "itemprop"],
      n
    ),
    noscriptTags: Ym("noscript", ["innerHTML"], n),
    onChangeClientState: FJ(n),
    scriptTags: Ym("script", ["src", "innerHTML"], n),
    styleTags: Ym("style", ["cssText"], n),
    title: jJ(n),
    titleAttributes: M_("titleAttributes", n),
    prioritizeSeoTags: BJ(n, Zh.PRIORITIZE_SEO_TAGS),
  }),
  t6 = (n) => (Array.isArray(n) ? n.join("") : n),
  VJ = (n, e) => {
    const t = Object.keys(n);
    for (let s = 0; s < t.length; s += 1)
      if (e[t[s]] && e[t[s]].includes(n[t[s]])) return !0;
    return !1;
  },
  N_ = (n, e) =>
    Array.isArray(n)
      ? n.reduce(
          (t, s) => (VJ(s, e) ? t.priority.push(s) : t.default.push(s), t),
          { priority: [], default: [] }
        )
      : { default: n, priority: [] },
  cj = (n, e) => ({ ...n, [e]: void 0 }),
  zJ = ["noscript", "script", "style"],
  qA = (n, e = !0) =>
    e === !1
      ? String(n)
      : String(n)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#x27;"),
  n6 = (n) =>
    Object.keys(n).reduce((e, t) => {
      const s = typeof n[t] < "u" ? `${t}="${n[t]}"` : `${t}`;
      return e ? `${e} ${s}` : s;
    }, ""),
  GJ = (n, e, t, s) => {
    const r = n6(t),
      i = t6(e);
    return r
      ? `<${n} ${Ia}="true" ${r}>${qA(i, s)}</${n}>`
      : `<${n} ${Ia}="true">${qA(i, s)}</${n}>`;
  },
  qJ = (n, e, t = !0) =>
    e.reduce((s, r) => {
      const i = r,
        a = Object.keys(i)
          .filter((c) => !(c === "innerHTML" || c === "cssText"))
          .reduce((c, h) => {
            const m = typeof i[h] > "u" ? h : `${h}="${qA(i[h], t)}"`;
            return c ? `${c} ${m}` : m;
          }, ""),
        o = i.innerHTML || i.cssText || "",
        l = zJ.indexOf(n) === -1;
      return `${s}<${n} ${Ia}="true" ${a}${l ? "/>" : `>${o}</${n}>`}`;
    }, ""),
  s6 = (n, e = {}) =>
    Object.keys(n).reduce((t, s) => {
      const r = kI[s];
      return (t[r || s] = n[s]), t;
    }, e),
  WJ = (n, e, t) => {
    const s = { key: e, [Ia]: !0 },
      r = s6(t, s);
    return [de.createElement("title", r, e)];
  },
  db = (n, e) =>
    e.map((t, s) => {
      const r = { key: s, [Ia]: !0 };
      return (
        Object.keys(t).forEach((i) => {
          const o = kI[i] || i;
          if (o === "innerHTML" || o === "cssText") {
            const l = t.innerHTML || t.cssText;
            r.dangerouslySetInnerHTML = { __html: l };
          } else r[o] = t[i];
        }),
        de.createElement(n, r)
      );
    }),
  Yi = (n, e, t = !0) => {
    switch (n) {
      case "title":
        return {
          toComponent: () => WJ(n, e.title, e.titleAttributes),
          toString: () => GJ(n, e.title, e.titleAttributes, t),
        };
      case "bodyAttributes":
      case "htmlAttributes":
        return { toComponent: () => s6(e), toString: () => n6(e) };
      default:
        return { toComponent: () => db(n, e), toString: () => qJ(n, e, t) };
    }
  },
  KJ = ({ metaTags: n, linkTags: e, scriptTags: t, encode: s }) => {
    const r = N_(n, P_.meta),
      i = N_(e, P_.link),
      a = N_(t, P_.script);
    return {
      priorityMethods: {
        toComponent: () => [
          ...db("meta", r.priority),
          ...db("link", i.priority),
          ...db("script", a.priority),
        ],
        toString: () =>
          `${Yi("meta", r.priority, s)} ${Yi("link", i.priority, s)} ${Yi(
            "script",
            a.priority,
            s
          )}`,
      },
      metaTags: r.default,
      linkTags: i.default,
      scriptTags: a.default,
    };
  },
  YJ = (n) => {
    const {
      baseTag: e,
      bodyAttributes: t,
      encode: s = !0,
      htmlAttributes: r,
      noscriptTags: i,
      styleTags: a,
      title: o = "",
      titleAttributes: l,
      prioritizeSeoTags: c,
    } = n;
    let { linkTags: h, metaTags: m, scriptTags: p } = n,
      g = { toComponent: () => {}, toString: () => "" };
    return (
      c &&
        ({
          priorityMethods: g,
          linkTags: h,
          metaTags: m,
          scriptTags: p,
        } = KJ(n)),
      {
        priority: g,
        base: Yi("base", e, s),
        bodyAttributes: Yi("bodyAttributes", t, s),
        htmlAttributes: Yi("htmlAttributes", r, s),
        link: Yi("link", h, s),
        meta: Yi("meta", m, s),
        noscript: Yi("noscript", i, s),
        script: Yi("script", p, s),
        style: Yi("style", a, s),
        title: Yi("title", { title: o, titleAttributes: l }, s),
      }
    );
  },
  WA = YJ,
  ry = [],
  r6 = !!(
    typeof window < "u" &&
    window.document &&
    window.document.createElement
  ),
  KA = class {
    instances = [];
    canUseDOM = r6;
    context;
    value = {
      setHelmet: (n) => {
        this.context.helmet = n;
      },
      helmetInstances: {
        get: () => (this.canUseDOM ? ry : this.instances),
        add: (n) => {
          (this.canUseDOM ? ry : this.instances).push(n);
        },
        remove: (n) => {
          const e = (this.canUseDOM ? ry : this.instances).indexOf(n);
          (this.canUseDOM ? ry : this.instances).splice(e, 1);
        },
      },
    };
    constructor(n, e) {
      (this.context = n),
        (this.canUseDOM = e || !1),
        e ||
          (n.helmet = WA({
            baseTag: [],
            bodyAttributes: {},
            htmlAttributes: {},
            linkTags: [],
            metaTags: [],
            noscriptTags: [],
            scriptTags: [],
            styleTags: [],
            title: "",
            titleAttributes: {},
          }));
    }
  },
  XJ = {},
  i6 = de.createContext(XJ),
  a6 = class o6 extends E.Component {
    static canUseDOM = r6;
    helmetData;
    constructor(e) {
      super(e),
        (this.helmetData = new KA(this.props.context || {}, o6.canUseDOM));
    }
    render() {
      return de.createElement(
        i6.Provider,
        { value: this.helmetData.value },
        this.props.children
      );
    }
  },
  Kd = (n, e) => {
    const t = document.head || document.querySelector("head"),
      s = t.querySelectorAll(`${n}[${Ia}]`),
      r = [].slice.call(s),
      i = [];
    let a;
    return (
      e &&
        e.length &&
        e.forEach((o) => {
          const l = document.createElement(n);
          for (const c in o)
            if (Object.prototype.hasOwnProperty.call(o, c))
              if (c === "innerHTML") l.innerHTML = o.innerHTML;
              else if (c === "cssText")
                l.styleSheet
                  ? (l.styleSheet.cssText = o.cssText)
                  : l.appendChild(document.createTextNode(o.cssText));
              else {
                const h = c,
                  m = typeof o[h] > "u" ? "" : o[h];
                l.setAttribute(c, m);
              }
          l.setAttribute(Ia, "true"),
            r.some((c, h) => ((a = h), l.isEqualNode(c)))
              ? r.splice(a, 1)
              : i.push(l);
        }),
      r.forEach((o) => o.parentNode?.removeChild(o)),
      i.forEach((o) => t.appendChild(o)),
      { oldTags: r, newTags: i }
    );
  },
  YA = (n, e) => {
    const t = document.getElementsByTagName(n)[0];
    if (!t) return;
    const s = t.getAttribute(Ia),
      r = s ? s.split(",") : [],
      i = [...r],
      a = Object.keys(e);
    for (const o of a) {
      const l = e[o] || "";
      t.getAttribute(o) !== l && t.setAttribute(o, l),
        r.indexOf(o) === -1 && r.push(o);
      const c = i.indexOf(o);
      c !== -1 && i.splice(c, 1);
    }
    for (let o = i.length - 1; o >= 0; o -= 1) t.removeAttribute(i[o]);
    r.length === i.length
      ? t.removeAttribute(Ia)
      : t.getAttribute(Ia) !== a.join(",") && t.setAttribute(Ia, a.join(","));
  },
  QJ = (n, e) => {
    typeof n < "u" && document.title !== n && (document.title = t6(n)),
      YA("title", e);
  },
  uj = (n, e) => {
    const {
      baseTag: t,
      bodyAttributes: s,
      htmlAttributes: r,
      linkTags: i,
      metaTags: a,
      noscriptTags: o,
      onChangeClientState: l,
      scriptTags: c,
      styleTags: h,
      title: m,
      titleAttributes: p,
    } = n;
    YA("body", s), YA("html", r), QJ(m, p);
    const g = {
        baseTag: Kd("base", t),
        linkTags: Kd("link", i),
        metaTags: Kd("meta", a),
        noscriptTags: Kd("noscript", o),
        scriptTags: Kd("script", c),
        styleTags: Kd("style", h),
      },
      y = {},
      b = {};
    Object.keys(g).forEach((w) => {
      const { newTags: S, oldTags: A } = g[w];
      S.length && (y[w] = S), A.length && (b[w] = g[w].oldTags);
    }),
      e && e(),
      l(n, y, b);
  },
  Xm = null,
  ZJ = (n) => {
    Xm && cancelAnimationFrame(Xm),
      n.defer
        ? (Xm = requestAnimationFrame(() => {
            uj(n, () => {
              Xm = null;
            });
          }))
        : (uj(n), (Xm = null));
  },
  JJ = ZJ,
  dj = class extends E.Component {
    rendered = !1;
    shouldComponentUpdate(n) {
      return !NJ(n, this.props);
    }
    componentDidUpdate() {
      this.emitChange();
    }
    componentWillUnmount() {
      const { helmetInstances: n } = this.props.context;
      n.remove(this), this.emitChange();
    }
    emitChange() {
      const { helmetInstances: n, setHelmet: e } = this.props.context;
      let t = null;
      const s = HJ(
        n.get().map((r) => {
          const i = { ...r.props };
          return delete i.context, i;
        })
      );
      a6.canUseDOM ? JJ(s) : WA && (t = WA(s)), e(t);
    }
    init() {
      if (this.rendered) return;
      this.rendered = !0;
      const { helmetInstances: n } = this.props.context;
      n.add(this), this.emitChange();
    }
    render() {
      return this.init(), null;
    }
  },
  eee = class extends E.Component {
    static defaultProps = {
      defer: !0,
      encodeSpecialCharacters: !0,
      prioritizeSeoTags: !1,
    };
    shouldComponentUpdate(n) {
      return !IJ(cj(this.props, "helmetData"), cj(n, "helmetData"));
    }
    mapNestedChildrenToProps(n, e) {
      if (!e) return null;
      switch (n.type) {
        case "script":
        case "noscript":
          return { innerHTML: e };
        case "style":
          return { cssText: e };
        default:
          throw new Error(
            `<${n.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`
          );
      }
    }
    flattenArrayTypeChildren(n, e, t, s) {
      return {
        ...e,
        [n.type]: [
          ...(e[n.type] || []),
          { ...t, ...this.mapNestedChildrenToProps(n, s) },
        ],
      };
    }
    mapObjectTypeChildren(n, e, t, s) {
      switch (n.type) {
        case "title":
          return { ...e, [n.type]: s, titleAttributes: { ...t } };
        case "body":
          return { ...e, bodyAttributes: { ...t } };
        case "html":
          return { ...e, htmlAttributes: { ...t } };
        default:
          return { ...e, [n.type]: { ...t } };
      }
    }
    mapArrayTypeChildrenToProps(n, e) {
      let t = { ...e };
      return (
        Object.keys(n).forEach((s) => {
          t = { ...t, [s]: n[s] };
        }),
        t
      );
    }
    warnOnInvalidChildren(n, e) {
      return (
        aj(
          lj.some((t) => n.type === t),
          typeof n.type == "function"
            ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information."
            : `Only elements types ${lj.join(
                ", "
              )} are allowed. Helmet does not support rendering <${
                n.type
              }> elements. Refer to our API for more information.`
        ),
        aj(
          !e ||
            typeof e == "string" ||
            (Array.isArray(e) && !e.some((t) => typeof t != "string")),
          `Helmet expects a string as a child of <${n.type}>. Did you forget to wrap your children in braces? ( <${n.type}>{\`\`}</${n.type}> ) Refer to our API for more information.`
        ),
        !0
      );
    }
    mapChildrenToProps(n, e) {
      let t = {};
      return (
        de.Children.forEach(n, (s) => {
          if (!s || !s.props) return;
          const { children: r, ...i } = s.props,
            a = Object.keys(i).reduce(
              (l, c) => ((l[OJ[c] || c] = i[c]), l),
              {}
            );
          let { type: o } = s;
          switch (
            (typeof o == "symbol"
              ? (o = o.toString())
              : this.warnOnInvalidChildren(s, r),
            o)
          ) {
            case "Symbol(react.fragment)":
              e = this.mapChildrenToProps(r, e);
              break;
            case "link":
            case "meta":
            case "noscript":
            case "script":
            case "style":
              t = this.flattenArrayTypeChildren(s, t, a, r);
              break;
            default:
              e = this.mapObjectTypeChildren(s, e, a, r);
              break;
          }
        }),
        this.mapArrayTypeChildrenToProps(t, e)
      );
    }
    render() {
      const { children: n, ...e } = this.props;
      let t = { ...e },
        { helmetData: s } = e;
      if ((n && (t = this.mapChildrenToProps(n, t)), s && !(s instanceof KA))) {
        const r = s;
        (s = new KA(r.context, !0)), delete t.helmetData;
      }
      return s
        ? de.createElement(dj, { ...t, context: s.value })
        : de.createElement(i6.Consumer, null, (r) =>
            de.createElement(dj, { ...t, context: r })
          );
    }
  };
/**
 * react-router v7.7.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ var hj = "popstate";
function tee(n = {}) {
  function e(s, r) {
    let { pathname: i, search: a, hash: o } = s.location;
    return XA(
      "",
      { pathname: i, search: a, hash: o },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function t(s, r) {
    return typeof r == "string" ? r : yg(r);
  }
  return see(e, t, null, n);
}
function Zn(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function ca(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function nee() {
  return Math.random().toString(36).substring(2, 10);
}
function fj(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function XA(n, e, t = null, s) {
  return {
    pathname: typeof n == "string" ? n : n.pathname,
    search: "",
    hash: "",
    ...(typeof e == "string" ? Of(e) : e),
    state: t,
    key: (e && e.key) || s || nee(),
  };
}
function yg({ pathname: n = "/", search: e = "", hash: t = "" }) {
  return (
    e && e !== "?" && (n += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (n += t.charAt(0) === "#" ? t : "#" + t),
    n
  );
}
function Of(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substring(t)), (n = n.substring(0, t)));
    let s = n.indexOf("?");
    s >= 0 && ((e.search = n.substring(s)), (n = n.substring(0, s))),
      n && (e.pathname = n);
  }
  return e;
}
function see(n, e, t, s = {}) {
  let { window: r = document.defaultView, v5Compat: i = !1 } = s,
    a = r.history,
    o = "POP",
    l = null,
    c = h();
  c == null && ((c = 0), a.replaceState({ ...a.state, idx: c }, ""));
  function h() {
    return (a.state || { idx: null }).idx;
  }
  function m() {
    o = "POP";
    let w = h(),
      S = w == null ? null : w - c;
    (c = w), l && l({ action: o, location: b.location, delta: S });
  }
  function p(w, S) {
    o = "PUSH";
    let A = XA(b.location, w, S);
    c = h() + 1;
    let _ = fj(A, c),
      R = b.createHref(A);
    try {
      a.pushState(_, "", R);
    } catch (C) {
      if (C instanceof DOMException && C.name === "DataCloneError") throw C;
      r.location.assign(R);
    }
    i && l && l({ action: o, location: b.location, delta: 1 });
  }
  function g(w, S) {
    o = "REPLACE";
    let A = XA(b.location, w, S);
    c = h();
    let _ = fj(A, c),
      R = b.createHref(A);
    a.replaceState(_, "", R),
      i && l && l({ action: o, location: b.location, delta: 0 });
  }
  function y(w) {
    return ree(w);
  }
  let b = {
    get action() {
      return o;
    },
    get location() {
      return n(r, a);
    },
    listen(w) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(hj, m),
        (l = w),
        () => {
          r.removeEventListener(hj, m), (l = null);
        }
      );
    },
    createHref(w) {
      return e(r, w);
    },
    createURL: y,
    encodeLocation(w) {
      let S = y(w);
      return { pathname: S.pathname, search: S.search, hash: S.hash };
    },
    push: p,
    replace: g,
    go(w) {
      return a.go(w);
    },
  };
  return b;
}
function ree(n, e = !1) {
  let t = "http://localhost";
  typeof window < "u" &&
    (t =
      window.location.origin !== "null"
        ? window.location.origin
        : window.location.href),
    Zn(t, "No window.location.(origin|href) available to create URL");
  let s = typeof n == "string" ? n : yg(n);
  return (
    (s = s.replace(/ $/, "%20")),
    !e && s.startsWith("//") && (s = t + s),
    new URL(s, t)
  );
}
function l6(n, e, t = "/") {
  return iee(n, e, t, !1);
}
function iee(n, e, t, s) {
  let r = typeof e == "string" ? Of(e) : e,
    i = El(r.pathname || "/", t);
  if (i == null) return null;
  let a = c6(n);
  aee(a);
  let o = null;
  for (let l = 0; o == null && l < a.length; ++l) {
    let c = vee(i);
    o = pee(a[l], c, s);
  }
  return o;
}
function c6(n, e = [], t = [], s = "") {
  let r = (i, a, o) => {
    let l = {
      relativePath: o === void 0 ? i.path || "" : o,
      caseSensitive: i.caseSensitive === !0,
      childrenIndex: a,
      route: i,
    };
    l.relativePath.startsWith("/") &&
      (Zn(
        l.relativePath.startsWith(s),
        `Absolute route path "${l.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ),
      (l.relativePath = l.relativePath.slice(s.length)));
    let c = wl([s, l.relativePath]),
      h = t.concat(l);
    i.children &&
      i.children.length > 0 &&
      (Zn(
        i.index !== !0,
        `Index routes must not have child routes. Please remove all child routes from route path "${c}".`
      ),
      c6(i.children, e, h, c)),
      !(i.path == null && !i.index) &&
        e.push({ path: c, score: fee(c, i.index), routesMeta: h });
  };
  return (
    n.forEach((i, a) => {
      if (i.path === "" || !i.path?.includes("?")) r(i, a);
      else for (let o of u6(i.path)) r(i, a, o);
    }),
    e
  );
}
function u6(n) {
  let e = n.split("/");
  if (e.length === 0) return [];
  let [t, ...s] = e,
    r = t.endsWith("?"),
    i = t.replace(/\?$/, "");
  if (s.length === 0) return r ? [i, ""] : [i];
  let a = u6(s.join("/")),
    o = [];
  return (
    o.push(...a.map((l) => (l === "" ? i : [i, l].join("/")))),
    r && o.push(...a),
    o.map((l) => (n.startsWith("/") && l === "" ? "/" : l))
  );
}
function aee(n) {
  n.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : mee(
          e.routesMeta.map((s) => s.childrenIndex),
          t.routesMeta.map((s) => s.childrenIndex)
        )
  );
}
var oee = /^:[\w-]+$/,
  lee = 3,
  cee = 2,
  uee = 1,
  dee = 10,
  hee = -2,
  mj = (n) => n === "*";
function fee(n, e) {
  let t = n.split("/"),
    s = t.length;
  return (
    t.some(mj) && (s += hee),
    e && (s += cee),
    t
      .filter((r) => !mj(r))
      .reduce((r, i) => r + (oee.test(i) ? lee : i === "" ? uee : dee), s)
  );
}
function mee(n, e) {
  return n.length === e.length && n.slice(0, -1).every((s, r) => s === e[r])
    ? n[n.length - 1] - e[e.length - 1]
    : 0;
}
function pee(n, e, t = !1) {
  let { routesMeta: s } = n,
    r = {},
    i = "/",
    a = [];
  for (let o = 0; o < s.length; ++o) {
    let l = s[o],
      c = o === s.length - 1,
      h = i === "/" ? e : e.slice(i.length) || "/",
      m = cx(
        { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
        h
      ),
      p = l.route;
    if (
      (!m &&
        c &&
        t &&
        !s[s.length - 1].route.index &&
        (m = cx(
          { path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 },
          h
        )),
      !m)
    )
      return null;
    Object.assign(r, m.params),
      a.push({
        params: r,
        pathname: wl([i, m.pathname]),
        pathnameBase: wee(wl([i, m.pathnameBase])),
        route: p,
      }),
      m.pathnameBase !== "/" && (i = wl([i, m.pathnameBase]));
  }
  return a;
}
function cx(n, e) {
  typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 });
  let [t, s] = gee(n.path, n.caseSensitive, n.end),
    r = e.match(t);
  if (!r) return null;
  let i = r[0],
    a = i.replace(/(.)\/+$/, "$1"),
    o = r.slice(1);
  return {
    params: s.reduce((c, { paramName: h, isOptional: m }, p) => {
      if (h === "*") {
        let y = o[p] || "";
        a = i.slice(0, i.length - y.length).replace(/(.)\/+$/, "$1");
      }
      const g = o[p];
      return (
        m && !g ? (c[h] = void 0) : (c[h] = (g || "").replace(/%2F/g, "/")), c
      );
    }, {}),
    pathname: i,
    pathnameBase: a,
    pattern: n,
  };
}
function gee(n, e = !1, t = !0) {
  ca(
    n === "*" || !n.endsWith("*") || n.endsWith("/*"),
    `Route path "${n}" will be treated as if it were "${n.replace(
      /\*$/,
      "/*"
    )}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(
      /\*$/,
      "/*"
    )}".`
  );
  let s = [],
    r =
      "^" +
      n
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (a, o, l) => (
            s.push({ paramName: o, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    n.endsWith("*")
      ? (s.push({ paramName: "*" }),
        (r += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : t
      ? (r += "\\/*$")
      : n !== "" && n !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r, e ? void 0 : "i"), s]
  );
}
function vee(n) {
  try {
    return n
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      ca(
        !1,
        `The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`
      ),
      n
    );
  }
}
function El(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    s = n.charAt(t);
  return s && s !== "/" ? null : n.slice(t) || "/";
}
function yee(n, e = "/") {
  let {
    pathname: t,
    search: s = "",
    hash: r = "",
  } = typeof n == "string" ? Of(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : bee(t, e)) : e,
    search: Eee(s),
    hash: See(r),
  };
}
function bee(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function O_(n, e, t, s) {
  return `Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(
    s
  )}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function xee(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function CI(n) {
  let e = xee(n);
  return e.map((t, s) => (s === e.length - 1 ? t.pathname : t.pathnameBase));
}
function II(n, e, t, s = !1) {
  let r;
  typeof n == "string"
    ? (r = Of(n))
    : ((r = { ...n }),
      Zn(
        !r.pathname || !r.pathname.includes("?"),
        O_("?", "pathname", "search", r)
      ),
      Zn(
        !r.pathname || !r.pathname.includes("#"),
        O_("#", "pathname", "hash", r)
      ),
      Zn(!r.search || !r.search.includes("#"), O_("#", "search", "hash", r)));
  let i = n === "" || r.pathname === "",
    a = i ? "/" : r.pathname,
    o;
  if (a == null) o = t;
  else {
    let m = e.length - 1;
    if (!s && a.startsWith("..")) {
      let p = a.split("/");
      for (; p[0] === ".."; ) p.shift(), (m -= 1);
      r.pathname = p.join("/");
    }
    o = m >= 0 ? e[m] : "/";
  }
  let l = yee(r, o),
    c = a && a !== "/" && a.endsWith("/"),
    h = (i || a === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (c || h) && (l.pathname += "/"), l;
}
var wl = (n) => n.join("/").replace(/\/\/+/g, "/"),
  wee = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"),
  Eee = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  See = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n);
function Tee(n) {
  return (
    n != null &&
    typeof n.status == "number" &&
    typeof n.statusText == "string" &&
    typeof n.internal == "boolean" &&
    "data" in n
  );
}
var d6 = ["POST", "PUT", "PATCH", "DELETE"];
new Set(d6);
var _ee = ["GET", ...d6];
new Set(_ee);
var jf = E.createContext(null);
jf.displayName = "DataRouter";
var rE = E.createContext(null);
rE.displayName = "DataRouterState";
E.createContext(!1);
var h6 = E.createContext({ isTransitioning: !1 });
h6.displayName = "ViewTransition";
var Aee = E.createContext(new Map());
Aee.displayName = "Fetchers";
var Ree = E.createContext(null);
Ree.displayName = "Await";
var Fa = E.createContext(null);
Fa.displayName = "Navigation";
var bv = E.createContext(null);
bv.displayName = "Location";
var Ua = E.createContext({ outlet: null, matches: [], isDataRoute: !1 });
Ua.displayName = "Route";
var LI = E.createContext(null);
LI.displayName = "RouteError";
function kee(n, { relative: e } = {}) {
  Zn(
    Ff(),
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: t, navigator: s } = E.useContext(Fa),
    { hash: r, pathname: i, search: a } = xv(n, { relative: e }),
    o = i;
  return (
    t !== "/" && (o = i === "/" ? t : wl([t, i])),
    s.createHref({ pathname: o, search: a, hash: r })
  );
}
function Ff() {
  return E.useContext(bv) != null;
}
function Dr() {
  return (
    Zn(
      Ff(),
      "useLocation() may be used only in the context of a <Router> component."
    ),
    E.useContext(bv).location
  );
}
var f6 =
  "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function m6(n) {
  E.useContext(Fa).static || E.useLayoutEffect(n);
}
function es() {
  let { isDataRoute: n } = E.useContext(Ua);
  return n ? Bee() : Cee();
}
function Cee() {
  Zn(
    Ff(),
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let n = E.useContext(jf),
    { basename: e, navigator: t } = E.useContext(Fa),
    { matches: s } = E.useContext(Ua),
    { pathname: r } = Dr(),
    i = JSON.stringify(CI(s)),
    a = E.useRef(!1);
  return (
    m6(() => {
      a.current = !0;
    }),
    E.useCallback(
      (l, c = {}) => {
        if ((ca(a.current, f6), !a.current)) return;
        if (typeof l == "number") {
          t.go(l);
          return;
        }
        let h = II(l, JSON.parse(i), r, c.relative === "path");
        n == null &&
          e !== "/" &&
          (h.pathname = h.pathname === "/" ? e : wl([e, h.pathname])),
          (c.replace ? t.replace : t.push)(h, c.state, c);
      },
      [e, t, i, r, n]
    )
  );
}
E.createContext(null);
function p6() {
  let { matches: n } = E.useContext(Ua),
    e = n[n.length - 1];
  return e ? e.params : {};
}
function xv(n, { relative: e } = {}) {
  let { matches: t } = E.useContext(Ua),
    { pathname: s } = Dr(),
    r = JSON.stringify(CI(t));
  return E.useMemo(() => II(n, JSON.parse(r), s, e === "path"), [n, r, s, e]);
}
function Iee(n, e) {
  return g6(n, e);
}
function g6(n, e, t, s) {
  Zn(
    Ff(),
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: r } = E.useContext(Fa),
    { matches: i } = E.useContext(Ua),
    a = i[i.length - 1],
    o = a ? a.params : {},
    l = a ? a.pathname : "/",
    c = a ? a.pathnameBase : "/",
    h = a && a.route;
  {
    let S = (h && h.path) || "";
    v6(
      l,
      !h || S.endsWith("*") || S.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${S}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${S}"> to <Route path="${
        S === "/" ? "*" : `${S}/*`
      }">.`
    );
  }
  let m = Dr(),
    p;
  if (e) {
    let S = typeof e == "string" ? Of(e) : e;
    Zn(
      c === "/" || S.pathname?.startsWith(c),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${S.pathname}" was given in the \`location\` prop.`
    ),
      (p = S);
  } else p = m;
  let g = p.pathname || "/",
    y = g;
  if (c !== "/") {
    let S = c.replace(/^\//, "").split("/");
    y = "/" + g.replace(/^\//, "").split("/").slice(S.length).join("/");
  }
  let b = l6(n, { pathname: y });
  ca(
    h || b != null,
    `No routes matched location "${p.pathname}${p.search}${p.hash}" `
  ),
    ca(
      b == null ||
        b[b.length - 1].route.element !== void 0 ||
        b[b.length - 1].route.Component !== void 0 ||
        b[b.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${p.pathname}${p.search}${p.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  let w = Nee(
    b &&
      b.map((S) =>
        Object.assign({}, S, {
          params: Object.assign({}, o, S.params),
          pathname: wl([
            c,
            r.encodeLocation
              ? r.encodeLocation(S.pathname).pathname
              : S.pathname,
          ]),
          pathnameBase:
            S.pathnameBase === "/"
              ? c
              : wl([
                  c,
                  r.encodeLocation
                    ? r.encodeLocation(S.pathnameBase).pathname
                    : S.pathnameBase,
                ]),
        })
      ),
    i,
    t,
    s
  );
  return e && w
    ? E.createElement(
        bv.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              ...p,
            },
            navigationType: "POP",
          },
        },
        w
      )
    : w;
}
function Lee() {
  let n = $ee(),
    e = Tee(n)
      ? `${n.status} ${n.statusText}`
      : n instanceof Error
      ? n.message
      : JSON.stringify(n),
    t = n instanceof Error ? n.stack : null,
    s = "rgba(200,200,200, 0.5)",
    r = { padding: "0.5rem", backgroundColor: s },
    i = { padding: "2px 4px", backgroundColor: s },
    a = null;
  return (
    console.error("Error handled by React Router default ErrorBoundary:", n),
    (a = E.createElement(
      E.Fragment,
      null,
      E.createElement("p", null, " Hey developer "),
      E.createElement(
        "p",
        null,
        "You can provide a way better UX than this when your app throws errors by providing your own ",
        E.createElement("code", { style: i }, "ErrorBoundary"),
        " or",
        " ",
        E.createElement("code", { style: i }, "errorElement"),
        " prop on your route."
      )
    )),
    E.createElement(
      E.Fragment,
      null,
      E.createElement("h2", null, "Unexpected Application Error!"),
      E.createElement("h3", { style: { fontStyle: "italic" } }, e),
      t ? E.createElement("pre", { style: r }, t) : null,
      a
    )
  );
}
var Dee = E.createElement(Lee, null),
  Pee = class extends E.Component {
    constructor(n) {
      super(n),
        (this.state = {
          location: n.location,
          revalidation: n.revalidation,
          error: n.error,
        });
    }
    static getDerivedStateFromError(n) {
      return { error: n };
    }
    static getDerivedStateFromProps(n, e) {
      return e.location !== n.location ||
        (e.revalidation !== "idle" && n.revalidation === "idle")
        ? { error: n.error, location: n.location, revalidation: n.revalidation }
        : {
            error: n.error !== void 0 ? n.error : e.error,
            location: e.location,
            revalidation: n.revalidation || e.revalidation,
          };
    }
    componentDidCatch(n, e) {
      console.error(
        "React Router caught the following error during render",
        n,
        e
      );
    }
    render() {
      return this.state.error !== void 0
        ? E.createElement(
            Ua.Provider,
            { value: this.props.routeContext },
            E.createElement(LI.Provider, {
              value: this.state.error,
              children: this.props.component,
            })
          )
        : this.props.children;
    }
  };
function Mee({ routeContext: n, match: e, children: t }) {
  let s = E.useContext(jf);
  return (
    s &&
      s.static &&
      s.staticContext &&
      (e.route.errorElement || e.route.ErrorBoundary) &&
      (s.staticContext._deepestRenderedBoundaryId = e.route.id),
    E.createElement(Ua.Provider, { value: n }, t)
  );
}
function Nee(n, e = [], t = null, s = null) {
  if (n == null) {
    if (!t) return null;
    if (t.errors) n = t.matches;
    else if (e.length === 0 && !t.initialized && t.matches.length > 0)
      n = t.matches;
    else return null;
  }
  let r = n,
    i = t?.errors;
  if (i != null) {
    let l = r.findIndex((c) => c.route.id && i?.[c.route.id] !== void 0);
    Zn(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        i
      ).join(",")}`
    ),
      (r = r.slice(0, Math.min(r.length, l + 1)));
  }
  let a = !1,
    o = -1;
  if (t)
    for (let l = 0; l < r.length; l++) {
      let c = r[l];
      if (
        ((c.route.HydrateFallback || c.route.hydrateFallbackElement) && (o = l),
        c.route.id)
      ) {
        let { loaderData: h, errors: m } = t,
          p =
            c.route.loader &&
            !h.hasOwnProperty(c.route.id) &&
            (!m || m[c.route.id] === void 0);
        if (c.route.lazy || p) {
          (a = !0), o >= 0 ? (r = r.slice(0, o + 1)) : (r = [r[0]]);
          break;
        }
      }
    }
  return r.reduceRight((l, c, h) => {
    let m,
      p = !1,
      g = null,
      y = null;
    t &&
      ((m = i && c.route.id ? i[c.route.id] : void 0),
      (g = c.route.errorElement || Dee),
      a &&
        (o < 0 && h === 0
          ? (v6(
              "route-fallback",
              !1,
              "No `HydrateFallback` element provided to render during initial hydration"
            ),
            (p = !0),
            (y = null))
          : o === h &&
            ((p = !0), (y = c.route.hydrateFallbackElement || null))));
    let b = e.concat(r.slice(0, h + 1)),
      w = () => {
        let S;
        return (
          m
            ? (S = g)
            : p
            ? (S = y)
            : c.route.Component
            ? (S = E.createElement(c.route.Component, null))
            : c.route.element
            ? (S = c.route.element)
            : (S = l),
          E.createElement(Mee, {
            match: c,
            routeContext: { outlet: l, matches: b, isDataRoute: t != null },
            children: S,
          })
        );
      };
    return t && (c.route.ErrorBoundary || c.route.errorElement || h === 0)
      ? E.createElement(Pee, {
          location: t.location,
          revalidation: t.revalidation,
          component: g,
          error: m,
          children: w(),
          routeContext: { outlet: null, matches: b, isDataRoute: !0 },
        })
      : w();
  }, null);
}
function DI(n) {
  return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Oee(n) {
  let e = E.useContext(jf);
  return Zn(e, DI(n)), e;
}
function jee(n) {
  let e = E.useContext(rE);
  return Zn(e, DI(n)), e;
}
function Fee(n) {
  let e = E.useContext(Ua);
  return Zn(e, DI(n)), e;
}
function PI(n) {
  let e = Fee(n),
    t = e.matches[e.matches.length - 1];
  return (
    Zn(
      t.route.id,
      `${n} can only be used on routes that contain a unique "id"`
    ),
    t.route.id
  );
}
function Uee() {
  return PI("useRouteId");
}
function $ee() {
  let n = E.useContext(LI),
    e = jee("useRouteError"),
    t = PI("useRouteError");
  return n !== void 0 ? n : e.errors?.[t];
}
function Bee() {
  let { router: n } = Oee("useNavigate"),
    e = PI("useNavigate"),
    t = E.useRef(!1);
  return (
    m6(() => {
      t.current = !0;
    }),
    E.useCallback(
      async (r, i = {}) => {
        ca(t.current, f6),
          t.current &&
            (typeof r == "number"
              ? n.navigate(r)
              : await n.navigate(r, { fromRouteId: e, ...i }));
      },
      [n, e]
    )
  );
}
var pj = {};
function v6(n, e, t) {
  !e && !pj[n] && ((pj[n] = !0), ca(!1, t));
}
E.memo(Hee);
function Hee({ routes: n, future: e, state: t }) {
  return g6(n, void 0, t, e);
}
function Vee({ to: n, replace: e, state: t, relative: s }) {
  Zn(
    Ff(),
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: r } = E.useContext(Fa);
  ca(
    !r,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: i } = E.useContext(Ua),
    { pathname: a } = Dr(),
    o = es(),
    l = II(n, CI(i), a, s === "path"),
    c = JSON.stringify(l);
  return (
    E.useEffect(() => {
      o(JSON.parse(c), { replace: e, state: t, relative: s });
    }, [o, c, s, e, t]),
    null
  );
}
function Yr(n) {
  Zn(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."
  );
}
function zee({
  basename: n = "/",
  children: e = null,
  location: t,
  navigationType: s = "POP",
  navigator: r,
  static: i = !1,
}) {
  Zn(
    !Ff(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let a = n.replace(/^\/*/, "/"),
    o = E.useMemo(
      () => ({ basename: a, navigator: r, static: i, future: {} }),
      [a, r, i]
    );
  typeof t == "string" && (t = Of(t));
  let {
      pathname: l = "/",
      search: c = "",
      hash: h = "",
      state: m = null,
      key: p = "default",
    } = t,
    g = E.useMemo(() => {
      let y = El(l, a);
      return y == null
        ? null
        : {
            location: { pathname: y, search: c, hash: h, state: m, key: p },
            navigationType: s,
          };
    }, [a, l, c, h, m, p, s]);
  return (
    ca(
      g != null,
      `<Router basename="${a}"> is not able to match the URL "${l}${c}${h}" because it does not start with the basename, so the <Router> won't render anything.`
    ),
    g == null
      ? null
      : E.createElement(
          Fa.Provider,
          { value: o },
          E.createElement(bv.Provider, { children: e, value: g })
        )
  );
}
function Gee({ children: n, location: e }) {
  return Iee(QA(n), e);
}
function QA(n, e = []) {
  let t = [];
  return (
    E.Children.forEach(n, (s, r) => {
      if (!E.isValidElement(s)) return;
      let i = [...e, r];
      if (s.type === E.Fragment) {
        t.push.apply(t, QA(s.props.children, i));
        return;
      }
      Zn(
        s.type === Yr,
        `[${
          typeof s.type == "string" ? s.type : s.type.name
        }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
      ),
        Zn(
          !s.props.index || !s.props.children,
          "An index route cannot have child routes."
        );
      let a = {
        id: s.props.id || i.join("-"),
        caseSensitive: s.props.caseSensitive,
        element: s.props.element,
        Component: s.props.Component,
        index: s.props.index,
        path: s.props.path,
        loader: s.props.loader,
        action: s.props.action,
        hydrateFallbackElement: s.props.hydrateFallbackElement,
        HydrateFallback: s.props.HydrateFallback,
        errorElement: s.props.errorElement,
        ErrorBoundary: s.props.ErrorBoundary,
        hasErrorBoundary:
          s.props.hasErrorBoundary === !0 ||
          s.props.ErrorBoundary != null ||
          s.props.errorElement != null,
        shouldRevalidate: s.props.shouldRevalidate,
        handle: s.props.handle,
        lazy: s.props.lazy,
      };
      s.props.children && (a.children = QA(s.props.children, i)), t.push(a);
    }),
    t
  );
}
var hb = "get",
  fb = "application/x-www-form-urlencoded";
function iE(n) {
  return n != null && typeof n.tagName == "string";
}
function qee(n) {
  return iE(n) && n.tagName.toLowerCase() === "button";
}
function Wee(n) {
  return iE(n) && n.tagName.toLowerCase() === "form";
}
function Kee(n) {
  return iE(n) && n.tagName.toLowerCase() === "input";
}
function Yee(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function Xee(n, e) {
  return n.button === 0 && (!e || e === "_self") && !Yee(n);
}
function ZA(n = "") {
  return new URLSearchParams(
    typeof n == "string" || Array.isArray(n) || n instanceof URLSearchParams
      ? n
      : Object.keys(n).reduce((e, t) => {
          let s = n[t];
          return e.concat(Array.isArray(s) ? s.map((r) => [t, r]) : [[t, s]]);
        }, [])
  );
}
function Qee(n, e) {
  let t = ZA(n);
  return (
    e &&
      e.forEach((s, r) => {
        t.has(r) ||
          e.getAll(r).forEach((i) => {
            t.append(r, i);
          });
      }),
    t
  );
}
var iy = null;
function Zee() {
  if (iy === null)
    try {
      new FormData(document.createElement("form"), 0), (iy = !1);
    } catch {
      iy = !0;
    }
  return iy;
}
var Jee = new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain",
]);
function j_(n) {
  return n != null && !Jee.has(n)
    ? (ca(
        !1,
        `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${fb}"`
      ),
      null)
    : n;
}
function ete(n, e) {
  let t, s, r, i, a;
  if (Wee(n)) {
    let o = n.getAttribute("action");
    (s = o ? El(o, e) : null),
      (t = n.getAttribute("method") || hb),
      (r = j_(n.getAttribute("enctype")) || fb),
      (i = new FormData(n));
  } else if (
    qee(n) ||
    (Kee(n) && (n.type === "submit" || n.type === "image"))
  ) {
    let o = n.form;
    if (o == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = n.getAttribute("formaction") || o.getAttribute("action");
    if (
      ((s = l ? El(l, e) : null),
      (t = n.getAttribute("formmethod") || o.getAttribute("method") || hb),
      (r =
        j_(n.getAttribute("formenctype")) ||
        j_(o.getAttribute("enctype")) ||
        fb),
      (i = new FormData(o, n)),
      !Zee())
    ) {
      let { name: c, type: h, value: m } = n;
      if (h === "image") {
        let p = c ? `${c}.` : "";
        i.append(`${p}x`, "0"), i.append(`${p}y`, "0");
      } else c && i.append(c, m);
    }
  } else {
    if (iE(n))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    (t = hb), (s = null), (r = fb), (a = n);
  }
  return (
    i && r === "text/plain" && ((a = i), (i = void 0)),
    { action: s, method: t.toLowerCase(), encType: r, formData: i, body: a }
  );
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function MI(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function tte(n, e, t) {
  let s =
    typeof n == "string"
      ? new URL(
          n,
          typeof window > "u" ? "server://singlefetch/" : window.location.origin
        )
      : n;
  return (
    s.pathname === "/"
      ? (s.pathname = `_root.${t}`)
      : e && El(s.pathname, e) === "/"
      ? (s.pathname = `${e.replace(/\/$/, "")}/_root.${t}`)
      : (s.pathname = `${s.pathname.replace(/\/$/, "")}.${t}`),
    s
  );
}
async function nte(n, e) {
  if (n.id in e) return e[n.id];
  try {
    let t = await import(n.module);
    return (e[n.id] = t), t;
  } catch (t) {
    return (
      console.error(
        `Error loading route module \`${n.module}\`, reloading page...`
      ),
      console.error(t),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
    );
  }
}
function ste(n) {
  return n == null
    ? !1
    : n.href == null
    ? n.rel === "preload" &&
      typeof n.imageSrcSet == "string" &&
      typeof n.imageSizes == "string"
    : typeof n.rel == "string" && typeof n.href == "string";
}
async function rte(n, e, t) {
  let s = await Promise.all(
    n.map(async (r) => {
      let i = e.routes[r.route.id];
      if (i) {
        let a = await nte(i, t);
        return a.links ? a.links() : [];
      }
      return [];
    })
  );
  return lte(
    s
      .flat(1)
      .filter(ste)
      .filter((r) => r.rel === "stylesheet" || r.rel === "preload")
      .map((r) =>
        r.rel === "stylesheet"
          ? { ...r, rel: "prefetch", as: "style" }
          : { ...r, rel: "prefetch" }
      )
  );
}
function gj(n, e, t, s, r, i) {
  let a = (l, c) => (t[c] ? l.route.id !== t[c].route.id : !0),
    o = (l, c) =>
      t[c].pathname !== l.pathname ||
      (t[c].route.path?.endsWith("*") && t[c].params["*"] !== l.params["*"]);
  return i === "assets"
    ? e.filter((l, c) => a(l, c) || o(l, c))
    : i === "data"
    ? e.filter((l, c) => {
        let h = s.routes[l.route.id];
        if (!h || !h.hasLoader) return !1;
        if (a(l, c) || o(l, c)) return !0;
        if (l.route.shouldRevalidate) {
          let m = l.route.shouldRevalidate({
            currentUrl: new URL(r.pathname + r.search + r.hash, window.origin),
            currentParams: t[0]?.params || {},
            nextUrl: new URL(n, window.origin),
            nextParams: l.params,
            defaultShouldRevalidate: !0,
          });
          if (typeof m == "boolean") return m;
        }
        return !0;
      })
    : [];
}
function ite(n, e, { includeHydrateFallback: t } = {}) {
  return ate(
    n
      .map((s) => {
        let r = e.routes[s.route.id];
        if (!r) return [];
        let i = [r.module];
        return (
          r.clientActionModule && (i = i.concat(r.clientActionModule)),
          r.clientLoaderModule && (i = i.concat(r.clientLoaderModule)),
          t &&
            r.hydrateFallbackModule &&
            (i = i.concat(r.hydrateFallbackModule)),
          r.imports && (i = i.concat(r.imports)),
          i
        );
      })
      .flat(1)
  );
}
function ate(n) {
  return [...new Set(n)];
}
function ote(n) {
  let e = {},
    t = Object.keys(n).sort();
  for (let s of t) e[s] = n[s];
  return e;
}
function lte(n, e) {
  let t = new Set();
  return (
    new Set(e),
    n.reduce((s, r) => {
      let i = JSON.stringify(ote(r));
      return t.has(i) || (t.add(i), s.push({ key: i, link: r })), s;
    }, [])
  );
}
function y6() {
  let n = E.useContext(jf);
  return (
    MI(
      n,
      "You must render this element inside a <DataRouterContext.Provider> element"
    ),
    n
  );
}
function cte() {
  let n = E.useContext(rE);
  return (
    MI(
      n,
      "You must render this element inside a <DataRouterStateContext.Provider> element"
    ),
    n
  );
}
var NI = E.createContext(void 0);
NI.displayName = "FrameworkContext";
function b6() {
  let n = E.useContext(NI);
  return (
    MI(n, "You must render this element inside a <HydratedRouter> element"), n
  );
}
function ute(n, e) {
  let t = E.useContext(NI),
    [s, r] = E.useState(!1),
    [i, a] = E.useState(!1),
    {
      onFocus: o,
      onBlur: l,
      onMouseEnter: c,
      onMouseLeave: h,
      onTouchStart: m,
    } = e,
    p = E.useRef(null);
  E.useEffect(() => {
    if ((n === "render" && a(!0), n === "viewport")) {
      let b = (S) => {
          S.forEach((A) => {
            a(A.isIntersecting);
          });
        },
        w = new IntersectionObserver(b, { threshold: 0.5 });
      return (
        p.current && w.observe(p.current),
        () => {
          w.disconnect();
        }
      );
    }
  }, [n]),
    E.useEffect(() => {
      if (s) {
        let b = setTimeout(() => {
          a(!0);
        }, 100);
        return () => {
          clearTimeout(b);
        };
      }
    }, [s]);
  let g = () => {
      r(!0);
    },
    y = () => {
      r(!1), a(!1);
    };
  return t
    ? n !== "intent"
      ? [i, p, {}]
      : [
          i,
          p,
          {
            onFocus: Qm(o, g),
            onBlur: Qm(l, y),
            onMouseEnter: Qm(c, g),
            onMouseLeave: Qm(h, y),
            onTouchStart: Qm(m, g),
          },
        ]
    : [!1, p, {}];
}
function Qm(n, e) {
  return (t) => {
    n && n(t), t.defaultPrevented || e(t);
  };
}
function dte({ page: n, ...e }) {
  let { router: t } = y6(),
    s = E.useMemo(() => l6(t.routes, n, t.basename), [t.routes, n, t.basename]);
  return s ? E.createElement(fte, { page: n, matches: s, ...e }) : null;
}
function hte(n) {
  let { manifest: e, routeModules: t } = b6(),
    [s, r] = E.useState([]);
  return (
    E.useEffect(() => {
      let i = !1;
      return (
        rte(n, e, t).then((a) => {
          i || r(a);
        }),
        () => {
          i = !0;
        }
      );
    }, [n, e, t]),
    s
  );
}
function fte({ page: n, matches: e, ...t }) {
  let s = Dr(),
    { manifest: r, routeModules: i } = b6(),
    { basename: a } = y6(),
    { loaderData: o, matches: l } = cte(),
    c = E.useMemo(() => gj(n, e, l, r, s, "data"), [n, e, l, r, s]),
    h = E.useMemo(() => gj(n, e, l, r, s, "assets"), [n, e, l, r, s]),
    m = E.useMemo(() => {
      if (n === s.pathname + s.search + s.hash) return [];
      let y = new Set(),
        b = !1;
      if (
        (e.forEach((S) => {
          let A = r.routes[S.route.id];
          !A ||
            !A.hasLoader ||
            ((!c.some((_) => _.route.id === S.route.id) &&
              S.route.id in o &&
              i[S.route.id]?.shouldRevalidate) ||
            A.hasClientLoader
              ? (b = !0)
              : y.add(S.route.id));
        }),
        y.size === 0)
      )
        return [];
      let w = tte(n, a, "data");
      return (
        b &&
          y.size > 0 &&
          w.searchParams.set(
            "_routes",
            e
              .filter((S) => y.has(S.route.id))
              .map((S) => S.route.id)
              .join(",")
          ),
        [w.pathname + w.search]
      );
    }, [a, o, s, r, c, e, n, i]),
    p = E.useMemo(() => ite(h, r), [h, r]),
    g = hte(h);
  return E.createElement(
    E.Fragment,
    null,
    m.map((y) =>
      E.createElement("link", {
        key: y,
        rel: "prefetch",
        as: "fetch",
        href: y,
        ...t,
      })
    ),
    p.map((y) =>
      E.createElement("link", { key: y, rel: "modulepreload", href: y, ...t })
    ),
    g.map(({ key: y, link: b }) => E.createElement("link", { key: y, ...b }))
  );
}
function mte(...n) {
  return (e) => {
    n.forEach((t) => {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
var x6 =
  typeof window < "u" &&
  typeof window.document < "u" &&
  typeof window.document.createElement < "u";
try {
  x6 && (window.__reactRouterVersion = "7.7.1");
} catch {}
function pte({ basename: n, children: e, window: t }) {
  let s = E.useRef();
  s.current == null && (s.current = tee({ window: t, v5Compat: !0 }));
  let r = s.current,
    [i, a] = E.useState({ action: r.action, location: r.location }),
    o = E.useCallback(
      (l) => {
        E.startTransition(() => a(l));
      },
      [a]
    );
  return (
    E.useLayoutEffect(() => r.listen(o), [r, o]),
    E.createElement(zee, {
      basename: n,
      children: e,
      location: i.location,
      navigationType: i.action,
      navigator: r,
    })
  );
}
var w6 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  br = E.forwardRef(function (
    {
      onClick: e,
      discover: t = "render",
      prefetch: s = "none",
      relative: r,
      reloadDocument: i,
      replace: a,
      state: o,
      target: l,
      to: c,
      preventScrollReset: h,
      viewTransition: m,
      ...p
    },
    g
  ) {
    let { basename: y } = E.useContext(Fa),
      b = typeof c == "string" && w6.test(c),
      w,
      S = !1;
    if (typeof c == "string" && b && ((w = c), x6))
      try {
        let V = new URL(window.location.href),
          N = c.startsWith("//") ? new URL(V.protocol + c) : new URL(c),
          W = El(N.pathname, y);
        N.origin === V.origin && W != null
          ? (c = W + N.search + N.hash)
          : (S = !0);
      } catch {
        ca(
          !1,
          `<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let A = kee(c, { relative: r }),
      [_, R, C] = ute(s, p),
      D = bte(c, {
        replace: a,
        state: o,
        target: l,
        preventScrollReset: h,
        relative: r,
        viewTransition: m,
      });
    function L(V) {
      e && e(V), V.defaultPrevented || D(V);
    }
    let P = E.createElement("a", {
      ...p,
      ...C,
      href: w || A,
      onClick: S || i ? e : L,
      ref: mte(g, R),
      target: l,
      "data-discover": !b && t === "render" ? "true" : void 0,
    });
    return _ && !b
      ? E.createElement(E.Fragment, null, P, E.createElement(dte, { page: A }))
      : P;
  });
br.displayName = "Link";
var gte = E.forwardRef(function (
  {
    "aria-current": e = "page",
    caseSensitive: t = !1,
    className: s = "",
    end: r = !1,
    style: i,
    to: a,
    viewTransition: o,
    children: l,
    ...c
  },
  h
) {
  let m = xv(a, { relative: c.relative }),
    p = Dr(),
    g = E.useContext(rE),
    { navigator: y, basename: b } = E.useContext(Fa),
    w = g != null && Tte(m) && o === !0,
    S = y.encodeLocation ? y.encodeLocation(m).pathname : m.pathname,
    A = p.pathname,
    _ =
      g && g.navigation && g.navigation.location
        ? g.navigation.location.pathname
        : null;
  t ||
    ((A = A.toLowerCase()),
    (_ = _ ? _.toLowerCase() : null),
    (S = S.toLowerCase())),
    _ && b && (_ = El(_, b) || _);
  const R = S !== "/" && S.endsWith("/") ? S.length - 1 : S.length;
  let C = A === S || (!r && A.startsWith(S) && A.charAt(R) === "/"),
    D =
      _ != null &&
      (_ === S || (!r && _.startsWith(S) && _.charAt(S.length) === "/")),
    L = { isActive: C, isPending: D, isTransitioning: w },
    P = C ? e : void 0,
    V;
  typeof s == "function"
    ? (V = s(L))
    : (V = [
        s,
        C ? "active" : null,
        D ? "pending" : null,
        w ? "transitioning" : null,
      ]
        .filter(Boolean)
        .join(" "));
  let N = typeof i == "function" ? i(L) : i;
  return E.createElement(
    br,
    {
      ...c,
      "aria-current": P,
      className: V,
      ref: h,
      style: N,
      to: a,
      viewTransition: o,
    },
    typeof l == "function" ? l(L) : l
  );
});
gte.displayName = "NavLink";
var vte = E.forwardRef(
  (
    {
      discover: n = "render",
      fetcherKey: e,
      navigate: t,
      reloadDocument: s,
      replace: r,
      state: i,
      method: a = hb,
      action: o,
      onSubmit: l,
      relative: c,
      preventScrollReset: h,
      viewTransition: m,
      ...p
    },
    g
  ) => {
    let y = Ete(),
      b = Ste(o, { relative: c }),
      w = a.toLowerCase() === "get" ? "get" : "post",
      S = typeof o == "string" && w6.test(o),
      A = (_) => {
        if ((l && l(_), _.defaultPrevented)) return;
        _.preventDefault();
        let R = _.nativeEvent.submitter,
          C = R?.getAttribute("formmethod") || a;
        y(R || _.currentTarget, {
          fetcherKey: e,
          method: C,
          navigate: t,
          replace: r,
          state: i,
          relative: c,
          preventScrollReset: h,
          viewTransition: m,
        });
      };
    return E.createElement("form", {
      ref: g,
      method: w,
      action: b,
      onSubmit: s ? l : A,
      ...p,
      "data-discover": !S && n === "render" ? "true" : void 0,
    });
  }
);
vte.displayName = "Form";
function yte(n) {
  return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function E6(n) {
  let e = E.useContext(jf);
  return Zn(e, yte(n)), e;
}
function bte(
  n,
  {
    target: e,
    replace: t,
    state: s,
    preventScrollReset: r,
    relative: i,
    viewTransition: a,
  } = {}
) {
  let o = es(),
    l = Dr(),
    c = xv(n, { relative: i });
  return E.useCallback(
    (h) => {
      if (Xee(h, e)) {
        h.preventDefault();
        let m = t !== void 0 ? t : yg(l) === yg(c);
        o(n, {
          replace: m,
          state: s,
          preventScrollReset: r,
          relative: i,
          viewTransition: a,
        });
      }
    },
    [l, o, c, t, s, e, n, r, i, a]
  );
}
function od(n) {
  ca(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let e = E.useRef(ZA(n)),
    t = E.useRef(!1),
    s = Dr(),
    r = E.useMemo(
      () => Qee(s.search, t.current ? null : e.current),
      [s.search]
    ),
    i = es(),
    a = E.useCallback(
      (o, l) => {
        const c = ZA(typeof o == "function" ? o(new URLSearchParams(r)) : o);
        (t.current = !0), i("?" + c, l);
      },
      [i, r]
    );
  return [r, a];
}
var xte = 0,
  wte = () => `__${String(++xte)}__`;
function Ete() {
  let { router: n } = E6("useSubmit"),
    { basename: e } = E.useContext(Fa),
    t = Uee();
  return E.useCallback(
    async (s, r = {}) => {
      let {
        action: i,
        method: a,
        encType: o,
        formData: l,
        body: c,
      } = ete(s, e);
      if (r.navigate === !1) {
        let h = r.fetcherKey || wte();
        await n.fetch(h, t, r.action || i, {
          preventScrollReset: r.preventScrollReset,
          formData: l,
          body: c,
          formMethod: r.method || a,
          formEncType: r.encType || o,
          flushSync: r.flushSync,
        });
      } else
        await n.navigate(r.action || i, {
          preventScrollReset: r.preventScrollReset,
          formData: l,
          body: c,
          formMethod: r.method || a,
          formEncType: r.encType || o,
          replace: r.replace,
          state: r.state,
          fromRouteId: t,
          flushSync: r.flushSync,
          viewTransition: r.viewTransition,
        });
    },
    [n, e, t]
  );
}
function Ste(n, { relative: e } = {}) {
  let { basename: t } = E.useContext(Fa),
    s = E.useContext(Ua);
  Zn(s, "useFormAction must be used inside a RouteContext");
  let [r] = s.matches.slice(-1),
    i = { ...xv(n || ".", { relative: e }) },
    a = Dr();
  if (n == null) {
    i.search = a.search;
    let o = new URLSearchParams(i.search),
      l = o.getAll("index");
    if (l.some((h) => h === "")) {
      o.delete("index"),
        l.filter((m) => m).forEach((m) => o.append("index", m));
      let h = o.toString();
      i.search = h ? `?${h}` : "";
    }
  }
  return (
    (!n || n === ".") &&
      r.route.index &&
      (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (i.pathname = i.pathname === "/" ? t : wl([t, i.pathname])),
    yg(i)
  );
}
function Tte(n, { relative: e } = {}) {
  let t = E.useContext(h6);
  Zn(
    t != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: s } = E6("useViewTransitionState"),
    r = xv(n, { relative: e });
  if (!t.isTransitioning) return !1;
  let i = El(t.currentLocation.pathname, s) || t.currentLocation.pathname,
    a = El(t.nextLocation.pathname, s) || t.nextLocation.pathname;
  return cx(r.pathname, a) != null || cx(r.pathname, i) != null;
}
var Zm = {},
  vj;
function _te() {
  if (vj) return Zm;
  (vj = 1),
    Object.defineProperty(Zm, "__esModule", { value: !0 }),
    (Zm.parse = a),
    (Zm.serialize = c);
  const n = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
    e = /^[\u0021-\u003A\u003C-\u007E]*$/,
    t =
      /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    s = /^[\u0020-\u003A\u003D-\u007E]*$/,
    r = Object.prototype.toString,
    i = (() => {
      const p = function () {};
      return (p.prototype = Object.create(null)), p;
    })();
  function a(p, g) {
    const y = new i(),
      b = p.length;
    if (b < 2) return y;
    const w = g?.decode || h;
    let S = 0;
    do {
      const A = p.indexOf("=", S);
      if (A === -1) break;
      const _ = p.indexOf(";", S),
        R = _ === -1 ? b : _;
      if (A > R) {
        S = p.lastIndexOf(";", A - 1) + 1;
        continue;
      }
      const C = o(p, S, A),
        D = l(p, A, C),
        L = p.slice(C, D);
      if (y[L] === void 0) {
        let P = o(p, A + 1, R),
          V = l(p, R, P);
        const N = w(p.slice(P, V));
        y[L] = N;
      }
      S = R + 1;
    } while (S < b);
    return y;
  }
  function o(p, g, y) {
    do {
      const b = p.charCodeAt(g);
      if (b !== 32 && b !== 9) return g;
    } while (++g < y);
    return y;
  }
  function l(p, g, y) {
    for (; g > y; ) {
      const b = p.charCodeAt(--g);
      if (b !== 32 && b !== 9) return g + 1;
    }
    return y;
  }
  function c(p, g, y) {
    const b = y?.encode || encodeURIComponent;
    if (!n.test(p)) throw new TypeError(`argument name is invalid: ${p}`);
    const w = b(g);
    if (!e.test(w)) throw new TypeError(`argument val is invalid: ${g}`);
    let S = p + "=" + w;
    if (!y) return S;
    if (y.maxAge !== void 0) {
      if (!Number.isInteger(y.maxAge))
        throw new TypeError(`option maxAge is invalid: ${y.maxAge}`);
      S += "; Max-Age=" + y.maxAge;
    }
    if (y.domain) {
      if (!t.test(y.domain))
        throw new TypeError(`option domain is invalid: ${y.domain}`);
      S += "; Domain=" + y.domain;
    }
    if (y.path) {
      if (!s.test(y.path))
        throw new TypeError(`option path is invalid: ${y.path}`);
      S += "; Path=" + y.path;
    }
    if (y.expires) {
      if (!m(y.expires) || !Number.isFinite(y.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${y.expires}`);
      S += "; Expires=" + y.expires.toUTCString();
    }
    if (
      (y.httpOnly && (S += "; HttpOnly"),
      y.secure && (S += "; Secure"),
      y.partitioned && (S += "; Partitioned"),
      y.priority)
    )
      switch (
        typeof y.priority == "string" ? y.priority.toLowerCase() : void 0
      ) {
        case "low":
          S += "; Priority=Low";
          break;
        case "medium":
          S += "; Priority=Medium";
          break;
        case "high":
          S += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${y.priority}`);
      }
    if (y.sameSite)
      switch (
        typeof y.sameSite == "string" ? y.sameSite.toLowerCase() : y.sameSite
      ) {
        case !0:
        case "strict":
          S += "; SameSite=Strict";
          break;
        case "lax":
          S += "; SameSite=Lax";
          break;
        case "none":
          S += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${y.sameSite}`);
      }
    return S;
  }
  function h(p) {
    if (p.indexOf("%") === -1) return p;
    try {
      return decodeURIComponent(p);
    } catch {
      return p;
    }
  }
  function m(p) {
    return r.call(p) === "[object Date]";
  }
  return Zm;
}
var yj = _te(),
  ri = Z5();
const S6 = ad(ri);
var wv = class {
    constructor() {
      (this.listeners = new Set()),
        (this.subscribe = this.subscribe.bind(this));
    }
    subscribe(n) {
      return (
        this.listeners.add(n),
        this.onSubscribe(),
        () => {
          this.listeners.delete(n), this.onUnsubscribe();
        }
      );
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  Wu = typeof window > "u" || "Deno" in globalThis;
function Jr() {}
function Ate(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function JA(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
function T6(n, e) {
  return Math.max(n + (e || 0) - Date.now(), 0);
}
function kc(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Qi(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function bj(n, e) {
  const {
    type: t = "all",
    exact: s,
    fetchStatus: r,
    predicate: i,
    queryKey: a,
    stale: o,
  } = n;
  if (a) {
    if (s) {
      if (e.queryHash !== OI(a, e.options)) return !1;
    } else if (!xg(e.queryKey, a)) return !1;
  }
  if (t !== "all") {
    const l = e.isActive();
    if ((t === "active" && !l) || (t === "inactive" && l)) return !1;
  }
  return !(
    (typeof o == "boolean" && e.isStale() !== o) ||
    (r && r !== e.state.fetchStatus) ||
    (i && !i(e))
  );
}
function xj(n, e) {
  const { exact: t, status: s, predicate: r, mutationKey: i } = n;
  if (i) {
    if (!e.options.mutationKey) return !1;
    if (t) {
      if (bg(e.options.mutationKey) !== bg(i)) return !1;
    } else if (!xg(e.options.mutationKey, i)) return !1;
  }
  return !((s && e.state.status !== s) || (r && !r(e)));
}
function OI(n, e) {
  return (e?.queryKeyHashFn || bg)(n);
}
function bg(n) {
  return JSON.stringify(n, (e, t) =>
    tR(t)
      ? Object.keys(t)
          .sort()
          .reduce((s, r) => ((s[r] = t[r]), s), {})
      : t
  );
}
function xg(n, e) {
  return n === e
    ? !0
    : typeof n != typeof e
    ? !1
    : n && e && typeof n == "object" && typeof e == "object"
    ? Object.keys(e).every((t) => xg(n[t], e[t]))
    : !1;
}
function _6(n, e) {
  if (n === e) return n;
  const t = wj(n) && wj(e);
  if (t || (tR(n) && tR(e))) {
    const s = t ? n : Object.keys(n),
      r = s.length,
      i = t ? e : Object.keys(e),
      a = i.length,
      o = t ? [] : {},
      l = new Set(s);
    let c = 0;
    for (let h = 0; h < a; h++) {
      const m = t ? h : i[h];
      ((!t && l.has(m)) || t) && n[m] === void 0 && e[m] === void 0
        ? ((o[m] = void 0), c++)
        : ((o[m] = _6(n[m], e[m])), o[m] === n[m] && n[m] !== void 0 && c++);
    }
    return r === a && c === r ? n : o;
  }
  return e;
}
function eR(n, e) {
  if (!e || Object.keys(n).length !== Object.keys(e).length) return !1;
  for (const t in n) if (n[t] !== e[t]) return !1;
  return !0;
}
function wj(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function tR(n) {
  if (!Ej(n)) return !1;
  const e = n.constructor;
  if (e === void 0) return !0;
  const t = e.prototype;
  return !(
    !Ej(t) ||
    !t.hasOwnProperty("isPrototypeOf") ||
    Object.getPrototypeOf(n) !== Object.prototype
  );
}
function Ej(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function Rte(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function nR(n, e, t) {
  return typeof t.structuralSharing == "function"
    ? t.structuralSharing(n, e)
    : t.structuralSharing !== !1
    ? _6(n, e)
    : e;
}
function kte(n, e, t = 0) {
  const s = [...n, e];
  return t && s.length > t ? s.slice(1) : s;
}
function Cte(n, e, t = 0) {
  const s = [e, ...n];
  return t && s.length > t ? s.slice(0, -1) : s;
}
var jI = Symbol();
function A6(n, e) {
  return !n.queryFn && e?.initialPromise
    ? () => e.initialPromise
    : !n.queryFn || n.queryFn === jI
    ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`))
    : n.queryFn;
}
function Ite(n, e) {
  return typeof n == "function" ? n(...e) : !!n;
}
var Lte = class extends wv {
    #e;
    #t;
    #n;
    constructor() {
      super(),
        (this.#n = (n) => {
          if (!Wu && window.addEventListener) {
            const e = () => n();
            return (
              window.addEventListener("visibilitychange", e, !1),
              () => {
                window.removeEventListener("visibilitychange", e);
              }
            );
          }
        });
    }
    onSubscribe() {
      this.#t || this.setEventListener(this.#n);
    }
    onUnsubscribe() {
      this.hasListeners() || (this.#t?.(), (this.#t = void 0));
    }
    setEventListener(n) {
      (this.#n = n),
        this.#t?.(),
        (this.#t = n((e) => {
          typeof e == "boolean" ? this.setFocused(e) : this.onFocus();
        }));
    }
    setFocused(n) {
      this.#e !== n && ((this.#e = n), this.onFocus());
    }
    onFocus() {
      const n = this.isFocused();
      this.listeners.forEach((e) => {
        e(n);
      });
    }
    isFocused() {
      return typeof this.#e == "boolean"
        ? this.#e
        : globalThis.document?.visibilityState !== "hidden";
    }
  },
  FI = new Lte(),
  Dte = class extends wv {
    #e = !0;
    #t;
    #n;
    constructor() {
      super(),
        (this.#n = (n) => {
          if (!Wu && window.addEventListener) {
            const e = () => n(!0),
              t = () => n(!1);
            return (
              window.addEventListener("online", e, !1),
              window.addEventListener("offline", t, !1),
              () => {
                window.removeEventListener("online", e),
                  window.removeEventListener("offline", t);
              }
            );
          }
        });
    }
    onSubscribe() {
      this.#t || this.setEventListener(this.#n);
    }
    onUnsubscribe() {
      this.hasListeners() || (this.#t?.(), (this.#t = void 0));
    }
    setEventListener(n) {
      (this.#n = n), this.#t?.(), (this.#t = n(this.setOnline.bind(this)));
    }
    setOnline(n) {
      this.#e !== n &&
        ((this.#e = n),
        this.listeners.forEach((t) => {
          t(n);
        }));
    }
    isOnline() {
      return this.#e;
    }
  },
  ux = new Dte();
function sR() {
  let n, e;
  const t = new Promise((r, i) => {
    (n = r), (e = i);
  });
  (t.status = "pending"), t.catch(() => {});
  function s(r) {
    Object.assign(t, r), delete t.resolve, delete t.reject;
  }
  return (
    (t.resolve = (r) => {
      s({ status: "fulfilled", value: r }), n(r);
    }),
    (t.reject = (r) => {
      s({ status: "rejected", reason: r }), e(r);
    }),
    t
  );
}
function Pte(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
function R6(n) {
  return (n ?? "online") === "online" ? ux.isOnline() : !0;
}
var k6 = class extends Error {
  constructor(n) {
    super("CancelledError"),
      (this.revert = n?.revert),
      (this.silent = n?.silent);
  }
};
function F_(n) {
  return n instanceof k6;
}
function C6(n) {
  let e = !1,
    t = 0,
    s = !1,
    r;
  const i = sR(),
    a = (b) => {
      s || (p(new k6(b)), n.abort?.());
    },
    o = () => {
      e = !0;
    },
    l = () => {
      e = !1;
    },
    c = () =>
      FI.isFocused() &&
      (n.networkMode === "always" || ux.isOnline()) &&
      n.canRun(),
    h = () => R6(n.networkMode) && n.canRun(),
    m = (b) => {
      s || ((s = !0), n.onSuccess?.(b), r?.(), i.resolve(b));
    },
    p = (b) => {
      s || ((s = !0), n.onError?.(b), r?.(), i.reject(b));
    },
    g = () =>
      new Promise((b) => {
        (r = (w) => {
          (s || c()) && b(w);
        }),
          n.onPause?.();
      }).then(() => {
        (r = void 0), s || n.onContinue?.();
      }),
    y = () => {
      if (s) return;
      let b;
      const w = t === 0 ? n.initialPromise : void 0;
      try {
        b = w ?? n.fn();
      } catch (S) {
        b = Promise.reject(S);
      }
      Promise.resolve(b)
        .then(m)
        .catch((S) => {
          if (s) return;
          const A = n.retry ?? (Wu ? 0 : 3),
            _ = n.retryDelay ?? Pte,
            R = typeof _ == "function" ? _(t, S) : _,
            C =
              A === !0 ||
              (typeof A == "number" && t < A) ||
              (typeof A == "function" && A(t, S));
          if (e || !C) {
            p(S);
            return;
          }
          t++,
            n.onFail?.(t, S),
            Rte(R)
              .then(() => (c() ? void 0 : g()))
              .then(() => {
                e ? p(S) : y();
              });
        });
    };
  return {
    promise: i,
    cancel: a,
    continue: () => (r?.(), i),
    cancelRetry: o,
    continueRetry: l,
    canStart: h,
    start: () => (h() ? y() : g().then(y), i),
  };
}
var Mte = (n) => setTimeout(n, 0);
function Nte() {
  let n = [],
    e = 0,
    t = (o) => {
      o();
    },
    s = (o) => {
      o();
    },
    r = Mte;
  const i = (o) => {
      e
        ? n.push(o)
        : r(() => {
            t(o);
          });
    },
    a = () => {
      const o = n;
      (n = []),
        o.length &&
          r(() => {
            s(() => {
              o.forEach((l) => {
                t(l);
              });
            });
          });
    };
  return {
    batch: (o) => {
      let l;
      e++;
      try {
        l = o();
      } finally {
        e--, e || a();
      }
      return l;
    },
    batchCalls:
      (o) =>
      (...l) => {
        i(() => {
          o(...l);
        });
      },
    schedule: i,
    setNotifyFunction: (o) => {
      t = o;
    },
    setBatchNotifyFunction: (o) => {
      s = o;
    },
    setScheduler: (o) => {
      r = o;
    },
  };
}
var yr = Nte(),
  I6 = class {
    #e;
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout(),
        JA(this.gcTime) &&
          (this.#e = setTimeout(() => {
            this.optionalRemove();
          }, this.gcTime));
    }
    updateGcTime(n) {
      this.gcTime = Math.max(this.gcTime || 0, n ?? (Wu ? 1 / 0 : 300 * 1e3));
    }
    clearGcTimeout() {
      this.#e && (clearTimeout(this.#e), (this.#e = void 0));
    }
  },
  Ote = class extends I6 {
    #e;
    #t;
    #n;
    #s;
    #r;
    #o;
    #i;
    constructor(n) {
      super(),
        (this.#i = !1),
        (this.#o = n.defaultOptions),
        this.setOptions(n.options),
        (this.observers = []),
        (this.#s = n.client),
        (this.#n = this.#s.getQueryCache()),
        (this.queryKey = n.queryKey),
        (this.queryHash = n.queryHash),
        (this.#e = jte(this.options)),
        (this.state = n.state ?? this.#e),
        this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      return this.#r?.promise;
    }
    setOptions(n) {
      (this.options = { ...this.#o, ...n }),
        this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      !this.observers.length &&
        this.state.fetchStatus === "idle" &&
        this.#n.remove(this);
    }
    setData(n, e) {
      const t = nR(this.state.data, n, this.options);
      return (
        this.#a({
          data: t,
          type: "success",
          dataUpdatedAt: e?.updatedAt,
          manual: e?.manual,
        }),
        t
      );
    }
    setState(n, e) {
      this.#a({ type: "setState", state: n, setStateOptions: e });
    }
    cancel(n) {
      const e = this.#r?.promise;
      return this.#r?.cancel(n), e ? e.then(Jr).catch(Jr) : Promise.resolve();
    }
    destroy() {
      super.destroy(), this.cancel({ silent: !0 });
    }
    reset() {
      this.destroy(), this.setState(this.#e);
    }
    isActive() {
      return this.observers.some((n) => Qi(n.options.enabled, this) !== !1);
    }
    isDisabled() {
      return this.getObserversCount() > 0
        ? !this.isActive()
        : this.options.queryFn === jI ||
            this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
    }
    isStatic() {
      return this.getObserversCount() > 0
        ? this.observers.some((n) => kc(n.options.staleTime, this) === "static")
        : !1;
    }
    isStale() {
      return this.getObserversCount() > 0
        ? this.observers.some((n) => n.getCurrentResult().isStale)
        : this.state.data === void 0 || this.state.isInvalidated;
    }
    isStaleByTime(n = 0) {
      return this.state.data === void 0
        ? !0
        : n === "static"
        ? !1
        : this.state.isInvalidated
        ? !0
        : !T6(this.state.dataUpdatedAt, n);
    }
    onFocus() {
      this.observers
        .find((e) => e.shouldFetchOnWindowFocus())
        ?.refetch({ cancelRefetch: !1 }),
        this.#r?.continue();
    }
    onOnline() {
      this.observers
        .find((e) => e.shouldFetchOnReconnect())
        ?.refetch({ cancelRefetch: !1 }),
        this.#r?.continue();
    }
    addObserver(n) {
      this.observers.includes(n) ||
        (this.observers.push(n),
        this.clearGcTimeout(),
        this.#n.notify({ type: "observerAdded", query: this, observer: n }));
    }
    removeObserver(n) {
      this.observers.includes(n) &&
        ((this.observers = this.observers.filter((e) => e !== n)),
        this.observers.length ||
          (this.#r &&
            (this.#i ? this.#r.cancel({ revert: !0 }) : this.#r.cancelRetry()),
          this.scheduleGc()),
        this.#n.notify({ type: "observerRemoved", query: this, observer: n }));
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      this.state.isInvalidated || this.#a({ type: "invalidate" });
    }
    fetch(n, e) {
      if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && e?.cancelRefetch)
          this.cancel({ silent: !0 });
        else if (this.#r) return this.#r.continueRetry(), this.#r.promise;
      }
      if ((n && this.setOptions(n), !this.options.queryFn)) {
        const l = this.observers.find((c) => c.options.queryFn);
        l && this.setOptions(l.options);
      }
      const t = new AbortController(),
        s = (l) => {
          Object.defineProperty(l, "signal", {
            enumerable: !0,
            get: () => ((this.#i = !0), t.signal),
          });
        },
        r = () => {
          const l = A6(this.options, e),
            h = (() => {
              const m = {
                client: this.#s,
                queryKey: this.queryKey,
                meta: this.meta,
              };
              return s(m), m;
            })();
          return (
            (this.#i = !1),
            this.options.persister ? this.options.persister(l, h, this) : l(h)
          );
        },
        a = (() => {
          const l = {
            fetchOptions: e,
            options: this.options,
            queryKey: this.queryKey,
            client: this.#s,
            state: this.state,
            fetchFn: r,
          };
          return s(l), l;
        })();
      this.options.behavior?.onFetch(a, this),
        (this.#t = this.state),
        (this.state.fetchStatus === "idle" ||
          this.state.fetchMeta !== a.fetchOptions?.meta) &&
          this.#a({ type: "fetch", meta: a.fetchOptions?.meta });
      const o = (l) => {
        (F_(l) && l.silent) || this.#a({ type: "error", error: l }),
          F_(l) ||
            (this.#n.config.onError?.(l, this),
            this.#n.config.onSettled?.(this.state.data, l, this)),
          this.scheduleGc();
      };
      return (
        (this.#r = C6({
          initialPromise: e?.initialPromise,
          fn: a.fetchFn,
          abort: t.abort.bind(t),
          onSuccess: (l) => {
            if (l === void 0) {
              o(new Error(`${this.queryHash} data is undefined`));
              return;
            }
            try {
              this.setData(l);
            } catch (c) {
              o(c);
              return;
            }
            this.#n.config.onSuccess?.(l, this),
              this.#n.config.onSettled?.(l, this.state.error, this),
              this.scheduleGc();
          },
          onError: o,
          onFail: (l, c) => {
            this.#a({ type: "failed", failureCount: l, error: c });
          },
          onPause: () => {
            this.#a({ type: "pause" });
          },
          onContinue: () => {
            this.#a({ type: "continue" });
          },
          retry: a.options.retry,
          retryDelay: a.options.retryDelay,
          networkMode: a.options.networkMode,
          canRun: () => !0,
        })),
        this.#r.start()
      );
    }
    #a(n) {
      const e = (t) => {
        switch (n.type) {
          case "failed":
            return {
              ...t,
              fetchFailureCount: n.failureCount,
              fetchFailureReason: n.error,
            };
          case "pause":
            return { ...t, fetchStatus: "paused" };
          case "continue":
            return { ...t, fetchStatus: "fetching" };
          case "fetch":
            return {
              ...t,
              ...L6(t.data, this.options),
              fetchMeta: n.meta ?? null,
            };
          case "success":
            return (
              (this.#t = void 0),
              {
                ...t,
                data: n.data,
                dataUpdateCount: t.dataUpdateCount + 1,
                dataUpdatedAt: n.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...(!n.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                }),
              }
            );
          case "error":
            const s = n.error;
            return F_(s) && s.revert && this.#t
              ? { ...this.#t, fetchStatus: "idle" }
              : {
                  ...t,
                  error: s,
                  errorUpdateCount: t.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: t.fetchFailureCount + 1,
                  fetchFailureReason: s,
                  fetchStatus: "idle",
                  status: "error",
                };
          case "invalidate":
            return { ...t, isInvalidated: !0 };
          case "setState":
            return { ...t, ...n.state };
        }
      };
      (this.state = e(this.state)),
        yr.batch(() => {
          this.observers.forEach((t) => {
            t.onQueryUpdate();
          }),
            this.#n.notify({ query: this, type: "updated", action: n });
        });
    }
  };
function L6(n, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: R6(e.networkMode) ? "fetching" : "paused",
    ...(n === void 0 && { error: null, status: "pending" }),
  };
}
function jte(n) {
  const e =
      typeof n.initialData == "function" ? n.initialData() : n.initialData,
    t = e !== void 0,
    s = t
      ? typeof n.initialDataUpdatedAt == "function"
        ? n.initialDataUpdatedAt()
        : n.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? s ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? "success" : "pending",
    fetchStatus: "idle",
  };
}
var Fte = class extends wv {
    constructor(n = {}) {
      super(), (this.config = n), (this.#e = new Map());
    }
    #e;
    build(n, e, t) {
      const s = e.queryKey,
        r = e.queryHash ?? OI(s, e);
      let i = this.get(r);
      return (
        i ||
          ((i = new Ote({
            client: n,
            queryKey: s,
            queryHash: r,
            options: n.defaultQueryOptions(e),
            state: t,
            defaultOptions: n.getQueryDefaults(s),
          })),
          this.add(i)),
        i
      );
    }
    add(n) {
      this.#e.has(n.queryHash) ||
        (this.#e.set(n.queryHash, n), this.notify({ type: "added", query: n }));
    }
    remove(n) {
      const e = this.#e.get(n.queryHash);
      e &&
        (n.destroy(),
        e === n && this.#e.delete(n.queryHash),
        this.notify({ type: "removed", query: n }));
    }
    clear() {
      yr.batch(() => {
        this.getAll().forEach((n) => {
          this.remove(n);
        });
      });
    }
    get(n) {
      return this.#e.get(n);
    }
    getAll() {
      return [...this.#e.values()];
    }
    find(n) {
      const e = { exact: !0, ...n };
      return this.getAll().find((t) => bj(e, t));
    }
    findAll(n = {}) {
      const e = this.getAll();
      return Object.keys(n).length > 0 ? e.filter((t) => bj(n, t)) : e;
    }
    notify(n) {
      yr.batch(() => {
        this.listeners.forEach((e) => {
          e(n);
        });
      });
    }
    onFocus() {
      yr.batch(() => {
        this.getAll().forEach((n) => {
          n.onFocus();
        });
      });
    }
    onOnline() {
      yr.batch(() => {
        this.getAll().forEach((n) => {
          n.onOnline();
        });
      });
    }
  },
  Ute = class extends I6 {
    #e;
    #t;
    #n;
    constructor(n) {
      super(),
        (this.mutationId = n.mutationId),
        (this.#t = n.mutationCache),
        (this.#e = []),
        (this.state = n.state || $te()),
        this.setOptions(n.options),
        this.scheduleGc();
    }
    setOptions(n) {
      (this.options = n), this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(n) {
      this.#e.includes(n) ||
        (this.#e.push(n),
        this.clearGcTimeout(),
        this.#t.notify({ type: "observerAdded", mutation: this, observer: n }));
    }
    removeObserver(n) {
      (this.#e = this.#e.filter((e) => e !== n)),
        this.scheduleGc(),
        this.#t.notify({
          type: "observerRemoved",
          mutation: this,
          observer: n,
        });
    }
    optionalRemove() {
      this.#e.length ||
        (this.state.status === "pending"
          ? this.scheduleGc()
          : this.#t.remove(this));
    }
    continue() {
      return this.#n?.continue() ?? this.execute(this.state.variables);
    }
    async execute(n) {
      const e = () => {
        this.#s({ type: "continue" });
      };
      this.#n = C6({
        fn: () =>
          this.options.mutationFn
            ? this.options.mutationFn(n)
            : Promise.reject(new Error("No mutationFn found")),
        onFail: (r, i) => {
          this.#s({ type: "failed", failureCount: r, error: i });
        },
        onPause: () => {
          this.#s({ type: "pause" });
        },
        onContinue: e,
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => this.#t.canRun(this),
      });
      const t = this.state.status === "pending",
        s = !this.#n.canStart();
      try {
        if (t) e();
        else {
          this.#s({ type: "pending", variables: n, isPaused: s }),
            await this.#t.config.onMutate?.(n, this);
          const i = await this.options.onMutate?.(n);
          i !== this.state.context &&
            this.#s({ type: "pending", context: i, variables: n, isPaused: s });
        }
        const r = await this.#n.start();
        return (
          await this.#t.config.onSuccess?.(r, n, this.state.context, this),
          await this.options.onSuccess?.(r, n, this.state.context),
          await this.#t.config.onSettled?.(
            r,
            null,
            this.state.variables,
            this.state.context,
            this
          ),
          await this.options.onSettled?.(r, null, n, this.state.context),
          this.#s({ type: "success", data: r }),
          r
        );
      } catch (r) {
        try {
          throw (
            (await this.#t.config.onError?.(r, n, this.state.context, this),
            await this.options.onError?.(r, n, this.state.context),
            await this.#t.config.onSettled?.(
              void 0,
              r,
              this.state.variables,
              this.state.context,
              this
            ),
            await this.options.onSettled?.(void 0, r, n, this.state.context),
            r)
          );
        } finally {
          this.#s({ type: "error", error: r });
        }
      } finally {
        this.#t.runNext(this);
      }
    }
    #s(n) {
      const e = (t) => {
        switch (n.type) {
          case "failed":
            return {
              ...t,
              failureCount: n.failureCount,
              failureReason: n.error,
            };
          case "pause":
            return { ...t, isPaused: !0 };
          case "continue":
            return { ...t, isPaused: !1 };
          case "pending":
            return {
              ...t,
              context: n.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: n.isPaused,
              status: "pending",
              variables: n.variables,
              submittedAt: Date.now(),
            };
          case "success":
            return {
              ...t,
              data: n.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: !1,
            };
          case "error":
            return {
              ...t,
              data: void 0,
              error: n.error,
              failureCount: t.failureCount + 1,
              failureReason: n.error,
              isPaused: !1,
              status: "error",
            };
        }
      };
      (this.state = e(this.state)),
        yr.batch(() => {
          this.#e.forEach((t) => {
            t.onMutationUpdate(n);
          }),
            this.#t.notify({ mutation: this, type: "updated", action: n });
        });
    }
  };
function $te() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0,
  };
}
var Bte = class extends wv {
  constructor(n = {}) {
    super(),
      (this.config = n),
      (this.#e = new Set()),
      (this.#t = new Map()),
      (this.#n = 0);
  }
  #e;
  #t;
  #n;
  build(n, e, t) {
    const s = new Ute({
      mutationCache: this,
      mutationId: ++this.#n,
      options: n.defaultMutationOptions(e),
      state: t,
    });
    return this.add(s), s;
  }
  add(n) {
    this.#e.add(n);
    const e = ay(n);
    if (typeof e == "string") {
      const t = this.#t.get(e);
      t ? t.push(n) : this.#t.set(e, [n]);
    }
    this.notify({ type: "added", mutation: n });
  }
  remove(n) {
    if (this.#e.delete(n)) {
      const e = ay(n);
      if (typeof e == "string") {
        const t = this.#t.get(e);
        if (t)
          if (t.length > 1) {
            const s = t.indexOf(n);
            s !== -1 && t.splice(s, 1);
          } else t[0] === n && this.#t.delete(e);
      }
    }
    this.notify({ type: "removed", mutation: n });
  }
  canRun(n) {
    const e = ay(n);
    if (typeof e == "string") {
      const s = this.#t.get(e)?.find((r) => r.state.status === "pending");
      return !s || s === n;
    } else return !0;
  }
  runNext(n) {
    const e = ay(n);
    return typeof e == "string"
      ? this.#t
          .get(e)
          ?.find((s) => s !== n && s.state.isPaused)
          ?.continue() ?? Promise.resolve()
      : Promise.resolve();
  }
  clear() {
    yr.batch(() => {
      this.#e.forEach((n) => {
        this.notify({ type: "removed", mutation: n });
      }),
        this.#e.clear(),
        this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(n) {
    const e = { exact: !0, ...n };
    return this.getAll().find((t) => xj(e, t));
  }
  findAll(n = {}) {
    return this.getAll().filter((e) => xj(n, e));
  }
  notify(n) {
    yr.batch(() => {
      this.listeners.forEach((e) => {
        e(n);
      });
    });
  }
  resumePausedMutations() {
    const n = this.getAll().filter((e) => e.state.isPaused);
    return yr.batch(() => Promise.all(n.map((e) => e.continue().catch(Jr))));
  }
};
function ay(n) {
  return n.options.scope?.id;
}
function Sj(n) {
  return {
    onFetch: (e, t) => {
      const s = e.options,
        r = e.fetchOptions?.meta?.fetchMore?.direction,
        i = e.state.data?.pages || [],
        a = e.state.data?.pageParams || [];
      let o = { pages: [], pageParams: [] },
        l = 0;
      const c = async () => {
        let h = !1;
        const m = (y) => {
            Object.defineProperty(y, "signal", {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (h = !0)
                  : e.signal.addEventListener("abort", () => {
                      h = !0;
                    }),
                e.signal
              ),
            });
          },
          p = A6(e.options, e.fetchOptions),
          g = async (y, b, w) => {
            if (h) return Promise.reject();
            if (b == null && y.pages.length) return Promise.resolve(y);
            const A = (() => {
                const D = {
                  client: e.client,
                  queryKey: e.queryKey,
                  pageParam: b,
                  direction: w ? "backward" : "forward",
                  meta: e.options.meta,
                };
                return m(D), D;
              })(),
              _ = await p(A),
              { maxPages: R } = e.options,
              C = w ? Cte : kte;
            return {
              pages: C(y.pages, _, R),
              pageParams: C(y.pageParams, b, R),
            };
          };
        if (r && i.length) {
          const y = r === "backward",
            b = y ? Hte : Tj,
            w = { pages: i, pageParams: a },
            S = b(s, w);
          o = await g(w, S, y);
        } else {
          const y = n ?? i.length;
          do {
            const b = l === 0 ? a[0] ?? s.initialPageParam : Tj(s, o);
            if (l > 0 && b == null) break;
            (o = await g(o, b)), l++;
          } while (l < y);
        }
        return o;
      };
      e.options.persister
        ? (e.fetchFn = () =>
            e.options.persister?.(
              c,
              {
                client: e.client,
                queryKey: e.queryKey,
                meta: e.options.meta,
                signal: e.signal,
              },
              t
            ))
        : (e.fetchFn = c);
    },
  };
}
function Tj(n, { pages: e, pageParams: t }) {
  const s = e.length - 1;
  return e.length > 0 ? n.getNextPageParam(e[s], e, t[s], t) : void 0;
}
function Hte(n, { pages: e, pageParams: t }) {
  return e.length > 0 ? n.getPreviousPageParam?.(e[0], e, t[0], t) : void 0;
}
var Vte = class {
    #e;
    #t;
    #n;
    #s;
    #r;
    #o;
    #i;
    #a;
    constructor(n = {}) {
      (this.#e = n.queryCache || new Fte()),
        (this.#t = n.mutationCache || new Bte()),
        (this.#n = n.defaultOptions || {}),
        (this.#s = new Map()),
        (this.#r = new Map()),
        (this.#o = 0);
    }
    mount() {
      this.#o++,
        this.#o === 1 &&
          ((this.#i = FI.subscribe(async (n) => {
            n && (await this.resumePausedMutations(), this.#e.onFocus());
          })),
          (this.#a = ux.subscribe(async (n) => {
            n && (await this.resumePausedMutations(), this.#e.onOnline());
          })));
    }
    unmount() {
      this.#o--,
        this.#o === 0 &&
          (this.#i?.(), (this.#i = void 0), this.#a?.(), (this.#a = void 0));
    }
    isFetching(n) {
      return this.#e.findAll({ ...n, fetchStatus: "fetching" }).length;
    }
    isMutating(n) {
      return this.#t.findAll({ ...n, status: "pending" }).length;
    }
    getQueryData(n) {
      const e = this.defaultQueryOptions({ queryKey: n });
      return this.#e.get(e.queryHash)?.state.data;
    }
    ensureQueryData(n) {
      const e = this.defaultQueryOptions(n),
        t = this.#e.build(this, e),
        s = t.state.data;
      return s === void 0
        ? this.fetchQuery(n)
        : (n.revalidateIfStale &&
            t.isStaleByTime(kc(e.staleTime, t)) &&
            this.prefetchQuery(e),
          Promise.resolve(s));
    }
    getQueriesData(n) {
      return this.#e.findAll(n).map(({ queryKey: e, state: t }) => {
        const s = t.data;
        return [e, s];
      });
    }
    setQueryData(n, e, t) {
      const s = this.defaultQueryOptions({ queryKey: n }),
        i = this.#e.get(s.queryHash)?.state.data,
        a = Ate(e, i);
      if (a !== void 0)
        return this.#e.build(this, s).setData(a, { ...t, manual: !0 });
    }
    setQueriesData(n, e, t) {
      return yr.batch(() =>
        this.#e
          .findAll(n)
          .map(({ queryKey: s }) => [s, this.setQueryData(s, e, t)])
      );
    }
    getQueryState(n) {
      const e = this.defaultQueryOptions({ queryKey: n });
      return this.#e.get(e.queryHash)?.state;
    }
    removeQueries(n) {
      const e = this.#e;
      yr.batch(() => {
        e.findAll(n).forEach((t) => {
          e.remove(t);
        });
      });
    }
    resetQueries(n, e) {
      const t = this.#e;
      return yr.batch(
        () => (
          t.findAll(n).forEach((s) => {
            s.reset();
          }),
          this.refetchQueries({ type: "active", ...n }, e)
        )
      );
    }
    cancelQueries(n, e = {}) {
      const t = { revert: !0, ...e },
        s = yr.batch(() => this.#e.findAll(n).map((r) => r.cancel(t)));
      return Promise.all(s).then(Jr).catch(Jr);
    }
    invalidateQueries(n, e = {}) {
      return yr.batch(
        () => (
          this.#e.findAll(n).forEach((t) => {
            t.invalidate();
          }),
          n?.refetchType === "none"
            ? Promise.resolve()
            : this.refetchQueries(
                { ...n, type: n?.refetchType ?? n?.type ?? "active" },
                e
              )
        )
      );
    }
    refetchQueries(n, e = {}) {
      const t = { ...e, cancelRefetch: e.cancelRefetch ?? !0 },
        s = yr.batch(() =>
          this.#e
            .findAll(n)
            .filter((r) => !r.isDisabled() && !r.isStatic())
            .map((r) => {
              let i = r.fetch(void 0, t);
              return (
                t.throwOnError || (i = i.catch(Jr)),
                r.state.fetchStatus === "paused" ? Promise.resolve() : i
              );
            })
        );
      return Promise.all(s).then(Jr);
    }
    fetchQuery(n) {
      const e = this.defaultQueryOptions(n);
      e.retry === void 0 && (e.retry = !1);
      const t = this.#e.build(this, e);
      return t.isStaleByTime(kc(e.staleTime, t))
        ? t.fetch(e)
        : Promise.resolve(t.state.data);
    }
    prefetchQuery(n) {
      return this.fetchQuery(n).then(Jr).catch(Jr);
    }
    fetchInfiniteQuery(n) {
      return (n.behavior = Sj(n.pages)), this.fetchQuery(n);
    }
    prefetchInfiniteQuery(n) {
      return this.fetchInfiniteQuery(n).then(Jr).catch(Jr);
    }
    ensureInfiniteQueryData(n) {
      return (n.behavior = Sj(n.pages)), this.ensureQueryData(n);
    }
    resumePausedMutations() {
      return ux.isOnline()
        ? this.#t.resumePausedMutations()
        : Promise.resolve();
    }
    getQueryCache() {
      return this.#e;
    }
    getMutationCache() {
      return this.#t;
    }
    getDefaultOptions() {
      return this.#n;
    }
    setDefaultOptions(n) {
      this.#n = n;
    }
    setQueryDefaults(n, e) {
      this.#s.set(bg(n), { queryKey: n, defaultOptions: e });
    }
    getQueryDefaults(n) {
      const e = [...this.#s.values()],
        t = {};
      return (
        e.forEach((s) => {
          xg(n, s.queryKey) && Object.assign(t, s.defaultOptions);
        }),
        t
      );
    }
    setMutationDefaults(n, e) {
      this.#r.set(bg(n), { mutationKey: n, defaultOptions: e });
    }
    getMutationDefaults(n) {
      const e = [...this.#r.values()],
        t = {};
      return (
        e.forEach((s) => {
          xg(n, s.mutationKey) && Object.assign(t, s.defaultOptions);
        }),
        t
      );
    }
    defaultQueryOptions(n) {
      if (n._defaulted) return n;
      const e = {
        ...this.#n.queries,
        ...this.getQueryDefaults(n.queryKey),
        ...n,
        _defaulted: !0,
      };
      return (
        e.queryHash || (e.queryHash = OI(e.queryKey, e)),
        e.refetchOnReconnect === void 0 &&
          (e.refetchOnReconnect = e.networkMode !== "always"),
        e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
        !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
        e.queryFn === jI && (e.enabled = !1),
        e
      );
    }
    defaultMutationOptions(n) {
      return n?._defaulted
        ? n
        : {
            ...this.#n.mutations,
            ...(n?.mutationKey && this.getMutationDefaults(n.mutationKey)),
            ...n,
            _defaulted: !0,
          };
    }
    clear() {
      this.#e.clear(), this.#t.clear();
    }
  },
  zte = class extends wv {
    constructor(n, e) {
      super(),
        (this.options = e),
        (this.#e = n),
        (this.#a = null),
        (this.#i = sR()),
        this.options.experimental_prefetchInRender ||
          this.#i.reject(
            new Error(
              "experimental_prefetchInRender feature flag is not enabled"
            )
          ),
        this.bindMethods(),
        this.setOptions(e);
    }
    #e;
    #t = void 0;
    #n = void 0;
    #s = void 0;
    #r;
    #o;
    #i;
    #a;
    #h;
    #l;
    #u;
    #c;
    #f;
    #d;
    #p = new Set();
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      this.listeners.size === 1 &&
        (this.#t.addObserver(this),
        _j(this.#t, this.options) ? this.#m() : this.updateResult(),
        this.#b());
    }
    onUnsubscribe() {
      this.hasListeners() || this.destroy();
    }
    shouldFetchOnReconnect() {
      return rR(this.#t, this.options, this.options.refetchOnReconnect);
    }
    shouldFetchOnWindowFocus() {
      return rR(this.#t, this.options, this.options.refetchOnWindowFocus);
    }
    destroy() {
      (this.listeners = new Set()),
        this.#x(),
        this.#w(),
        this.#t.removeObserver(this);
    }
    setOptions(n) {
      const e = this.options,
        t = this.#t;
      if (
        ((this.options = this.#e.defaultQueryOptions(n)),
        this.options.enabled !== void 0 &&
          typeof this.options.enabled != "boolean" &&
          typeof this.options.enabled != "function" &&
          typeof Qi(this.options.enabled, this.#t) != "boolean")
      )
        throw new Error(
          "Expected enabled to be a boolean or a callback that returns a boolean"
        );
      this.#E(),
        this.#t.setOptions(this.options),
        e._defaulted &&
          !eR(this.options, e) &&
          this.#e
            .getQueryCache()
            .notify({
              type: "observerOptionsUpdated",
              query: this.#t,
              observer: this,
            });
      const s = this.hasListeners();
      s && Aj(this.#t, t, this.options, e) && this.#m(),
        this.updateResult(),
        s &&
          (this.#t !== t ||
            Qi(this.options.enabled, this.#t) !== Qi(e.enabled, this.#t) ||
            kc(this.options.staleTime, this.#t) !== kc(e.staleTime, this.#t)) &&
          this.#g();
      const r = this.#v();
      s &&
        (this.#t !== t ||
          Qi(this.options.enabled, this.#t) !== Qi(e.enabled, this.#t) ||
          r !== this.#d) &&
        this.#y(r);
    }
    getOptimisticResult(n) {
      const e = this.#e.getQueryCache().build(this.#e, n),
        t = this.createResult(e, n);
      return (
        qte(this, t) &&
          ((this.#s = t), (this.#o = this.options), (this.#r = this.#t.state)),
        t
      );
    }
    getCurrentResult() {
      return this.#s;
    }
    trackResult(n, e) {
      return new Proxy(n, {
        get: (t, s) => (this.trackProp(s), e?.(s), Reflect.get(t, s)),
      });
    }
    trackProp(n) {
      this.#p.add(n);
    }
    getCurrentQuery() {
      return this.#t;
    }
    refetch({ ...n } = {}) {
      return this.fetch({ ...n });
    }
    fetchOptimistic(n) {
      const e = this.#e.defaultQueryOptions(n),
        t = this.#e.getQueryCache().build(this.#e, e);
      return t.fetch().then(() => this.createResult(t, e));
    }
    fetch(n) {
      return this.#m({ ...n, cancelRefetch: n.cancelRefetch ?? !0 }).then(
        () => (this.updateResult(), this.#s)
      );
    }
    #m(n) {
      this.#E();
      let e = this.#t.fetch(this.options, n);
      return n?.throwOnError || (e = e.catch(Jr)), e;
    }
    #g() {
      this.#x();
      const n = kc(this.options.staleTime, this.#t);
      if (Wu || this.#s.isStale || !JA(n)) return;
      const t = T6(this.#s.dataUpdatedAt, n) + 1;
      this.#c = setTimeout(() => {
        this.#s.isStale || this.updateResult();
      }, t);
    }
    #v() {
      return (
        (typeof this.options.refetchInterval == "function"
          ? this.options.refetchInterval(this.#t)
          : this.options.refetchInterval) ?? !1
      );
    }
    #y(n) {
      this.#w(),
        (this.#d = n),
        !(
          Wu ||
          Qi(this.options.enabled, this.#t) === !1 ||
          !JA(this.#d) ||
          this.#d === 0
        ) &&
          (this.#f = setInterval(() => {
            (this.options.refetchIntervalInBackground || FI.isFocused()) &&
              this.#m();
          }, this.#d));
    }
    #b() {
      this.#g(), this.#y(this.#v());
    }
    #x() {
      this.#c && (clearTimeout(this.#c), (this.#c = void 0));
    }
    #w() {
      this.#f && (clearInterval(this.#f), (this.#f = void 0));
    }
    createResult(n, e) {
      const t = this.#t,
        s = this.options,
        r = this.#s,
        i = this.#r,
        a = this.#o,
        l = n !== t ? n.state : this.#n,
        { state: c } = n;
      let h = { ...c },
        m = !1,
        p;
      if (e._optimisticResults) {
        const P = this.hasListeners(),
          V = !P && _j(n, e),
          N = P && Aj(n, t, e, s);
        (V || N) && (h = { ...h, ...L6(c.data, n.options) }),
          e._optimisticResults === "isRestoring" && (h.fetchStatus = "idle");
      }
      let { error: g, errorUpdatedAt: y, status: b } = h;
      p = h.data;
      let w = !1;
      if (e.placeholderData !== void 0 && p === void 0 && b === "pending") {
        let P;
        r?.isPlaceholderData && e.placeholderData === a?.placeholderData
          ? ((P = r.data), (w = !0))
          : (P =
              typeof e.placeholderData == "function"
                ? e.placeholderData(this.#u?.state.data, this.#u)
                : e.placeholderData),
          P !== void 0 && ((b = "success"), (p = nR(r?.data, P, e)), (m = !0));
      }
      if (e.select && p !== void 0 && !w)
        if (r && p === i?.data && e.select === this.#h) p = this.#l;
        else
          try {
            (this.#h = e.select),
              (p = e.select(p)),
              (p = nR(r?.data, p, e)),
              (this.#l = p),
              (this.#a = null);
          } catch (P) {
            this.#a = P;
          }
      this.#a &&
        ((g = this.#a), (p = this.#l), (y = Date.now()), (b = "error"));
      const S = h.fetchStatus === "fetching",
        A = b === "pending",
        _ = b === "error",
        R = A && S,
        C = p !== void 0,
        L = {
          status: b,
          fetchStatus: h.fetchStatus,
          isPending: A,
          isSuccess: b === "success",
          isError: _,
          isInitialLoading: R,
          isLoading: R,
          data: p,
          dataUpdatedAt: h.dataUpdatedAt,
          error: g,
          errorUpdatedAt: y,
          failureCount: h.fetchFailureCount,
          failureReason: h.fetchFailureReason,
          errorUpdateCount: h.errorUpdateCount,
          isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
          isFetchedAfterMount:
            h.dataUpdateCount > l.dataUpdateCount ||
            h.errorUpdateCount > l.errorUpdateCount,
          isFetching: S,
          isRefetching: S && !A,
          isLoadingError: _ && !C,
          isPaused: h.fetchStatus === "paused",
          isPlaceholderData: m,
          isRefetchError: _ && C,
          isStale: UI(n, e),
          refetch: this.refetch,
          promise: this.#i,
          isEnabled: Qi(e.enabled, n) !== !1,
        };
      if (this.options.experimental_prefetchInRender) {
        const P = (W) => {
            L.status === "error"
              ? W.reject(L.error)
              : L.data !== void 0 && W.resolve(L.data);
          },
          V = () => {
            const W = (this.#i = L.promise = sR());
            P(W);
          },
          N = this.#i;
        switch (N.status) {
          case "pending":
            n.queryHash === t.queryHash && P(N);
            break;
          case "fulfilled":
            (L.status === "error" || L.data !== N.value) && V();
            break;
          case "rejected":
            (L.status !== "error" || L.error !== N.reason) && V();
            break;
        }
      }
      return L;
    }
    updateResult() {
      const n = this.#s,
        e = this.createResult(this.#t, this.options);
      if (
        ((this.#r = this.#t.state),
        (this.#o = this.options),
        this.#r.data !== void 0 && (this.#u = this.#t),
        eR(e, n))
      )
        return;
      this.#s = e;
      const t = () => {
        if (!n) return !0;
        const { notifyOnChangeProps: s } = this.options,
          r = typeof s == "function" ? s() : s;
        if (r === "all" || (!r && !this.#p.size)) return !0;
        const i = new Set(r ?? this.#p);
        return (
          this.options.throwOnError && i.add("error"),
          Object.keys(this.#s).some((a) => {
            const o = a;
            return this.#s[o] !== n[o] && i.has(o);
          })
        );
      };
      this.#S({ listeners: t() });
    }
    #E() {
      const n = this.#e.getQueryCache().build(this.#e, this.options);
      if (n === this.#t) return;
      const e = this.#t;
      (this.#t = n),
        (this.#n = n.state),
        this.hasListeners() && (e?.removeObserver(this), n.addObserver(this));
    }
    onQueryUpdate() {
      this.updateResult(), this.hasListeners() && this.#b();
    }
    #S(n) {
      yr.batch(() => {
        n.listeners &&
          this.listeners.forEach((e) => {
            e(this.#s);
          }),
          this.#e
            .getQueryCache()
            .notify({ query: this.#t, type: "observerResultsUpdated" });
      });
    }
  };
function Gte(n, e) {
  return (
    Qi(e.enabled, n) !== !1 &&
    n.state.data === void 0 &&
    !(n.state.status === "error" && e.retryOnMount === !1)
  );
}
function _j(n, e) {
  return Gte(n, e) || (n.state.data !== void 0 && rR(n, e, e.refetchOnMount));
}
function rR(n, e, t) {
  if (Qi(e.enabled, n) !== !1 && kc(e.staleTime, n) !== "static") {
    const s = typeof t == "function" ? t(n) : t;
    return s === "always" || (s !== !1 && UI(n, e));
  }
  return !1;
}
function Aj(n, e, t, s) {
  return (
    (n !== e || Qi(s.enabled, n) === !1) &&
    (!t.suspense || n.state.status !== "error") &&
    UI(n, t)
  );
}
function UI(n, e) {
  return Qi(e.enabled, n) !== !1 && n.isStaleByTime(kc(e.staleTime, n));
}
function qte(n, e) {
  return !eR(n.getCurrentResult(), e);
}
var D6 = E.createContext(void 0),
  P6 = (n) => {
    const e = E.useContext(D6);
    if (!e)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e;
  },
  Wte = ({ client: n, children: e }) => (
    E.useEffect(
      () => (
        n.mount(),
        () => {
          n.unmount();
        }
      ),
      [n]
    ),
    u.jsx(D6.Provider, { value: n, children: e })
  ),
  M6 = E.createContext(!1),
  Kte = () => E.useContext(M6);
M6.Provider;
function Yte() {
  let n = !1;
  return {
    clearReset: () => {
      n = !1;
    },
    reset: () => {
      n = !0;
    },
    isReset: () => n,
  };
}
var Xte = E.createContext(Yte()),
  Qte = () => E.useContext(Xte),
  Zte = (n, e) => {
    (n.suspense || n.throwOnError || n.experimental_prefetchInRender) &&
      (e.isReset() || (n.retryOnMount = !1));
  },
  Jte = (n) => {
    E.useEffect(() => {
      n.clearReset();
    }, [n]);
  },
  ene = ({
    result: n,
    errorResetBoundary: e,
    throwOnError: t,
    query: s,
    suspense: r,
  }) =>
    n.isError &&
    !e.isReset() &&
    !n.isFetching &&
    s &&
    ((r && n.data === void 0) || Ite(t, [n.error, s])),
  tne = (n) => {
    if (n.suspense) {
      const e = (s) => (s === "static" ? s : Math.max(s ?? 1e3, 1e3)),
        t = n.staleTime;
      (n.staleTime = typeof t == "function" ? (...s) => e(t(...s)) : e(t)),
        typeof n.gcTime == "number" && (n.gcTime = Math.max(n.gcTime, 1e3));
    }
  },
  nne = (n, e) => n.isLoading && n.isFetching && !e,
  sne = (n, e) => n?.suspense && e.isPending,
  Rj = (n, e, t) =>
    e.fetchOptimistic(n).catch(() => {
      t.clearReset();
    });
function rne(n, e, t) {
  const s = Kte(),
    r = Qte(),
    i = P6(),
    a = i.defaultQueryOptions(n);
  i.getDefaultOptions().queries?._experimental_beforeQuery?.(a),
    (a._optimisticResults = s ? "isRestoring" : "optimistic"),
    tne(a),
    Zte(a, r),
    Jte(r);
  const o = !i.getQueryCache().get(a.queryHash),
    [l] = E.useState(() => new e(i, a)),
    c = l.getOptimisticResult(a),
    h = !s && n.subscribed !== !1;
  if (
    (E.useSyncExternalStore(
      E.useCallback(
        (m) => {
          const p = h ? l.subscribe(yr.batchCalls(m)) : Jr;
          return l.updateResult(), p;
        },
        [l, h]
      ),
      () => l.getCurrentResult(),
      () => l.getCurrentResult()
    ),
    E.useEffect(() => {
      l.setOptions(a);
    }, [a, l]),
    sne(a, c))
  )
    throw Rj(a, l, r);
  if (
    ene({
      result: c,
      errorResetBoundary: r,
      throwOnError: a.throwOnError,
      query: i.getQueryCache().get(a.queryHash),
      suspense: a.suspense,
    })
  )
    throw c.error;
  return (
    i.getDefaultOptions().queries?._experimental_afterQuery?.(a, c),
    a.experimental_prefetchInRender &&
      !Wu &&
      nne(c, s) &&
      (o ? Rj(a, l, r) : i.getQueryCache().get(a.queryHash)?.promise)
        ?.catch(Jr)
        .finally(() => {
          l.updateResult();
        }),
    a.notifyOnChangeProps ? c : l.trackResult(c)
  );
}
function N6(n, e) {
  return rne(n, zte);
}
var ine = (n) => {
    switch (n) {
      case "success":
        return lne;
      case "info":
        return une;
      case "warning":
        return cne;
      case "error":
        return dne;
      default:
        return null;
    }
  },
  ane = Array(12).fill(0),
  one = ({ visible: n, className: e }) =>
    de.createElement(
      "div",
      {
        className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "),
        "data-visible": n,
      },
      de.createElement(
        "div",
        { className: "sonner-spinner" },
        ane.map((t, s) =>
          de.createElement("div", {
            className: "sonner-loading-bar",
            key: `spinner-bar-${s}`,
          })
        )
      )
    ),
  lne = de.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    de.createElement("path", {
      fillRule: "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
      clipRule: "evenodd",
    })
  ),
  cne = de.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    de.createElement("path", {
      fillRule: "evenodd",
      d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
      clipRule: "evenodd",
    })
  ),
  une = de.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    de.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
      clipRule: "evenodd",
    })
  ),
  dne = de.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    de.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
      clipRule: "evenodd",
    })
  ),
  hne = de.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "12",
      height: "12",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round",
    },
    de.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
    de.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
  ),
  fne = () => {
    let [n, e] = de.useState(document.hidden);
    return (
      de.useEffect(() => {
        let t = () => {
          e(document.hidden);
        };
        return (
          document.addEventListener("visibilitychange", t),
          () => window.removeEventListener("visibilitychange", t)
        );
      }, []),
      n
    );
  },
  iR = 1,
  mne = class {
    constructor() {
      (this.subscribe = (e) => (
        this.subscribers.push(e),
        () => {
          let t = this.subscribers.indexOf(e);
          this.subscribers.splice(t, 1);
        }
      )),
        (this.publish = (e) => {
          this.subscribers.forEach((t) => t(e));
        }),
        (this.addToast = (e) => {
          this.publish(e), (this.toasts = [...this.toasts, e]);
        }),
        (this.create = (e) => {
          var t;
          let { message: s, ...r } = e,
            i =
              typeof e?.id == "number" ||
              ((t = e.id) == null ? void 0 : t.length) > 0
                ? e.id
                : iR++,
            a = this.toasts.find((l) => l.id === i),
            o = e.dismissible === void 0 ? !0 : e.dismissible;
          return (
            this.dismissedToasts.has(i) && this.dismissedToasts.delete(i),
            a
              ? (this.toasts = this.toasts.map((l) =>
                  l.id === i
                    ? (this.publish({ ...l, ...e, id: i, title: s }),
                      { ...l, ...e, id: i, dismissible: o, title: s })
                    : l
                ))
              : this.addToast({ title: s, ...r, dismissible: o, id: i }),
            i
          );
        }),
        (this.dismiss = (e) => (
          this.dismissedToasts.add(e),
          e ||
            this.toasts.forEach((t) => {
              this.subscribers.forEach((s) => s({ id: t.id, dismiss: !0 }));
            }),
          this.subscribers.forEach((t) => t({ id: e, dismiss: !0 })),
          e
        )),
        (this.message = (e, t) => this.create({ ...t, message: e })),
        (this.error = (e, t) =>
          this.create({ ...t, message: e, type: "error" })),
        (this.success = (e, t) =>
          this.create({ ...t, type: "success", message: e })),
        (this.info = (e, t) => this.create({ ...t, type: "info", message: e })),
        (this.warning = (e, t) =>
          this.create({ ...t, type: "warning", message: e })),
        (this.loading = (e, t) =>
          this.create({ ...t, type: "loading", message: e })),
        (this.promise = (e, t) => {
          if (!t) return;
          let s;
          t.loading !== void 0 &&
            (s = this.create({
              ...t,
              promise: e,
              type: "loading",
              message: t.loading,
              description:
                typeof t.description != "function" ? t.description : void 0,
            }));
          let r = e instanceof Promise ? e : e(),
            i = s !== void 0,
            a,
            o = r
              .then(async (c) => {
                if (((a = ["resolve", c]), de.isValidElement(c)))
                  (i = !1), this.create({ id: s, type: "default", message: c });
                else if (gne(c) && !c.ok) {
                  i = !1;
                  let h =
                      typeof t.error == "function"
                        ? await t.error(`HTTP error! status: ${c.status}`)
                        : t.error,
                    m =
                      typeof t.description == "function"
                        ? await t.description(`HTTP error! status: ${c.status}`)
                        : t.description;
                  this.create({
                    id: s,
                    type: "error",
                    message: h,
                    description: m,
                  });
                } else if (t.success !== void 0) {
                  i = !1;
                  let h =
                      typeof t.success == "function"
                        ? await t.success(c)
                        : t.success,
                    m =
                      typeof t.description == "function"
                        ? await t.description(c)
                        : t.description;
                  this.create({
                    id: s,
                    type: "success",
                    message: h,
                    description: m,
                  });
                }
              })
              .catch(async (c) => {
                if (((a = ["reject", c]), t.error !== void 0)) {
                  i = !1;
                  let h =
                      typeof t.error == "function" ? await t.error(c) : t.error,
                    m =
                      typeof t.description == "function"
                        ? await t.description(c)
                        : t.description;
                  this.create({
                    id: s,
                    type: "error",
                    message: h,
                    description: m,
                  });
                }
              })
              .finally(() => {
                var c;
                i && (this.dismiss(s), (s = void 0)),
                  (c = t.finally) == null || c.call(t);
              }),
            l = () =>
              new Promise((c, h) =>
                o.then(() => (a[0] === "reject" ? h(a[1]) : c(a[1]))).catch(h)
              );
          return typeof s != "string" && typeof s != "number"
            ? { unwrap: l }
            : Object.assign(s, { unwrap: l });
        }),
        (this.custom = (e, t) => {
          let s = t?.id || iR++;
          return this.create({ jsx: e(s), id: s, ...t }), s;
        }),
        (this.getActiveToasts = () =>
          this.toasts.filter((e) => !this.dismissedToasts.has(e.id))),
        (this.subscribers = []),
        (this.toasts = []),
        (this.dismissedToasts = new Set());
    }
  },
  Qr = new mne(),
  pne = (n, e) => {
    let t = e?.id || iR++;
    return Qr.addToast({ title: n, ...e, id: t }), t;
  },
  gne = (n) =>
    n &&
    typeof n == "object" &&
    "ok" in n &&
    typeof n.ok == "boolean" &&
    "status" in n &&
    typeof n.status == "number",
  vne = pne,
  yne = () => Qr.toasts,
  bne = () => Qr.getActiveToasts(),
  Xe = Object.assign(
    vne,
    {
      success: Qr.success,
      info: Qr.info,
      warning: Qr.warning,
      error: Qr.error,
      custom: Qr.custom,
      message: Qr.message,
      promise: Qr.promise,
      dismiss: Qr.dismiss,
      loading: Qr.loading,
    },
    { getHistory: yne, getToasts: bne }
  );
function xne(n, { insertAt: e } = {}) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0],
    s = document.createElement("style");
  (s.type = "text/css"),
    e === "top" && t.firstChild
      ? t.insertBefore(s, t.firstChild)
      : t.appendChild(s),
    s.styleSheet
      ? (s.styleSheet.cssText = n)
      : s.appendChild(document.createTextNode(n));
}
xne(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function oy(n) {
  return n.label !== void 0;
}
var wne = 3,
  Ene = "32px",
  Sne = "16px",
  kj = 4e3,
  Tne = 356,
  _ne = 14,
  Ane = 20,
  Rne = 200;
function ga(...n) {
  return n.filter(Boolean).join(" ");
}
function kne(n) {
  let [e, t] = n.split("-"),
    s = [];
  return e && s.push(e), t && s.push(t), s;
}
var Cne = (n) => {
  var e, t, s, r, i, a, o, l, c, h, m;
  let {
      invert: p,
      toast: g,
      unstyled: y,
      interacting: b,
      setHeights: w,
      visibleToasts: S,
      heights: A,
      index: _,
      toasts: R,
      expanded: C,
      removeToast: D,
      defaultRichColors: L,
      closeButton: P,
      style: V,
      cancelButtonStyle: N,
      actionButtonStyle: W,
      className: H = "",
      descriptionClassName: z = "",
      duration: B,
      position: q,
      gap: O,
      loadingIcon: U,
      expandByDefault: j,
      classNames: Q,
      icons: M,
      closeButtonAriaLabel: I = "Close toast",
      pauseWhenPageIsHidden: F,
    } = n,
    [Y, J] = de.useState(null),
    [X, Z] = de.useState(null),
    [te, ce] = de.useState(!1),
    [pe, se] = de.useState(!1),
    [be, K] = de.useState(!1),
    [ve, Ee] = de.useState(!1),
    [De, ge] = de.useState(!1),
    [re, fe] = de.useState(0),
    [ke, ne] = de.useState(0),
    ie = de.useRef(g.duration || B || kj),
    Ne = de.useRef(null),
    $e = de.useRef(null),
    ot = _ === 0,
    st = _ + 1 <= S,
    ht = g.type,
    xt = g.dismissible !== !1,
    _e = g.className || "",
    Ue = g.descriptionClassName || "",
    He = de.useMemo(
      () => A.findIndex((Je) => Je.toastId === g.id) || 0,
      [A, g.id]
    ),
    Ve = de.useMemo(() => {
      var Je;
      return (Je = g.closeButton) != null ? Je : P;
    }, [g.closeButton, P]),
    Ze = de.useMemo(() => g.duration || B || kj, [g.duration, B]),
    ct = de.useRef(0),
    ft = de.useRef(0),
    Ye = de.useRef(0),
    Ot = de.useRef(null),
    [$t, wn] = q.split("-"),
    Bn = de.useMemo(
      () => A.reduce((Je, Ge, mt) => (mt >= He ? Je : Je + Ge.height), 0),
      [A, He]
    ),
    Ws = fne(),
    ts = g.invert || p,
    Vt = ht === "loading";
  (ft.current = de.useMemo(() => He * O + Bn, [He, Bn])),
    de.useEffect(() => {
      ie.current = Ze;
    }, [Ze]),
    de.useEffect(() => {
      ce(!0);
    }, []),
    de.useEffect(() => {
      let Je = $e.current;
      if (Je) {
        let Ge = Je.getBoundingClientRect().height;
        return (
          ne(Ge),
          w((mt) => [
            { toastId: g.id, height: Ge, position: g.position },
            ...mt,
          ]),
          () => w((mt) => mt.filter((zt) => zt.toastId !== g.id))
        );
      }
    }, [w, g.id]),
    de.useLayoutEffect(() => {
      if (!te) return;
      let Je = $e.current,
        Ge = Je.style.height;
      Je.style.height = "auto";
      let mt = Je.getBoundingClientRect().height;
      (Je.style.height = Ge),
        ne(mt),
        w((zt) =>
          zt.find((an) => an.toastId === g.id)
            ? zt.map((an) => (an.toastId === g.id ? { ...an, height: mt } : an))
            : [{ toastId: g.id, height: mt, position: g.position }, ...zt]
        );
    }, [te, g.title, g.description, w, g.id]);
  let Zt = de.useCallback(() => {
    se(!0),
      fe(ft.current),
      w((Je) => Je.filter((Ge) => Ge.toastId !== g.id)),
      setTimeout(() => {
        D(g);
      }, Rne);
  }, [g, D, w, ft]);
  de.useEffect(() => {
    if (
      (g.promise && ht === "loading") ||
      g.duration === 1 / 0 ||
      g.type === "loading"
    )
      return;
    let Je;
    return (
      C || b || (F && Ws)
        ? (() => {
            if (Ye.current < ct.current) {
              let Ge = new Date().getTime() - ct.current;
              ie.current = ie.current - Ge;
            }
            Ye.current = new Date().getTime();
          })()
        : ie.current !== 1 / 0 &&
          ((ct.current = new Date().getTime()),
          (Je = setTimeout(() => {
            var Ge;
            (Ge = g.onAutoClose) == null || Ge.call(g, g), Zt();
          }, ie.current))),
      () => clearTimeout(Je)
    );
  }, [C, b, g, ht, F, Ws, Zt]),
    de.useEffect(() => {
      g.delete && Zt();
    }, [Zt, g.delete]);
  function ln() {
    var Je, Ge, mt;
    return M != null && M.loading
      ? de.createElement(
          "div",
          {
            className: ga(
              Q?.loader,
              (Je = g?.classNames) == null ? void 0 : Je.loader,
              "sonner-loader"
            ),
            "data-visible": ht === "loading",
          },
          M.loading
        )
      : U
      ? de.createElement(
          "div",
          {
            className: ga(
              Q?.loader,
              (Ge = g?.classNames) == null ? void 0 : Ge.loader,
              "sonner-loader"
            ),
            "data-visible": ht === "loading",
          },
          U
        )
      : de.createElement(one, {
          className: ga(
            Q?.loader,
            (mt = g?.classNames) == null ? void 0 : mt.loader
          ),
          visible: ht === "loading",
        });
  }
  return de.createElement(
    "li",
    {
      tabIndex: 0,
      ref: $e,
      className: ga(
        H,
        _e,
        Q?.toast,
        (e = g?.classNames) == null ? void 0 : e.toast,
        Q?.default,
        Q?.[ht],
        (t = g?.classNames) == null ? void 0 : t[ht]
      ),
      "data-sonner-toast": "",
      "data-rich-colors": (s = g.richColors) != null ? s : L,
      "data-styled": !(g.jsx || g.unstyled || y),
      "data-mounted": te,
      "data-promise": !!g.promise,
      "data-swiped": De,
      "data-removed": pe,
      "data-visible": st,
      "data-y-position": $t,
      "data-x-position": wn,
      "data-index": _,
      "data-front": ot,
      "data-swiping": be,
      "data-dismissible": xt,
      "data-type": ht,
      "data-invert": ts,
      "data-swipe-out": ve,
      "data-swipe-direction": X,
      "data-expanded": !!(C || (j && te)),
      style: {
        "--index": _,
        "--toasts-before": _,
        "--z-index": R.length - _,
        "--offset": `${pe ? re : ft.current}px`,
        "--initial-height": j ? "auto" : `${ke}px`,
        ...V,
        ...g.style,
      },
      onDragEnd: () => {
        K(!1), J(null), (Ot.current = null);
      },
      onPointerDown: (Je) => {
        Vt ||
          !xt ||
          ((Ne.current = new Date()),
          fe(ft.current),
          Je.target.setPointerCapture(Je.pointerId),
          Je.target.tagName !== "BUTTON" &&
            (K(!0), (Ot.current = { x: Je.clientX, y: Je.clientY })));
      },
      onPointerUp: () => {
        var Je, Ge, mt, zt;
        if (ve || !xt) return;
        Ot.current = null;
        let an = Number(
            ((Je = $e.current) == null
              ? void 0
              : Je.style
                  .getPropertyValue("--swipe-amount-x")
                  .replace("px", "")) || 0
          ),
          le = Number(
            ((Ge = $e.current) == null
              ? void 0
              : Ge.style
                  .getPropertyValue("--swipe-amount-y")
                  .replace("px", "")) || 0
          ),
          je =
            new Date().getTime() -
            ((mt = Ne.current) == null ? void 0 : mt.getTime()),
          Ke = Y === "x" ? an : le,
          ut = Math.abs(Ke) / je;
        if (Math.abs(Ke) >= Ane || ut > 0.11) {
          fe(ft.current),
            (zt = g.onDismiss) == null || zt.call(g, g),
            Z(Y === "x" ? (an > 0 ? "right" : "left") : le > 0 ? "down" : "up"),
            Zt(),
            Ee(!0),
            ge(!1);
          return;
        }
        K(!1), J(null);
      },
      onPointerMove: (Je) => {
        var Ge, mt, zt, an;
        if (
          !Ot.current ||
          !xt ||
          ((Ge = window.getSelection()) == null
            ? void 0
            : Ge.toString().length) > 0
        )
          return;
        let le = Je.clientY - Ot.current.y,
          je = Je.clientX - Ot.current.x,
          Ke = (mt = n.swipeDirections) != null ? mt : kne(q);
        !Y &&
          (Math.abs(je) > 1 || Math.abs(le) > 1) &&
          J(Math.abs(je) > Math.abs(le) ? "x" : "y");
        let ut = { x: 0, y: 0 };
        Y === "y"
          ? (Ke.includes("top") || Ke.includes("bottom")) &&
            ((Ke.includes("top") && le < 0) ||
              (Ke.includes("bottom") && le > 0)) &&
            (ut.y = le)
          : Y === "x" &&
            (Ke.includes("left") || Ke.includes("right")) &&
            ((Ke.includes("left") && je < 0) ||
              (Ke.includes("right") && je > 0)) &&
            (ut.x = je),
          (Math.abs(ut.x) > 0 || Math.abs(ut.y) > 0) && ge(!0),
          (zt = $e.current) == null ||
            zt.style.setProperty("--swipe-amount-x", `${ut.x}px`),
          (an = $e.current) == null ||
            an.style.setProperty("--swipe-amount-y", `${ut.y}px`);
      },
    },
    Ve && !g.jsx
      ? de.createElement(
          "button",
          {
            "aria-label": I,
            "data-disabled": Vt,
            "data-close-button": !0,
            onClick:
              Vt || !xt
                ? () => {}
                : () => {
                    var Je;
                    Zt(), (Je = g.onDismiss) == null || Je.call(g, g);
                  },
            className: ga(
              Q?.closeButton,
              (r = g?.classNames) == null ? void 0 : r.closeButton
            ),
          },
          (i = M?.close) != null ? i : hne
        )
      : null,
    g.jsx || E.isValidElement(g.title)
      ? g.jsx
        ? g.jsx
        : typeof g.title == "function"
        ? g.title()
        : g.title
      : de.createElement(
          de.Fragment,
          null,
          ht || g.icon || g.promise
            ? de.createElement(
                "div",
                {
                  "data-icon": "",
                  className: ga(
                    Q?.icon,
                    (a = g?.classNames) == null ? void 0 : a.icon
                  ),
                },
                g.promise || (g.type === "loading" && !g.icon)
                  ? g.icon || ln()
                  : null,
                g.type !== "loading" ? g.icon || M?.[ht] || ine(ht) : null
              )
            : null,
          de.createElement(
            "div",
            {
              "data-content": "",
              className: ga(
                Q?.content,
                (o = g?.classNames) == null ? void 0 : o.content
              ),
            },
            de.createElement(
              "div",
              {
                "data-title": "",
                className: ga(
                  Q?.title,
                  (l = g?.classNames) == null ? void 0 : l.title
                ),
              },
              typeof g.title == "function" ? g.title() : g.title
            ),
            g.description
              ? de.createElement(
                  "div",
                  {
                    "data-description": "",
                    className: ga(
                      z,
                      Ue,
                      Q?.description,
                      (c = g?.classNames) == null ? void 0 : c.description
                    ),
                  },
                  typeof g.description == "function"
                    ? g.description()
                    : g.description
                )
              : null
          ),
          E.isValidElement(g.cancel)
            ? g.cancel
            : g.cancel && oy(g.cancel)
            ? de.createElement(
                "button",
                {
                  "data-button": !0,
                  "data-cancel": !0,
                  style: g.cancelButtonStyle || N,
                  onClick: (Je) => {
                    var Ge, mt;
                    oy(g.cancel) &&
                      xt &&
                      ((mt = (Ge = g.cancel).onClick) == null ||
                        mt.call(Ge, Je),
                      Zt());
                  },
                  className: ga(
                    Q?.cancelButton,
                    (h = g?.classNames) == null ? void 0 : h.cancelButton
                  ),
                },
                g.cancel.label
              )
            : null,
          E.isValidElement(g.action)
            ? g.action
            : g.action && oy(g.action)
            ? de.createElement(
                "button",
                {
                  "data-button": !0,
                  "data-action": !0,
                  style: g.actionButtonStyle || W,
                  onClick: (Je) => {
                    var Ge, mt;
                    oy(g.action) &&
                      ((mt = (Ge = g.action).onClick) == null ||
                        mt.call(Ge, Je),
                      !Je.defaultPrevented && Zt());
                  },
                  className: ga(
                    Q?.actionButton,
                    (m = g?.classNames) == null ? void 0 : m.actionButton
                  ),
                },
                g.action.label
              )
            : null
        )
  );
};
function Cj() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  let n = document.documentElement.getAttribute("dir");
  return n === "auto" || !n
    ? window.getComputedStyle(document.documentElement).direction
    : n;
}
function Ine(n, e) {
  let t = {};
  return (
    [n, e].forEach((s, r) => {
      let i = r === 1,
        a = i ? "--mobile-offset" : "--offset",
        o = i ? Sne : Ene;
      function l(c) {
        ["top", "right", "bottom", "left"].forEach((h) => {
          t[`${a}-${h}`] = typeof c == "number" ? `${c}px` : c;
        });
      }
      typeof s == "number" || typeof s == "string"
        ? l(s)
        : typeof s == "object"
        ? ["top", "right", "bottom", "left"].forEach((c) => {
            s[c] === void 0
              ? (t[`${a}-${c}`] = o)
              : (t[`${a}-${c}`] = typeof s[c] == "number" ? `${s[c]}px` : s[c]);
          })
        : l(o);
    }),
    t
  );
}
var Lne = E.forwardRef(function (n, e) {
  let {
      invert: t,
      position: s = "bottom-right",
      hotkey: r = ["altKey", "KeyT"],
      expand: i,
      closeButton: a,
      className: o,
      offset: l,
      mobileOffset: c,
      theme: h = "light",
      richColors: m,
      duration: p,
      style: g,
      visibleToasts: y = wne,
      toastOptions: b,
      dir: w = Cj(),
      gap: S = _ne,
      loadingIcon: A,
      icons: _,
      containerAriaLabel: R = "Notifications",
      pauseWhenPageIsHidden: C,
    } = n,
    [D, L] = de.useState([]),
    P = de.useMemo(
      () =>
        Array.from(
          new Set(
            [s].concat(D.filter((F) => F.position).map((F) => F.position))
          )
        ),
      [D, s]
    ),
    [V, N] = de.useState([]),
    [W, H] = de.useState(!1),
    [z, B] = de.useState(!1),
    [q, O] = de.useState(
      h !== "system"
        ? h
        : typeof window < "u" &&
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light"
    ),
    U = de.useRef(null),
    j = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""),
    Q = de.useRef(null),
    M = de.useRef(!1),
    I = de.useCallback((F) => {
      L((Y) => {
        var J;
        return (
          ((J = Y.find((X) => X.id === F.id)) != null && J.delete) ||
            Qr.dismiss(F.id),
          Y.filter(({ id: X }) => X !== F.id)
        );
      });
    }, []);
  return (
    de.useEffect(
      () =>
        Qr.subscribe((F) => {
          if (F.dismiss) {
            L((Y) => Y.map((J) => (J.id === F.id ? { ...J, delete: !0 } : J)));
            return;
          }
          setTimeout(() => {
            S6.flushSync(() => {
              L((Y) => {
                let J = Y.findIndex((X) => X.id === F.id);
                return J !== -1
                  ? [...Y.slice(0, J), { ...Y[J], ...F }, ...Y.slice(J + 1)]
                  : [F, ...Y];
              });
            });
          });
        }),
      []
    ),
    de.useEffect(() => {
      if (h !== "system") {
        O(h);
        return;
      }
      if (
        (h === "system" &&
          (window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
            ? O("dark")
            : O("light")),
        typeof window > "u")
      )
        return;
      let F = window.matchMedia("(prefers-color-scheme: dark)");
      try {
        F.addEventListener("change", ({ matches: Y }) => {
          O(Y ? "dark" : "light");
        });
      } catch {
        F.addListener(({ matches: J }) => {
          try {
            O(J ? "dark" : "light");
          } catch (X) {
            console.error(X);
          }
        });
      }
    }, [h]),
    de.useEffect(() => {
      D.length <= 1 && H(!1);
    }, [D]),
    de.useEffect(() => {
      let F = (Y) => {
        var J, X;
        r.every((Z) => Y[Z] || Y.code === Z) &&
          (H(!0), (J = U.current) == null || J.focus()),
          Y.code === "Escape" &&
            (document.activeElement === U.current ||
              ((X = U.current) != null &&
                X.contains(document.activeElement))) &&
            H(!1);
      };
      return (
        document.addEventListener("keydown", F),
        () => document.removeEventListener("keydown", F)
      );
    }, [r]),
    de.useEffect(() => {
      if (U.current)
        return () => {
          Q.current &&
            (Q.current.focus({ preventScroll: !0 }),
            (Q.current = null),
            (M.current = !1));
        };
    }, [U.current]),
    de.createElement(
      "section",
      {
        ref: e,
        "aria-label": `${R} ${j}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: !0,
      },
      P.map((F, Y) => {
        var J;
        let [X, Z] = F.split("-");
        return D.length
          ? de.createElement(
              "ol",
              {
                key: F,
                dir: w === "auto" ? Cj() : w,
                tabIndex: -1,
                ref: U,
                className: o,
                "data-sonner-toaster": !0,
                "data-theme": q,
                "data-y-position": X,
                "data-lifted": W && D.length > 1 && !i,
                "data-x-position": Z,
                style: {
                  "--front-toast-height": `${
                    ((J = V[0]) == null ? void 0 : J.height) || 0
                  }px`,
                  "--width": `${Tne}px`,
                  "--gap": `${S}px`,
                  ...g,
                  ...Ine(l, c),
                },
                onBlur: (te) => {
                  M.current &&
                    !te.currentTarget.contains(te.relatedTarget) &&
                    ((M.current = !1),
                    Q.current &&
                      (Q.current.focus({ preventScroll: !0 }),
                      (Q.current = null)));
                },
                onFocus: (te) => {
                  (te.target instanceof HTMLElement &&
                    te.target.dataset.dismissible === "false") ||
                    M.current ||
                    ((M.current = !0), (Q.current = te.relatedTarget));
                },
                onMouseEnter: () => H(!0),
                onMouseMove: () => H(!0),
                onMouseLeave: () => {
                  z || H(!1);
                },
                onDragEnd: () => H(!1),
                onPointerDown: (te) => {
                  (te.target instanceof HTMLElement &&
                    te.target.dataset.dismissible === "false") ||
                    B(!0);
                },
                onPointerUp: () => B(!1),
              },
              D.filter(
                (te) => (!te.position && Y === 0) || te.position === F
              ).map((te, ce) => {
                var pe, se;
                return de.createElement(Cne, {
                  key: te.id,
                  icons: _,
                  index: ce,
                  toast: te,
                  defaultRichColors: m,
                  duration: (pe = b?.duration) != null ? pe : p,
                  className: b?.className,
                  descriptionClassName: b?.descriptionClassName,
                  invert: t,
                  visibleToasts: y,
                  closeButton: (se = b?.closeButton) != null ? se : a,
                  interacting: z,
                  position: F,
                  style: b?.style,
                  unstyled: b?.unstyled,
                  classNames: b?.classNames,
                  cancelButtonStyle: b?.cancelButtonStyle,
                  actionButtonStyle: b?.actionButtonStyle,
                  removeToast: I,
                  toasts: D.filter((be) => be.position == te.position),
                  heights: V.filter((be) => be.position == te.position),
                  setHeights: N,
                  expandByDefault: i,
                  gap: S,
                  loadingIcon: A,
                  expanded: W,
                  pauseWhenPageIsHidden: C,
                  swipeDirections: n.swipeDirections,
                });
              })
            )
          : null;
      })
    )
  );
});
const O6 = de.createContext({}),
  j6 = !0;
function Dne({
  baseColor: n,
  highlightColor: e,
  width: t,
  height: s,
  borderRadius: r,
  circle: i,
  direction: a,
  duration: o,
  enableAnimation: l = j6,
  customHighlightBackground: c,
}) {
  const h = {};
  return (
    a === "rtl" && (h["--animation-direction"] = "reverse"),
    typeof o == "number" && (h["--animation-duration"] = `${o}s`),
    l || (h["--pseudo-element-display"] = "none"),
    (typeof t == "string" || typeof t == "number") && (h.width = t),
    (typeof s == "string" || typeof s == "number") && (h.height = s),
    (typeof r == "string" || typeof r == "number") && (h.borderRadius = r),
    i && (h.borderRadius = "50%"),
    typeof n < "u" && (h["--base-color"] = n),
    typeof e < "u" && (h["--highlight-color"] = e),
    typeof c == "string" && (h["--custom-highlight-background"] = c),
    h
  );
}
function yo({
  count: n = 1,
  wrapper: e,
  className: t,
  containerClassName: s,
  containerTestId: r,
  circle: i = !1,
  style: a,
  ...o
}) {
  var l, c, h;
  const m = de.useContext(O6),
    p = { ...o };
  for (const [_, R] of Object.entries(o)) typeof R > "u" && delete p[_];
  const g = { ...m, ...p, circle: i },
    y = { ...a, ...Dne(g) };
  let b = "react-loading-skeleton";
  t && (b += ` ${t}`);
  const w = (l = g.inline) !== null && l !== void 0 ? l : !1,
    S = [],
    A = Math.ceil(n);
  for (let _ = 0; _ < A; _++) {
    let R = y;
    if (A > n && _ === A - 1) {
      const D = (c = R.width) !== null && c !== void 0 ? c : "100%",
        L = n % 1,
        P = typeof D == "number" ? D * L : `calc(${D} * ${L})`;
      R = { ...R, width: P };
    }
    const C = de.createElement("span", { className: b, style: R, key: _ }, "");
    w
      ? S.push(C)
      : S.push(
          de.createElement(
            de.Fragment,
            { key: _ },
            C,
            de.createElement("br", null)
          )
        );
  }
  return de.createElement(
    "span",
    {
      className: s,
      "data-testid": r,
      "aria-live": "polite",
      "aria-busy": (h = g.enableAnimation) !== null && h !== void 0 ? h : j6,
    },
    e ? S.map((_, R) => de.createElement(e, { key: R }, _)) : S
  );
}
function Pne({ children: n, ...e }) {
  return de.createElement(O6.Provider, { value: e }, n);
}
const Mne = "modulepreload",
  Nne = function (n) {
    return "/" + n;
  },
  Ij = {},
  Lt = function (e, t, s) {
    let r = Promise.resolve();
    if (t && t.length > 0) {
      let c = function (h) {
        return Promise.all(
          h.map((m) =>
            Promise.resolve(m).then(
              (p) => ({ status: "fulfilled", value: p }),
              (p) => ({ status: "rejected", reason: p })
            )
          )
        );
      };
      var a = c;
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"),
        l = o?.nonce || o?.getAttribute("nonce");
      r = c(
        t.map((h) => {
          if (((h = Nne(h)), h in Ij)) return;
          Ij[h] = !0;
          const m = h.endsWith(".css"),
            p = m ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${h}"]${p}`)) return;
          const g = document.createElement("link");
          if (
            ((g.rel = m ? "stylesheet" : Mne),
            m || (g.as = "script"),
            (g.crossOrigin = ""),
            (g.href = h),
            l && g.setAttribute("nonce", l),
            document.head.appendChild(g),
            m)
          )
            return new Promise((y, b) => {
              g.addEventListener("load", y),
                g.addEventListener("error", () =>
                  b(new Error(`Unable to preload CSS for ${h}`))
                );
            });
        })
      );
    }
    function i(o) {
      const l = new Event("vite:preloadError", { cancelable: !0 });
      if (((l.payload = o), window.dispatchEvent(l), !l.defaultPrevented))
        throw o;
    }
    return r.then((o) => {
      for (const l of o || []) l.status === "rejected" && i(l.reason);
      return e().catch(i);
    });
  },
  Lj = (n) => {
    let e;
    const t = new Set(),
      s = (c, h) => {
        const m = typeof c == "function" ? c(e) : c;
        if (!Object.is(m, e)) {
          const p = e;
          (e =
            h ?? (typeof m != "object" || m === null)
              ? m
              : Object.assign({}, e, m)),
            t.forEach((g) => g(e, p));
        }
      },
      r = () => e,
      o = {
        setState: s,
        getState: r,
        getInitialState: () => l,
        subscribe: (c) => (t.add(c), () => t.delete(c)),
      },
      l = (e = n(s, r, o));
    return o;
  },
  One = (n) => (n ? Lj(n) : Lj),
  jne = (n) => n;
function Fne(n, e = jne) {
  const t = de.useSyncExternalStore(
    n.subscribe,
    () => e(n.getState()),
    () => e(n.getInitialState())
  );
  return de.useDebugValue(t), t;
}
const Une = (n) => {
    const e = One(n),
      t = (s) => Fne(e, s);
    return Object.assign(t, e), t;
  },
  Di = (n) => Une,
  $ne = (n) => (e, t, s) => {
    const r = s.subscribe;
    return (
      (s.subscribe = (a, o, l) => {
        let c = a;
        if (o) {
          const h = l?.equalityFn || Object.is;
          let m = a(s.getState());
          (c = (p) => {
            const g = a(p);
            if (!h(m, g)) {
              const y = m;
              o((m = g), y);
            }
          }),
            l?.fireImmediately && o(m, m);
        }
        return r(c);
      }),
      n(e, t, s)
    );
  },
  $a = $ne;
function Bne(n, e) {
  let t;
  try {
    t = n();
  } catch {
    return;
  }
  return {
    getItem: (r) => {
      var i;
      const a = (l) => (l === null ? null : JSON.parse(l, void 0)),
        o = (i = t.getItem(r)) != null ? i : null;
      return o instanceof Promise ? o.then(a) : a(o);
    },
    setItem: (r, i) => t.setItem(r, JSON.stringify(i, void 0)),
    removeItem: (r) => t.removeItem(r),
  };
}
const aR = (n) => (e) => {
    try {
      const t = n(e);
      return t instanceof Promise
        ? t
        : {
            then(s) {
              return aR(s)(t);
            },
            catch(s) {
              return this;
            },
          };
    } catch (t) {
      return {
        then(s) {
          return this;
        },
        catch(s) {
          return aR(s)(t);
        },
      };
    }
  },
  Hne = (n, e) => (t, s, r) => {
    let i = {
        storage: Bne(() => localStorage),
        partialize: (b) => b,
        version: 0,
        merge: (b, w) => ({ ...w, ...b }),
        ...e,
      },
      a = !1;
    const o = new Set(),
      l = new Set();
    let c = i.storage;
    if (!c)
      return n(
        (...b) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${i.name}', the given storage is currently unavailable.`
          ),
            t(...b);
        },
        s,
        r
      );
    const h = () => {
        const b = i.partialize({ ...s() });
        return c.setItem(i.name, { state: b, version: i.version });
      },
      m = r.setState;
    r.setState = (b, w) => {
      m(b, w), h();
    };
    const p = n(
      (...b) => {
        t(...b), h();
      },
      s,
      r
    );
    r.getInitialState = () => p;
    let g;
    const y = () => {
      var b, w;
      if (!c) return;
      (a = !1),
        o.forEach((A) => {
          var _;
          return A((_ = s()) != null ? _ : p);
        });
      const S =
        ((w = i.onRehydrateStorage) == null
          ? void 0
          : w.call(i, (b = s()) != null ? b : p)) || void 0;
      return aR(c.getItem.bind(c))(i.name)
        .then((A) => {
          if (A)
            if (typeof A.version == "number" && A.version !== i.version) {
              if (i.migrate) {
                const _ = i.migrate(A.state, A.version);
                return _ instanceof Promise ? _.then((R) => [!0, R]) : [!0, _];
              }
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return [!1, A.state];
          return [!1, void 0];
        })
        .then((A) => {
          var _;
          const [R, C] = A;
          if (((g = i.merge(C, (_ = s()) != null ? _ : p)), t(g, !0), R))
            return h();
        })
        .then(() => {
          S?.(g, void 0), (g = s()), (a = !0), l.forEach((A) => A(g));
        })
        .catch((A) => {
          S?.(void 0, A);
        });
    };
    return (
      (r.persist = {
        setOptions: (b) => {
          (i = { ...i, ...b }), b.storage && (c = b.storage);
        },
        clearStorage: () => {
          c?.removeItem(i.name);
        },
        getOptions: () => i,
        rehydrate: () => y(),
        hasHydrated: () => a,
        onHydrate: (b) => (
          o.add(b),
          () => {
            o.delete(b);
          }
        ),
        onFinishHydration: (b) => (
          l.add(b),
          () => {
            l.delete(b);
          }
        ),
      }),
      i.skipHydration || y(),
      g || p
    );
  },
  Vne = Hne;
var F6 = Symbol.for("immer-nothing"),
  Dj = Symbol.for("immer-draftable"),
  bn = Symbol.for("immer-state");
function Ji(n, ...e) {
  throw new Error(
    `[Immer] minified error nr: ${n}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var pf = Object.getPrototypeOf;
function gf(n) {
  return !!n && !!n[bn];
}
function Sl(n) {
  return n
    ? U6(n) ||
        Array.isArray(n) ||
        !!n[Dj] ||
        !!n.constructor?.[Dj] ||
        oE(n) ||
        lE(n)
    : !1;
}
var zne = Object.prototype.constructor.toString();
function U6(n) {
  if (!n || typeof n != "object") return !1;
  const e = pf(n);
  if (e === null) return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object
    ? !0
    : typeof t == "function" && Function.toString.call(t) === zne;
}
function wg(n, e) {
  aE(n) === 0
    ? Reflect.ownKeys(n).forEach((t) => {
        e(t, n[t], n);
      })
    : n.forEach((t, s) => e(s, t, n));
}
function aE(n) {
  const e = n[bn];
  return e ? e.type_ : Array.isArray(n) ? 1 : oE(n) ? 2 : lE(n) ? 3 : 0;
}
function oR(n, e) {
  return aE(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function $6(n, e, t) {
  const s = aE(n);
  s === 2 ? n.set(e, t) : s === 3 ? n.add(t) : (n[e] = t);
}
function Gne(n, e) {
  return n === e ? n !== 0 || 1 / n === 1 / e : n !== n && e !== e;
}
function oE(n) {
  return n instanceof Map;
}
function lE(n) {
  return n instanceof Set;
}
function rr(n) {
  return n.copy_ || n.base_;
}
function lR(n, e) {
  if (oE(n)) return new Map(n);
  if (lE(n)) return new Set(n);
  if (Array.isArray(n)) return Array.prototype.slice.call(n);
  const t = U6(n);
  if (e === !0 || (e === "class_only" && !t)) {
    const s = Object.getOwnPropertyDescriptors(n);
    delete s[bn];
    let r = Reflect.ownKeys(s);
    for (let i = 0; i < r.length; i++) {
      const a = r[i],
        o = s[a];
      o.writable === !1 && ((o.writable = !0), (o.configurable = !0)),
        (o.get || o.set) &&
          (s[a] = {
            configurable: !0,
            writable: !0,
            enumerable: o.enumerable,
            value: n[a],
          });
    }
    return Object.create(pf(n), s);
  } else {
    const s = pf(n);
    if (s !== null && t) return { ...n };
    const r = Object.create(s);
    return Object.assign(r, n);
  }
}
function $I(n, e = !1) {
  return (
    cE(n) ||
      gf(n) ||
      !Sl(n) ||
      (aE(n) > 1 && (n.set = n.add = n.clear = n.delete = qne),
      Object.freeze(n),
      e && Object.entries(n).forEach(([t, s]) => $I(s, !0))),
    n
  );
}
function qne() {
  Ji(2);
}
function cE(n) {
  return Object.isFrozen(n);
}
var cR = {};
function Ku(n) {
  const e = cR[n];
  return e || Ji(0, n), e;
}
function Wne(n, e) {
  cR[n] || (cR[n] = e);
}
var Eg;
function dx() {
  return Eg;
}
function Kne(n, e) {
  return {
    drafts_: [],
    parent_: n,
    immer_: e,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
  };
}
function Pj(n, e) {
  e &&
    (Ku("Patches"),
    (n.patches_ = []),
    (n.inversePatches_ = []),
    (n.patchListener_ = e));
}
function uR(n) {
  dR(n), n.drafts_.forEach(Yne), (n.drafts_ = null);
}
function dR(n) {
  n === Eg && (Eg = n.parent_);
}
function Mj(n) {
  return (Eg = Kne(Eg, n));
}
function Yne(n) {
  const e = n[bn];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : (e.revoked_ = !0);
}
function Nj(n, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return (
    n !== void 0 && n !== t
      ? (t[bn].modified_ && (uR(e), Ji(4)),
        Sl(n) && ((n = hx(e, n)), e.parent_ || fx(e, n)),
        e.patches_ &&
          Ku("Patches").generateReplacementPatches_(
            t[bn].base_,
            n,
            e.patches_,
            e.inversePatches_
          ))
      : (n = hx(e, t, [])),
    uR(e),
    e.patches_ && e.patchListener_(e.patches_, e.inversePatches_),
    n !== F6 ? n : void 0
  );
}
function hx(n, e, t) {
  if (cE(e)) return e;
  const s = e[bn];
  if (!s) return wg(e, (r, i) => Oj(n, s, e, r, i, t)), e;
  if (s.scope_ !== n) return e;
  if (!s.modified_) return fx(n, s.base_, !0), s.base_;
  if (!s.finalized_) {
    (s.finalized_ = !0), s.scope_.unfinalizedDrafts_--;
    const r = s.copy_;
    let i = r,
      a = !1;
    s.type_ === 3 && ((i = new Set(r)), r.clear(), (a = !0)),
      wg(i, (o, l) => Oj(n, s, r, o, l, t, a)),
      fx(n, r, !1),
      t &&
        n.patches_ &&
        Ku("Patches").generatePatches_(s, t, n.patches_, n.inversePatches_);
  }
  return s.copy_;
}
function Oj(n, e, t, s, r, i, a) {
  if (gf(r)) {
    const o =
        i && e && e.type_ !== 3 && !oR(e.assigned_, s) ? i.concat(s) : void 0,
      l = hx(n, r, o);
    if (($6(t, s, l), gf(l))) n.canAutoFreeze_ = !1;
    else return;
  } else a && t.add(r);
  if (Sl(r) && !cE(r)) {
    if (!n.immer_.autoFreeze_ && n.unfinalizedDrafts_ < 1) return;
    hx(n, r),
      (!e || !e.scope_.parent_) &&
        typeof s != "symbol" &&
        Object.prototype.propertyIsEnumerable.call(t, s) &&
        fx(n, r);
  }
}
function fx(n, e, t = !1) {
  !n.parent_ && n.immer_.autoFreeze_ && n.canAutoFreeze_ && $I(e, t);
}
function Xne(n, e) {
  const t = Array.isArray(n),
    s = {
      type_: t ? 1 : 0,
      scope_: e ? e.scope_ : dx(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: e,
      base_: n,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    };
  let r = s,
    i = BI;
  t && ((r = [s]), (i = Sg));
  const { revoke: a, proxy: o } = Proxy.revocable(r, i);
  return (s.draft_ = o), (s.revoke_ = a), o;
}
var BI = {
    get(n, e) {
      if (e === bn) return n;
      const t = rr(n);
      if (!oR(t, e)) return Qne(n, t, e);
      const s = t[e];
      return n.finalized_ || !Sl(s)
        ? s
        : s === U_(n.base_, e)
        ? ($_(n), (n.copy_[e] = Tg(s, n)))
        : s;
    },
    has(n, e) {
      return e in rr(n);
    },
    ownKeys(n) {
      return Reflect.ownKeys(rr(n));
    },
    set(n, e, t) {
      const s = B6(rr(n), e);
      if (s?.set) return s.set.call(n.draft_, t), !0;
      if (!n.modified_) {
        const r = U_(rr(n), e),
          i = r?.[bn];
        if (i && i.base_ === t)
          return (n.copy_[e] = t), (n.assigned_[e] = !1), !0;
        if (Gne(t, r) && (t !== void 0 || oR(n.base_, e))) return !0;
        $_(n), vl(n);
      }
      return (
        (n.copy_[e] === t && (t !== void 0 || e in n.copy_)) ||
          (Number.isNaN(t) && Number.isNaN(n.copy_[e])) ||
          ((n.copy_[e] = t), (n.assigned_[e] = !0)),
        !0
      );
    },
    deleteProperty(n, e) {
      return (
        U_(n.base_, e) !== void 0 || e in n.base_
          ? ((n.assigned_[e] = !1), $_(n), vl(n))
          : delete n.assigned_[e],
        n.copy_ && delete n.copy_[e],
        !0
      );
    },
    getOwnPropertyDescriptor(n, e) {
      const t = rr(n),
        s = Reflect.getOwnPropertyDescriptor(t, e);
      return (
        s && {
          writable: !0,
          configurable: n.type_ !== 1 || e !== "length",
          enumerable: s.enumerable,
          value: t[e],
        }
      );
    },
    defineProperty() {
      Ji(11);
    },
    getPrototypeOf(n) {
      return pf(n.base_);
    },
    setPrototypeOf() {
      Ji(12);
    },
  },
  Sg = {};
wg(BI, (n, e) => {
  Sg[n] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
});
Sg.deleteProperty = function (n, e) {
  return Sg.set.call(this, n, e, void 0);
};
Sg.set = function (n, e, t) {
  return BI.set.call(this, n[0], e, t, n[0]);
};
function U_(n, e) {
  const t = n[bn];
  return (t ? rr(t) : n)[e];
}
function Qne(n, e, t) {
  const s = B6(e, t);
  return s ? ("value" in s ? s.value : s.get?.call(n.draft_)) : void 0;
}
function B6(n, e) {
  if (!(e in n)) return;
  let t = pf(n);
  for (; t; ) {
    const s = Object.getOwnPropertyDescriptor(t, e);
    if (s) return s;
    t = pf(t);
  }
}
function vl(n) {
  n.modified_ || ((n.modified_ = !0), n.parent_ && vl(n.parent_));
}
function $_(n) {
  n.copy_ || (n.copy_ = lR(n.base_, n.scope_.immer_.useStrictShallowCopy_));
}
var Zne = class {
  constructor(n) {
    (this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (e, t, s) => {
        if (typeof e == "function" && typeof t != "function") {
          const i = t;
          t = e;
          const a = this;
          return function (l = i, ...c) {
            return a.produce(l, (h) => t.call(this, h, ...c));
          };
        }
        typeof t != "function" && Ji(6),
          s !== void 0 && typeof s != "function" && Ji(7);
        let r;
        if (Sl(e)) {
          const i = Mj(this),
            a = Tg(e, void 0);
          let o = !0;
          try {
            (r = t(a)), (o = !1);
          } finally {
            o ? uR(i) : dR(i);
          }
          return Pj(i, s), Nj(r, i);
        } else if (!e || typeof e != "object") {
          if (
            ((r = t(e)),
            r === void 0 && (r = e),
            r === F6 && (r = void 0),
            this.autoFreeze_ && $I(r, !0),
            s)
          ) {
            const i = [],
              a = [];
            Ku("Patches").generateReplacementPatches_(e, r, i, a), s(i, a);
          }
          return r;
        } else Ji(1, e);
      }),
      (this.produceWithPatches = (e, t) => {
        if (typeof e == "function")
          return (a, ...o) => this.produceWithPatches(a, (l) => e(l, ...o));
        let s, r;
        return [
          this.produce(e, t, (a, o) => {
            (s = a), (r = o);
          }),
          s,
          r,
        ];
      }),
      typeof n?.autoFreeze == "boolean" && this.setAutoFreeze(n.autoFreeze),
      typeof n?.useStrictShallowCopy == "boolean" &&
        this.setUseStrictShallowCopy(n.useStrictShallowCopy);
  }
  createDraft(n) {
    Sl(n) || Ji(8), gf(n) && (n = Jne(n));
    const e = Mj(this),
      t = Tg(n, void 0);
    return (t[bn].isManual_ = !0), dR(e), t;
  }
  finishDraft(n, e) {
    const t = n && n[bn];
    (!t || !t.isManual_) && Ji(9);
    const { scope_: s } = t;
    return Pj(s, e), Nj(void 0, s);
  }
  setAutoFreeze(n) {
    this.autoFreeze_ = n;
  }
  setUseStrictShallowCopy(n) {
    this.useStrictShallowCopy_ = n;
  }
  applyPatches(n, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const r = e[t];
      if (r.path.length === 0 && r.op === "replace") {
        n = r.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const s = Ku("Patches").applyPatches_;
    return gf(n) ? s(n, e) : this.produce(n, (r) => s(r, e));
  }
};
function Tg(n, e) {
  const t = oE(n)
    ? Ku("MapSet").proxyMap_(n, e)
    : lE(n)
    ? Ku("MapSet").proxySet_(n, e)
    : Xne(n, e);
  return (e ? e.scope_ : dx()).drafts_.push(t), t;
}
function Jne(n) {
  return gf(n) || Ji(10, n), H6(n);
}
function H6(n) {
  if (!Sl(n) || cE(n)) return n;
  const e = n[bn];
  let t;
  if (e) {
    if (!e.modified_) return e.base_;
    (e.finalized_ = !0), (t = lR(n, e.scope_.immer_.useStrictShallowCopy_));
  } else t = lR(n, !0);
  return (
    wg(t, (s, r) => {
      $6(t, s, H6(r));
    }),
    e && (e.finalized_ = !1),
    t
  );
}
function ese() {
  class n extends Map {
    constructor(l, c) {
      super(),
        (this[bn] = {
          type_: 2,
          parent_: c,
          scope_: c ? c.scope_ : dx(),
          modified_: !1,
          finalized_: !1,
          copy_: void 0,
          assigned_: void 0,
          base_: l,
          draft_: this,
          isManual_: !1,
          revoked_: !1,
        });
    }
    get size() {
      return rr(this[bn]).size;
    }
    has(l) {
      return rr(this[bn]).has(l);
    }
    set(l, c) {
      const h = this[bn];
      return (
        a(h),
        (!rr(h).has(l) || rr(h).get(l) !== c) &&
          (t(h),
          vl(h),
          h.assigned_.set(l, !0),
          h.copy_.set(l, c),
          h.assigned_.set(l, !0)),
        this
      );
    }
    delete(l) {
      if (!this.has(l)) return !1;
      const c = this[bn];
      return (
        a(c),
        t(c),
        vl(c),
        c.base_.has(l) ? c.assigned_.set(l, !1) : c.assigned_.delete(l),
        c.copy_.delete(l),
        !0
      );
    }
    clear() {
      const l = this[bn];
      a(l),
        rr(l).size &&
          (t(l),
          vl(l),
          (l.assigned_ = new Map()),
          wg(l.base_, (c) => {
            l.assigned_.set(c, !1);
          }),
          l.copy_.clear());
    }
    forEach(l, c) {
      const h = this[bn];
      rr(h).forEach((m, p, g) => {
        l.call(c, this.get(p), p, this);
      });
    }
    get(l) {
      const c = this[bn];
      a(c);
      const h = rr(c).get(l);
      if (c.finalized_ || !Sl(h) || h !== c.base_.get(l)) return h;
      const m = Tg(h, c);
      return t(c), c.copy_.set(l, m), m;
    }
    keys() {
      return rr(this[bn]).keys();
    }
    values() {
      const l = this.keys();
      return {
        [Symbol.iterator]: () => this.values(),
        next: () => {
          const c = l.next();
          return c.done ? c : { done: !1, value: this.get(c.value) };
        },
      };
    }
    entries() {
      const l = this.keys();
      return {
        [Symbol.iterator]: () => this.entries(),
        next: () => {
          const c = l.next();
          if (c.done) return c;
          const h = this.get(c.value);
          return { done: !1, value: [c.value, h] };
        },
      };
    }
    [Symbol.iterator]() {
      return this.entries();
    }
  }
  function e(o, l) {
    return new n(o, l);
  }
  function t(o) {
    o.copy_ || ((o.assigned_ = new Map()), (o.copy_ = new Map(o.base_)));
  }
  class s extends Set {
    constructor(l, c) {
      super(),
        (this[bn] = {
          type_: 3,
          parent_: c,
          scope_: c ? c.scope_ : dx(),
          modified_: !1,
          finalized_: !1,
          copy_: void 0,
          base_: l,
          draft_: this,
          drafts_: new Map(),
          revoked_: !1,
          isManual_: !1,
        });
    }
    get size() {
      return rr(this[bn]).size;
    }
    has(l) {
      const c = this[bn];
      return (
        a(c),
        c.copy_
          ? !!(
              c.copy_.has(l) ||
              (c.drafts_.has(l) && c.copy_.has(c.drafts_.get(l)))
            )
          : c.base_.has(l)
      );
    }
    add(l) {
      const c = this[bn];
      return a(c), this.has(l) || (i(c), vl(c), c.copy_.add(l)), this;
    }
    delete(l) {
      if (!this.has(l)) return !1;
      const c = this[bn];
      return (
        a(c),
        i(c),
        vl(c),
        c.copy_.delete(l) ||
          (c.drafts_.has(l) ? c.copy_.delete(c.drafts_.get(l)) : !1)
      );
    }
    clear() {
      const l = this[bn];
      a(l), rr(l).size && (i(l), vl(l), l.copy_.clear());
    }
    values() {
      const l = this[bn];
      return a(l), i(l), l.copy_.values();
    }
    entries() {
      const l = this[bn];
      return a(l), i(l), l.copy_.entries();
    }
    keys() {
      return this.values();
    }
    [Symbol.iterator]() {
      return this.values();
    }
    forEach(l, c) {
      const h = this.values();
      let m = h.next();
      for (; !m.done; ) l.call(c, m.value, m.value, this), (m = h.next());
    }
  }
  function r(o, l) {
    return new s(o, l);
  }
  function i(o) {
    o.copy_ ||
      ((o.copy_ = new Set()),
      o.base_.forEach((l) => {
        if (Sl(l)) {
          const c = Tg(l, o);
          o.drafts_.set(l, c), o.copy_.add(c);
        } else o.copy_.add(l);
      }));
  }
  function a(o) {
    o.revoked_ && Ji(3, JSON.stringify(rr(o)));
  }
  Wne("MapSet", { proxyMap_: e, proxySet_: r });
}
var Ci = new Zne(),
  tse = Ci.produce;
Ci.produceWithPatches.bind(Ci);
Ci.setAutoFreeze.bind(Ci);
Ci.setUseStrictShallowCopy.bind(Ci);
Ci.applyPatches.bind(Ci);
Ci.createDraft.bind(Ci);
Ci.finishDraft.bind(Ci);
const nse = (n) => (e, t, s) => (
    (s.setState = (r, i, ...a) => {
      const o = typeof r == "function" ? tse(r) : r;
      return e(o, i, ...a);
    }),
    n(s.setState, t, s)
  ),
  ha = nse,
  sse = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Lt(async () => {
              const { default: s } = await Promise.resolve().then(() => Uf);
              return { default: s };
            }, []).then(({ default: s }) => s(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  };
class HI extends Error {
  constructor(e, t = "FunctionsError", s) {
    super(e), (this.name = t), (this.context = s);
  }
}
class rse extends HI {
  constructor(e) {
    super(
      "Failed to send a request to the Edge Function",
      "FunctionsFetchError",
      e
    );
  }
}
class jj extends HI {
  constructor(e) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", e);
  }
}
class Fj extends HI {
  constructor(e) {
    super(
      "Edge Function returned a non-2xx status code",
      "FunctionsHttpError",
      e
    );
  }
}
var hR;
(function (n) {
  (n.Any = "any"),
    (n.ApNortheast1 = "ap-northeast-1"),
    (n.ApNortheast2 = "ap-northeast-2"),
    (n.ApSouth1 = "ap-south-1"),
    (n.ApSoutheast1 = "ap-southeast-1"),
    (n.ApSoutheast2 = "ap-southeast-2"),
    (n.CaCentral1 = "ca-central-1"),
    (n.EuCentral1 = "eu-central-1"),
    (n.EuWest1 = "eu-west-1"),
    (n.EuWest2 = "eu-west-2"),
    (n.EuWest3 = "eu-west-3"),
    (n.SaEast1 = "sa-east-1"),
    (n.UsEast1 = "us-east-1"),
    (n.UsWest1 = "us-west-1"),
    (n.UsWest2 = "us-west-2");
})(hR || (hR = {}));
var ise = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
class ase {
  constructor(e, { headers: t = {}, customFetch: s, region: r = hR.Any } = {}) {
    (this.url = e),
      (this.headers = t),
      (this.region = r),
      (this.fetch = sse(s));
  }
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`;
  }
  invoke(e, t = {}) {
    var s;
    return ise(this, void 0, void 0, function* () {
      try {
        const { headers: r, method: i, body: a } = t;
        let o = {},
          { region: l } = t;
        l || (l = this.region);
        const c = new URL(`${this.url}/${e}`);
        l &&
          l !== "any" &&
          ((o["x-region"] = l), c.searchParams.set("forceFunctionRegion", l));
        let h;
        a &&
          ((r && !Object.prototype.hasOwnProperty.call(r, "Content-Type")) ||
            !r) &&
          ((typeof Blob < "u" && a instanceof Blob) || a instanceof ArrayBuffer
            ? ((o["Content-Type"] = "application/octet-stream"), (h = a))
            : typeof a == "string"
            ? ((o["Content-Type"] = "text/plain"), (h = a))
            : typeof FormData < "u" && a instanceof FormData
            ? (h = a)
            : ((o["Content-Type"] = "application/json"),
              (h = JSON.stringify(a))));
        const m = yield this.fetch(c.toString(), {
            method: i || "POST",
            headers: Object.assign(
              Object.assign(Object.assign({}, o), this.headers),
              r
            ),
            body: h,
          }).catch((b) => {
            throw new rse(b);
          }),
          p = m.headers.get("x-relay-error");
        if (p && p === "true") throw new jj(m);
        if (!m.ok) throw new Fj(m);
        let g = (
            (s = m.headers.get("Content-Type")) !== null && s !== void 0
              ? s
              : "text/plain"
          )
            .split(";")[0]
            .trim(),
          y;
        return (
          g === "application/json"
            ? (y = yield m.json())
            : g === "application/octet-stream"
            ? (y = yield m.blob())
            : g === "text/event-stream"
            ? (y = m)
            : g === "multipart/form-data"
            ? (y = yield m.formData())
            : (y = yield m.text()),
          { data: y, error: null, response: m }
        );
      } catch (r) {
        return {
          data: null,
          error: r,
          response: r instanceof Fj || r instanceof jj ? r.context : void 0,
        };
      }
    });
  }
}
var Qs = {},
  Yd = {},
  Xd = {},
  Qd = {},
  Zd = {},
  Jd = {},
  ose = function () {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  },
  vf = ose();
const lse = vf.fetch,
  V6 = vf.fetch.bind(vf),
  z6 = vf.Headers,
  cse = vf.Request,
  use = vf.Response,
  Uf = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Headers: z6,
        Request: cse,
        Response: use,
        default: V6,
        fetch: lse,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  dse = yJ(Uf);
var ly = {},
  Uj;
function G6() {
  if (Uj) return ly;
  (Uj = 1), Object.defineProperty(ly, "__esModule", { value: !0 });
  class n extends Error {
    constructor(t) {
      super(t.message),
        (this.name = "PostgrestError"),
        (this.details = t.details),
        (this.hint = t.hint),
        (this.code = t.code);
    }
  }
  return (ly.default = n), ly;
}
var $j;
function q6() {
  if ($j) return Jd;
  $j = 1;
  var n =
    (Jd && Jd.__importDefault) ||
    function (r) {
      return r && r.__esModule ? r : { default: r };
    };
  Object.defineProperty(Jd, "__esModule", { value: !0 });
  const e = n(dse),
    t = n(G6());
  class s {
    constructor(i) {
      (this.shouldThrowOnError = !1),
        (this.method = i.method),
        (this.url = i.url),
        (this.headers = i.headers),
        (this.schema = i.schema),
        (this.body = i.body),
        (this.shouldThrowOnError = i.shouldThrowOnError),
        (this.signal = i.signal),
        (this.isMaybeSingle = i.isMaybeSingle),
        i.fetch
          ? (this.fetch = i.fetch)
          : typeof fetch > "u"
          ? (this.fetch = e.default)
          : (this.fetch = fetch);
    }
    throwOnError() {
      return (this.shouldThrowOnError = !0), this;
    }
    setHeader(i, a) {
      return (
        (this.headers = Object.assign({}, this.headers)),
        (this.headers[i] = a),
        this
      );
    }
    then(i, a) {
      this.schema === void 0 ||
        (["GET", "HEAD"].includes(this.method)
          ? (this.headers["Accept-Profile"] = this.schema)
          : (this.headers["Content-Profile"] = this.schema)),
        this.method !== "GET" &&
          this.method !== "HEAD" &&
          (this.headers["Content-Type"] = "application/json");
      const o = this.fetch;
      let l = o(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal,
      }).then(async (c) => {
        var h, m, p;
        let g = null,
          y = null,
          b = null,
          w = c.status,
          S = c.statusText;
        if (c.ok) {
          if (this.method !== "HEAD") {
            const C = await c.text();
            C === "" ||
              (this.headers.Accept === "text/csv" ||
              (this.headers.Accept &&
                this.headers.Accept.includes("application/vnd.pgrst.plan+text"))
                ? (y = C)
                : (y = JSON.parse(C)));
          }
          const _ =
              (h = this.headers.Prefer) === null || h === void 0
                ? void 0
                : h.match(/count=(exact|planned|estimated)/),
            R =
              (m = c.headers.get("content-range")) === null || m === void 0
                ? void 0
                : m.split("/");
          _ && R && R.length > 1 && (b = parseInt(R[1])),
            this.isMaybeSingle &&
              this.method === "GET" &&
              Array.isArray(y) &&
              (y.length > 1
                ? ((g = {
                    code: "PGRST116",
                    details: `Results contain ${y.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message:
                      "JSON object requested, multiple (or no) rows returned",
                  }),
                  (y = null),
                  (b = null),
                  (w = 406),
                  (S = "Not Acceptable"))
                : y.length === 1
                ? (y = y[0])
                : (y = null));
        } else {
          const _ = await c.text();
          try {
            (g = JSON.parse(_)),
              Array.isArray(g) &&
                c.status === 404 &&
                ((y = []), (g = null), (w = 200), (S = "OK"));
          } catch {
            c.status === 404 && _ === ""
              ? ((w = 204), (S = "No Content"))
              : (g = { message: _ });
          }
          if (
            (g &&
              this.isMaybeSingle &&
              !((p = g?.details) === null || p === void 0) &&
              p.includes("0 rows") &&
              ((g = null), (w = 200), (S = "OK")),
            g && this.shouldThrowOnError)
          )
            throw new t.default(g);
        }
        return { error: g, data: y, count: b, status: w, statusText: S };
      });
      return (
        this.shouldThrowOnError ||
          (l = l.catch((c) => {
            var h, m, p;
            return {
              error: {
                message: `${
                  (h = c?.name) !== null && h !== void 0 ? h : "FetchError"
                }: ${c?.message}`,
                details: `${(m = c?.stack) !== null && m !== void 0 ? m : ""}`,
                hint: "",
                code: `${(p = c?.code) !== null && p !== void 0 ? p : ""}`,
              },
              data: null,
              count: null,
              status: 0,
              statusText: "",
            };
          })),
        l.then(i, a)
      );
    }
    returns() {
      return this;
    }
    overrideTypes() {
      return this;
    }
  }
  return (Jd.default = s), Jd;
}
var Bj;
function W6() {
  if (Bj) return Zd;
  Bj = 1;
  var n =
    (Zd && Zd.__importDefault) ||
    function (s) {
      return s && s.__esModule ? s : { default: s };
    };
  Object.defineProperty(Zd, "__esModule", { value: !0 });
  const e = n(q6());
  class t extends e.default {
    select(r) {
      let i = !1;
      const a = (r ?? "*")
        .split("")
        .map((o) => (/\s/.test(o) && !i ? "" : (o === '"' && (i = !i), o)))
        .join("");
      return (
        this.url.searchParams.set("select", a),
        this.headers.Prefer && (this.headers.Prefer += ","),
        (this.headers.Prefer += "return=representation"),
        this
      );
    }
    order(
      r,
      {
        ascending: i = !0,
        nullsFirst: a,
        foreignTable: o,
        referencedTable: l = o,
      } = {}
    ) {
      const c = l ? `${l}.order` : "order",
        h = this.url.searchParams.get(c);
      return (
        this.url.searchParams.set(
          c,
          `${h ? `${h},` : ""}${r}.${i ? "asc" : "desc"}${
            a === void 0 ? "" : a ? ".nullsfirst" : ".nullslast"
          }`
        ),
        this
      );
    }
    limit(r, { foreignTable: i, referencedTable: a = i } = {}) {
      const o = typeof a > "u" ? "limit" : `${a}.limit`;
      return this.url.searchParams.set(o, `${r}`), this;
    }
    range(r, i, { foreignTable: a, referencedTable: o = a } = {}) {
      const l = typeof o > "u" ? "offset" : `${o}.offset`,
        c = typeof o > "u" ? "limit" : `${o}.limit`;
      return (
        this.url.searchParams.set(l, `${r}`),
        this.url.searchParams.set(c, `${i - r + 1}`),
        this
      );
    }
    abortSignal(r) {
      return (this.signal = r), this;
    }
    single() {
      return (this.headers.Accept = "application/vnd.pgrst.object+json"), this;
    }
    maybeSingle() {
      return (
        this.method === "GET"
          ? (this.headers.Accept = "application/json")
          : (this.headers.Accept = "application/vnd.pgrst.object+json"),
        (this.isMaybeSingle = !0),
        this
      );
    }
    csv() {
      return (this.headers.Accept = "text/csv"), this;
    }
    geojson() {
      return (this.headers.Accept = "application/geo+json"), this;
    }
    explain({
      analyze: r = !1,
      verbose: i = !1,
      settings: a = !1,
      buffers: o = !1,
      wal: l = !1,
      format: c = "text",
    } = {}) {
      var h;
      const m = [
          r ? "analyze" : null,
          i ? "verbose" : null,
          a ? "settings" : null,
          o ? "buffers" : null,
          l ? "wal" : null,
        ]
          .filter(Boolean)
          .join("|"),
        p =
          (h = this.headers.Accept) !== null && h !== void 0
            ? h
            : "application/json";
      return (
        (this.headers.Accept = `application/vnd.pgrst.plan+${c}; for="${p}"; options=${m};`),
        c === "json" ? this : this
      );
    }
    rollback() {
      var r;
      return (
        ((r = this.headers.Prefer) !== null && r !== void 0 ? r : "").trim()
          .length > 0
          ? (this.headers.Prefer += ",tx=rollback")
          : (this.headers.Prefer = "tx=rollback"),
        this
      );
    }
    returns() {
      return this;
    }
  }
  return (Zd.default = t), Zd;
}
var Hj;
function VI() {
  if (Hj) return Qd;
  Hj = 1;
  var n =
    (Qd && Qd.__importDefault) ||
    function (s) {
      return s && s.__esModule ? s : { default: s };
    };
  Object.defineProperty(Qd, "__esModule", { value: !0 });
  const e = n(W6());
  class t extends e.default {
    eq(r, i) {
      return this.url.searchParams.append(r, `eq.${i}`), this;
    }
    neq(r, i) {
      return this.url.searchParams.append(r, `neq.${i}`), this;
    }
    gt(r, i) {
      return this.url.searchParams.append(r, `gt.${i}`), this;
    }
    gte(r, i) {
      return this.url.searchParams.append(r, `gte.${i}`), this;
    }
    lt(r, i) {
      return this.url.searchParams.append(r, `lt.${i}`), this;
    }
    lte(r, i) {
      return this.url.searchParams.append(r, `lte.${i}`), this;
    }
    like(r, i) {
      return this.url.searchParams.append(r, `like.${i}`), this;
    }
    likeAllOf(r, i) {
      return (
        this.url.searchParams.append(r, `like(all).{${i.join(",")}}`), this
      );
    }
    likeAnyOf(r, i) {
      return (
        this.url.searchParams.append(r, `like(any).{${i.join(",")}}`), this
      );
    }
    ilike(r, i) {
      return this.url.searchParams.append(r, `ilike.${i}`), this;
    }
    ilikeAllOf(r, i) {
      return (
        this.url.searchParams.append(r, `ilike(all).{${i.join(",")}}`), this
      );
    }
    ilikeAnyOf(r, i) {
      return (
        this.url.searchParams.append(r, `ilike(any).{${i.join(",")}}`), this
      );
    }
    is(r, i) {
      return this.url.searchParams.append(r, `is.${i}`), this;
    }
    in(r, i) {
      const a = Array.from(new Set(i))
        .map((o) =>
          typeof o == "string" && new RegExp("[,()]").test(o)
            ? `"${o}"`
            : `${o}`
        )
        .join(",");
      return this.url.searchParams.append(r, `in.(${a})`), this;
    }
    contains(r, i) {
      return (
        typeof i == "string"
          ? this.url.searchParams.append(r, `cs.${i}`)
          : Array.isArray(i)
          ? this.url.searchParams.append(r, `cs.{${i.join(",")}}`)
          : this.url.searchParams.append(r, `cs.${JSON.stringify(i)}`),
        this
      );
    }
    containedBy(r, i) {
      return (
        typeof i == "string"
          ? this.url.searchParams.append(r, `cd.${i}`)
          : Array.isArray(i)
          ? this.url.searchParams.append(r, `cd.{${i.join(",")}}`)
          : this.url.searchParams.append(r, `cd.${JSON.stringify(i)}`),
        this
      );
    }
    rangeGt(r, i) {
      return this.url.searchParams.append(r, `sr.${i}`), this;
    }
    rangeGte(r, i) {
      return this.url.searchParams.append(r, `nxl.${i}`), this;
    }
    rangeLt(r, i) {
      return this.url.searchParams.append(r, `sl.${i}`), this;
    }
    rangeLte(r, i) {
      return this.url.searchParams.append(r, `nxr.${i}`), this;
    }
    rangeAdjacent(r, i) {
      return this.url.searchParams.append(r, `adj.${i}`), this;
    }
    overlaps(r, i) {
      return (
        typeof i == "string"
          ? this.url.searchParams.append(r, `ov.${i}`)
          : this.url.searchParams.append(r, `ov.{${i.join(",")}}`),
        this
      );
    }
    textSearch(r, i, { config: a, type: o } = {}) {
      let l = "";
      o === "plain"
        ? (l = "pl")
        : o === "phrase"
        ? (l = "ph")
        : o === "websearch" && (l = "w");
      const c = a === void 0 ? "" : `(${a})`;
      return this.url.searchParams.append(r, `${l}fts${c}.${i}`), this;
    }
    match(r) {
      return (
        Object.entries(r).forEach(([i, a]) => {
          this.url.searchParams.append(i, `eq.${a}`);
        }),
        this
      );
    }
    not(r, i, a) {
      return this.url.searchParams.append(r, `not.${i}.${a}`), this;
    }
    or(r, { foreignTable: i, referencedTable: a = i } = {}) {
      const o = a ? `${a}.or` : "or";
      return this.url.searchParams.append(o, `(${r})`), this;
    }
    filter(r, i, a) {
      return this.url.searchParams.append(r, `${i}.${a}`), this;
    }
  }
  return (Qd.default = t), Qd;
}
var Vj;
function K6() {
  if (Vj) return Xd;
  Vj = 1;
  var n =
    (Xd && Xd.__importDefault) ||
    function (s) {
      return s && s.__esModule ? s : { default: s };
    };
  Object.defineProperty(Xd, "__esModule", { value: !0 });
  const e = n(VI());
  class t {
    constructor(r, { headers: i = {}, schema: a, fetch: o }) {
      (this.url = r), (this.headers = i), (this.schema = a), (this.fetch = o);
    }
    select(r, { head: i = !1, count: a } = {}) {
      const o = i ? "HEAD" : "GET";
      let l = !1;
      const c = (r ?? "*")
        .split("")
        .map((h) => (/\s/.test(h) && !l ? "" : (h === '"' && (l = !l), h)))
        .join("");
      return (
        this.url.searchParams.set("select", c),
        a && (this.headers.Prefer = `count=${a}`),
        new e.default({
          method: o,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: !1,
        })
      );
    }
    insert(r, { count: i, defaultToNull: a = !0 } = {}) {
      const o = "POST",
        l = [];
      if (
        (this.headers.Prefer && l.push(this.headers.Prefer),
        i && l.push(`count=${i}`),
        a || l.push("missing=default"),
        (this.headers.Prefer = l.join(",")),
        Array.isArray(r))
      ) {
        const c = r.reduce((h, m) => h.concat(Object.keys(m)), []);
        if (c.length > 0) {
          const h = [...new Set(c)].map((m) => `"${m}"`);
          this.url.searchParams.set("columns", h.join(","));
        }
      }
      return new e.default({
        method: o,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: r,
        fetch: this.fetch,
        allowEmpty: !1,
      });
    }
    upsert(
      r,
      {
        onConflict: i,
        ignoreDuplicates: a = !1,
        count: o,
        defaultToNull: l = !0,
      } = {}
    ) {
      const c = "POST",
        h = [`resolution=${a ? "ignore" : "merge"}-duplicates`];
      if (
        (i !== void 0 && this.url.searchParams.set("on_conflict", i),
        this.headers.Prefer && h.push(this.headers.Prefer),
        o && h.push(`count=${o}`),
        l || h.push("missing=default"),
        (this.headers.Prefer = h.join(",")),
        Array.isArray(r))
      ) {
        const m = r.reduce((p, g) => p.concat(Object.keys(g)), []);
        if (m.length > 0) {
          const p = [...new Set(m)].map((g) => `"${g}"`);
          this.url.searchParams.set("columns", p.join(","));
        }
      }
      return new e.default({
        method: c,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: r,
        fetch: this.fetch,
        allowEmpty: !1,
      });
    }
    update(r, { count: i } = {}) {
      const a = "PATCH",
        o = [];
      return (
        this.headers.Prefer && o.push(this.headers.Prefer),
        i && o.push(`count=${i}`),
        (this.headers.Prefer = o.join(",")),
        new e.default({
          method: a,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: r,
          fetch: this.fetch,
          allowEmpty: !1,
        })
      );
    }
    delete({ count: r } = {}) {
      const i = "DELETE",
        a = [];
      return (
        r && a.push(`count=${r}`),
        this.headers.Prefer && a.unshift(this.headers.Prefer),
        (this.headers.Prefer = a.join(",")),
        new e.default({
          method: i,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
          allowEmpty: !1,
        })
      );
    }
  }
  return (Xd.default = t), Xd;
}
var Jm = {},
  ep = {},
  zj;
function hse() {
  return (
    zj ||
      ((zj = 1),
      Object.defineProperty(ep, "__esModule", { value: !0 }),
      (ep.version = void 0),
      (ep.version = "0.0.0-automated")),
    ep
  );
}
var Gj;
function fse() {
  if (Gj) return Jm;
  (Gj = 1),
    Object.defineProperty(Jm, "__esModule", { value: !0 }),
    (Jm.DEFAULT_HEADERS = void 0);
  const n = hse();
  return (
    (Jm.DEFAULT_HEADERS = { "X-Client-Info": `postgrest-js/${n.version}` }), Jm
  );
}
var qj;
function mse() {
  if (qj) return Yd;
  qj = 1;
  var n =
    (Yd && Yd.__importDefault) ||
    function (i) {
      return i && i.__esModule ? i : { default: i };
    };
  Object.defineProperty(Yd, "__esModule", { value: !0 });
  const e = n(K6()),
    t = n(VI()),
    s = fse();
  class r {
    constructor(a, { headers: o = {}, schema: l, fetch: c } = {}) {
      (this.url = a),
        (this.headers = Object.assign(Object.assign({}, s.DEFAULT_HEADERS), o)),
        (this.schemaName = l),
        (this.fetch = c);
    }
    from(a) {
      const o = new URL(`${this.url}/${a}`);
      return new e.default(o, {
        headers: Object.assign({}, this.headers),
        schema: this.schemaName,
        fetch: this.fetch,
      });
    }
    schema(a) {
      return new r(this.url, {
        headers: this.headers,
        schema: a,
        fetch: this.fetch,
      });
    }
    rpc(a, o = {}, { head: l = !1, get: c = !1, count: h } = {}) {
      let m;
      const p = new URL(`${this.url}/rpc/${a}`);
      let g;
      l || c
        ? ((m = l ? "HEAD" : "GET"),
          Object.entries(o)
            .filter(([b, w]) => w !== void 0)
            .map(([b, w]) => [
              b,
              Array.isArray(w) ? `{${w.join(",")}}` : `${w}`,
            ])
            .forEach(([b, w]) => {
              p.searchParams.append(b, w);
            }))
        : ((m = "POST"), (g = o));
      const y = Object.assign({}, this.headers);
      return (
        h && (y.Prefer = `count=${h}`),
        new t.default({
          method: m,
          url: p,
          headers: y,
          schema: this.schemaName,
          body: g,
          fetch: this.fetch,
          allowEmpty: !1,
        })
      );
    }
  }
  return (Yd.default = r), Yd;
}
var Wj;
function pse() {
  if (Wj) return Qs;
  Wj = 1;
  var n =
    (Qs && Qs.__importDefault) ||
    function (o) {
      return o && o.__esModule ? o : { default: o };
    };
  Object.defineProperty(Qs, "__esModule", { value: !0 }),
    (Qs.PostgrestError =
      Qs.PostgrestBuilder =
      Qs.PostgrestTransformBuilder =
      Qs.PostgrestFilterBuilder =
      Qs.PostgrestQueryBuilder =
      Qs.PostgrestClient =
        void 0);
  const e = n(mse());
  Qs.PostgrestClient = e.default;
  const t = n(K6());
  Qs.PostgrestQueryBuilder = t.default;
  const s = n(VI());
  Qs.PostgrestFilterBuilder = s.default;
  const r = n(W6());
  Qs.PostgrestTransformBuilder = r.default;
  const i = n(q6());
  Qs.PostgrestBuilder = i.default;
  const a = n(G6());
  return (
    (Qs.PostgrestError = a.default),
    (Qs.default = {
      PostgrestClient: e.default,
      PostgrestQueryBuilder: t.default,
      PostgrestFilterBuilder: s.default,
      PostgrestTransformBuilder: r.default,
      PostgrestBuilder: i.default,
      PostgrestError: a.default,
    }),
    Qs
  );
}
var gse = pse();
const vse = ad(gse),
  {
    PostgrestClient: yse,
    PostgrestQueryBuilder: BMe,
    PostgrestFilterBuilder: HMe,
    PostgrestTransformBuilder: VMe,
    PostgrestBuilder: zMe,
    PostgrestError: GMe,
  } = vse;
function bse() {
  if (typeof WebSocket < "u") return WebSocket;
  if (typeof global.WebSocket < "u") return global.WebSocket;
  if (typeof window.WebSocket < "u") return window.WebSocket;
  if (typeof self.WebSocket < "u") return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}
const xse = bse(),
  wse = "2.11.15",
  Ese = `realtime-js/${wse}`,
  Sse = "1.0.0",
  Y6 = 1e4,
  Tse = 1e3;
var Hp;
(function (n) {
  (n[(n.connecting = 0)] = "connecting"),
    (n[(n.open = 1)] = "open"),
    (n[(n.closing = 2)] = "closing"),
    (n[(n.closed = 3)] = "closed");
})(Hp || (Hp = {}));
var Tr;
(function (n) {
  (n.closed = "closed"),
    (n.errored = "errored"),
    (n.joined = "joined"),
    (n.joining = "joining"),
    (n.leaving = "leaving");
})(Tr || (Tr = {}));
var Aa;
(function (n) {
  (n.close = "phx_close"),
    (n.error = "phx_error"),
    (n.join = "phx_join"),
    (n.reply = "phx_reply"),
    (n.leave = "phx_leave"),
    (n.access_token = "access_token");
})(Aa || (Aa = {}));
var fR;
(function (n) {
  n.websocket = "websocket";
})(fR || (fR = {}));
var Pu;
(function (n) {
  (n.Connecting = "connecting"),
    (n.Open = "open"),
    (n.Closing = "closing"),
    (n.Closed = "closed");
})(Pu || (Pu = {}));
class _se {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(e, t) {
    return e.constructor === ArrayBuffer
      ? t(this._binaryDecode(e))
      : t(typeof e == "string" ? JSON.parse(e) : {});
  }
  _binaryDecode(e) {
    const t = new DataView(e),
      s = new TextDecoder();
    return this._decodeBroadcast(e, t, s);
  }
  _decodeBroadcast(e, t, s) {
    const r = t.getUint8(1),
      i = t.getUint8(2);
    let a = this.HEADER_LENGTH + 2;
    const o = s.decode(e.slice(a, a + r));
    a = a + r;
    const l = s.decode(e.slice(a, a + i));
    a = a + i;
    const c = JSON.parse(s.decode(e.slice(a, e.byteLength)));
    return { ref: null, topic: o, event: l, payload: c };
  }
}
class X6 {
  constructor(e, t) {
    (this.callback = e),
      (this.timerCalc = t),
      (this.timer = void 0),
      (this.tries = 0),
      (this.callback = e),
      (this.timerCalc = t);
  }
  reset() {
    (this.tries = 0), clearTimeout(this.timer);
  }
  scheduleTimeout() {
    clearTimeout(this.timer),
      (this.timer = setTimeout(() => {
        (this.tries = this.tries + 1), this.callback();
      }, this.timerCalc(this.tries + 1)));
  }
}
var Un;
(function (n) {
  (n.abstime = "abstime"),
    (n.bool = "bool"),
    (n.date = "date"),
    (n.daterange = "daterange"),
    (n.float4 = "float4"),
    (n.float8 = "float8"),
    (n.int2 = "int2"),
    (n.int4 = "int4"),
    (n.int4range = "int4range"),
    (n.int8 = "int8"),
    (n.int8range = "int8range"),
    (n.json = "json"),
    (n.jsonb = "jsonb"),
    (n.money = "money"),
    (n.numeric = "numeric"),
    (n.oid = "oid"),
    (n.reltime = "reltime"),
    (n.text = "text"),
    (n.time = "time"),
    (n.timestamp = "timestamp"),
    (n.timestamptz = "timestamptz"),
    (n.timetz = "timetz"),
    (n.tsrange = "tsrange"),
    (n.tstzrange = "tstzrange");
})(Un || (Un = {}));
const Kj = (n, e, t = {}) => {
    var s;
    const r = (s = t.skipTypes) !== null && s !== void 0 ? s : [];
    return Object.keys(e).reduce((i, a) => ((i[a] = Ase(a, n, e, r)), i), {});
  },
  Ase = (n, e, t, s) => {
    const r = e.find((o) => o.name === n),
      i = r?.type,
      a = t[n];
    return i && !s.includes(i) ? Q6(i, a) : mR(a);
  },
  Q6 = (n, e) => {
    if (n.charAt(0) === "_") {
      const t = n.slice(1, n.length);
      return Ise(e, t);
    }
    switch (n) {
      case Un.bool:
        return Rse(e);
      case Un.float4:
      case Un.float8:
      case Un.int2:
      case Un.int4:
      case Un.int8:
      case Un.numeric:
      case Un.oid:
        return kse(e);
      case Un.json:
      case Un.jsonb:
        return Cse(e);
      case Un.timestamp:
        return Lse(e);
      case Un.abstime:
      case Un.date:
      case Un.daterange:
      case Un.int4range:
      case Un.int8range:
      case Un.money:
      case Un.reltime:
      case Un.text:
      case Un.time:
      case Un.timestamptz:
      case Un.timetz:
      case Un.tsrange:
      case Un.tstzrange:
        return mR(e);
      default:
        return mR(e);
    }
  },
  mR = (n) => n,
  Rse = (n) => {
    switch (n) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return n;
    }
  },
  kse = (n) => {
    if (typeof n == "string") {
      const e = parseFloat(n);
      if (!Number.isNaN(e)) return e;
    }
    return n;
  },
  Cse = (n) => {
    if (typeof n == "string")
      try {
        return JSON.parse(n);
      } catch (e) {
        return `${e}`, n;
      }
    return n;
  },
  Ise = (n, e) => {
    if (typeof n != "string") return n;
    const t = n.length - 1,
      s = n[t];
    if (n[0] === "{" && s === "}") {
      let i;
      const a = n.slice(1, t);
      try {
        i = JSON.parse("[" + a + "]");
      } catch {
        i = a ? a.split(",") : [];
      }
      return i.map((o) => Q6(e, o));
    }
    return n;
  },
  Lse = (n) => (typeof n == "string" ? n.replace(" ", "T") : n),
  Z6 = (n) => {
    let e = n;
    return (
      (e = e.replace(/^ws/i, "http")),
      (e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "")),
      e.replace(/\/+$/, "")
    );
  };
class B_ {
  constructor(e, t, s = {}, r = Y6) {
    (this.channel = e),
      (this.event = t),
      (this.payload = s),
      (this.timeout = r),
      (this.sent = !1),
      (this.timeoutTimer = void 0),
      (this.ref = ""),
      (this.receivedResp = null),
      (this.recHooks = []),
      (this.refEvent = null);
  }
  resend(e) {
    (this.timeout = e),
      this._cancelRefEvent(),
      (this.ref = ""),
      (this.refEvent = null),
      (this.receivedResp = null),
      (this.sent = !1),
      this.send();
  }
  send() {
    this._hasReceived("timeout") ||
      (this.startTimeout(),
      (this.sent = !0),
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef(),
      }));
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e);
  }
  receive(e, t) {
    var s;
    return (
      this._hasReceived(e) &&
        t(
          (s = this.receivedResp) === null || s === void 0 ? void 0 : s.response
        ),
      this.recHooks.push({ status: e, callback: t }),
      this
    );
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    (this.ref = this.channel.socket._makeRef()),
      (this.refEvent = this.channel._replyEventName(this.ref));
    const e = (t) => {
      this._cancelRefEvent(),
        this._cancelTimeout(),
        (this.receivedResp = t),
        this._matchReceive(t);
    };
    this.channel._on(this.refEvent, {}, e),
      (this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout));
  }
  trigger(e, t) {
    this.refEvent &&
      this.channel._trigger(this.refEvent, { status: e, response: t });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0);
  }
  _matchReceive({ status: e, response: t }) {
    this.recHooks.filter((s) => s.status === e).forEach((s) => s.callback(t));
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
}
var Yj;
(function (n) {
  (n.SYNC = "sync"), (n.JOIN = "join"), (n.LEAVE = "leave");
})(Yj || (Yj = {}));
class Vp {
  constructor(e, t) {
    (this.channel = e),
      (this.state = {}),
      (this.pendingDiffs = []),
      (this.joinRef = null),
      (this.caller = { onJoin: () => {}, onLeave: () => {}, onSync: () => {} });
    const s = t?.events || { state: "presence_state", diff: "presence_diff" };
    this.channel._on(s.state, {}, (r) => {
      const { onJoin: i, onLeave: a, onSync: o } = this.caller;
      (this.joinRef = this.channel._joinRef()),
        (this.state = Vp.syncState(this.state, r, i, a)),
        this.pendingDiffs.forEach((l) => {
          this.state = Vp.syncDiff(this.state, l, i, a);
        }),
        (this.pendingDiffs = []),
        o();
    }),
      this.channel._on(s.diff, {}, (r) => {
        const { onJoin: i, onLeave: a, onSync: o } = this.caller;
        this.inPendingSyncState()
          ? this.pendingDiffs.push(r)
          : ((this.state = Vp.syncDiff(this.state, r, i, a)), o());
      }),
      this.onJoin((r, i, a) => {
        this.channel._trigger("presence", {
          event: "join",
          key: r,
          currentPresences: i,
          newPresences: a,
        });
      }),
      this.onLeave((r, i, a) => {
        this.channel._trigger("presence", {
          event: "leave",
          key: r,
          currentPresences: i,
          leftPresences: a,
        });
      }),
      this.onSync(() => {
        this.channel._trigger("presence", { event: "sync" });
      });
  }
  static syncState(e, t, s, r) {
    const i = this.cloneDeep(e),
      a = this.transformState(t),
      o = {},
      l = {};
    return (
      this.map(i, (c, h) => {
        a[c] || (l[c] = h);
      }),
      this.map(a, (c, h) => {
        const m = i[c];
        if (m) {
          const p = h.map((w) => w.presence_ref),
            g = m.map((w) => w.presence_ref),
            y = h.filter((w) => g.indexOf(w.presence_ref) < 0),
            b = m.filter((w) => p.indexOf(w.presence_ref) < 0);
          y.length > 0 && (o[c] = y), b.length > 0 && (l[c] = b);
        } else o[c] = h;
      }),
      this.syncDiff(i, { joins: o, leaves: l }, s, r)
    );
  }
  static syncDiff(e, t, s, r) {
    const { joins: i, leaves: a } = {
      joins: this.transformState(t.joins),
      leaves: this.transformState(t.leaves),
    };
    return (
      s || (s = () => {}),
      r || (r = () => {}),
      this.map(i, (o, l) => {
        var c;
        const h = (c = e[o]) !== null && c !== void 0 ? c : [];
        if (((e[o] = this.cloneDeep(l)), h.length > 0)) {
          const m = e[o].map((g) => g.presence_ref),
            p = h.filter((g) => m.indexOf(g.presence_ref) < 0);
          e[o].unshift(...p);
        }
        s(o, h, l);
      }),
      this.map(a, (o, l) => {
        let c = e[o];
        if (!c) return;
        const h = l.map((m) => m.presence_ref);
        (c = c.filter((m) => h.indexOf(m.presence_ref) < 0)),
          (e[o] = c),
          r(o, c, l),
          c.length === 0 && delete e[o];
      }),
      e
    );
  }
  static map(e, t) {
    return Object.getOwnPropertyNames(e).map((s) => t(s, e[s]));
  }
  static transformState(e) {
    return (
      (e = this.cloneDeep(e)),
      Object.getOwnPropertyNames(e).reduce((t, s) => {
        const r = e[s];
        return (
          "metas" in r
            ? (t[s] = r.metas.map(
                (i) => (
                  (i.presence_ref = i.phx_ref),
                  delete i.phx_ref,
                  delete i.phx_ref_prev,
                  i
                )
              ))
            : (t[s] = r),
          t
        );
      }, {})
    );
  }
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e));
  }
  onJoin(e) {
    this.caller.onJoin = e;
  }
  onLeave(e) {
    this.caller.onLeave = e;
  }
  onSync(e) {
    this.caller.onSync = e;
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var Xj;
(function (n) {
  (n.ALL = "*"),
    (n.INSERT = "INSERT"),
    (n.UPDATE = "UPDATE"),
    (n.DELETE = "DELETE");
})(Xj || (Xj = {}));
var Qj;
(function (n) {
  (n.BROADCAST = "broadcast"),
    (n.PRESENCE = "presence"),
    (n.POSTGRES_CHANGES = "postgres_changes"),
    (n.SYSTEM = "system");
})(Qj || (Qj = {}));
var cl;
(function (n) {
  (n.SUBSCRIBED = "SUBSCRIBED"),
    (n.TIMED_OUT = "TIMED_OUT"),
    (n.CLOSED = "CLOSED"),
    (n.CHANNEL_ERROR = "CHANNEL_ERROR");
})(cl || (cl = {}));
class zI {
  constructor(e, t = { config: {} }, s) {
    (this.topic = e),
      (this.params = t),
      (this.socket = s),
      (this.bindings = {}),
      (this.state = Tr.closed),
      (this.joinedOnce = !1),
      (this.pushBuffer = []),
      (this.subTopic = e.replace(/^realtime:/i, "")),
      (this.params.config = Object.assign(
        {
          broadcast: { ack: !1, self: !1 },
          presence: { key: "" },
          private: !1,
        },
        t.config
      )),
      (this.timeout = this.socket.timeout),
      (this.joinPush = new B_(this, Aa.join, this.params, this.timeout)),
      (this.rejoinTimer = new X6(
        () => this._rejoinUntilConnected(),
        this.socket.reconnectAfterMs
      )),
      this.joinPush.receive("ok", () => {
        (this.state = Tr.joined),
          this.rejoinTimer.reset(),
          this.pushBuffer.forEach((r) => r.send()),
          (this.pushBuffer = []);
      }),
      this._onClose(() => {
        this.rejoinTimer.reset(),
          this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
          (this.state = Tr.closed),
          this.socket._remove(this);
      }),
      this._onError((r) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log("channel", `error ${this.topic}`, r),
          (this.state = Tr.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive("timeout", () => {
        this._isJoining() &&
          (this.socket.log(
            "channel",
            `timeout ${this.topic}`,
            this.joinPush.timeout
          ),
          (this.state = Tr.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this._on(Aa.reply, {}, (r, i) => {
        this._trigger(this._replyEventName(i), r);
      }),
      (this.presence = new Vp(this)),
      (this.broadcastEndpointURL = Z6(this.socket.endPoint) + "/api/broadcast"),
      (this.private = this.params.config.private || !1);
  }
  subscribe(e, t = this.timeout) {
    var s, r;
    if (
      (this.socket.isConnected() || this.socket.connect(),
      this.state == Tr.closed)
    ) {
      const {
        config: { broadcast: i, presence: a, private: o },
      } = this.params;
      this._onError((h) => e?.(cl.CHANNEL_ERROR, h)),
        this._onClose(() => e?.(cl.CLOSED));
      const l = {},
        c = {
          broadcast: i,
          presence: a,
          postgres_changes:
            (r =
              (s = this.bindings.postgres_changes) === null || s === void 0
                ? void 0
                : s.map((h) => h.filter)) !== null && r !== void 0
              ? r
              : [],
          private: o,
        };
      this.socket.accessTokenValue &&
        (l.access_token = this.socket.accessTokenValue),
        this.updateJoinPayload(Object.assign({ config: c }, l)),
        (this.joinedOnce = !0),
        this._rejoin(t),
        this.joinPush
          .receive("ok", async ({ postgres_changes: h }) => {
            var m;
            if ((this.socket.setAuth(), h === void 0)) {
              e?.(cl.SUBSCRIBED);
              return;
            } else {
              const p = this.bindings.postgres_changes,
                g = (m = p?.length) !== null && m !== void 0 ? m : 0,
                y = [];
              for (let b = 0; b < g; b++) {
                const w = p[b],
                  {
                    filter: { event: S, schema: A, table: _, filter: R },
                  } = w,
                  C = h && h[b];
                if (
                  C &&
                  C.event === S &&
                  C.schema === A &&
                  C.table === _ &&
                  C.filter === R
                )
                  y.push(Object.assign(Object.assign({}, w), { id: C.id }));
                else {
                  this.unsubscribe(),
                    (this.state = Tr.errored),
                    e?.(
                      cl.CHANNEL_ERROR,
                      new Error(
                        "mismatch between server and client bindings for postgres changes"
                      )
                    );
                  return;
                }
              }
              (this.bindings.postgres_changes = y), e && e(cl.SUBSCRIBED);
              return;
            }
          })
          .receive("error", (h) => {
            (this.state = Tr.errored),
              e?.(
                cl.CHANNEL_ERROR,
                new Error(
                  JSON.stringify(Object.values(h).join(", ") || "error")
                )
              );
          })
          .receive("timeout", () => {
            e?.(cl.TIMED_OUT);
          });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(e, t = {}) {
    return await this.send(
      { type: "presence", event: "track", payload: e },
      t.timeout || this.timeout
    );
  }
  async untrack(e = {}) {
    return await this.send({ type: "presence", event: "untrack" }, e);
  }
  on(e, t, s) {
    return this._on(e, t, s);
  }
  async send(e, t = {}) {
    var s, r;
    if (!this._canPush() && e.type === "broadcast") {
      const { event: i, payload: a } = e,
        l = {
          method: "POST",
          headers: {
            Authorization: this.socket.accessTokenValue
              ? `Bearer ${this.socket.accessTokenValue}`
              : "",
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event: i,
                payload: a,
                private: this.private,
              },
            ],
          }),
        };
      try {
        const c = await this._fetchWithTimeout(
          this.broadcastEndpointURL,
          l,
          (s = t.timeout) !== null && s !== void 0 ? s : this.timeout
        );
        return (
          await ((r = c.body) === null || r === void 0 ? void 0 : r.cancel()),
          c.ok ? "ok" : "error"
        );
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((i) => {
        var a, o, l;
        const c = this._push(e.type, e, t.timeout || this.timeout);
        e.type === "broadcast" &&
          !(
            !(
              (l =
                (o =
                  (a = this.params) === null || a === void 0
                    ? void 0
                    : a.config) === null || o === void 0
                  ? void 0
                  : o.broadcast) === null || l === void 0
            ) && l.ack
          ) &&
          i("ok"),
          c.receive("ok", () => i("ok")),
          c.receive("error", () => i("error")),
          c.receive("timeout", () => i("timed out"));
      });
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e);
  }
  unsubscribe(e = this.timeout) {
    this.state = Tr.leaving;
    const t = () => {
      this.socket.log("channel", `leave ${this.topic}`),
        this._trigger(Aa.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let s = null;
    return new Promise((r) => {
      (s = new B_(this, Aa.leave, {}, e)),
        s
          .receive("ok", () => {
            t(), r("ok");
          })
          .receive("timeout", () => {
            t(), r("timed out");
          })
          .receive("error", () => {
            r("error");
          }),
        s.send(),
        this._canPush() || s.trigger("ok", {});
    }).finally(() => {
      s?.destroy();
    });
  }
  teardown() {
    this.pushBuffer.forEach((e) => e.destroy()),
      this.rejoinTimer && clearTimeout(this.rejoinTimer.timer),
      this.joinPush.destroy();
  }
  async _fetchWithTimeout(e, t, s) {
    const r = new AbortController(),
      i = setTimeout(() => r.abort(), s),
      a = await this.socket.fetch(
        e,
        Object.assign(Object.assign({}, t), { signal: r.signal })
      );
    return clearTimeout(i), a;
  }
  _push(e, t, s = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let r = new B_(this, e, t, s);
    return (
      this._canPush() ? r.send() : (r.startTimeout(), this.pushBuffer.push(r)),
      r
    );
  }
  _onMessage(e, t, s) {
    return t;
  }
  _isMember(e) {
    return this.topic === e;
  }
  _joinRef() {
    return this.joinPush.ref;
  }
  _trigger(e, t, s) {
    var r, i;
    const a = e.toLocaleLowerCase(),
      { close: o, error: l, leave: c, join: h } = Aa;
    if (s && [o, l, c, h].indexOf(a) >= 0 && s !== this._joinRef()) return;
    let p = this._onMessage(a, t, s);
    if (t && !p)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(a)
      ? (r = this.bindings.postgres_changes) === null ||
        r === void 0 ||
        r
          .filter((g) => {
            var y, b, w;
            return (
              ((y = g.filter) === null || y === void 0 ? void 0 : y.event) ===
                "*" ||
              ((w =
                (b = g.filter) === null || b === void 0 ? void 0 : b.event) ===
                null || w === void 0
                ? void 0
                : w.toLocaleLowerCase()) === a
            );
          })
          .map((g) => g.callback(p, s))
      : (i = this.bindings[a]) === null ||
        i === void 0 ||
        i
          .filter((g) => {
            var y, b, w, S, A, _;
            if (["broadcast", "presence", "postgres_changes"].includes(a))
              if ("id" in g) {
                const R = g.id,
                  C =
                    (y = g.filter) === null || y === void 0 ? void 0 : y.event;
                return (
                  R &&
                  ((b = t.ids) === null || b === void 0
                    ? void 0
                    : b.includes(R)) &&
                  (C === "*" ||
                    C?.toLocaleLowerCase() ===
                      ((w = t.data) === null || w === void 0
                        ? void 0
                        : w.type.toLocaleLowerCase()))
                );
              } else {
                const R =
                  (A =
                    (S = g?.filter) === null || S === void 0
                      ? void 0
                      : S.event) === null || A === void 0
                    ? void 0
                    : A.toLocaleLowerCase();
                return (
                  R === "*" ||
                  R ===
                    ((_ = t?.event) === null || _ === void 0
                      ? void 0
                      : _.toLocaleLowerCase())
                );
              }
            else return g.type.toLocaleLowerCase() === a;
          })
          .map((g) => {
            if (typeof p == "object" && "ids" in p) {
              const y = p.data,
                {
                  schema: b,
                  table: w,
                  commit_timestamp: S,
                  type: A,
                  errors: _,
                } = y;
              p = Object.assign(
                Object.assign(
                  {},
                  {
                    schema: b,
                    table: w,
                    commit_timestamp: S,
                    eventType: A,
                    new: {},
                    old: {},
                    errors: _,
                  }
                ),
                this._getPayloadRecords(y)
              );
            }
            g.callback(p, s);
          });
  }
  _isClosed() {
    return this.state === Tr.closed;
  }
  _isJoined() {
    return this.state === Tr.joined;
  }
  _isJoining() {
    return this.state === Tr.joining;
  }
  _isLeaving() {
    return this.state === Tr.leaving;
  }
  _replyEventName(e) {
    return `chan_reply_${e}`;
  }
  _on(e, t, s) {
    const r = e.toLocaleLowerCase(),
      i = { type: r, filter: t, callback: s };
    return (
      this.bindings[r] ? this.bindings[r].push(i) : (this.bindings[r] = [i]),
      this
    );
  }
  _off(e, t) {
    const s = e.toLocaleLowerCase();
    return (
      (this.bindings[s] = this.bindings[s].filter((r) => {
        var i;
        return !(
          ((i = r.type) === null || i === void 0
            ? void 0
            : i.toLocaleLowerCase()) === s && zI.isEqual(r.filter, t)
        );
      })),
      this
    );
  }
  static isEqual(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const s in e) if (e[s] !== t[s]) return !1;
    return !0;
  }
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(),
      this.socket.isConnected() && this._rejoin();
  }
  _onClose(e) {
    this._on(Aa.close, {}, e);
  }
  _onError(e) {
    this._on(Aa.error, {}, (t) => e(t));
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  _rejoin(e = this.timeout) {
    this._isLeaving() ||
      (this.socket._leaveOpenTopic(this.topic),
      (this.state = Tr.joining),
      this.joinPush.resend(e));
  }
  _getPayloadRecords(e) {
    const t = { new: {}, old: {} };
    return (
      (e.type === "INSERT" || e.type === "UPDATE") &&
        (t.new = Kj(e.columns, e.record)),
      (e.type === "UPDATE" || e.type === "DELETE") &&
        (t.old = Kj(e.columns, e.old_record)),
      t
    );
  }
}
const Zj = () => {},
  Dse = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class Pse {
  constructor(e, t) {
    var s;
    (this.accessTokenValue = null),
      (this.apiKey = null),
      (this.channels = new Array()),
      (this.endPoint = ""),
      (this.httpEndpoint = ""),
      (this.headers = {}),
      (this.params = {}),
      (this.timeout = Y6),
      (this.heartbeatIntervalMs = 25e3),
      (this.heartbeatTimer = void 0),
      (this.pendingHeartbeatRef = null),
      (this.heartbeatCallback = Zj),
      (this.ref = 0),
      (this.logger = Zj),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.serializer = new _se()),
      (this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: [],
      }),
      (this.accessToken = null),
      (this._resolveFetch = (i) => {
        let a;
        return (
          i
            ? (a = i)
            : typeof fetch > "u"
            ? (a = (...o) =>
                Lt(async () => {
                  const { default: l } = await Promise.resolve().then(() => Uf);
                  return { default: l };
                }, void 0).then(({ default: l }) => l(...o)))
            : (a = fetch),
          (...o) => a(...o)
        );
      }),
      (this.endPoint = `${e}/${fR.websocket}`),
      (this.httpEndpoint = Z6(e)),
      t?.transport ? (this.transport = t.transport) : (this.transport = null),
      t?.params && (this.params = t.params),
      t?.timeout && (this.timeout = t.timeout),
      t?.logger && (this.logger = t.logger),
      (t?.logLevel || t?.log_level) &&
        ((this.logLevel = t.logLevel || t.log_level),
        (this.params = Object.assign(Object.assign({}, this.params), {
          log_level: this.logLevel,
        }))),
      t?.heartbeatIntervalMs &&
        (this.heartbeatIntervalMs = t.heartbeatIntervalMs);
    const r = (s = t?.params) === null || s === void 0 ? void 0 : s.apikey;
    if (
      (r && ((this.accessTokenValue = r), (this.apiKey = r)),
      (this.reconnectAfterMs = t?.reconnectAfterMs
        ? t.reconnectAfterMs
        : (i) => [1e3, 2e3, 5e3, 1e4][i - 1] || 1e4),
      (this.encode = t?.encode ? t.encode : (i, a) => a(JSON.stringify(i))),
      (this.decode = t?.decode
        ? t.decode
        : this.serializer.decode.bind(this.serializer)),
      (this.reconnectTimer = new X6(async () => {
        this.disconnect(), this.connect();
      }, this.reconnectAfterMs)),
      (this.fetch = this._resolveFetch(t?.fetch)),
      t?.worker)
    ) {
      if (typeof window < "u" && !window.Worker)
        throw new Error("Web Worker is not supported");
      (this.worker = t?.worker || !1), (this.workerUrl = t?.workerUrl);
    }
    this.accessToken = t?.accessToken || null;
  }
  connect() {
    if (!this.conn) {
      if ((this.transport || (this.transport = xse), !this.transport))
        throw new Error("No transport provided");
      (this.conn = new this.transport(this.endpointURL())),
        this.setupConnection();
    }
  }
  endpointURL() {
    return this._appendParams(
      this.endPoint,
      Object.assign({}, this.params, { vsn: Sse })
    );
  }
  disconnect(e, t) {
    this.conn &&
      ((this.conn.onclose = function () {}),
      e ? this.conn.close(e, t ?? "") : this.conn.close(),
      (this.conn = null),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.reset(),
      this.channels.forEach((s) => s.teardown()));
  }
  getChannels() {
    return this.channels;
  }
  async removeChannel(e) {
    const t = await e.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), t;
  }
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map((t) => t.unsubscribe()));
    return (this.channels = []), this.disconnect(), e;
  }
  log(e, t, s) {
    this.logger(e, t, s);
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case Hp.connecting:
        return Pu.Connecting;
      case Hp.open:
        return Pu.Open;
      case Hp.closing:
        return Pu.Closing;
      default:
        return Pu.Closed;
    }
  }
  isConnected() {
    return this.connectionState() === Pu.Open;
  }
  channel(e, t = { config: {} }) {
    const s = `realtime:${e}`,
      r = this.getChannels().find((i) => i.topic === s);
    if (r) return r;
    {
      const i = new zI(`realtime:${e}`, t, this);
      return this.channels.push(i), i;
    }
  }
  push(e) {
    const { topic: t, event: s, payload: r, ref: i } = e,
      a = () => {
        this.encode(e, (o) => {
          var l;
          (l = this.conn) === null || l === void 0 || l.send(o);
        });
      };
    this.log("push", `${t} ${s} (${i})`, r),
      this.isConnected() ? a() : this.sendBuffer.push(a);
  }
  async setAuth(e = null) {
    let t =
      e ||
      (this.accessToken && (await this.accessToken())) ||
      this.accessTokenValue;
    this.accessTokenValue != t &&
      ((this.accessTokenValue = t),
      this.channels.forEach((s) => {
        const r = { access_token: t, version: Ese };
        t && s.updateJoinPayload(r),
          s.joinedOnce &&
            s._isJoined() &&
            s._push(Aa.access_token, { access_token: t });
      }));
  }
  async sendHeartbeat() {
    var e;
    if (!this.isConnected()) {
      this.heartbeatCallback("disconnected");
      return;
    }
    if (this.pendingHeartbeatRef) {
      (this.pendingHeartbeatRef = null),
        this.log(
          "transport",
          "heartbeat timeout. Attempting to re-establish connection"
        ),
        this.heartbeatCallback("timeout"),
        (e = this.conn) === null ||
          e === void 0 ||
          e.close(Tse, "hearbeat timeout");
      return;
    }
    (this.pendingHeartbeatRef = this._makeRef()),
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef,
      }),
      this.heartbeatCallback("sent"),
      await this.setAuth();
  }
  onHeartbeat(e) {
    this.heartbeatCallback = e;
  }
  flushSendBuffer() {
    this.isConnected() &&
      this.sendBuffer.length > 0 &&
      (this.sendBuffer.forEach((e) => e()), (this.sendBuffer = []));
  }
  _makeRef() {
    let e = this.ref + 1;
    return (
      e === this.ref ? (this.ref = 0) : (this.ref = e), this.ref.toString()
    );
  }
  _leaveOpenTopic(e) {
    let t = this.channels.find(
      (s) => s.topic === e && (s._isJoined() || s._isJoining())
    );
    t &&
      (this.log("transport", `leaving duplicate topic "${e}"`),
      t.unsubscribe());
  }
  _remove(e) {
    this.channels = this.channels.filter((t) => t.topic !== e.topic);
  }
  setupConnection() {
    this.conn &&
      ((this.conn.binaryType = "arraybuffer"),
      (this.conn.onopen = () => this._onConnOpen()),
      (this.conn.onerror = (e) => this._onConnError(e)),
      (this.conn.onmessage = (e) => this._onConnMessage(e)),
      (this.conn.onclose = (e) => this._onConnClose(e)));
  }
  _onConnMessage(e) {
    this.decode(e.data, (t) => {
      let { topic: s, event: r, payload: i, ref: a } = t;
      s === "phoenix" &&
        r === "phx_reply" &&
        this.heartbeatCallback(t.payload.status == "ok" ? "ok" : "error"),
        a &&
          a === this.pendingHeartbeatRef &&
          (this.pendingHeartbeatRef = null),
        this.log(
          "receive",
          `${i.status || ""} ${s} ${r} ${(a && "(" + a + ")") || ""}`,
          i
        ),
        Array.from(this.channels)
          .filter((o) => o._isMember(s))
          .forEach((o) => o._trigger(r, i, a)),
        this.stateChangeCallbacks.message.forEach((o) => o(t));
    });
  }
  _onConnOpen() {
    this.log("transport", `connected to ${this.endpointURL()}`),
      this.flushSendBuffer(),
      this.reconnectTimer.reset(),
      this.worker
        ? this.workerRef || this._startWorkerHeartbeat()
        : this._startHeartbeat(),
      this.stateChangeCallbacks.open.forEach((e) => e());
  }
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      (this.heartbeatTimer = setInterval(
        () => this.sendHeartbeat(),
        this.heartbeatIntervalMs
      ));
  }
  _startWorkerHeartbeat() {
    this.workerUrl
      ? this.log("worker", `starting worker for from ${this.workerUrl}`)
      : this.log("worker", "starting default worker");
    const e = this._workerObjectUrl(this.workerUrl);
    (this.workerRef = new Worker(e)),
      (this.workerRef.onerror = (t) => {
        this.log("worker", "worker error", t.message),
          this.workerRef.terminate();
      }),
      (this.workerRef.onmessage = (t) => {
        t.data.event === "keepAlive" && this.sendHeartbeat();
      }),
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs,
      });
  }
  _onConnClose(e) {
    this.log("transport", "close", e),
      this._triggerChanError(),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.scheduleTimeout(),
      this.stateChangeCallbacks.close.forEach((t) => t(e));
  }
  _onConnError(e) {
    this.log("transport", `${e}`),
      this._triggerChanError(),
      this.stateChangeCallbacks.error.forEach((t) => t(e));
  }
  _triggerChanError() {
    this.channels.forEach((e) => e._trigger(Aa.error));
  }
  _appendParams(e, t) {
    if (Object.keys(t).length === 0) return e;
    const s = e.match(/\?/) ? "&" : "?",
      r = new URLSearchParams(t);
    return `${e}${s}${r}`;
  }
  _workerObjectUrl(e) {
    let t;
    if (e) t = e;
    else {
      const s = new Blob([Dse], { type: "application/javascript" });
      t = URL.createObjectURL(s);
    }
    return t;
  }
}
class GI extends Error {
  constructor(e) {
    super(e), (this.__isStorageError = !0), (this.name = "StorageError");
  }
}
function nr(n) {
  return typeof n == "object" && n !== null && "__isStorageError" in n;
}
class Mse extends GI {
  constructor(e, t, s) {
    super(e),
      (this.name = "StorageApiError"),
      (this.status = t),
      (this.statusCode = s);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode,
    };
  }
}
class pR extends GI {
  constructor(e, t) {
    super(e), (this.name = "StorageUnknownError"), (this.originalError = t);
  }
}
var Nse = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
const J6 = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Lt(async () => {
              const { default: s } = await Promise.resolve().then(() => Uf);
              return { default: s };
            }, void 0).then(({ default: s }) => s(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  },
  Ose = () =>
    Nse(void 0, void 0, void 0, function* () {
      return typeof Response > "u"
        ? (yield Lt(() => Promise.resolve().then(() => Uf), void 0)).Response
        : Response;
    }),
  gR = (n) => {
    if (Array.isArray(n)) return n.map((t) => gR(t));
    if (typeof n == "function" || n !== Object(n)) return n;
    const e = {};
    return (
      Object.entries(n).forEach(([t, s]) => {
        const r = t.replace(/([-_][a-z])/gi, (i) =>
          i.toUpperCase().replace(/[-_]/g, "")
        );
        e[r] = gR(s);
      }),
      e
    );
  },
  jse = (n) => {
    if (typeof n != "object" || n === null) return !1;
    const e = Object.getPrototypeOf(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  };
var ld = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
const H_ = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  Fse = (n, e, t) =>
    ld(void 0, void 0, void 0, function* () {
      const s = yield Ose();
      n instanceof s && !t?.noResolveJson
        ? n
            .json()
            .then((r) => {
              const i = n.status || 500,
                a = r?.statusCode || i + "";
              e(new Mse(H_(r), i, a));
            })
            .catch((r) => {
              e(new pR(H_(r), r));
            })
        : e(new pR(H_(n), n));
    }),
  Use = (n, e, t, s) => {
    const r = { method: n, headers: e?.headers || {} };
    return n === "GET" || !s
      ? r
      : (jse(s)
          ? ((r.headers = Object.assign(
              { "Content-Type": "application/json" },
              e?.headers
            )),
            (r.body = JSON.stringify(s)))
          : (r.body = s),
        Object.assign(Object.assign({}, r), t));
  };
function Ev(n, e, t, s, r, i) {
  return ld(this, void 0, void 0, function* () {
    return new Promise((a, o) => {
      n(t, Use(e, s, r, i))
        .then((l) => {
          if (!l.ok) throw l;
          return s?.noResolveJson ? l : l.json();
        })
        .then((l) => a(l))
        .catch((l) => Fse(l, o, s));
    });
  });
}
function mx(n, e, t, s) {
  return ld(this, void 0, void 0, function* () {
    return Ev(n, "GET", e, t, s);
  });
}
function ul(n, e, t, s, r) {
  return ld(this, void 0, void 0, function* () {
    return Ev(n, "POST", e, s, r, t);
  });
}
function vR(n, e, t, s, r) {
  return ld(this, void 0, void 0, function* () {
    return Ev(n, "PUT", e, s, r, t);
  });
}
function $se(n, e, t, s) {
  return ld(this, void 0, void 0, function* () {
    return Ev(
      n,
      "HEAD",
      e,
      Object.assign(Object.assign({}, t), { noResolveJson: !0 }),
      s
    );
  });
}
function e8(n, e, t, s, r) {
  return ld(this, void 0, void 0, function* () {
    return Ev(n, "DELETE", e, s, r, t);
  });
}
var Wr = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
const Bse = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } },
  Jj = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1,
  };
class Hse {
  constructor(e, t = {}, s, r) {
    (this.url = e),
      (this.headers = t),
      (this.bucketId = s),
      (this.fetch = J6(r));
  }
  uploadOrUpdate(e, t, s, r) {
    return Wr(this, void 0, void 0, function* () {
      try {
        let i;
        const a = Object.assign(Object.assign({}, Jj), r);
        let o = Object.assign(
          Object.assign({}, this.headers),
          e === "POST" && { "x-upsert": String(a.upsert) }
        );
        const l = a.metadata;
        typeof Blob < "u" && s instanceof Blob
          ? ((i = new FormData()),
            i.append("cacheControl", a.cacheControl),
            l && i.append("metadata", this.encodeMetadata(l)),
            i.append("", s))
          : typeof FormData < "u" && s instanceof FormData
          ? ((i = s),
            i.append("cacheControl", a.cacheControl),
            l && i.append("metadata", this.encodeMetadata(l)))
          : ((i = s),
            (o["cache-control"] = `max-age=${a.cacheControl}`),
            (o["content-type"] = a.contentType),
            l && (o["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
          r?.headers && (o = Object.assign(Object.assign({}, o), r.headers));
        const c = this._removeEmptyFolders(t),
          h = this._getFinalPath(c),
          m = yield (e == "PUT" ? vR : ul)(
            this.fetch,
            `${this.url}/object/${h}`,
            i,
            Object.assign({ headers: o }, a?.duplex ? { duplex: a.duplex } : {})
          );
        return { data: { path: c, id: m.Id, fullPath: m.Key }, error: null };
      } catch (i) {
        if (nr(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  upload(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", e, t, s);
    });
  }
  uploadToSignedUrl(e, t, s, r) {
    return Wr(this, void 0, void 0, function* () {
      const i = this._removeEmptyFolders(e),
        a = this._getFinalPath(i),
        o = new URL(this.url + `/object/upload/sign/${a}`);
      o.searchParams.set("token", t);
      try {
        let l;
        const c = Object.assign({ upsert: Jj.upsert }, r),
          h = Object.assign(Object.assign({}, this.headers), {
            "x-upsert": String(c.upsert),
          });
        typeof Blob < "u" && s instanceof Blob
          ? ((l = new FormData()),
            l.append("cacheControl", c.cacheControl),
            l.append("", s))
          : typeof FormData < "u" && s instanceof FormData
          ? ((l = s), l.append("cacheControl", c.cacheControl))
          : ((l = s),
            (h["cache-control"] = `max-age=${c.cacheControl}`),
            (h["content-type"] = c.contentType));
        const m = yield vR(this.fetch, o.toString(), l, { headers: h });
        return { data: { path: i, fullPath: m.Key }, error: null };
      } catch (l) {
        if (nr(l)) return { data: null, error: l };
        throw l;
      }
    });
  }
  createSignedUploadUrl(e, t) {
    return Wr(this, void 0, void 0, function* () {
      try {
        let s = this._getFinalPath(e);
        const r = Object.assign({}, this.headers);
        t?.upsert && (r["x-upsert"] = "true");
        const i = yield ul(
            this.fetch,
            `${this.url}/object/upload/sign/${s}`,
            {},
            { headers: r }
          ),
          a = new URL(this.url + i.url),
          o = a.searchParams.get("token");
        if (!o) throw new GI("No token returned by API");
        return {
          data: { signedUrl: a.toString(), path: e, token: o },
          error: null,
        };
      } catch (s) {
        if (nr(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  update(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", e, t, s);
    });
  }
  move(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      try {
        return {
          data: yield ul(
            this.fetch,
            `${this.url}/object/move`,
            {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: t,
              destinationBucket: s?.destinationBucket,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (r) {
        if (nr(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  copy(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield ul(
              this.fetch,
              `${this.url}/object/copy`,
              {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: t,
                destinationBucket: s?.destinationBucket,
              },
              { headers: this.headers }
            )).Key,
          },
          error: null,
        };
      } catch (r) {
        if (nr(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrl(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      try {
        let r = this._getFinalPath(e),
          i = yield ul(
            this.fetch,
            `${this.url}/object/sign/${r}`,
            Object.assign(
              { expiresIn: t },
              s?.transform ? { transform: s.transform } : {}
            ),
            { headers: this.headers }
          );
        const a = s?.download
          ? `&download=${s.download === !0 ? "" : s.download}`
          : "";
        return (
          (i = { signedUrl: encodeURI(`${this.url}${i.signedURL}${a}`) }),
          { data: i, error: null }
        );
      } catch (r) {
        if (nr(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrls(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      try {
        const r = yield ul(
            this.fetch,
            `${this.url}/object/sign/${this.bucketId}`,
            { expiresIn: t, paths: e },
            { headers: this.headers }
          ),
          i = s?.download
            ? `&download=${s.download === !0 ? "" : s.download}`
            : "";
        return {
          data: r.map((a) =>
            Object.assign(Object.assign({}, a), {
              signedUrl: a.signedURL
                ? encodeURI(`${this.url}${a.signedURL}${i}`)
                : null,
            })
          ),
          error: null,
        };
      } catch (r) {
        if (nr(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  download(e, t) {
    return Wr(this, void 0, void 0, function* () {
      const r =
          typeof t?.transform < "u" ? "render/image/authenticated" : "object",
        i = this.transformOptsToQueryString(t?.transform || {}),
        a = i ? `?${i}` : "";
      try {
        const o = this._getFinalPath(e);
        return {
          data: yield (yield mx(this.fetch, `${this.url}/${r}/${o}${a}`, {
            headers: this.headers,
            noResolveJson: !0,
          })).blob(),
          error: null,
        };
      } catch (o) {
        if (nr(o)) return { data: null, error: o };
        throw o;
      }
    });
  }
  info(e) {
    return Wr(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        const s = yield mx(this.fetch, `${this.url}/object/info/${t}`, {
          headers: this.headers,
        });
        return { data: gR(s), error: null };
      } catch (s) {
        if (nr(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  exists(e) {
    return Wr(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        return (
          yield $se(this.fetch, `${this.url}/object/${t}`, {
            headers: this.headers,
          }),
          { data: !0, error: null }
        );
      } catch (s) {
        if (nr(s) && s instanceof pR) {
          const r = s.originalError;
          if ([400, 404].includes(r?.status)) return { data: !1, error: s };
        }
        throw s;
      }
    });
  }
  getPublicUrl(e, t) {
    const s = this._getFinalPath(e),
      r = [],
      i = t?.download ? `download=${t.download === !0 ? "" : t.download}` : "";
    i !== "" && r.push(i);
    const o = typeof t?.transform < "u" ? "render/image" : "object",
      l = this.transformOptsToQueryString(t?.transform || {});
    l !== "" && r.push(l);
    let c = r.join("&");
    return (
      c !== "" && (c = `?${c}`),
      { data: { publicUrl: encodeURI(`${this.url}/${o}/public/${s}${c}`) } }
    );
  }
  remove(e) {
    return Wr(this, void 0, void 0, function* () {
      try {
        return {
          data: yield e8(
            this.fetch,
            `${this.url}/object/${this.bucketId}`,
            { prefixes: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (nr(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  list(e, t, s) {
    return Wr(this, void 0, void 0, function* () {
      try {
        const r = Object.assign(Object.assign(Object.assign({}, Bse), t), {
          prefix: e || "",
        });
        return {
          data: yield ul(
            this.fetch,
            `${this.url}/object/list/${this.bucketId}`,
            r,
            { headers: this.headers },
            s
          ),
          error: null,
        };
      } catch (r) {
        if (nr(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  encodeMetadata(e) {
    return JSON.stringify(e);
  }
  toBase64(e) {
    return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e);
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(e) {
    const t = [];
    return (
      e.width && t.push(`width=${e.width}`),
      e.height && t.push(`height=${e.height}`),
      e.resize && t.push(`resize=${e.resize}`),
      e.format && t.push(`format=${e.format}`),
      e.quality && t.push(`quality=${e.quality}`),
      t.join("&")
    );
  }
}
const Vse = "2.10.4",
  zse = { "X-Client-Info": `storage-js/${Vse}` };
var eh = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
class Gse {
  constructor(e, t = {}, s, r) {
    const i = new URL(e);
    r?.useNewHostname &&
      /supabase\.(co|in|red)$/.test(i.hostname) &&
      !i.hostname.includes("storage.supabase.") &&
      (i.hostname = i.hostname.replace("supabase.", "storage.supabase.")),
      (this.url = i.href),
      (this.headers = Object.assign(Object.assign({}, zse), t)),
      (this.fetch = J6(s));
  }
  listBuckets() {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield mx(this.fetch, `${this.url}/bucket`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (e) {
        if (nr(e)) return { data: null, error: e };
        throw e;
      }
    });
  }
  getBucket(e) {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield mx(this.fetch, `${this.url}/bucket/${e}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (nr(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  createBucket(e, t = { public: !1 }) {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield ul(
            this.fetch,
            `${this.url}/bucket`,
            {
              id: e,
              name: e,
              type: t.type,
              public: t.public,
              file_size_limit: t.fileSizeLimit,
              allowed_mime_types: t.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (s) {
        if (nr(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  updateBucket(e, t) {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield vR(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {
              id: e,
              name: e,
              public: t.public,
              file_size_limit: t.fileSizeLimit,
              allowed_mime_types: t.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (s) {
        if (nr(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  emptyBucket(e) {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield ul(
            this.fetch,
            `${this.url}/bucket/${e}/empty`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (nr(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return eh(this, void 0, void 0, function* () {
      try {
        return {
          data: yield e8(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (nr(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
class qse extends Gse {
  constructor(e, t = {}, s, r) {
    super(e, t, s, r);
  }
  from(e) {
    return new Hse(this.url, this.headers, e, this.fetch);
  }
}
const Wse = "2.53.0";
let yp = "";
typeof Deno < "u"
  ? (yp = "deno")
  : typeof document < "u"
  ? (yp = "web")
  : typeof navigator < "u" && navigator.product === "ReactNative"
  ? (yp = "react-native")
  : (yp = "node");
const Kse = { "X-Client-Info": `supabase-js-${yp}/${Wse}` },
  Yse = { headers: Kse },
  Xse = { schema: "public" },
  Qse = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit",
  },
  Zse = {};
var Jse = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
const ere = (n) => {
    let e;
    return (
      n ? (e = n) : typeof fetch > "u" ? (e = V6) : (e = fetch),
      (...t) => e(...t)
    );
  },
  tre = () => (typeof Headers > "u" ? z6 : Headers),
  nre = (n, e, t) => {
    const s = ere(t),
      r = tre();
    return (i, a) =>
      Jse(void 0, void 0, void 0, function* () {
        var o;
        const l = (o = yield e()) !== null && o !== void 0 ? o : n;
        let c = new r(a?.headers);
        return (
          c.has("apikey") || c.set("apikey", n),
          c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
          s(i, Object.assign(Object.assign({}, a), { headers: c }))
        );
      });
  };
var sre = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
function rre(n) {
  return n.endsWith("/") ? n : n + "/";
}
function ire(n, e) {
  var t, s;
  const { db: r, auth: i, realtime: a, global: o } = n,
    { db: l, auth: c, realtime: h, global: m } = e,
    p = {
      db: Object.assign(Object.assign({}, l), r),
      auth: Object.assign(Object.assign({}, c), i),
      realtime: Object.assign(Object.assign({}, h), a),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, m), o), {
        headers: Object.assign(
          Object.assign({}, (t = m?.headers) !== null && t !== void 0 ? t : {}),
          (s = o?.headers) !== null && s !== void 0 ? s : {}
        ),
      }),
      accessToken: () =>
        sre(this, void 0, void 0, function* () {
          return "";
        }),
    };
  return (
    n.accessToken ? (p.accessToken = n.accessToken) : delete p.accessToken, p
  );
}
const t8 = "2.71.1",
  Eh = 30 * 1e3,
  yR = 3,
  V_ = yR * Eh,
  are = "http://localhost:9999",
  ore = "supabase.auth.token",
  lre = { "X-Client-Info": `gotrue-js/${t8}` },
  bR = "X-Supabase-Api-Version",
  n8 = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01",
    },
  },
  cre = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  ure = 600 * 1e3;
class qI extends Error {
  constructor(e, t, s) {
    super(e),
      (this.__isAuthError = !0),
      (this.name = "AuthError"),
      (this.status = t),
      (this.code = s);
  }
}
function Ht(n) {
  return typeof n == "object" && n !== null && "__isAuthError" in n;
}
class dre extends qI {
  constructor(e, t, s) {
    super(e, t, s),
      (this.name = "AuthApiError"),
      (this.status = t),
      (this.code = s);
  }
}
function hre(n) {
  return Ht(n) && n.name === "AuthApiError";
}
class s8 extends qI {
  constructor(e, t) {
    super(e), (this.name = "AuthUnknownError"), (this.originalError = t);
  }
}
class Vc extends qI {
  constructor(e, t, s, r) {
    super(e, s, r), (this.name = t), (this.status = s);
  }
}
class dc extends Vc {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function fre(n) {
  return Ht(n) && n.name === "AuthSessionMissingError";
}
class cy extends Vc {
  constructor() {
    super(
      "Auth session or user missing",
      "AuthInvalidTokenResponseError",
      500,
      void 0
    );
  }
}
class uy extends Vc {
  constructor(e) {
    super(e, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class dy extends Vc {
  constructor(e, t = null) {
    super(e, "AuthImplicitGrantRedirectError", 500, void 0),
      (this.details = null),
      (this.details = t);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
function mre(n) {
  return Ht(n) && n.name === "AuthImplicitGrantRedirectError";
}
class eF extends Vc {
  constructor(e, t = null) {
    super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
      (this.details = null),
      (this.details = t);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
class xR extends Vc {
  constructor(e, t) {
    super(e, "AuthRetryableFetchError", t, void 0);
  }
}
function z_(n) {
  return Ht(n) && n.name === "AuthRetryableFetchError";
}
class tF extends Vc {
  constructor(e, t, s) {
    super(e, "AuthWeakPasswordError", t, "weak_password"), (this.reasons = s);
  }
}
class wR extends Vc {
  constructor(e) {
    super(e, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const px =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(
      ""
    ),
  nF = ` 	
\r=`.split(""),
  pre = (() => {
    const n = new Array(128);
    for (let e = 0; e < n.length; e += 1) n[e] = -1;
    for (let e = 0; e < nF.length; e += 1) n[nF[e].charCodeAt(0)] = -2;
    for (let e = 0; e < px.length; e += 1) n[px[e].charCodeAt(0)] = e;
    return n;
  })();
function sF(n, e, t) {
  if (n !== null)
    for (e.queue = (e.queue << 8) | n, e.queuedBits += 8; e.queuedBits >= 6; ) {
      const s = (e.queue >> (e.queuedBits - 6)) & 63;
      t(px[s]), (e.queuedBits -= 6);
    }
  else if (e.queuedBits > 0)
    for (
      e.queue = e.queue << (6 - e.queuedBits), e.queuedBits = 6;
      e.queuedBits >= 6;

    ) {
      const s = (e.queue >> (e.queuedBits - 6)) & 63;
      t(px[s]), (e.queuedBits -= 6);
    }
}
function r8(n, e, t) {
  const s = pre[n];
  if (s > -1)
    for (e.queue = (e.queue << 6) | s, e.queuedBits += 6; e.queuedBits >= 8; )
      t((e.queue >> (e.queuedBits - 8)) & 255), (e.queuedBits -= 8);
  else {
    if (s === -2) return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`);
  }
}
function rF(n) {
  const e = [],
    t = (a) => {
      e.push(String.fromCodePoint(a));
    },
    s = { utf8seq: 0, codepoint: 0 },
    r = { queue: 0, queuedBits: 0 },
    i = (a) => {
      yre(a, s, t);
    };
  for (let a = 0; a < n.length; a += 1) r8(n.charCodeAt(a), r, i);
  return e.join("");
}
function gre(n, e) {
  if (n <= 127) {
    e(n);
    return;
  } else if (n <= 2047) {
    e(192 | (n >> 6)), e(128 | (n & 63));
    return;
  } else if (n <= 65535) {
    e(224 | (n >> 12)), e(128 | ((n >> 6) & 63)), e(128 | (n & 63));
    return;
  } else if (n <= 1114111) {
    e(240 | (n >> 18)),
      e(128 | ((n >> 12) & 63)),
      e(128 | ((n >> 6) & 63)),
      e(128 | (n & 63));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`);
}
function vre(n, e) {
  for (let t = 0; t < n.length; t += 1) {
    let s = n.charCodeAt(t);
    if (s > 55295 && s <= 56319) {
      const r = ((s - 55296) * 1024) & 65535;
      (s = (((n.charCodeAt(t + 1) - 56320) & 65535) | r) + 65536), (t += 1);
    }
    gre(s, e);
  }
}
function yre(n, e, t) {
  if (e.utf8seq === 0) {
    if (n <= 127) {
      t(n);
      return;
    }
    for (let s = 1; s < 6; s += 1)
      if (((n >> (7 - s)) & 1) === 0) {
        e.utf8seq = s;
        break;
      }
    if (e.utf8seq === 2) e.codepoint = n & 31;
    else if (e.utf8seq === 3) e.codepoint = n & 15;
    else if (e.utf8seq === 4) e.codepoint = n & 7;
    else throw new Error("Invalid UTF-8 sequence");
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (n <= 127) throw new Error("Invalid UTF-8 sequence");
    (e.codepoint = (e.codepoint << 6) | (n & 63)),
      (e.utf8seq -= 1),
      e.utf8seq === 0 && t(e.codepoint);
  }
}
function bre(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    s = (r) => {
      e.push(r);
    };
  for (let r = 0; r < n.length; r += 1) r8(n.charCodeAt(r), t, s);
  return new Uint8Array(e);
}
function xre(n) {
  const e = [];
  return vre(n, (t) => e.push(t)), new Uint8Array(e);
}
function wre(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    s = (r) => {
      e.push(r);
    };
  return n.forEach((r) => sF(r, t, s)), sF(null, t, s), e.join("");
}
function Ere(n) {
  return Math.round(Date.now() / 1e3) + n;
}
function Sre() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (n) {
    const e = (Math.random() * 16) | 0;
    return (n == "x" ? e : (e & 3) | 8).toString(16);
  });
}
const ya = () => typeof window < "u" && typeof document < "u",
  pu = { tested: !1, writable: !1 },
  i8 = () => {
    if (!ya()) return !1;
    try {
      if (typeof globalThis.localStorage != "object") return !1;
    } catch {
      return !1;
    }
    if (pu.tested) return pu.writable;
    const n = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(n, n),
        globalThis.localStorage.removeItem(n),
        (pu.tested = !0),
        (pu.writable = !0);
    } catch {
      (pu.tested = !0), (pu.writable = !1);
    }
    return pu.writable;
  };
function Tre(n) {
  const e = {},
    t = new URL(n);
  if (t.hash && t.hash[0] === "#")
    try {
      new URLSearchParams(t.hash.substring(1)).forEach((r, i) => {
        e[i] = r;
      });
    } catch {}
  return (
    t.searchParams.forEach((s, r) => {
      e[r] = s;
    }),
    e
  );
}
const a8 = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Lt(async () => {
              const { default: s } = await Promise.resolve().then(() => Uf);
              return { default: s };
            }, void 0).then(({ default: s }) => s(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  },
  _re = (n) =>
    typeof n == "object" &&
    n !== null &&
    "status" in n &&
    "ok" in n &&
    "json" in n &&
    typeof n.json == "function",
  Sh = async (n, e, t) => {
    await n.setItem(e, JSON.stringify(t));
  },
  gu = async (n, e) => {
    const t = await n.getItem(e);
    if (!t) return null;
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  },
  Jl = async (n, e) => {
    await n.removeItem(e);
  };
class uE {
  constructor() {
    this.promise = new uE.promiseConstructor((e, t) => {
      (this.resolve = e), (this.reject = t);
    });
  }
}
uE.promiseConstructor = Promise;
function G_(n) {
  const e = n.split(".");
  if (e.length !== 3) throw new wR("Invalid JWT structure");
  for (let s = 0; s < e.length; s++)
    if (!cre.test(e[s])) throw new wR("JWT not in base64url format");
  return {
    header: JSON.parse(rF(e[0])),
    payload: JSON.parse(rF(e[1])),
    signature: bre(e[2]),
    raw: { header: e[0], payload: e[1] },
  };
}
async function Are(n) {
  return await new Promise((e) => {
    setTimeout(() => e(null), n);
  });
}
function Rre(n, e) {
  return new Promise((s, r) => {
    (async () => {
      for (let i = 0; i < 1 / 0; i++)
        try {
          const a = await n(i);
          if (!e(i, null, a)) {
            s(a);
            return;
          }
        } catch (a) {
          if (!e(i, a)) {
            r(a);
            return;
          }
        }
    })();
  });
}
function kre(n) {
  return ("0" + n.toString(16)).substr(-2);
}
function Cre() {
  const e = new Uint32Array(56);
  if (typeof crypto > "u") {
    const t =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
      s = t.length;
    let r = "";
    for (let i = 0; i < 56; i++) r += t.charAt(Math.floor(Math.random() * s));
    return r;
  }
  return crypto.getRandomValues(e), Array.from(e, kre).join("");
}
async function Ire(n) {
  const t = new TextEncoder().encode(n),
    s = await crypto.subtle.digest("SHA-256", t),
    r = new Uint8Array(s);
  return Array.from(r)
    .map((i) => String.fromCharCode(i))
    .join("");
}
async function Lre(n) {
  if (
    !(
      typeof crypto < "u" &&
      typeof crypto.subtle < "u" &&
      typeof TextEncoder < "u"
    )
  )
    return (
      console.warn(
        "WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."
      ),
      n
    );
  const t = await Ire(n);
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function th(n, e, t = !1) {
  const s = Cre();
  let r = s;
  t && (r += "/PASSWORD_RECOVERY"), await Sh(n, `${e}-code-verifier`, r);
  const i = await Lre(s);
  return [i, s === i ? "plain" : "s256"];
}
const Dre = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function Pre(n) {
  const e = n.headers.get(bR);
  if (!e || !e.match(Dre)) return null;
  try {
    return new Date(`${e}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function Mre(n) {
  if (!n) throw new Error("Missing exp claim");
  const e = Math.floor(Date.now() / 1e3);
  if (n <= e) throw new Error("JWT has expired");
}
function Nre(n) {
  switch (n) {
    case "RS256":
      return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
    case "ES256":
      return { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } };
    default:
      throw new Error("Invalid alg claim");
  }
}
const Ore = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function nh(n) {
  if (!Ore.test(n))
    throw new Error(
      "@supabase/auth-js: Expected parameter to be UUID but is not"
    );
}
function q_() {
  const n = {};
  return new Proxy(n, {
    get: (e, t) => {
      if (t === "__isUserNotAvailableProxy") return !0;
      if (typeof t == "symbol") {
        const s = t.toString();
        if (
          s === "Symbol(Symbol.toPrimitive)" ||
          s === "Symbol(Symbol.toStringTag)" ||
          s === "Symbol(util.inspect.custom)"
        )
          return;
      }
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`
      );
    },
    set: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
    deleteProperty: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
  });
}
function iF(n) {
  return JSON.parse(JSON.stringify(n));
}
var jre = function (n, e) {
  var t = {};
  for (var s in n)
    Object.prototype.hasOwnProperty.call(n, s) &&
      e.indexOf(s) < 0 &&
      (t[s] = n[s]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, s = Object.getOwnPropertySymbols(n); r < s.length; r++)
      e.indexOf(s[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, s[r]) &&
        (t[s[r]] = n[s[r]]);
  return t;
};
const Tu = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  Fre = [502, 503, 504];
async function aF(n) {
  var e;
  if (!_re(n)) throw new xR(Tu(n), 0);
  if (Fre.includes(n.status)) throw new xR(Tu(n), n.status);
  let t;
  try {
    t = await n.json();
  } catch (i) {
    throw new s8(Tu(i), i);
  }
  let s;
  const r = Pre(n);
  if (
    (r &&
    r.getTime() >= n8["2024-01-01"].timestamp &&
    typeof t == "object" &&
    t &&
    typeof t.code == "string"
      ? (s = t.code)
      : typeof t == "object" &&
        t &&
        typeof t.error_code == "string" &&
        (s = t.error_code),
    s)
  ) {
    if (s === "weak_password")
      throw new tF(
        Tu(t),
        n.status,
        ((e = t.weak_password) === null || e === void 0 ? void 0 : e.reasons) ||
          []
      );
    if (s === "session_not_found") throw new dc();
  } else if (
    typeof t == "object" &&
    t &&
    typeof t.weak_password == "object" &&
    t.weak_password &&
    Array.isArray(t.weak_password.reasons) &&
    t.weak_password.reasons.length &&
    t.weak_password.reasons.reduce((i, a) => i && typeof a == "string", !0)
  )
    throw new tF(Tu(t), n.status, t.weak_password.reasons);
  throw new dre(Tu(t), n.status || 500, s);
}
const Ure = (n, e, t, s) => {
  const r = { method: n, headers: e?.headers || {} };
  return n === "GET"
    ? r
    : ((r.headers = Object.assign(
        { "Content-Type": "application/json;charset=UTF-8" },
        e?.headers
      )),
      (r.body = JSON.stringify(s)),
      Object.assign(Object.assign({}, r), t));
};
async function sn(n, e, t, s) {
  var r;
  const i = Object.assign({}, s?.headers);
  i[bR] || (i[bR] = n8["2024-01-01"].name),
    s?.jwt && (i.Authorization = `Bearer ${s.jwt}`);
  const a = (r = s?.query) !== null && r !== void 0 ? r : {};
  s?.redirectTo && (a.redirect_to = s.redirectTo);
  const o = Object.keys(a).length
      ? "?" + new URLSearchParams(a).toString()
      : "",
    l = await $re(
      n,
      e,
      t + o,
      { headers: i, noResolveJson: s?.noResolveJson },
      {},
      s?.body
    );
  return s?.xform ? s?.xform(l) : { data: Object.assign({}, l), error: null };
}
async function $re(n, e, t, s, r, i) {
  const a = Ure(e, s, r, i);
  let o;
  try {
    o = await n(t, Object.assign({}, a));
  } catch (l) {
    throw (console.error(l), new xR(Tu(l), 0));
  }
  if ((o.ok || (await aF(o)), s?.noResolveJson)) return o;
  try {
    return await o.json();
  } catch (l) {
    await aF(l);
  }
}
function al(n) {
  var e;
  let t = null;
  zre(n) &&
    ((t = Object.assign({}, n)),
    n.expires_at || (t.expires_at = Ere(n.expires_in)));
  const s = (e = n.user) !== null && e !== void 0 ? e : n;
  return { data: { session: t, user: s }, error: null };
}
function oF(n) {
  const e = al(n);
  return (
    !e.error &&
      n.weak_password &&
      typeof n.weak_password == "object" &&
      Array.isArray(n.weak_password.reasons) &&
      n.weak_password.reasons.length &&
      n.weak_password.message &&
      typeof n.weak_password.message == "string" &&
      n.weak_password.reasons.reduce((t, s) => t && typeof s == "string", !0) &&
      (e.data.weak_password = n.weak_password),
    e
  );
}
function Ec(n) {
  var e;
  return {
    data: { user: (e = n.user) !== null && e !== void 0 ? e : n },
    error: null,
  };
}
function Bre(n) {
  return { data: n, error: null };
}
function Hre(n) {
  const {
      action_link: e,
      email_otp: t,
      hashed_token: s,
      redirect_to: r,
      verification_type: i,
    } = n,
    a = jre(n, [
      "action_link",
      "email_otp",
      "hashed_token",
      "redirect_to",
      "verification_type",
    ]),
    o = {
      action_link: e,
      email_otp: t,
      hashed_token: s,
      redirect_to: r,
      verification_type: i,
    },
    l = Object.assign({}, a);
  return { data: { properties: o, user: l }, error: null };
}
function Vre(n) {
  return n;
}
function zre(n) {
  return n.access_token && n.refresh_token && n.expires_in;
}
const W_ = ["global", "local", "others"];
var Gre = function (n, e) {
  var t = {};
  for (var s in n)
    Object.prototype.hasOwnProperty.call(n, s) &&
      e.indexOf(s) < 0 &&
      (t[s] = n[s]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, s = Object.getOwnPropertySymbols(n); r < s.length; r++)
      e.indexOf(s[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, s[r]) &&
        (t[s[r]] = n[s[r]]);
  return t;
};
class qre {
  constructor({ url: e = "", headers: t = {}, fetch: s }) {
    (this.url = e),
      (this.headers = t),
      (this.fetch = a8(s)),
      (this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this),
      });
  }
  async signOut(e, t = W_[0]) {
    if (W_.indexOf(t) < 0)
      throw new Error(
        `@supabase/auth-js: Parameter scope must be one of ${W_.join(", ")}`
      );
    try {
      return (
        await sn(this.fetch, "POST", `${this.url}/logout?scope=${t}`, {
          headers: this.headers,
          jwt: e,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (s) {
      if (Ht(s)) return { data: null, error: s };
      throw s;
    }
  }
  async inviteUserByEmail(e, t = {}) {
    try {
      return await sn(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: e, data: t.data },
        headers: this.headers,
        redirectTo: t.redirectTo,
        xform: Ec,
      });
    } catch (s) {
      if (Ht(s)) return { data: { user: null }, error: s };
      throw s;
    }
  }
  async generateLink(e) {
    try {
      const { options: t } = e,
        s = Gre(e, ["options"]),
        r = Object.assign(Object.assign({}, s), t);
      return (
        "newEmail" in s && ((r.new_email = s?.newEmail), delete r.newEmail),
        await sn(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: r,
          headers: this.headers,
          xform: Hre,
          redirectTo: t?.redirectTo,
        })
      );
    } catch (t) {
      if (Ht(t)) return { data: { properties: null, user: null }, error: t };
      throw t;
    }
  }
  async createUser(e) {
    try {
      return await sn(this.fetch, "POST", `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: Ec,
      });
    } catch (t) {
      if (Ht(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async listUsers(e) {
    var t, s, r, i, a, o, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        h = await sn(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (s =
                (t = e?.page) === null || t === void 0
                  ? void 0
                  : t.toString()) !== null && s !== void 0
                ? s
                : "",
            per_page:
              (i =
                (r = e?.perPage) === null || r === void 0
                  ? void 0
                  : r.toString()) !== null && i !== void 0
                ? i
                : "",
          },
          xform: Vre,
        });
      if (h.error) throw h.error;
      const m = await h.json(),
        p =
          (a = h.headers.get("x-total-count")) !== null && a !== void 0 ? a : 0,
        g =
          (l =
            (o = h.headers.get("link")) === null || o === void 0
              ? void 0
              : o.split(",")) !== null && l !== void 0
            ? l
            : [];
      return (
        g.length > 0 &&
          (g.forEach((y) => {
            const b = parseInt(y.split(";")[0].split("=")[1].substring(0, 1)),
              w = JSON.parse(y.split(";")[1].split("=")[1]);
            c[`${w}Page`] = b;
          }),
          (c.total = parseInt(p))),
        { data: Object.assign(Object.assign({}, m), c), error: null }
      );
    } catch (c) {
      if (Ht(c)) return { data: { users: [] }, error: c };
      throw c;
    }
  }
  async getUserById(e) {
    nh(e);
    try {
      return await sn(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: Ec,
      });
    } catch (t) {
      if (Ht(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async updateUserById(e, t) {
    nh(e);
    try {
      return await sn(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
        body: t,
        headers: this.headers,
        xform: Ec,
      });
    } catch (s) {
      if (Ht(s)) return { data: { user: null }, error: s };
      throw s;
    }
  }
  async deleteUser(e, t = !1) {
    nh(e);
    try {
      return await sn(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: { should_soft_delete: t },
        xform: Ec,
      });
    } catch (s) {
      if (Ht(s)) return { data: { user: null }, error: s };
      throw s;
    }
  }
  async _listFactors(e) {
    nh(e.userId);
    try {
      const { data: t, error: s } = await sn(
        this.fetch,
        "GET",
        `${this.url}/admin/users/${e.userId}/factors`,
        {
          headers: this.headers,
          xform: (r) => ({ data: { factors: r }, error: null }),
        }
      );
      return { data: t, error: s };
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _deleteFactor(e) {
    nh(e.userId), nh(e.id);
    try {
      return {
        data: await sn(
          this.fetch,
          "DELETE",
          `${this.url}/admin/users/${e.userId}/factors/${e.id}`,
          { headers: this.headers }
        ),
        error: null,
      };
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
}
function lF(n = {}) {
  return {
    getItem: (e) => n[e] || null,
    setItem: (e, t) => {
      n[e] = t;
    },
    removeItem: (e) => {
      delete n[e];
    },
  };
}
function Wre() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function () {
          return this;
        },
        configurable: !0,
      }),
        (__magic__.globalThis = __magic__),
        delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
const sh = {
  debug: !!(
    globalThis &&
    i8() &&
    globalThis.localStorage &&
    globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true"
  ),
};
class o8 extends Error {
  constructor(e) {
    super(e), (this.isAcquireTimeout = !0);
  }
}
class Kre extends o8 {}
async function Yre(n, e, t) {
  sh.debug;
  const s = new globalThis.AbortController();
  return (
    e > 0 &&
      setTimeout(() => {
        s.abort(), sh.debug;
      }, e),
    await Promise.resolve().then(() =>
      globalThis.navigator.locks.request(
        n,
        e === 0
          ? { mode: "exclusive", ifAvailable: !0 }
          : { mode: "exclusive", signal: s.signal },
        async (r) => {
          if (r) {
            sh.debug && r.name;
            try {
              return await t();
            } finally {
              sh.debug && r.name;
            }
          } else {
            if (e === 0)
              throw (
                (sh.debug,
                new Kre(
                  `Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`
                ))
              );
            if (sh.debug)
              try {
                const i = await globalThis.navigator.locks.query();
                JSON.stringify(i, null, "  ");
              } catch (i) {
                console.warn(
                  "@supabase/gotrue-js: Error when querying Navigator LockManager state",
                  i
                );
              }
            return (
              console.warn(
                "@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"
              ),
              await t()
            );
          }
        }
      )
    )
  );
}
Wre();
const Xre = {
  url: are,
  storageKey: ore,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: lre,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
};
async function cF(n, e, t) {
  return await t();
}
const rh = {};
class _g {
  constructor(e) {
    var t, s;
    (this.userStorage = null),
      (this.memoryStorage = null),
      (this.stateChangeEmitters = new Map()),
      (this.autoRefreshTicker = null),
      (this.visibilityChangedCallback = null),
      (this.refreshingDeferred = null),
      (this.initializePromise = null),
      (this.detectSessionInUrl = !0),
      (this.hasCustomAuthorizationHeader = !1),
      (this.suppressGetSessionWarning = !1),
      (this.lockAcquired = !1),
      (this.pendingInLock = []),
      (this.broadcastChannel = null),
      (this.logger = console.log),
      (this.instanceID = _g.nextInstanceID),
      (_g.nextInstanceID += 1),
      this.instanceID > 0 &&
        ya() &&
        console.warn(
          "Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."
        );
    const r = Object.assign(Object.assign({}, Xre), e);
    if (
      ((this.logDebugMessages = !!r.debug),
      typeof r.debug == "function" && (this.logger = r.debug),
      (this.persistSession = r.persistSession),
      (this.storageKey = r.storageKey),
      (this.autoRefreshToken = r.autoRefreshToken),
      (this.admin = new qre({
        url: r.url,
        headers: r.headers,
        fetch: r.fetch,
      })),
      (this.url = r.url),
      (this.headers = r.headers),
      (this.fetch = a8(r.fetch)),
      (this.lock = r.lock || cF),
      (this.detectSessionInUrl = r.detectSessionInUrl),
      (this.flowType = r.flowType),
      (this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader),
      r.lock
        ? (this.lock = r.lock)
        : ya() &&
          !((t = globalThis?.navigator) === null || t === void 0) &&
          t.locks
        ? (this.lock = Yre)
        : (this.lock = cF),
      this.jwks ||
        ((this.jwks = { keys: [] }),
        (this.jwks_cached_at = Number.MIN_SAFE_INTEGER)),
      (this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel:
          this._getAuthenticatorAssuranceLevel.bind(this),
      }),
      this.persistSession
        ? (r.storage
            ? (this.storage = r.storage)
            : i8()
            ? (this.storage = globalThis.localStorage)
            : ((this.memoryStorage = {}),
              (this.storage = lF(this.memoryStorage))),
          r.userStorage && (this.userStorage = r.userStorage))
        : ((this.memoryStorage = {}), (this.storage = lF(this.memoryStorage))),
      ya() &&
        globalThis.BroadcastChannel &&
        this.persistSession &&
        this.storageKey)
    ) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(
          this.storageKey
        );
      } catch (i) {
        console.error(
          "Failed to create a new BroadcastChannel, multi-tab state changes will not be available",
          i
        );
      }
      (s = this.broadcastChannel) === null ||
        s === void 0 ||
        s.addEventListener("message", async (i) => {
          this._debug(
            "received broadcast notification from other tab or client",
            i
          ),
            await this._notifyAllSubscribers(i.data.event, i.data.session, !1);
        });
    }
    this.initialize();
  }
  get jwks() {
    var e, t;
    return (t =
      (e = rh[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !==
      null && t !== void 0
      ? t
      : { keys: [] };
  }
  set jwks(e) {
    rh[this.storageKey] = Object.assign(
      Object.assign({}, rh[this.storageKey]),
      { jwks: e }
    );
  }
  get jwks_cached_at() {
    var e, t;
    return (t =
      (e = rh[this.storageKey]) === null || e === void 0
        ? void 0
        : e.cachedAt) !== null && t !== void 0
      ? t
      : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(e) {
    rh[this.storageKey] = Object.assign(
      Object.assign({}, rh[this.storageKey]),
      { cachedAt: e }
    );
  }
  _debug(...e) {
    return (
      this.logDebugMessages &&
        this.logger(
          `GoTrueClient@${this.instanceID} (${t8}) ${new Date().toISOString()}`,
          ...e
        ),
      this
    );
  }
  async initialize() {
    return this.initializePromise
      ? await this.initializePromise
      : ((this.initializePromise = (async () =>
          await this._acquireLock(-1, async () => await this._initialize()))()),
        await this.initializePromise);
  }
  async _initialize() {
    var e;
    try {
      const t = Tre(window.location.href);
      let s = "none";
      if (
        (this._isImplicitGrantCallback(t)
          ? (s = "implicit")
          : (await this._isPKCECallback(t)) && (s = "pkce"),
        ya() && this.detectSessionInUrl && s !== "none")
      ) {
        const { data: r, error: i } = await this._getSessionFromURL(t, s);
        if (i) {
          if (
            (this._debug(
              "#_initialize()",
              "error detecting session from URL",
              i
            ),
            mre(i))
          ) {
            const l =
              (e = i.details) === null || e === void 0 ? void 0 : e.code;
            if (
              l === "identity_already_exists" ||
              l === "identity_not_found" ||
              l === "single_identity_not_deletable"
            )
              return { error: i };
          }
          return await this._removeSession(), { error: i };
        }
        const { session: a, redirectType: o } = r;
        return (
          this._debug(
            "#_initialize()",
            "detected session in URL",
            a,
            "redirect type",
            o
          ),
          await this._saveSession(a),
          setTimeout(async () => {
            o === "recovery"
              ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", a)
              : await this._notifyAllSubscribers("SIGNED_IN", a);
          }, 0),
          { error: null }
        );
      }
      return await this._recoverAndRefresh(), { error: null };
    } catch (t) {
      return Ht(t)
        ? { error: t }
        : { error: new s8("Unexpected error during initialization", t) };
    } finally {
      await this._handleVisibilityChange(),
        this._debug("#_initialize()", "end");
    }
  }
  async signInAnonymously(e) {
    var t, s, r;
    try {
      const i = await sn(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data:
              (s =
                (t = e?.options) === null || t === void 0 ? void 0 : t.data) !==
                null && s !== void 0
                ? s
                : {},
            gotrue_meta_security: {
              captcha_token:
                (r = e?.options) === null || r === void 0
                  ? void 0
                  : r.captchaToken,
            },
          },
          xform: al,
        }),
        { data: a, error: o } = i;
      if (o || !a) return { data: { user: null, session: null }, error: o };
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (i) {
      if (Ht(i)) return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  async signUp(e) {
    var t, s, r;
    try {
      let i;
      if ("email" in e) {
        const { email: h, password: m, options: p } = e;
        let g = null,
          y = null;
        this.flowType === "pkce" &&
          ([g, y] = await th(this.storage, this.storageKey)),
          (i = await sn(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: p?.emailRedirectTo,
            body: {
              email: h,
              password: m,
              data: (t = p?.data) !== null && t !== void 0 ? t : {},
              gotrue_meta_security: { captcha_token: p?.captchaToken },
              code_challenge: g,
              code_challenge_method: y,
            },
            xform: al,
          }));
      } else if ("phone" in e) {
        const { phone: h, password: m, options: p } = e;
        i = await sn(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: h,
            password: m,
            data: (s = p?.data) !== null && s !== void 0 ? s : {},
            channel: (r = p?.channel) !== null && r !== void 0 ? r : "sms",
            gotrue_meta_security: { captcha_token: p?.captchaToken },
          },
          xform: al,
        });
      } else
        throw new uy(
          "You must provide either an email or phone number and a password"
        );
      const { data: a, error: o } = i;
      if (o || !a) return { data: { user: null, session: null }, error: o };
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (i) {
      if (Ht(i)) return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  async signInWithPassword(e) {
    try {
      let t;
      if ("email" in e) {
        const { email: i, password: a, options: o } = e;
        t = await sn(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              email: i,
              password: a,
              gotrue_meta_security: { captcha_token: o?.captchaToken },
            },
            xform: oF,
          }
        );
      } else if ("phone" in e) {
        const { phone: i, password: a, options: o } = e;
        t = await sn(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              phone: i,
              password: a,
              gotrue_meta_security: { captcha_token: o?.captchaToken },
            },
            xform: oF,
          }
        );
      } else
        throw new uy(
          "You must provide either an email or phone number and a password"
        );
      const { data: s, error: r } = t;
      return r
        ? { data: { user: null, session: null }, error: r }
        : !s || !s.session || !s.user
        ? { data: { user: null, session: null }, error: new cy() }
        : (s.session &&
            (await this._saveSession(s.session),
            await this._notifyAllSubscribers("SIGNED_IN", s.session)),
          {
            data: Object.assign(
              { user: s.user, session: s.session },
              s.weak_password ? { weakPassword: s.weak_password } : null
            ),
            error: r,
          });
    } catch (t) {
      if (Ht(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async signInWithOAuth(e) {
    var t, s, r, i;
    return await this._handleProviderSignIn(e.provider, {
      redirectTo:
        (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo,
      scopes: (s = e.options) === null || s === void 0 ? void 0 : s.scopes,
      queryParams:
        (r = e.options) === null || r === void 0 ? void 0 : r.queryParams,
      skipBrowserRedirect:
        (i = e.options) === null || i === void 0
          ? void 0
          : i.skipBrowserRedirect,
    });
  }
  async exchangeCodeForSession(e) {
    return (
      await this.initializePromise,
      this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    );
  }
  async signInWithWeb3(e) {
    const { chain: t } = e;
    if (t === "solana") return await this.signInWithSolana(e);
    throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`);
  }
  async signInWithSolana(e) {
    var t, s, r, i, a, o, l, c, h, m, p, g;
    let y, b;
    if ("message" in e) (y = e.message), (b = e.signature);
    else {
      const { chain: w, wallet: S, statement: A, options: _ } = e;
      let R;
      if (ya())
        if (typeof S == "object") R = S;
        else {
          const D = window;
          if (
            "solana" in D &&
            typeof D.solana == "object" &&
            (("signIn" in D.solana && typeof D.solana.signIn == "function") ||
              ("signMessage" in D.solana &&
                typeof D.solana.signMessage == "function"))
          )
            R = D.solana;
          else
            throw new Error(
              "@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead."
            );
        }
      else {
        if (typeof S != "object" || !_?.url)
          throw new Error(
            "@supabase/auth-js: Both wallet and url must be specified in non-browser environments."
          );
        R = S;
      }
      const C = new URL(
        (t = _?.url) !== null && t !== void 0 ? t : window.location.href
      );
      if ("signIn" in R && R.signIn) {
        const D = await R.signIn(
          Object.assign(
            Object.assign(
              Object.assign(
                { issuedAt: new Date().toISOString() },
                _?.signInWithSolana
              ),
              { version: "1", domain: C.host, uri: C.href }
            ),
            A ? { statement: A } : null
          )
        );
        let L;
        if (Array.isArray(D) && D[0] && typeof D[0] == "object") L = D[0];
        else if (
          D &&
          typeof D == "object" &&
          "signedMessage" in D &&
          "signature" in D
        )
          L = D;
        else
          throw new Error(
            "@supabase/auth-js: Wallet method signIn() returned unrecognized value"
          );
        if (
          "signedMessage" in L &&
          "signature" in L &&
          (typeof L.signedMessage == "string" ||
            L.signedMessage instanceof Uint8Array) &&
          L.signature instanceof Uint8Array
        )
          (y =
            typeof L.signedMessage == "string"
              ? L.signedMessage
              : new TextDecoder().decode(L.signedMessage)),
            (b = L.signature);
        else
          throw new Error(
            "@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields"
          );
      } else {
        if (
          !("signMessage" in R) ||
          typeof R.signMessage != "function" ||
          !("publicKey" in R) ||
          typeof R != "object" ||
          !R.publicKey ||
          !("toBase58" in R.publicKey) ||
          typeof R.publicKey.toBase58 != "function"
        )
          throw new Error(
            "@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API"
          );
        y = [
          `${C.host} wants you to sign in with your Solana account:`,
          R.publicKey.toBase58(),
          ...(A ? ["", A, ""] : [""]),
          "Version: 1",
          `URI: ${C.href}`,
          `Issued At: ${
            (r =
              (s = _?.signInWithSolana) === null || s === void 0
                ? void 0
                : s.issuedAt) !== null && r !== void 0
              ? r
              : new Date().toISOString()
          }`,
          ...(!((i = _?.signInWithSolana) === null || i === void 0) &&
          i.notBefore
            ? [`Not Before: ${_.signInWithSolana.notBefore}`]
            : []),
          ...(!((a = _?.signInWithSolana) === null || a === void 0) &&
          a.expirationTime
            ? [`Expiration Time: ${_.signInWithSolana.expirationTime}`]
            : []),
          ...(!((o = _?.signInWithSolana) === null || o === void 0) && o.chainId
            ? [`Chain ID: ${_.signInWithSolana.chainId}`]
            : []),
          ...(!((l = _?.signInWithSolana) === null || l === void 0) && l.nonce
            ? [`Nonce: ${_.signInWithSolana.nonce}`]
            : []),
          ...(!((c = _?.signInWithSolana) === null || c === void 0) &&
          c.requestId
            ? [`Request ID: ${_.signInWithSolana.requestId}`]
            : []),
          ...(!(
            (m =
              (h = _?.signInWithSolana) === null || h === void 0
                ? void 0
                : h.resources) === null || m === void 0
          ) && m.length
            ? [
                "Resources",
                ..._.signInWithSolana.resources.map((L) => `- ${L}`),
              ]
            : []),
        ].join(`
`);
        const D = await R.signMessage(new TextEncoder().encode(y), "utf8");
        if (!D || !(D instanceof Uint8Array))
          throw new Error(
            "@supabase/auth-js: Wallet signMessage() API returned an recognized value"
          );
        b = D;
      }
    }
    try {
      const { data: w, error: S } = await sn(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=web3`,
        {
          headers: this.headers,
          body: Object.assign(
            { chain: "solana", message: y, signature: wre(b) },
            !((p = e.options) === null || p === void 0) && p.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token:
                      (g = e.options) === null || g === void 0
                        ? void 0
                        : g.captchaToken,
                  },
                }
              : null
          ),
          xform: al,
        }
      );
      if (S) throw S;
      return !w || !w.session || !w.user
        ? { data: { user: null, session: null }, error: new cy() }
        : (w.session &&
            (await this._saveSession(w.session),
            await this._notifyAllSubscribers("SIGNED_IN", w.session)),
          { data: Object.assign({}, w), error: S });
    } catch (w) {
      if (Ht(w)) return { data: { user: null, session: null }, error: w };
      throw w;
    }
  }
  async _exchangeCodeForSession(e) {
    const t = await gu(this.storage, `${this.storageKey}-code-verifier`),
      [s, r] = (t ?? "").split("/");
    try {
      const { data: i, error: a } = await sn(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=pkce`,
        {
          headers: this.headers,
          body: { auth_code: e, code_verifier: s },
          xform: al,
        }
      );
      if ((await Jl(this.storage, `${this.storageKey}-code-verifier`), a))
        throw a;
      return !i || !i.session || !i.user
        ? {
            data: { user: null, session: null, redirectType: null },
            error: new cy(),
          }
        : (i.session &&
            (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
          {
            data: Object.assign(Object.assign({}, i), {
              redirectType: r ?? null,
            }),
            error: a,
          });
    } catch (i) {
      if (Ht(i))
        return {
          data: { user: null, session: null, redirectType: null },
          error: i,
        };
      throw i;
    }
  }
  async signInWithIdToken(e) {
    try {
      const {
          options: t,
          provider: s,
          token: r,
          access_token: i,
          nonce: a,
        } = e,
        o = await sn(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=id_token`,
          {
            headers: this.headers,
            body: {
              provider: s,
              id_token: r,
              access_token: i,
              nonce: a,
              gotrue_meta_security: { captcha_token: t?.captchaToken },
            },
            xform: al,
          }
        ),
        { data: l, error: c } = o;
      return c
        ? { data: { user: null, session: null }, error: c }
        : !l || !l.session || !l.user
        ? { data: { user: null, session: null }, error: new cy() }
        : (l.session &&
            (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
          { data: l, error: c });
    } catch (t) {
      if (Ht(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async signInWithOtp(e) {
    var t, s, r, i, a;
    try {
      if ("email" in e) {
        const { email: o, options: l } = e;
        let c = null,
          h = null;
        this.flowType === "pkce" &&
          ([c, h] = await th(this.storage, this.storageKey));
        const { error: m } = await sn(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: o,
            data: (t = l?.data) !== null && t !== void 0 ? t : {},
            create_user:
              (s = l?.shouldCreateUser) !== null && s !== void 0 ? s : !0,
            gotrue_meta_security: { captcha_token: l?.captchaToken },
            code_challenge: c,
            code_challenge_method: h,
          },
          redirectTo: l?.emailRedirectTo,
        });
        return { data: { user: null, session: null }, error: m };
      }
      if ("phone" in e) {
        const { phone: o, options: l } = e,
          { data: c, error: h } = await sn(
            this.fetch,
            "POST",
            `${this.url}/otp`,
            {
              headers: this.headers,
              body: {
                phone: o,
                data: (r = l?.data) !== null && r !== void 0 ? r : {},
                create_user:
                  (i = l?.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                gotrue_meta_security: { captcha_token: l?.captchaToken },
                channel: (a = l?.channel) !== null && a !== void 0 ? a : "sms",
              },
            }
          );
        return {
          data: { user: null, session: null, messageId: c?.message_id },
          error: h,
        };
      }
      throw new uy("You must provide either an email or phone number.");
    } catch (o) {
      if (Ht(o)) return { data: { user: null, session: null }, error: o };
      throw o;
    }
  }
  async verifyOtp(e) {
    var t, s;
    try {
      let r, i;
      "options" in e &&
        ((r = (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo),
        (i =
          (s = e.options) === null || s === void 0 ? void 0 : s.captchaToken));
      const { data: a, error: o } = await sn(
        this.fetch,
        "POST",
        `${this.url}/verify`,
        {
          headers: this.headers,
          body: Object.assign(Object.assign({}, e), {
            gotrue_meta_security: { captcha_token: i },
          }),
          redirectTo: r,
          xform: al,
        }
      );
      if (o) throw o;
      if (!a) throw new Error("An error occurred on token verification.");
      const l = a.session,
        c = a.user;
      return (
        l?.access_token &&
          (await this._saveSession(l),
          await this._notifyAllSubscribers(
            e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN",
            l
          )),
        { data: { user: c, session: l }, error: null }
      );
    } catch (r) {
      if (Ht(r)) return { data: { user: null, session: null }, error: r };
      throw r;
    }
  }
  async signInWithSSO(e) {
    var t, s, r;
    try {
      let i = null,
        a = null;
      return (
        this.flowType === "pkce" &&
          ([i, a] = await th(this.storage, this.storageKey)),
        await sn(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    {},
                    "providerId" in e ? { provider_id: e.providerId } : null
                  ),
                  "domain" in e ? { domain: e.domain } : null
                ),
                {
                  redirect_to:
                    (s =
                      (t = e.options) === null || t === void 0
                        ? void 0
                        : t.redirectTo) !== null && s !== void 0
                      ? s
                      : void 0,
                }
              ),
              !((r = e?.options) === null || r === void 0) && r.captchaToken
                ? {
                    gotrue_meta_security: {
                      captcha_token: e.options.captchaToken,
                    },
                  }
                : null
            ),
            {
              skip_http_redirect: !0,
              code_challenge: i,
              code_challenge_method: a,
            }
          ),
          headers: this.headers,
          xform: Bre,
        })
      );
    } catch (i) {
      if (Ht(i)) return { data: null, error: i };
      throw i;
    }
  }
  async reauthenticate() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._reauthenticate())
    );
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (e) => {
        const {
          data: { session: t },
          error: s,
        } = e;
        if (s) throw s;
        if (!t) throw new dc();
        const { error: r } = await sn(
          this.fetch,
          "GET",
          `${this.url}/reauthenticate`,
          { headers: this.headers, jwt: t.access_token }
        );
        return { data: { user: null, session: null }, error: r };
      });
    } catch (e) {
      if (Ht(e)) return { data: { user: null, session: null }, error: e };
      throw e;
    }
  }
  async resend(e) {
    try {
      const t = `${this.url}/resend`;
      if ("email" in e) {
        const { email: s, type: r, options: i } = e,
          { error: a } = await sn(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              email: s,
              type: r,
              gotrue_meta_security: { captcha_token: i?.captchaToken },
            },
            redirectTo: i?.emailRedirectTo,
          });
        return { data: { user: null, session: null }, error: a };
      } else if ("phone" in e) {
        const { phone: s, type: r, options: i } = e,
          { data: a, error: o } = await sn(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              phone: s,
              type: r,
              gotrue_meta_security: { captcha_token: i?.captchaToken },
            },
          });
        return {
          data: { user: null, session: null, messageId: a?.message_id },
          error: o,
        };
      }
      throw new uy(
        "You must provide either an email or phone number and a type"
      );
    } catch (t) {
      if (Ht(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async getSession() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => this._useSession(async (t) => t))
    );
  }
  async _acquireLock(e, t) {
    this._debug("#_acquireLock", "begin", e);
    try {
      if (this.lockAcquired) {
        const s = this.pendingInLock.length
            ? this.pendingInLock[this.pendingInLock.length - 1]
            : Promise.resolve(),
          r = (async () => (await s, await t()))();
        return (
          this.pendingInLock.push(
            (async () => {
              try {
                await r;
              } catch {}
            })()
          ),
          r
        );
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug(
          "#_acquireLock",
          "lock acquired for storage key",
          this.storageKey
        );
        try {
          this.lockAcquired = !0;
          const s = t();
          for (
            this.pendingInLock.push(
              (async () => {
                try {
                  await s;
                } catch {}
              })()
            ),
              await s;
            this.pendingInLock.length;

          ) {
            const r = [...this.pendingInLock];
            await Promise.all(r), this.pendingInLock.splice(0, r.length);
          }
          return await s;
        } finally {
          this._debug(
            "#_acquireLock",
            "lock released for storage key",
            this.storageKey
          ),
            (this.lockAcquired = !1);
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  async _useSession(e) {
    this._debug("#_useSession", "begin");
    try {
      const t = await this.__loadSession();
      return await e(t);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  async __loadSession() {
    this._debug("#__loadSession()", "begin"),
      this.lockAcquired ||
        this._debug(
          "#__loadSession()",
          "used outside of an acquired lock!",
          new Error().stack
        );
    try {
      let e = null;
      const t = await gu(this.storage, this.storageKey);
      if (
        (this._debug("#getSession()", "session from storage", t),
        t !== null &&
          (this._isValidSession(t)
            ? (e = t)
            : (this._debug(
                "#getSession()",
                "session from storage is not valid"
              ),
              await this._removeSession())),
        !e)
      )
        return { data: { session: null }, error: null };
      const s = e.expires_at ? e.expires_at * 1e3 - Date.now() < V_ : !1;
      if (
        (this._debug(
          "#__loadSession()",
          `session has${s ? "" : " not"} expired`,
          "expires_at",
          e.expires_at
        ),
        !s)
      ) {
        if (this.userStorage) {
          const a = await gu(this.userStorage, this.storageKey + "-user");
          a?.user ? (e.user = a.user) : (e.user = q_());
        }
        if (this.storage.isServer && e.user) {
          let a = this.suppressGetSessionWarning;
          e = new Proxy(e, {
            get: (l, c, h) => (
              !a &&
                c === "user" &&
                (console.warn(
                  "Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."
                ),
                (a = !0),
                (this.suppressGetSessionWarning = !0)),
              Reflect.get(l, c, h)
            ),
          });
        }
        return { data: { session: e }, error: null };
      }
      const { session: r, error: i } = await this._callRefreshToken(
        e.refresh_token
      );
      return i
        ? { data: { session: null }, error: i }
        : { data: { session: r }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  async getUser(e) {
    return e
      ? await this._getUser(e)
      : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(e) {
    try {
      return e
        ? await sn(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: e,
            xform: Ec,
          })
        : await this._useSession(async (t) => {
            var s, r, i;
            const { data: a, error: o } = t;
            if (o) throw o;
            return !(
              !((s = a.session) === null || s === void 0) && s.access_token
            ) && !this.hasCustomAuthorizationHeader
              ? { data: { user: null }, error: new dc() }
              : await sn(this.fetch, "GET", `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    (i =
                      (r = a.session) === null || r === void 0
                        ? void 0
                        : r.access_token) !== null && i !== void 0
                      ? i
                      : void 0,
                  xform: Ec,
                });
          });
    } catch (t) {
      if (Ht(t))
        return (
          fre(t) &&
            (await this._removeSession(),
            await Jl(this.storage, `${this.storageKey}-code-verifier`)),
          { data: { user: null }, error: t }
        );
      throw t;
    }
  }
  async updateUser(e, t = {}) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._updateUser(e, t))
    );
  }
  async _updateUser(e, t = {}) {
    try {
      return await this._useSession(async (s) => {
        const { data: r, error: i } = s;
        if (i) throw i;
        if (!r.session) throw new dc();
        const a = r.session;
        let o = null,
          l = null;
        this.flowType === "pkce" &&
          e.email != null &&
          ([o, l] = await th(this.storage, this.storageKey));
        const { data: c, error: h } = await sn(
          this.fetch,
          "PUT",
          `${this.url}/user`,
          {
            headers: this.headers,
            redirectTo: t?.emailRedirectTo,
            body: Object.assign(Object.assign({}, e), {
              code_challenge: o,
              code_challenge_method: l,
            }),
            jwt: a.access_token,
            xform: Ec,
          }
        );
        if (h) throw h;
        return (
          (a.user = c.user),
          await this._saveSession(a),
          await this._notifyAllSubscribers("USER_UPDATED", a),
          { data: { user: a.user }, error: null }
        );
      });
    } catch (s) {
      if (Ht(s)) return { data: { user: null }, error: s };
      throw s;
    }
  }
  async setSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._setSession(e))
    );
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token) throw new dc();
      const t = Date.now() / 1e3;
      let s = t,
        r = !0,
        i = null;
      const { payload: a } = G_(e.access_token);
      if ((a.exp && ((s = a.exp), (r = s <= t)), r)) {
        const { session: o, error: l } = await this._callRefreshToken(
          e.refresh_token
        );
        if (l) return { data: { user: null, session: null }, error: l };
        if (!o) return { data: { user: null, session: null }, error: null };
        i = o;
      } else {
        const { data: o, error: l } = await this._getUser(e.access_token);
        if (l) throw l;
        (i = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: o.user,
          token_type: "bearer",
          expires_in: s - t,
          expires_at: s,
        }),
          await this._saveSession(i),
          await this._notifyAllSubscribers("SIGNED_IN", i);
      }
      return { data: { user: i.user, session: i }, error: null };
    } catch (t) {
      if (Ht(t)) return { data: { session: null, user: null }, error: t };
      throw t;
    }
  }
  async refreshSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._refreshSession(e))
    );
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async (t) => {
        var s;
        if (!e) {
          const { data: a, error: o } = t;
          if (o) throw o;
          e = (s = a.session) !== null && s !== void 0 ? s : void 0;
        }
        if (!e?.refresh_token) throw new dc();
        const { session: r, error: i } = await this._callRefreshToken(
          e.refresh_token
        );
        return i
          ? { data: { user: null, session: null }, error: i }
          : r
          ? { data: { user: r.user, session: r }, error: null }
          : { data: { user: null, session: null }, error: null };
      });
    } catch (t) {
      if (Ht(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async _getSessionFromURL(e, t) {
    try {
      if (!ya()) throw new dy("No browser detected.");
      if (e.error || e.error_description || e.error_code)
        throw new dy(
          e.error_description ||
            "Error in URL with unspecified error_description",
          {
            error: e.error || "unspecified_error",
            code: e.error_code || "unspecified_code",
          }
        );
      switch (t) {
        case "implicit":
          if (this.flowType === "pkce")
            throw new eF("Not a valid PKCE flow url.");
          break;
        case "pkce":
          if (this.flowType === "implicit")
            throw new dy("Not a valid implicit grant flow url.");
          break;
        default:
      }
      if (t === "pkce") {
        if (
          (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !e.code)
        )
          throw new eF("No code detected.");
        const { data: A, error: _ } = await this._exchangeCodeForSession(
          e.code
        );
        if (_) throw _;
        const R = new URL(window.location.href);
        return (
          R.searchParams.delete("code"),
          window.history.replaceState(window.history.state, "", R.toString()),
          { data: { session: A.session, redirectType: null }, error: null }
        );
      }
      const {
        provider_token: s,
        provider_refresh_token: r,
        access_token: i,
        refresh_token: a,
        expires_in: o,
        expires_at: l,
        token_type: c,
      } = e;
      if (!i || !o || !a || !c) throw new dy("No session defined in URL");
      const h = Math.round(Date.now() / 1e3),
        m = parseInt(o);
      let p = h + m;
      l && (p = parseInt(l));
      const g = p - h;
      g * 1e3 <= Eh &&
        console.warn(
          `@supabase/gotrue-js: Session as retrieved from URL expires in ${g}s, should have been closer to ${m}s`
        );
      const y = p - m;
      h - y >= 120
        ? console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",
            y,
            p,
            h
          )
        : h - y < 0 &&
          console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",
            y,
            p,
            h
          );
      const { data: b, error: w } = await this._getUser(i);
      if (w) throw w;
      const S = {
        provider_token: s,
        provider_refresh_token: r,
        access_token: i,
        expires_in: m,
        expires_at: p,
        refresh_token: a,
        token_type: c,
        user: b.user,
      };
      return (
        (window.location.hash = ""),
        this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
        { data: { session: S, redirectType: e.type }, error: null }
      );
    } catch (s) {
      if (Ht(s))
        return { data: { session: null, redirectType: null }, error: s };
      throw s;
    }
  }
  _isImplicitGrantCallback(e) {
    return !!(e.access_token || e.error_description);
  }
  async _isPKCECallback(e) {
    const t = await gu(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && t);
  }
  async signOut(e = { scope: "global" }) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._signOut(e))
    );
  }
  async _signOut({ scope: e } = { scope: "global" }) {
    return await this._useSession(async (t) => {
      var s;
      const { data: r, error: i } = t;
      if (i) return { error: i };
      const a =
        (s = r.session) === null || s === void 0 ? void 0 : s.access_token;
      if (a) {
        const { error: o } = await this.admin.signOut(a, e);
        if (
          o &&
          !(
            hre(o) &&
            (o.status === 404 || o.status === 401 || o.status === 403)
          )
        )
          return { error: o };
      }
      return (
        e !== "others" &&
          (await this._removeSession(),
          await Jl(this.storage, `${this.storageKey}-code-verifier`)),
        { error: null }
      );
    });
  }
  onAuthStateChange(e) {
    const t = Sre(),
      s = {
        id: t,
        callback: e,
        unsubscribe: () => {
          this._debug(
            "#unsubscribe()",
            "state change callback with id removed",
            t
          ),
            this.stateChangeEmitters.delete(t);
        },
      };
    return (
      this._debug("#onAuthStateChange()", "registered callback with id", t),
      this.stateChangeEmitters.set(t, s),
      (async () => (
        await this.initializePromise,
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(t);
        })
      ))(),
      { data: { subscription: s } }
    );
  }
  async _emitInitialSession(e) {
    return await this._useSession(async (t) => {
      var s, r;
      try {
        const {
          data: { session: i },
          error: a,
        } = t;
        if (a) throw a;
        await ((s = this.stateChangeEmitters.get(e)) === null || s === void 0
          ? void 0
          : s.callback("INITIAL_SESSION", i)),
          this._debug("INITIAL_SESSION", "callback id", e, "session", i);
      } catch (i) {
        await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0
          ? void 0
          : r.callback("INITIAL_SESSION", null)),
          this._debug("INITIAL_SESSION", "callback id", e, "error", i),
          console.error(i);
      }
    });
  }
  async resetPasswordForEmail(e, t = {}) {
    let s = null,
      r = null;
    this.flowType === "pkce" &&
      ([s, r] = await th(this.storage, this.storageKey, !0));
    try {
      return await sn(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: s,
          code_challenge_method: r,
          gotrue_meta_security: { captcha_token: t.captchaToken },
        },
        headers: this.headers,
        redirectTo: t.redirectTo,
      });
    } catch (i) {
      if (Ht(i)) return { data: null, error: i };
      throw i;
    }
  }
  async getUserIdentities() {
    var e;
    try {
      const { data: t, error: s } = await this.getUser();
      if (s) throw s;
      return {
        data: {
          identities: (e = t.user.identities) !== null && e !== void 0 ? e : [],
        },
        error: null,
      };
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
  async linkIdentity(e) {
    var t;
    try {
      const { data: s, error: r } = await this._useSession(async (i) => {
        var a, o, l, c, h;
        const { data: m, error: p } = i;
        if (p) throw p;
        const g = await this._getUrlForProvider(
          `${this.url}/user/identities/authorize`,
          e.provider,
          {
            redirectTo:
              (a = e.options) === null || a === void 0 ? void 0 : a.redirectTo,
            scopes:
              (o = e.options) === null || o === void 0 ? void 0 : o.scopes,
            queryParams:
              (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
            skipBrowserRedirect: !0,
          }
        );
        return await sn(this.fetch, "GET", g, {
          headers: this.headers,
          jwt:
            (h =
              (c = m.session) === null || c === void 0
                ? void 0
                : c.access_token) !== null && h !== void 0
              ? h
              : void 0,
        });
      });
      if (r) throw r;
      return (
        ya() &&
          !(
            !((t = e.options) === null || t === void 0) && t.skipBrowserRedirect
          ) &&
          window.location.assign(s?.url),
        { data: { provider: e.provider, url: s?.url }, error: null }
      );
    } catch (s) {
      if (Ht(s)) return { data: { provider: e.provider, url: null }, error: s };
      throw s;
    }
  }
  async unlinkIdentity(e) {
    try {
      return await this._useSession(async (t) => {
        var s, r;
        const { data: i, error: a } = t;
        if (a) throw a;
        return await sn(
          this.fetch,
          "DELETE",
          `${this.url}/user/identities/${e.identity_id}`,
          {
            headers: this.headers,
            jwt:
              (r =
                (s = i.session) === null || s === void 0
                  ? void 0
                  : s.access_token) !== null && r !== void 0
                ? r
                : void 0,
          }
        );
      });
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _refreshAccessToken(e) {
    const t = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
    this._debug(t, "begin");
    try {
      const s = Date.now();
      return await Rre(
        async (r) => (
          r > 0 && (await Are(200 * Math.pow(2, r - 1))),
          this._debug(t, "refreshing attempt", r),
          await sn(
            this.fetch,
            "POST",
            `${this.url}/token?grant_type=refresh_token`,
            { body: { refresh_token: e }, headers: this.headers, xform: al }
          )
        ),
        (r, i) => {
          const a = 200 * Math.pow(2, r);
          return i && z_(i) && Date.now() + a - s < Eh;
        }
      );
    } catch (s) {
      if ((this._debug(t, "error", s), Ht(s)))
        return { data: { session: null, user: null }, error: s };
      throw s;
    } finally {
      this._debug(t, "end");
    }
  }
  _isValidSession(e) {
    return (
      typeof e == "object" &&
      e !== null &&
      "access_token" in e &&
      "refresh_token" in e &&
      "expires_at" in e
    );
  }
  async _handleProviderSignIn(e, t) {
    const s = await this._getUrlForProvider(`${this.url}/authorize`, e, {
      redirectTo: t.redirectTo,
      scopes: t.scopes,
      queryParams: t.queryParams,
    });
    return (
      this._debug(
        "#_handleProviderSignIn()",
        "provider",
        e,
        "options",
        t,
        "url",
        s
      ),
      ya() && !t.skipBrowserRedirect && window.location.assign(s),
      { data: { provider: e, url: s }, error: null }
    );
  }
  async _recoverAndRefresh() {
    var e, t;
    const s = "#_recoverAndRefresh()";
    this._debug(s, "begin");
    try {
      const r = await gu(this.storage, this.storageKey);
      if (r && this.userStorage) {
        let a = await gu(this.userStorage, this.storageKey + "-user");
        !this.storage.isServer &&
          Object.is(this.storage, this.userStorage) &&
          !a &&
          ((a = { user: r.user }),
          await Sh(this.userStorage, this.storageKey + "-user", a)),
          (r.user = (e = a?.user) !== null && e !== void 0 ? e : q_());
      } else if (r && !r.user && !r.user) {
        const a = await gu(this.storage, this.storageKey + "-user");
        a && a?.user
          ? ((r.user = a.user),
            await Jl(this.storage, this.storageKey + "-user"),
            await Sh(this.storage, this.storageKey, r))
          : (r.user = q_());
      }
      if (
        (this._debug(s, "session from storage", r), !this._isValidSession(r))
      ) {
        this._debug(s, "session is not valid"),
          r !== null && (await this._removeSession());
        return;
      }
      const i =
        ((t = r.expires_at) !== null && t !== void 0 ? t : 1 / 0) * 1e3 -
          Date.now() <
        V_;
      if (
        (this._debug(
          s,
          `session has${i ? "" : " not"} expired with margin of ${V_}s`
        ),
        i)
      ) {
        if (this.autoRefreshToken && r.refresh_token) {
          const { error: a } = await this._callRefreshToken(r.refresh_token);
          a &&
            (console.error(a),
            z_(a) ||
              (this._debug(
                s,
                "refresh failed with a non-retryable error, removing the session",
                a
              ),
              await this._removeSession()));
        }
      } else if (r.user && r.user.__isUserNotAvailableProxy === !0)
        try {
          const { data: a, error: o } = await this._getUser(r.access_token);
          !o && a?.user
            ? ((r.user = a.user),
              await this._saveSession(r),
              await this._notifyAllSubscribers("SIGNED_IN", r))
            : this._debug(
                s,
                "could not get user data, skipping SIGNED_IN notification"
              );
        } catch (a) {
          console.error("Error getting user data:", a),
            this._debug(
              s,
              "error getting user data, skipping SIGNED_IN notification",
              a
            );
        }
      else await this._notifyAllSubscribers("SIGNED_IN", r);
    } catch (r) {
      this._debug(s, "error", r), console.error(r);
      return;
    } finally {
      this._debug(s, "end");
    }
  }
  async _callRefreshToken(e) {
    var t, s;
    if (!e) throw new dc();
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const r = `#_callRefreshToken(${e.substring(0, 5)}...)`;
    this._debug(r, "begin");
    try {
      this.refreshingDeferred = new uE();
      const { data: i, error: a } = await this._refreshAccessToken(e);
      if (a) throw a;
      if (!i.session) throw new dc();
      await this._saveSession(i.session),
        await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
      const o = { session: i.session, error: null };
      return this.refreshingDeferred.resolve(o), o;
    } catch (i) {
      if ((this._debug(r, "error", i), Ht(i))) {
        const a = { session: null, error: i };
        return (
          z_(i) || (await this._removeSession()),
          (t = this.refreshingDeferred) === null ||
            t === void 0 ||
            t.resolve(a),
          a
        );
      }
      throw (
        ((s = this.refreshingDeferred) === null || s === void 0 || s.reject(i),
        i)
      );
    } finally {
      (this.refreshingDeferred = null), this._debug(r, "end");
    }
  }
  async _notifyAllSubscribers(e, t, s = !0) {
    const r = `#_notifyAllSubscribers(${e})`;
    this._debug(r, "begin", t, `broadcast = ${s}`);
    try {
      this.broadcastChannel &&
        s &&
        this.broadcastChannel.postMessage({ event: e, session: t });
      const i = [],
        a = Array.from(this.stateChangeEmitters.values()).map(async (o) => {
          try {
            await o.callback(e, t);
          } catch (l) {
            i.push(l);
          }
        });
      if ((await Promise.all(a), i.length > 0)) {
        for (let o = 0; o < i.length; o += 1) console.error(i[o]);
        throw i[0];
      }
    } finally {
      this._debug(r, "end");
    }
  }
  async _saveSession(e) {
    this._debug("#_saveSession()", e), (this.suppressGetSessionWarning = !0);
    const t = Object.assign({}, e),
      s = t.user && t.user.__isUserNotAvailableProxy === !0;
    if (this.userStorage) {
      !s &&
        t.user &&
        (await Sh(this.userStorage, this.storageKey + "-user", {
          user: t.user,
        }));
      const r = Object.assign({}, t);
      delete r.user;
      const i = iF(r);
      await Sh(this.storage, this.storageKey, i);
    } else {
      const r = iF(t);
      await Sh(this.storage, this.storageKey, r);
    }
  }
  async _removeSession() {
    this._debug("#_removeSession()"),
      await Jl(this.storage, this.storageKey),
      await Jl(this.storage, this.storageKey + "-code-verifier"),
      await Jl(this.storage, this.storageKey + "-user"),
      this.userStorage &&
        (await Jl(this.userStorage, this.storageKey + "-user")),
      await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e &&
        ya() &&
        window?.removeEventListener &&
        window.removeEventListener("visibilitychange", e);
    } catch (t) {
      console.error("removing visibilitychange callback failed", t);
    }
  }
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const e = setInterval(() => this._autoRefreshTokenTick(), Eh);
    (this.autoRefreshTicker = e),
      e && typeof e == "object" && typeof e.unref == "function"
        ? e.unref()
        : typeof Deno < "u" &&
          typeof Deno.unrefTimer == "function" &&
          Deno.unrefTimer(e),
      setTimeout(async () => {
        await this.initializePromise, await this._autoRefreshTokenTick();
      }, 0);
  }
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const e = this.autoRefreshTicker;
    (this.autoRefreshTicker = null), e && clearInterval(e);
  }
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async (t) => {
              const {
                data: { session: s },
              } = t;
              if (!s || !s.refresh_token || !s.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const r = Math.floor((s.expires_at * 1e3 - e) / Eh);
              this._debug(
                "#_autoRefreshTokenTick()",
                `access token expires in ${r} ticks, a tick lasts ${Eh}ms, refresh threshold is ${yR} ticks`
              ),
                r <= yR && (await this._callRefreshToken(s.refresh_token));
            });
          } catch (t) {
            console.error(
              "Auto refresh tick failed with error. This is likely a transient error.",
              t
            );
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof o8)
        this._debug("auto refresh token tick lock not available");
      else throw e;
    }
  }
  async _handleVisibilityChange() {
    if (
      (this._debug("#_handleVisibilityChange()"),
      !ya() || !window?.addEventListener)
    )
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      (this.visibilityChangedCallback = async () =>
        await this._onVisibilityChanged(!1)),
        window?.addEventListener(
          "visibilitychange",
          this.visibilityChangedCallback
        ),
        await this._onVisibilityChanged(!0);
    } catch (e) {
      console.error("_handleVisibilityChange", e);
    }
  }
  async _onVisibilityChanged(e) {
    const t = `#_onVisibilityChanged(${e})`;
    this._debug(t, "visibilityState", document.visibilityState),
      document.visibilityState === "visible"
        ? (this.autoRefreshToken && this._startAutoRefresh(),
          e ||
            (await this.initializePromise,
            await this._acquireLock(-1, async () => {
              if (document.visibilityState !== "visible") {
                this._debug(
                  t,
                  "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"
                );
                return;
              }
              await this._recoverAndRefresh();
            })))
        : document.visibilityState === "hidden" &&
          this.autoRefreshToken &&
          this._stopAutoRefresh();
  }
  async _getUrlForProvider(e, t, s) {
    const r = [`provider=${encodeURIComponent(t)}`];
    if (
      (s?.redirectTo &&
        r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),
      s?.scopes && r.push(`scopes=${encodeURIComponent(s.scopes)}`),
      this.flowType === "pkce")
    ) {
      const [i, a] = await th(this.storage, this.storageKey),
        o = new URLSearchParams({
          code_challenge: `${encodeURIComponent(i)}`,
          code_challenge_method: `${encodeURIComponent(a)}`,
        });
      r.push(o.toString());
    }
    if (s?.queryParams) {
      const i = new URLSearchParams(s.queryParams);
      r.push(i.toString());
    }
    return (
      s?.skipBrowserRedirect &&
        r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),
      `${e}?${r.join("&")}`
    );
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async (t) => {
        var s;
        const { data: r, error: i } = t;
        return i
          ? { data: null, error: i }
          : await sn(
              this.fetch,
              "DELETE",
              `${this.url}/factors/${e.factorId}`,
              {
                headers: this.headers,
                jwt:
                  (s = r?.session) === null || s === void 0
                    ? void 0
                    : s.access_token,
              }
            );
      });
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async (t) => {
        var s, r;
        const { data: i, error: a } = t;
        if (a) return { data: null, error: a };
        const o = Object.assign(
            { friendly_name: e.friendlyName, factor_type: e.factorType },
            e.factorType === "phone" ? { phone: e.phone } : { issuer: e.issuer }
          ),
          { data: l, error: c } = await sn(
            this.fetch,
            "POST",
            `${this.url}/factors`,
            {
              body: o,
              headers: this.headers,
              jwt:
                (s = i?.session) === null || s === void 0
                  ? void 0
                  : s.access_token,
            }
          );
        return c
          ? { data: null, error: c }
          : (e.factorType === "totp" &&
              !((r = l?.totp) === null || r === void 0) &&
              r.qr_code &&
              (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
            { data: l, error: null });
      });
    } catch (t) {
      if (Ht(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var s;
          const { data: r, error: i } = t;
          if (i) return { data: null, error: i };
          const { data: a, error: o } = await sn(
            this.fetch,
            "POST",
            `${this.url}/factors/${e.factorId}/verify`,
            {
              body: { code: e.code, challenge_id: e.challengeId },
              headers: this.headers,
              jwt:
                (s = r?.session) === null || s === void 0
                  ? void 0
                  : s.access_token,
            }
          );
          return o
            ? { data: null, error: o }
            : (await this._saveSession(
                Object.assign(
                  { expires_at: Math.round(Date.now() / 1e3) + a.expires_in },
                  a
                )
              ),
              await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
              { data: a, error: o });
        });
      } catch (t) {
        if (Ht(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var s;
          const { data: r, error: i } = t;
          return i
            ? { data: null, error: i }
            : await sn(
                this.fetch,
                "POST",
                `${this.url}/factors/${e.factorId}/challenge`,
                {
                  body: { channel: e.channel },
                  headers: this.headers,
                  jwt:
                    (s = r?.session) === null || s === void 0
                      ? void 0
                      : s.access_token,
                }
              );
        });
      } catch (t) {
        if (Ht(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  async _challengeAndVerify(e) {
    const { data: t, error: s } = await this._challenge({
      factorId: e.factorId,
    });
    return s
      ? { data: null, error: s }
      : await this._verify({
          factorId: e.factorId,
          challengeId: t.id,
          code: e.code,
        });
  }
  async _listFactors() {
    const {
      data: { user: e },
      error: t,
    } = await this.getUser();
    if (t) return { data: null, error: t };
    const s = e?.factors || [],
      r = s.filter((a) => a.factor_type === "totp" && a.status === "verified"),
      i = s.filter((a) => a.factor_type === "phone" && a.status === "verified");
    return { data: { all: s, totp: r, phone: i }, error: null };
  }
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(
      -1,
      async () =>
        await this._useSession(async (e) => {
          var t, s;
          const {
            data: { session: r },
            error: i,
          } = e;
          if (i) return { data: null, error: i };
          if (!r)
            return {
              data: {
                currentLevel: null,
                nextLevel: null,
                currentAuthenticationMethods: [],
              },
              error: null,
            };
          const { payload: a } = G_(r.access_token);
          let o = null;
          a.aal && (o = a.aal);
          let l = o;
          ((s =
            (t = r.user.factors) === null || t === void 0
              ? void 0
              : t.filter((m) => m.status === "verified")) !== null &&
          s !== void 0
            ? s
            : []
          ).length > 0 && (l = "aal2");
          const h = a.amr || [];
          return {
            data: {
              currentLevel: o,
              nextLevel: l,
              currentAuthenticationMethods: h,
            },
            error: null,
          };
        })
    );
  }
  async fetchJwk(e, t = { keys: [] }) {
    let s = t.keys.find((o) => o.kid === e);
    if (s) return s;
    const r = Date.now();
    if (
      ((s = this.jwks.keys.find((o) => o.kid === e)),
      s && this.jwks_cached_at + ure > r)
    )
      return s;
    const { data: i, error: a } = await sn(
      this.fetch,
      "GET",
      `${this.url}/.well-known/jwks.json`,
      { headers: this.headers }
    );
    if (a) throw a;
    return !i.keys ||
      i.keys.length === 0 ||
      ((this.jwks = i),
      (this.jwks_cached_at = r),
      (s = i.keys.find((o) => o.kid === e)),
      !s)
      ? null
      : s;
  }
  async getClaims(e, t = {}) {
    try {
      let s = e;
      if (!s) {
        const { data: g, error: y } = await this.getSession();
        if (y || !g.session) return { data: null, error: y };
        s = g.session.access_token;
      }
      const {
        header: r,
        payload: i,
        signature: a,
        raw: { header: o, payload: l },
      } = G_(s);
      t?.allowExpired || Mre(i.exp);
      const c =
        !r.alg ||
        r.alg.startsWith("HS") ||
        !r.kid ||
        !("crypto" in globalThis && "subtle" in globalThis.crypto)
          ? null
          : await this.fetchJwk(r.kid, t?.keys ? { keys: t.keys } : t?.jwks);
      if (!c) {
        const { error: g } = await this.getUser(s);
        if (g) throw g;
        return { data: { claims: i, header: r, signature: a }, error: null };
      }
      const h = Nre(r.alg),
        m = await crypto.subtle.importKey("jwk", c, h, !0, ["verify"]);
      if (!(await crypto.subtle.verify(h, m, a, xre(`${o}.${l}`))))
        throw new wR("Invalid JWT signature");
      return { data: { claims: i, header: r, signature: a }, error: null };
    } catch (s) {
      if (Ht(s)) return { data: null, error: s };
      throw s;
    }
  }
}
_g.nextInstanceID = 0;
const Qre = _g;
class Zre extends Qre {
  constructor(e) {
    super(e);
  }
}
var Jre = function (n, e, t, s) {
  function r(i) {
    return i instanceof t
      ? i
      : new t(function (a) {
          a(i);
        });
  }
  return new (t || (t = Promise))(function (i, a) {
    function o(h) {
      try {
        c(s.next(h));
      } catch (m) {
        a(m);
      }
    }
    function l(h) {
      try {
        c(s.throw(h));
      } catch (m) {
        a(m);
      }
    }
    function c(h) {
      h.done ? i(h.value) : r(h.value).then(o, l);
    }
    c((s = s.apply(n, e || [])).next());
  });
};
class eie {
  constructor(e, t, s) {
    var r, i, a;
    if (((this.supabaseUrl = e), (this.supabaseKey = t), !e))
      throw new Error("supabaseUrl is required.");
    if (!t) throw new Error("supabaseKey is required.");
    const o = rre(e),
      l = new URL(o);
    (this.realtimeUrl = new URL("realtime/v1", l)),
      (this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(
        "http",
        "ws"
      )),
      (this.authUrl = new URL("auth/v1", l)),
      (this.storageUrl = new URL("storage/v1", l)),
      (this.functionsUrl = new URL("functions/v1", l));
    const c = `sb-${l.hostname.split(".")[0]}-auth-token`,
      h = {
        db: Xse,
        realtime: Zse,
        auth: Object.assign(Object.assign({}, Qse), { storageKey: c }),
        global: Yse,
      },
      m = ire(s ?? {}, h);
    (this.storageKey =
      (r = m.auth.storageKey) !== null && r !== void 0 ? r : ""),
      (this.headers = (i = m.global.headers) !== null && i !== void 0 ? i : {}),
      m.accessToken
        ? ((this.accessToken = m.accessToken),
          (this.auth = new Proxy(
            {},
            {
              get: (p, g) => {
                throw new Error(
                  `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(
                    g
                  )} is not possible`
                );
              },
            }
          )))
        : (this.auth = this._initSupabaseAuthClient(
            (a = m.auth) !== null && a !== void 0 ? a : {},
            this.headers,
            m.global.fetch
          )),
      (this.fetch = nre(t, this._getAccessToken.bind(this), m.global.fetch)),
      (this.realtime = this._initRealtimeClient(
        Object.assign(
          {
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this),
          },
          m.realtime
        )
      )),
      (this.rest = new yse(new URL("rest/v1", l).href, {
        headers: this.headers,
        schema: m.db.schema,
        fetch: this.fetch,
      })),
      (this.storage = new qse(
        this.storageUrl.href,
        this.headers,
        this.fetch,
        s?.storage
      )),
      m.accessToken || this._listenForAuthEvents();
  }
  get functions() {
    return new ase(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch,
    });
  }
  from(e) {
    return this.rest.from(e);
  }
  schema(e) {
    return this.rest.schema(e);
  }
  rpc(e, t = {}, s = {}) {
    return this.rest.rpc(e, t, s);
  }
  channel(e, t = { config: {} }) {
    return this.realtime.channel(e, t);
  }
  getChannels() {
    return this.realtime.getChannels();
  }
  removeChannel(e) {
    return this.realtime.removeChannel(e);
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var e, t;
    return Jre(this, void 0, void 0, function* () {
      if (this.accessToken) return yield this.accessToken();
      const { data: s } = yield this.auth.getSession();
      return (t =
        (e = s.session) === null || e === void 0 ? void 0 : e.access_token) !==
        null && t !== void 0
        ? t
        : null;
    });
  }
  _initSupabaseAuthClient(
    {
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: s,
      storage: r,
      storageKey: i,
      flowType: a,
      lock: o,
      debug: l,
    },
    c,
    h
  ) {
    const m = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`,
    };
    return new Zre({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, m), c),
      storageKey: i,
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: s,
      storage: r,
      flowType: a,
      lock: o,
      debug: l,
      fetch: h,
      hasCustomAuthorizationHeader: "Authorization" in this.headers,
    });
  }
  _initRealtimeClient(e) {
    return new Pse(
      this.realtimeUrl.href,
      Object.assign(Object.assign({}, e), {
        params: Object.assign({ apikey: this.supabaseKey }, e?.params),
      })
    );
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((t, s) => {
      this._handleTokenChanged(t, "CLIENT", s?.access_token);
    });
  }
  _handleTokenChanged(e, t, s) {
    (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") &&
    this.changedAccessToken !== s
      ? (this.changedAccessToken = s)
      : e === "SIGNED_OUT" &&
        (this.realtime.setAuth(),
        t == "STORAGE" && this.auth.signOut(),
        (this.changedAccessToken = void 0));
  }
}
const tie = (n, e, t) => new eie(n, e, t);
function nie() {
  if (
    typeof window < "u" ||
    typeof process > "u" ||
    process.version === void 0 ||
    process.version === null
  )
    return !1;
  const n = process.version.match(/^v(\d+)\./);
  return n ? parseInt(n[1], 10) <= 18 : !1;
}
nie() &&
  console.warn(
    "  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217"
  );
const sie = "0.6.1";
function zp() {
  return typeof window < "u" && typeof window.document < "u";
}
const hy = {
    path: "/",
    sameSite: "lax",
    httpOnly: !1,
    maxAge: 400 * 24 * 60 * 60,
  },
  rie = 3180,
  iie = /^(.*)[.](0|[1-9][0-9]*)$/;
function uF(n, e) {
  if (n === e) return !0;
  const t = n.match(iie);
  return !!(t && t[1] === e);
}
function aie(n, e, t) {
  const s = rie;
  let r = encodeURIComponent(e);
  if (r.length <= s) return [{ name: n, value: e }];
  const i = [];
  for (; r.length > 0; ) {
    let a = r.slice(0, s);
    const o = a.lastIndexOf("%");
    o > s - 3 && (a = a.slice(0, o));
    let l = "";
    for (; a.length > 0; )
      try {
        l = decodeURIComponent(a);
        break;
      } catch (c) {
        if (c instanceof URIError && a.at(-3) === "%" && a.length > 3)
          a = a.slice(0, a.length - 3);
        else throw c;
      }
    i.push(l), (r = r.slice(a.length));
  }
  return i.map((a, o) => ({ name: `${n}.${o}`, value: a }));
}
async function oie(n, e) {
  const t = await e(n);
  if (t) return t;
  let s = [];
  for (let r = 0; ; r++) {
    const i = `${n}.${r}`,
      a = await e(i);
    if (!a) break;
    s.push(a);
  }
  return s.length > 0 ? s.join("") : null;
}
const gx =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(
      ""
    ),
  dF = ` 	
\r=`.split(""),
  lie = (() => {
    const n = new Array(128);
    for (let e = 0; e < n.length; e += 1) n[e] = -1;
    for (let e = 0; e < dF.length; e += 1) n[dF[e].charCodeAt(0)] = -2;
    for (let e = 0; e < gx.length; e += 1) n[gx[e].charCodeAt(0)] = e;
    return n;
  })();
function cie(n) {
  const e = [];
  let t = 0,
    s = 0;
  if (
    (hie(n, (i) => {
      for (t = (t << 8) | i, s += 8; s >= 6; ) {
        const a = (t >> (s - 6)) & 63;
        e.push(gx[a]), (s -= 6);
      }
    }),
    s > 0)
  )
    for (t = t << (6 - s), s = 6; s >= 6; ) {
      const i = (t >> (s - 6)) & 63;
      e.push(gx[i]), (s -= 6);
    }
  return e.join("");
}
function uie(n) {
  const e = [],
    t = (a) => {
      e.push(String.fromCodePoint(a));
    },
    s = { utf8seq: 0, codepoint: 0 };
  let r = 0,
    i = 0;
  for (let a = 0; a < n.length; a += 1) {
    const o = n.charCodeAt(a),
      l = lie[o];
    if (l > -1)
      for (r = (r << 6) | l, i += 6; i >= 8; )
        fie((r >> (i - 8)) & 255, s, t), (i -= 8);
    else {
      if (l === -2) continue;
      throw new Error(
        `Invalid Base64-URL character "${n.at(a)}" at position ${a}`
      );
    }
  }
  return e.join("");
}
function die(n, e) {
  if (n <= 127) {
    e(n);
    return;
  } else if (n <= 2047) {
    e(192 | (n >> 6)), e(128 | (n & 63));
    return;
  } else if (n <= 65535) {
    e(224 | (n >> 12)), e(128 | ((n >> 6) & 63)), e(128 | (n & 63));
    return;
  } else if (n <= 1114111) {
    e(240 | (n >> 18)),
      e(128 | ((n >> 12) & 63)),
      e(128 | ((n >> 6) & 63)),
      e(128 | (n & 63));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`);
}
function hie(n, e) {
  for (let t = 0; t < n.length; t += 1) {
    let s = n.charCodeAt(t);
    if (s > 55295 && s <= 56319) {
      const r = ((s - 55296) * 1024) & 65535;
      (s = (((n.charCodeAt(t + 1) - 56320) & 65535) | r) + 65536), (t += 1);
    }
    die(s, e);
  }
}
function fie(n, e, t) {
  if (e.utf8seq === 0) {
    if (n <= 127) {
      t(n);
      return;
    }
    for (let s = 1; s < 6; s += 1)
      if (((n >> (7 - s)) & 1) === 0) {
        e.utf8seq = s;
        break;
      }
    if (e.utf8seq === 2) e.codepoint = n & 31;
    else if (e.utf8seq === 3) e.codepoint = n & 15;
    else if (e.utf8seq === 4) e.codepoint = n & 7;
    else throw new Error("Invalid UTF-8 sequence");
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (n <= 127) throw new Error("Invalid UTF-8 sequence");
    (e.codepoint = (e.codepoint << 6) | (n & 63)),
      (e.utf8seq -= 1),
      e.utf8seq === 0 && t(e.codepoint);
  }
}
const K_ = "base64-";
function mie(n, e) {
  const t = n.cookies ?? null,
    s = n.cookieEncoding,
    r = {},
    i = {};
  let a, o;
  if (t)
    if ("get" in t) {
      const l = async (c) => {
        const h = c.flatMap((p) => [
            p,
            ...Array.from({ length: 5 }).map((g, y) => `${p}.${y}`),
          ]),
          m = [];
        for (let p = 0; p < h.length; p += 1) {
          const g = await t.get(h[p]);
          (!g && typeof g != "string") || m.push({ name: h[p], value: g });
        }
        return m;
      };
      if (((a = async (c) => await l(c)), "set" in t && "remove" in t))
        o = async (c) => {
          for (let h = 0; h < c.length; h += 1) {
            const { name: m, value: p, options: g } = c[h];
            p ? await t.set(m, p, g) : await t.remove(m, g);
          }
        };
      else
        throw new Error(
          "@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)"
        );
    } else if ("getAll" in t)
      if (((a = async () => await t.getAll()), "setAll" in t)) o = t.setAll;
      else
        throw new Error(
          "@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)"
        );
    else
      throw new Error(
        `@supabase/ssr: createBrowserClient requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${
          zp()
            ? " As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically."
            : ""
        }`
      );
  else if (zp()) {
    const l = () => {
      const c = yj.parse(document.cookie);
      return Object.keys(c).map((h) => ({ name: h, value: c[h] ?? "" }));
    };
    (a = () => l()),
      (o = (c) => {
        c.forEach(({ name: h, value: m, options: p }) => {
          document.cookie = yj.serialize(h, m, p);
        });
      });
  } else
    (a = () => []),
      (o = () => {
        throw new Error(
          "@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed"
        );
      });
  return {
    getAll: a,
    setAll: o,
    setItems: r,
    removedItems: i,
    storage: {
      isServer: !1,
      getItem: async (l) => {
        const c = await a([l]),
          h = await oie(l, async (p) => {
            const g = c?.find(({ name: y }) => y === p) || null;
            return g ? g.value : null;
          });
        if (!h) return null;
        let m = h;
        return h.startsWith(K_) && (m = uie(h.substring(K_.length))), m;
      },
      setItem: async (l, c) => {
        const m = (await a([l]))?.map(({ name: A }) => A) || [],
          p = new Set(m.filter((A) => uF(A, l)));
        let g = c;
        s === "base64url" && (g = K_ + cie(c));
        const y = aie(l, g);
        y.forEach(({ name: A }) => {
          p.delete(A);
        });
        const b = { ...hy, ...n?.cookieOptions, maxAge: 0 },
          w = { ...hy, ...n?.cookieOptions, maxAge: hy.maxAge };
        delete b.name, delete w.name;
        const S = [
          ...[...p].map((A) => ({ name: A, value: "", options: b })),
          ...y.map(({ name: A, value: _ }) => ({
            name: A,
            value: _,
            options: w,
          })),
        ];
        S.length > 0 && (await o(S));
      },
      removeItem: async (l) => {
        const m = ((await a([l]))?.map(({ name: g }) => g) || []).filter((g) =>
            uF(g, l)
          ),
          p = { ...hy, ...n?.cookieOptions, maxAge: 0 };
        delete p.name,
          m.length > 0 &&
            (await o(m.map((g) => ({ name: g, value: "", options: p }))));
      },
    },
  };
}
let Y_;
function pie(n, e, t) {
  const s = t?.isSingleton === !0 || ((!t || !("isSingleton" in t)) && zp());
  if (s && Y_) return Y_;
  const { storage: r } = mie({
      ...t,
      cookieEncoding: t?.cookieEncoding ?? "base64url",
    }),
    i = tie(n, e, {
      ...t,
      global: {
        ...t?.global,
        headers: {
          ...t?.global?.headers,
          "X-Client-Info": `supabase-ssr/${sie} createBrowserClient`,
        },
      },
      auth: {
        ...t?.auth,
        ...(t?.cookieOptions?.name
          ? { storageKey: t.cookieOptions.name }
          : null),
        flowType: "pkce",
        autoRefreshToken: zp(),
        detectSessionInUrl: zp(),
        persistSession: !0,
        storage: r,
      },
    });
  return s && (Y_ = i), i;
}
function gie() {
  const e = ".flask.do";
  return pie(
    "https://wfolvflsphwdqhbnlysw.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indmb2x2ZmxzcGh3ZHFoYm5seXN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ2MjQxOTgsImV4cCI6MjA2MDIwMDE5OH0.BpFNSXauqJBFJfyPR-Uv0-J6TDLrJWwvAwEsdvRjUSA",
    {
      cookies: {
        get(t) {
          const r = document.cookie
            .split(";")
            .find((i) => i.trim().startsWith(`${t}=`));
          if (r) return decodeURIComponent(r.split("=")[1]);
        },
        set(t, s, r) {
          let i = `${t}=${encodeURIComponent(s)}`;
          r?.maxAge && (i += `; Max-Age=${r.maxAge}`),
            r?.expires && (i += `; Expires=${r.expires.toUTCString()}`),
            r?.path && (i += `; Path=${r.path}`),
            r?.domain ? (i += `; Domain=${r.domain}`) : (i += `; Domain=${e}`),
            r?.secure,
            (i += "; Secure"),
            r?.sameSite
              ? (i += `; SameSite=${r.sameSite}`)
              : (i += "; SameSite=Lax"),
            (document.cookie = i);
        },
        remove(t, s) {
          let r = `${t}=; Max-Age=0`;
          s?.path && (r += `; Path=${s.path}`),
            s?.domain ? (r += `; Domain=${s.domain}`) : (r += `; Domain=${e}`),
            (document.cookie = r);
        },
      },
      cookieOptions: {
        domain: e,
        path: "/",
        sameSite: "lax",
        secure: !0,
        maxAge: 3600 * 24 * 180,
      },
      auth: {
        autoRefreshToken: !0,
        persistSession: !0,
        detectSessionInUrl: !1,
        flowType: "pkce",
      },
    }
  );
}
let X_ = null;
function l8() {
  return X_ || (X_ = gie()), X_;
}
const ka = () => l8(),
  Ds = l8(),
  vie = "https://api.flask.do",
  c8 = (n) => {
    const e = n.startsWith("/") ? n : `/${n}`;
    return `${vie}${e}`;
  },
  Ut = (n, e = {}) => {
    const t = c8(n),
      s = { ...e.headers };
    return (
      !(e.body instanceof FormData) &&
        !e.headers?.["Content-Type"] &&
        (s["Content-Type"] = "application/json"),
      fetch(t, { ...e, credentials: "include", headers: s })
    );
  },
  yie = (n, e = {}) => {
    const t = c8(n),
      s = { ...e.headers };
    return (
      !(e.body instanceof FormData) &&
        !e.headers?.["Content-Type"] &&
        (s["Content-Type"] = "application/json"),
      fetch(t, { ...e, credentials: "omit", headers: s })
    );
  },
  bie = async (n, e, t, s, r, i, a) => {
    try {
      const o = await Ut("/api/flasks", {
        method: "POST",
        body: JSON.stringify({
          user_id: n,
          youtube_url: e || null,
          name: t || null,
          thumbnail: s || null,
          asset_id: r || null,
          asset_ids: a || null,
          mux_asset_info: i || null,
        }),
      });
      if (!o.ok) {
        const c = await o.json();
        if (c.code === "FLASK_LIMIT_REACHED") {
          const h = new Error(c.error);
          throw ((h.code = c.code), h);
        }
        throw (
          (console.error("Failed to create flask:", c),
          new Error(c.error || "Failed to create flask"))
        );
      }
      return await o.json();
    } catch (o) {
      throw (console.error("Error creating flask:", o), o);
    }
  },
  xie = async (n) => {
    try {
      return (await Ut(`/api/flasks/${n}`, { method: "DELETE" })).ok
        ? !0
        : (console.error("Failed to delete flask"), !1);
    } catch (e) {
      return console.error("Error deleting flask:", e), !1;
    }
  },
  WI = async (n, e) => {
    try {
      const t = await Ut(`/api/flasks/${n}`, {
        method: "PUT",
        body: JSON.stringify(e),
      });
      return t.ok
        ? await t.json()
        : (console.error("Failed to update flask"), null);
    } catch (t) {
      return console.error("Error updating flask:", t), null;
    }
  },
  wie = async (n, e) => {
    const t = await Ut("/api/flask-tags", {
      method: "POST",
      body: JSON.stringify({ name: n, team_id: e }),
    });
    if (!t.ok) throw new Error("Failed to create tag");
    return t.json();
  },
  Eie = async (n) => {
    if (!(await Ut(`/api/flask-tags/${n}`, { method: "DELETE" })).ok)
      throw new Error("Failed to delete tag");
  },
  Sie = async (n, e) => {
    const t = await Ut(`/api/flask-tags/${n}`, {
      method: "PATCH",
      body: JSON.stringify({ name: e }),
    });
    if (!t.ok) throw new Error("Failed to edit tag");
    return t.json();
  },
  hF = async (n, e) => {
    const t = await Ut(`/api/flasks/${n}/tag`, {
      method: "POST",
      body: JSON.stringify({ tagId: e }),
    });
    if (!t.ok) throw new Error("Failed to update flask tag");
    return t.json();
  },
  Tie = async (n) => {
    const e = n ? `/api/flask-tags?teamId=${n}` : "/api/flask-tags",
      t = await Ut(e, { method: "GET" });
    if (!t.ok) throw new Error("Failed to fetch tags");
    return t.json();
  };
var _ie = (n, e, t, s, r, i, a, o) => {
  let l = document.documentElement,
    c = ["light", "dark"];
  function h(g) {
    (Array.isArray(n) ? n : [n]).forEach((y) => {
      let b = y === "class",
        w = b && i ? r.map((S) => i[S] || S) : r;
      b
        ? (l.classList.remove(...w), l.classList.add(i && i[g] ? i[g] : g))
        : l.setAttribute(y, g);
    }),
      m(g);
  }
  function m(g) {
    o && c.includes(g) && (l.style.colorScheme = g);
  }
  function p() {
    return window.matchMedia("(prefers-color-scheme: dark)").matches
      ? "dark"
      : "light";
  }
  if (s) h(s);
  else
    try {
      let g = localStorage.getItem(e) || t,
        y = a && g === "system" ? p() : g;
      h(y);
    } catch {}
};
E.createContext(void 0);
E.memo(
  ({
    forcedTheme: n,
    storageKey: e,
    attribute: t,
    enableSystem: s,
    enableColorScheme: r,
    defaultTheme: i,
    value: a,
    themes: o,
    nonce: l,
    scriptProps: c,
  }) => {
    let h = JSON.stringify([t, e, i, n, o, a, s, r]).slice(1, -1);
    return E.createElement("script", {
      ...c,
      suppressHydrationWarning: !0,
      nonce: typeof window > "u" ? l : "",
      dangerouslySetInnerHTML: { __html: `(${_ie.toString()})(${h})` },
    });
  }
);
const Q_ = Object.freeze(
    Object.defineProperty({ __proto__: null, toast: Xe }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  u8 = async (n) => {
    if (!n.length) return {};
    try {
      const e = await Ut("/api/users/profiles", {
        method: "POST",
        body: JSON.stringify({ userIds: n }),
      });
      return e.ok
        ? await e.json()
        : (console.error(
            "Failed to fetch user profiles:",
            e.status,
            e.statusText
          ),
          {});
    } catch (e) {
      return console.error("Error fetching user profiles:", e), {};
    }
  },
  fF = [
    "accent-purple",
    "accent-blue",
    "accent-teal",
    "accent-green",
    "accent-lime",
    "accent-orange",
    "accent-red",
  ],
  mF = {
    currentTeam: null,
    userTeams: [],
    isLoadingTeams: !1,
    teamsError: null,
    flasks: [],
    isLoadingFlasks: !1,
    flasksError: null,
    selectedFlaskIds: [],
    flaskFilter: { tagId: null, userId: null, searchTerm: "" },
    tags: [],
    isLoadingTags: !1,
    tagsError: null,
    userProfiles: {},
    isInitialized: !1,
    pendingOperations: new Set(),
    skeleton: { showFlaskGrid: !1, showSidebar: !1, isTransitioning: !1 },
    flasksSubscription: null,
    tagsSubscription: null,
    teamsSubscription: null,
  },
  Pt = Di()(
    $a(
      ha((n, e) => ({
        ...mF,
        getFilteredFlasks: () => {
          const t = e();
          let s = t.flasks;
          if (
            (t.flaskFilter.tagId &&
              (s = s.filter((r) => r.flask_tag?.id === t.flaskFilter.tagId)),
            t.flaskFilter.userId &&
              (s = s.filter((r) => r.user_id === t.flaskFilter.userId)),
            t.flaskFilter.searchTerm)
          ) {
            const r = t.flaskFilter.searchTerm.toLowerCase();
            s = s.filter((i) => i.name.toLowerCase().includes(r));
          }
          return [...s].sort((r, i) => {
            const a = new Date(r.updated_at || r.created_at || 0).getTime();
            return new Date(i.updated_at || i.created_at || 0).getTime() - a;
          });
        },
        getNextTagColor: () => {
          const t = e().tags.length;
          return fF[t % fF.length];
        },
        isProTeam: () => e().currentTeam?.team_type === "pro_team",
        isFreeTeam: () => e().currentTeam?.team_type === "free_team",
        hasActiveSubscription: () => {
          const t = e().currentTeam;
          return (
            t?.team_type === "pro_team" && t?.subscription_status === "active"
          );
        },
        isTeamAdmin: (t) => {
          const s = e().currentTeam;
          return s
            ? s.members.find((i) => i.user_id === t)?.role === "admin"
            : !1;
        },
        shouldShowSkeleton: () => {
          const t = e();
          return (
            t.skeleton.showFlaskGrid ||
            t.skeleton.showSidebar ||
            t.skeleton.isTransitioning
          );
        },
        initialize: async (t) => {
          if (!(!t || e().isInitialized))
            try {
              e().showAllSkeletons(),
                await Promise.all([
                  e().fetchUserTeams(t),
                  e().fetchCurrentTeam(t),
                ]);
              const s = e().currentTeam;
              s &&
                (await Promise.all([
                  e().fetchFlasks(s.id),
                  e().fetchTags(s.id),
                ])),
                e().subscribeToChanges(),
                n((r) => {
                  r.isInitialized = !0;
                }),
                e().hideAllSkeletons();
            } catch (s) {
              console.error("Failed to initialize dashboard:", s),
                e().hideAllSkeletons();
            }
        },
        reset: () => {
          e().unsubscribeAll(),
            n(() => ({ ...mF, pendingOperations: new Set() }));
        },
        fetchUserTeams: async (t) => {
          if (t) {
            n((s) => {
              (s.isLoadingTeams = !0), (s.teamsError = null);
            });
            try {
              const s = ka();
              let r = 0;
              const i = 3;
              let a = null,
                o = null;
              for (; r < i; ) {
                const c = await s
                  .from("user_teams")
                  .select("*, teams(*)")
                  .eq("user_id", t)
                  .order("joined_at", { ascending: !1 });
                if (((a = c.data), (o = c.error), o)) throw o;
                if (a && a.length > 0) break;
                r++,
                  r < i &&
                    (`${r}${i}`, await new Promise((h) => setTimeout(h, 1e3)));
              }
              const l = a?.map((c) => c.teams).filter(Boolean);
              n((c) => {
                (c.userTeams = l || []), (c.isLoadingTeams = !1);
              });
            } catch (s) {
              console.error("Error fetching user teams:", s),
                n((r) => {
                  (r.teamsError =
                    s instanceof Error ? s.message : "Failed to fetch teams"),
                    (r.isLoadingTeams = !1);
                });
            }
          }
        },
        fetchCurrentTeam: async (t) => {
          if (t) {
            n((s) => {
              (s.isLoadingTeams = !0), (s.teamsError = null);
            });
            try {
              const s = ka();
              let r = 0;
              const i = 3;
              let a = null,
                o = null;
              for (; r < i; ) {
                const m = await s
                  .from("user_teams")
                  .select("*, teams(*)")
                  .eq("user_id", t)
                  .eq("active", !0)
                  .single();
                if (((a = m.data), (o = m.error), a?.teams)) break;
                if (o) {
                  const { data: p } = await s
                    .from("user_teams")
                    .select("*, teams(*)")
                    .eq("user_id", t)
                    .order("joined_at", { ascending: !1 })
                    .limit(1)
                    .single();
                  if (p?.teams) {
                    await s
                      .from("user_teams")
                      .update({ active: !0 })
                      .eq("user_id", t)
                      .eq("team_id", p.teams.id),
                      (a = p),
                      (o = null);
                    break;
                  }
                }
                r++,
                  r < i &&
                    (`${r}${i}`, await new Promise((p) => setTimeout(p, 1e3)));
              }
              if (!a?.teams) {
                n((m) => {
                  (m.currentTeam = null), (m.isLoadingTeams = !1);
                });
                return;
              }
              const l = a.teams,
                c = await Ut(`/api/teams/${l.id}`);
              if (!c.ok) throw new Error("Failed to fetch team details");
              const h = await c.json();
              n((m) => {
                (m.currentTeam = h.team), (m.isLoadingTeams = !1);
              });
            } catch (s) {
              console.error("Error fetching current team:", s),
                n((r) => {
                  (r.teamsError =
                    s instanceof Error ? s.message : "Failed to fetch team"),
                    (r.isLoadingTeams = !1);
                });
            }
          }
        },
        switchTeam: async (t) => {
          const s = ka(),
            r = `switch-team-${t}`,
            i = e().currentTeam,
            a = e().userTeams.find((o) => o.id === t);
          if (a) {
            n((o) => {
              (o.skeleton.isTransitioning = !0),
                (o.skeleton.showFlaskGrid = !0),
                (o.skeleton.showSidebar = !0),
                (o.currentTeam = { ...a, members: [], member_count: 0 }),
                o.pendingOperations.add(r),
                (o.flasks = []),
                (o.tags = []),
                (o.flaskFilter.tagId = null);
            });
            try {
              const { data: o } = await s.auth.getUser();
              if (!o?.user) throw new Error("Not authenticated");
              await s
                .from("user_teams")
                .update({ active: !1 })
                .eq("user_id", o.user.id);
              const { error: l } = await s
                .from("user_teams")
                .update({ active: !0 })
                .eq("user_id", o.user.id)
                .eq("team_id", t);
              if (l) throw l;
              const c = await Ut(`/api/teams/${t}`);
              if (!c.ok) throw new Error("Failed to fetch team details");
              const h = await c.json();
              await Promise.all([e().fetchFlasks(t), e().fetchTags(t)]),
                n((m) => {
                  (m.currentTeam = h.team),
                    m.pendingOperations.delete(r),
                    (m.skeleton.isTransitioning = !1),
                    (m.skeleton.showFlaskGrid = !1),
                    (m.skeleton.showSidebar = !1);
                }),
                Xe.success("Team switched successfully");
            } catch (o) {
              console.error("Error switching team:", o),
                n((l) => {
                  (l.currentTeam = i),
                    l.pendingOperations.delete(r),
                    (l.skeleton.isTransitioning = !1),
                    (l.skeleton.showFlaskGrid = !1),
                    (l.skeleton.showSidebar = !1);
                }),
                Xe.error("Failed to switch team");
            }
          }
        },
        updateTeamName: async (t, s) => {
          const r = `update-team-${t}`,
            i = e().currentTeam;
          n((a) => {
            a.currentTeam && a.currentTeam.id === t && (a.currentTeam.name = s);
            const o = a.userTeams.findIndex((l) => l.id === t);
            o !== -1 && (a.userTeams[o].name = s), a.pendingOperations.add(r);
          });
          try {
            if (
              !(
                await Ut(`/api/teams/${t}`, {
                  method: "PATCH",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ name: s }),
                })
              ).ok
            )
              throw new Error("Failed to update team name");
            n((o) => {
              o.pendingOperations.delete(r);
            }),
              Xe.success("Team name updated");
          } catch (a) {
            console.error("Error updating team name:", a),
              n((o) => {
                i && o.currentTeam?.id === t && (o.currentTeam.name = i.name),
                  o.pendingOperations.delete(r);
              }),
              Xe.error("Failed to update team name");
          }
        },
        updateInviteEnabled: async (t, s) => {
          const r = `update-invite-${t}`,
            i = e().currentTeam?.invite_enabled;
          n((a) => {
            a.currentTeam &&
              a.currentTeam.id === t &&
              (a.currentTeam.invite_enabled = s),
              a.pendingOperations.add(r);
          });
          try {
            if (
              !(
                await Ut(`/api/teams/${t}`, {
                  method: "PATCH",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ invite_enabled: s }),
                })
              ).ok
            )
              throw new Error("Failed to update invite settings");
            n((o) => {
              o.pendingOperations.delete(r);
            }),
              Xe.success(s ? "Invites enabled" : "Invites disabled");
          } catch (a) {
            console.error("Error updating invite settings:", a),
              n((o) => {
                o.currentTeam &&
                  o.currentTeam.id === t &&
                  (o.currentTeam.invite_enabled = i || !1),
                  o.pendingOperations.delete(r);
              }),
              Xe.error("Failed to update invite settings");
          }
        },
        removeMember: async (t, s) => {
          const r = `remove-member-${s}`;
          try {
            n((a) => {
              a.pendingOperations.add(r);
            });
            const i = await Ut(`/api/teams/${t}/members/${s}`, {
              method: "DELETE",
            });
            if (!i.ok) {
              const a = await i.json();
              throw new Error(a.error || "Failed to remove member");
            }
            await e().refreshCurrentTeam(),
              n((a) => {
                a.pendingOperations.delete(r);
              }),
              Xe.success("Member removed");
          } catch (i) {
            console.error("Error removing member:", i),
              n((a) => {
                a.pendingOperations.delete(r);
              }),
              Xe.error(
                i instanceof Error ? i.message : "Failed to remove member"
              );
          }
        },
        refreshCurrentTeam: async () => {
          const t = e().currentTeam;
          if (t)
            try {
              const s = await Ut(`/api/teams/${t.id}`);
              if (!s.ok) throw new Error("Failed to refresh team");
              const r = await s.json();
              n((i) => {
                i.currentTeam = r.team;
              });
            } catch (s) {
              console.error("Error refreshing team:", s);
            }
        },
        setFlasks: (t) => {
          n((s) => {
            s.flasks = t;
          });
        },
        fetchFlasks: async (t) => {
          const s = t || e().currentTeam?.id;
          if (s) {
            n((r) => {
              (r.isLoadingFlasks = !0),
                (r.flasksError = null),
                r.isInitialized || (r.skeleton.showFlaskGrid = !0);
            });
            try {
              const r = await Ut(`/api/flasks?teamId=${s}`);
              if (!r.ok) throw new Error("Failed to fetch flasks");
              const i = await r.json(),
                a = Array.from(
                  new Set(i.map((l) => l.user_id).filter(Boolean))
                );
              let o = {};
              if (a.length > 0)
                try {
                  o = await u8(a);
                } catch (l) {
                  console.error("Error fetching user profiles:", l);
                }
              n((l) => {
                (l.flasks = i || []),
                  (l.userProfiles = { ...l.userProfiles, ...o }),
                  (l.isLoadingFlasks = !1),
                  (l.skeleton.showFlaskGrid = !1);
              });
            } catch (r) {
              console.error("Error fetching flasks:", r),
                n((i) => {
                  (i.flasksError =
                    r instanceof Error ? r.message : "Failed to fetch flasks"),
                    (i.isLoadingFlasks = !1),
                    (i.skeleton.showFlaskGrid = !1);
                });
            }
          }
        },
        createNewFlask: async (t) => {
          try {
            const s = await bie(
              t.userId,
              t.youtubeUrl,
              t.name,
              t.thumbnail,
              t.assetId,
              t.muxAssetInfo,
              t.assetIds
            );
            return (
              s &&
                (n((r) => {
                  r.flasks.unshift(s);
                }),
                Xe.success("Flask created successfully")),
              s
            );
          } catch (s) {
            return (
              console.error("Error creating flask:", s),
              Xe.error("Failed to create flask"),
              null
            );
          }
        },
        updateFlaskOptimistic: async (t, s) => {
          const r = `update-flask-${t}`,
            i = e().flasks.find((a) => a.id === t);
          if (i) {
            n((a) => {
              const o = a.flasks.findIndex((l) => l.id === t);
              o !== -1 && Object.assign(a.flasks[o], s),
                a.pendingOperations.add(r);
            });
            try {
              const a = await WI(t, s);
              a &&
                n((o) => {
                  const l = o.flasks.findIndex((c) => c.id === t);
                  l !== -1 && (o.flasks[l] = { ...a, flask_tag: i.flask_tag }),
                    o.pendingOperations.delete(r);
                });
            } catch (a) {
              console.error("Error updating flask:", a),
                n((o) => {
                  const l = o.flasks.findIndex((c) => c.id === t);
                  l !== -1 && (o.flasks[l] = i), o.pendingOperations.delete(r);
                }),
                Xe.error("Failed to update flask");
            }
          }
        },
        deleteFlaskOptimistic: async (t) => {
          const s = `delete-flask-${t}`,
            r = e().flasks;
          if (r.find((a) => a.id === t)) {
            n((a) => {
              (a.flasks = a.flasks.filter((o) => o.id !== t)),
                (a.selectedFlaskIds = a.selectedFlaskIds.filter(
                  (o) => o !== t
                )),
                a.pendingOperations.add(s);
            });
            try {
              if (!(await xie(t))) throw new Error("Failed to delete flask");
              n((o) => {
                o.pendingOperations.delete(s);
              }),
                Xe.success("Flask deleted successfully");
            } catch (a) {
              console.error("Error deleting flask:", a),
                n((o) => {
                  (o.flasks = r), o.pendingOperations.delete(s);
                }),
                Xe.error("Failed to delete flask");
            }
          }
        },
        selectFlask: (t, s = !1) => {
          n((r) => {
            if (s) {
              const i = r.selectedFlaskIds.indexOf(t);
              i === -1
                ? r.selectedFlaskIds.push(t)
                : r.selectedFlaskIds.splice(i, 1);
            } else r.selectedFlaskIds = [t];
          });
        },
        clearFlaskSelection: () => {
          n((t) => {
            t.selectedFlaskIds = [];
          });
        },
        setFlaskTagFilter: (t) => {
          n((s) => {
            s.flaskFilter.tagId = t;
          });
        },
        setFlaskUserFilter: (t) => {
          n((s) => {
            s.flaskFilter.userId = t;
          });
        },
        setFlaskSearchFilter: (t) => {
          n((s) => {
            s.flaskFilter.searchTerm = t;
          });
        },
        updateFlaskTagOptimistic: async (t, s) => {
          const r = `update-flask-tag-${t}`,
            i = e().flasks.find((o) => o.id === t);
          if (!i) return;
          const a = s ? e().tags.find((o) => o.id === s) : null;
          n((o) => {
            const l = o.flasks.findIndex((c) => c.id === t);
            l !== -1 && (o.flasks[l].flask_tag = a || null),
              o.pendingOperations.add(r);
          });
          try {
            await hF(t, s),
              n((o) => {
                o.pendingOperations.delete(r);
              });
          } catch (o) {
            console.error("Error updating flask tag:", o),
              n((l) => {
                const c = l.flasks.findIndex((h) => h.id === t);
                c !== -1 && (l.flasks[c] = i), l.pendingOperations.delete(r);
              }),
              Xe.error("Failed to update tag");
          }
        },
        fetchTags: async (t) => {
          const s = t || e().currentTeam?.id;
          if (s) {
            n((r) => {
              (r.isLoadingTags = !0),
                (r.tagsError = null),
                r.isInitialized || (r.skeleton.showSidebar = !0);
            });
            try {
              const r = await Tie(s);
              n((i) => {
                (i.tags = r || []),
                  (i.isLoadingTags = !1),
                  (i.skeleton.showSidebar = !1);
              });
            } catch (r) {
              console.error("Error fetching tags:", r),
                n((i) => {
                  (i.tagsError =
                    r instanceof Error ? r.message : "Failed to fetch tags"),
                    (i.isLoadingTags = !1),
                    (i.skeleton.showSidebar = !1);
                });
            }
          }
        },
        createTagOptimistic: async (t, s) => {
          const r = `create-tag-${Date.now()}`,
            i = e().currentTeam?.id;
          if (!i) return null;
          const a = {
            id: `temp-${Date.now()}`,
            name: t,
            color: e().getNextTagColor(),
            user_id: "",
            team_id: i,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };
          n((o) => {
            if ((o.tags.push(a), s)) {
              const l = o.flasks.findIndex((c) => c.id === s);
              l !== -1 && (o.flasks[l].flask_tag = a);
            }
            o.pendingOperations.add(r);
          });
          try {
            const o = await wie(t, i);
            if (!o) throw new Error("Failed to create tag");
            return (
              n((l) => {
                const c = l.tags.findIndex((h) => h.id === a.id);
                if ((c !== -1 && (l.tags[c] = o), s)) {
                  const h = l.flasks.findIndex((m) => m.id === s);
                  h !== -1 &&
                    ((l.flasks[h].flask_tag = o),
                    hF(s, o.id).catch(console.error));
                }
                l.pendingOperations.delete(r);
              }),
              o
            );
          } catch (o) {
            return (
              console.error("Error creating tag:", o),
              n((l) => {
                if (((l.tags = l.tags.filter((c) => c.id !== a.id)), s)) {
                  const c = l.flasks.findIndex((h) => h.id === s);
                  c !== -1 && (l.flasks[c].flask_tag = null);
                }
                l.pendingOperations.delete(r);
              }),
              Xe.error("Failed to create tag"),
              null
            );
          }
        },
        deleteTagOptimistic: async (t) => {
          const s = `delete-tag-${t}`,
            r = e().tags,
            i = e().flasks;
          n((a) => {
            (a.tags = a.tags.filter((o) => o.id !== t)),
              a.flasks.forEach((o) => {
                o.flask_tag?.id === t && (o.flask_tag = null);
              }),
              a.flaskFilter.tagId === t && (a.flaskFilter.tagId = null),
              a.pendingOperations.add(s);
          });
          try {
            await Eie(t),
              n((a) => {
                a.pendingOperations.delete(s);
              }),
              Xe.success("Tag deleted successfully");
          } catch (a) {
            console.error("Error deleting tag:", a),
              n((o) => {
                (o.tags = r), (o.flasks = i), o.pendingOperations.delete(s);
              }),
              Xe.error("Failed to delete tag");
          }
        },
        editTagOptimistic: async (t, s) => {
          const r = `edit-tag-${t}`,
            i = e().tags.find((a) => a.id === t);
          if (i) {
            n((a) => {
              const o = a.tags.findIndex((l) => l.id === t);
              o !== -1 && (a.tags[o].name = s),
                a.flasks.forEach((l) => {
                  l.flask_tag?.id === t && (l.flask_tag.name = s);
                }),
                a.pendingOperations.add(r);
            });
            try {
              const a = await Sie(t, s);
              a &&
                n((o) => {
                  const l = o.tags.findIndex((c) => c.id === t);
                  l !== -1 && (o.tags[l] = a),
                    o.flasks.forEach((c) => {
                      c.flask_tag?.id === t && (c.flask_tag = a);
                    }),
                    o.pendingOperations.delete(r);
                });
            } catch (a) {
              console.error("Error editing tag:", a),
                n((o) => {
                  const l = o.tags.findIndex((c) => c.id === t);
                  l !== -1 && (o.tags[l] = i),
                    o.flasks.forEach((c) => {
                      c.flask_tag?.id === t && (c.flask_tag = i);
                    }),
                    o.pendingOperations.delete(r);
                }),
                Xe.error("Failed to edit tag");
            }
          }
        },
        subscribeToChanges: () => {
          const t = ka(),
            s = t
              .channel("dashboard-flasks")
              .on(
                "postgres_changes",
                { event: "*", schema: "public", table: "flasks" },
                (a) => {
                  const o = e().currentTeam;
                  o && e().fetchFlasks(o.id);
                }
              )
              .subscribe(),
            r = t
              .channel("dashboard-tags")
              .on(
                "postgres_changes",
                { event: "*", schema: "public", table: "flask_tags" },
                (a) => {
                  const o = e().currentTeam;
                  o && e().fetchTags(o.id);
                }
              )
              .subscribe(),
            i = t
              .channel("dashboard-teams")
              .on(
                "postgres_changes",
                { event: "*", schema: "public", table: "teams" },
                (a) => {
                  const o = e().currentTeam;
                  o && a.new && a.new.id === o.id && e().refreshCurrentTeam();
                }
              )
              .subscribe();
          n((a) => {
            (a.flasksSubscription = s),
              (a.tagsSubscription = r),
              (a.teamsSubscription = i);
          });
        },
        unsubscribeAll: () => {
          const t = ka(),
            s = e();
          s.flasksSubscription && t.removeChannel(s.flasksSubscription),
            s.tagsSubscription && t.removeChannel(s.tagsSubscription),
            s.teamsSubscription && t.removeChannel(s.teamsSubscription),
            n((r) => {
              (r.flasksSubscription = null),
                (r.tagsSubscription = null),
                (r.teamsSubscription = null);
            });
        },
        markOperationPending: (t) => {
          n((s) => {
            s.pendingOperations.add(t);
          });
        },
        markOperationComplete: (t) => {
          n((s) => {
            s.pendingOperations.delete(t);
          });
        },
        isOperationPending: (t) => e().pendingOperations.has(t),
        updateSkeletonState: (t) => {
          const s = e().skeleton;
          Object.keys(t).some((i) => s[i] !== t[i]) &&
            n((i) => {
              Object.assign(i.skeleton, t);
            });
        },
        showAllSkeletons: () => {
          const t = e().skeleton;
          (!t.showFlaskGrid || !t.showSidebar) &&
            n((s) => {
              (s.skeleton.showFlaskGrid = !0),
                (s.skeleton.showSidebar = !0),
                (s.skeleton.isTransitioning = !1);
            });
        },
        hideAllSkeletons: () => {
          const t = e().skeleton;
          (t.showFlaskGrid || t.showSidebar || t.isTransitioning) &&
            n((r) => {
              (r.skeleton.showFlaskGrid = !1),
                (r.skeleton.showSidebar = !1),
                (r.skeleton.isTransitioning = !1);
            });
        },
      }))
    )
  ),
  Sv = (n) => {
    const e = Pt((s) => s.initialize),
      t = Pt((s) => s.reset);
    Pt((s) => s.isInitialized),
      de.useEffect(() => {
        n ? e(n) : t();
      }, [n, e, t]);
  },
  pF = 15,
  gF = 0.1,
  Aie = 45,
  Rie = 20,
  kie = 70,
  Z_ = [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2],
  d8 = [
    { minDuration: 0, maxDuration: 600, width: 3e3 },
    { minDuration: 600, maxDuration: 900, width: 5500 },
    { minDuration: 900, maxDuration: 1200, width: 7e3 },
    { minDuration: 1200, maxDuration: 1800, width: 9e3 },
    { minDuration: 1800, maxDuration: 1 / 0, width: 11e3 },
  ],
  vF = d8[0].width,
  h8 = 8,
  Ln = 280,
  yF = 64,
  Cie = 32,
  Iie = 48,
  f8 = 0.25,
  J_ = 100,
  m8 = [
    { label: "Pricing", href: "/#pricing", isExternal: !1 },
    { label: "FAQ", href: "/#faq", isExternal: !1 },
    { label: "Talk to Humans", href: "/#talk-to-us", isExternal: !1 },
  ];
var Re = typeof window < "u" ? window : void 0,
  ii = typeof globalThis < "u" ? globalThis : Re,
  p8 = Array.prototype,
  bF = p8.forEach,
  xF = p8.indexOf,
  _i = ii?.navigator,
  rt = ii?.document,
  ti = ii?.location,
  ER = ii?.fetch,
  SR =
    ii != null &&
    ii.XMLHttpRequest &&
    "withCredentials" in new ii.XMLHttpRequest()
      ? ii.XMLHttpRequest
      : void 0,
  wF = ii?.AbortController,
  Zr = _i?.userAgent,
  Mt = Re ?? {},
  yl = { DEBUG: !1, LIB_VERSION: "1.258.2" },
  e1 = "$copy_autocapture",
  Lie = [
    "$snapshot",
    "$pageview",
    "$pageleave",
    "$set",
    "survey dismissed",
    "survey sent",
    "survey shown",
    "$identify",
    "$groupidentify",
    "$create_alias",
    "$$client_ingestion_warning",
    "$web_experiment_applied",
    "$feature_enrollment_update",
    "$feature_flag_called",
  ],
  xl = (function (n) {
    return (n.GZipJS = "gzip-js"), (n.Base64 = "base64"), n;
  })({}),
  Die = ["fatal", "error", "warning", "log", "info", "debug"];
function rn(n, e) {
  return n.indexOf(e) !== -1;
}
var dE = function (n) {
    return n.trim();
  },
  TR = function (n) {
    return n.replace(/^\$/, "");
  },
  Pie = Array.isArray,
  g8 = Object.prototype,
  v8 = g8.hasOwnProperty,
  hE = g8.toString,
  zn =
    Pie ||
    function (n) {
      return hE.call(n) === "[object Array]";
    },
  sa = (n) => typeof n == "function",
  fs = (n) => n === Object(n) && !zn(n),
  $h = (n) => {
    if (fs(n)) {
      for (var e in n) if (v8.call(n, e)) return !1;
      return !0;
    }
    return !1;
  },
  We = (n) => n === void 0,
  ms = (n) => hE.call(n) == "[object String]",
  _R = (n) => ms(n) && n.trim().length === 0,
  zc = (n) => n === null,
  yn = (n) => We(n) || zc(n),
  Cr = (n) => hE.call(n) == "[object Number]",
  bo = (n) => hE.call(n) === "[object Boolean]",
  Mie = (n) => n instanceof FormData,
  Nie = (n) => rn(Lie, n),
  y8 = (n) => {
    var e = {
      t: function (t) {
        if (
          Re &&
          (yl.DEBUG || Mt.POSTHOG_DEBUG) &&
          !We(Re.console) &&
          Re.console
        ) {
          for (
            var s =
                ("__rrweb_original__" in Re.console[t])
                  ? Re.console[t].__rrweb_original__
                  : Re.console[t],
              r = arguments.length,
              i = new Array(r > 1 ? r - 1 : 0),
              a = 1;
            a < r;
            a++
          )
            i[a - 1] = arguments[a];
          s(n, ...i);
        }
      },
      info: function () {
        for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
          s[r] = arguments[r];
        e.t("log", ...s);
      },
      warn: function () {
        for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
          s[r] = arguments[r];
        e.t("warn", ...s);
      },
      error: function () {
        for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
          s[r] = arguments[r];
        e.t("error", ...s);
      },
      critical: function () {
        for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
          s[r] = arguments[r];
        console.error(n, ...s);
      },
      uninitializedWarning: (t) => {
        e.error("You must initialize PostHog before calling " + t);
      },
      createLogger: (t) => y8(n + " " + t),
    };
    return e;
  },
  at = y8("[PostHog.js]"),
  cr = at.createLogger,
  Oie = cr("[ExternalScriptsLoader]"),
  EF = (n, e, t) => {
    if (n.config.disable_external_dependency_loading)
      return (
        Oie.warn(
          e + " was requested but loading of external scripts is disabled."
        ),
        t("Loading of external scripts is disabled")
      );
    var s = rt?.querySelectorAll("script");
    if (s) {
      for (var r = 0; r < s.length; r++) if (s[r].src === e) return t();
    }
    var i = () => {
      if (!rt) return t("document not found");
      var a = rt.createElement("script");
      if (
        ((a.type = "text/javascript"),
        (a.crossOrigin = "anonymous"),
        (a.src = e),
        (a.onload = (c) => t(void 0, c)),
        (a.onerror = (c) => t(c)),
        n.config.prepare_external_dependency_script &&
          (a = n.config.prepare_external_dependency_script(a)),
        !a)
      )
        return t("prepare_external_dependency_script returned null");
      var o,
        l = rt.querySelectorAll("body > script");
      l.length > 0
        ? (o = l[0].parentNode) == null || o.insertBefore(a, l[0])
        : rt.body.appendChild(a);
    };
    rt != null && rt.body ? i() : rt?.addEventListener("DOMContentLoaded", i);
  };
function nt() {
  return (
    (nt = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var s in t) ({}).hasOwnProperty.call(t, s) && (n[s] = t[s]);
          }
          return n;
        }),
    nt.apply(null, arguments)
  );
}
function b8(n, e) {
  if (n == null) return {};
  var t = {};
  for (var s in n)
    if ({}.hasOwnProperty.call(n, s)) {
      if (e.indexOf(s) !== -1) continue;
      t[s] = n[s];
    }
  return t;
}
(Mt.__PosthogExtensions__ = Mt.__PosthogExtensions__ || {}),
  (Mt.__PosthogExtensions__.loadExternalDependency = (n, e, t) => {
    var s = "/static/" + e + ".js?v=" + n.version;
    if (
      (e === "remote-config" && (s = "/array/" + n.config.token + "/config.js"),
      e === "toolbar")
    ) {
      var r = 3e5;
      s = s + "&t=" + Math.floor(Date.now() / r) * r;
    }
    var i = n.requestRouter.endpointFor("assets", s);
    EF(n, i, t);
  }),
  (Mt.__PosthogExtensions__.loadSiteApp = (n, e, t) => {
    var s = n.requestRouter.endpointFor("api", e);
    EF(n, s, t);
  });
var vx = {};
function Cc(n, e, t) {
  if (zn(n)) {
    if (bF && n.forEach === bF) n.forEach(e, t);
    else if ("length" in n && n.length === +n.length) {
      for (var s = 0, r = n.length; s < r; s++)
        if (s in n && e.call(t, n[s], s) === vx) return;
    }
  }
}
function Dn(n, e, t) {
  if (!yn(n)) {
    if (zn(n)) return Cc(n, e, t);
    if (Mie(n)) {
      for (var s of n.entries()) if (e.call(t, s[1], s[0]) === vx) return;
    } else
      for (var r in n) if (v8.call(n, r) && e.call(t, n[r], r) === vx) return;
  }
}
var As = function (n) {
    for (
      var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), s = 1;
      s < e;
      s++
    )
      t[s - 1] = arguments[s];
    return (
      Cc(t, function (r) {
        for (var i in r) r[i] !== void 0 && (n[i] = r[i]);
      }),
      n
    );
  },
  fE = function (n) {
    for (
      var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), s = 1;
      s < e;
      s++
    )
      t[s - 1] = arguments[s];
    return (
      Cc(t, function (r) {
        Cc(r, function (i) {
          n.push(i);
        });
      }),
      n
    );
  };
function mb(n) {
  for (var e = Object.keys(n), t = e.length, s = new Array(t); t--; )
    s[t] = [e[t], n[e[t]]];
  return s;
}
var SF = function (n) {
    try {
      return n();
    } catch {
      return;
    }
  },
  jie = function (n) {
    return function () {
      try {
        for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
          t[s] = arguments[s];
        return n.apply(this, t);
      } catch (r) {
        at.critical(
          "Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."
        ),
          at.critical(r);
      }
    };
  },
  KI = function (n) {
    var e = {};
    return (
      Dn(n, function (t, s) {
        ((ms(t) && t.length > 0) || Cr(t)) && (e[s] = t);
      }),
      e
    );
  };
function Fie(n, e) {
  return (
    (t = n),
    (s = (i) => (ms(i) && !zc(e) ? i.slice(0, e) : i)),
    (r = new Set()),
    (function i(a, o) {
      return a !== Object(a)
        ? s
          ? s(a, o)
          : a
        : r.has(a)
        ? void 0
        : (r.add(a),
          zn(a)
            ? ((l = []),
              Cc(a, (c) => {
                l.push(i(c));
              }))
            : ((l = {}),
              Dn(a, (c, h) => {
                r.has(c) || (l[h] = i(c, h));
              })),
          l);
      var l;
    })(t)
  );
  var t, s, r;
}
var Uie = ["herokuapp.com", "vercel.app", "netlify.app"];
function $ie(n) {
  var e = n?.hostname;
  if (!ms(e)) return !1;
  var t = e.split(".").slice(-2).join(".");
  for (var s of Uie) if (t === s) return !1;
  return !0;
}
function x8(n, e) {
  for (var t = 0; t < n.length; t++) if (e(n[t])) return n[t];
}
function is(n, e, t, s) {
  var { capture: r = !1, passive: i = !0 } = s ?? {};
  n?.addEventListener(e, t, { capture: r, passive: i });
}
var w8 = "$people_distinct_id",
  bp = "__alias",
  xp = "__timers",
  TF = "$autocapture_disabled_server_side",
  AR = "$heatmaps_enabled_server_side",
  _F = "$exception_capture_enabled_server_side",
  RR = "$error_tracking_suppression_rules",
  AF = "$error_tracking_capture_extension_exceptions",
  RF = "$web_vitals_enabled_server_side",
  E8 = "$dead_clicks_enabled_server_side",
  kF = "$web_vitals_allowed_metrics",
  kR = "$session_recording_enabled_server_side",
  CF = "$console_log_recording_enabled_server_side",
  IF = "$session_recording_network_payload_capture",
  LF = "$session_recording_masking",
  DF = "$session_recording_canvas_recording",
  PF = "$replay_sample_rate",
  MF = "$replay_minimum_duration",
  NF = "$replay_script_config",
  yx = "$sesid",
  wp = "$session_is_sampled",
  CR = "$session_recording_url_trigger_activated_session",
  IR = "$session_recording_event_trigger_activated_session",
  Bh = "$enabled_feature_flags",
  pb = "$early_access_features",
  LR = "$feature_flag_details",
  Ep = "$stored_person_properties",
  _u = "$stored_group_properties",
  DR = "$surveys",
  fy = "$surveys_activated",
  bx = "$flag_call_reported",
  dl = "$user_state",
  PR = "$client_session_props",
  MR = "$capture_rate_limit",
  NR = "$initial_campaign_params",
  OR = "$initial_referrer_info",
  xx = "$initial_person_info",
  wx = "$epp",
  S8 = "__POSTHOG_TOOLBAR__",
  my = "$posthog_cookieless",
  Bie = [
    w8,
    bp,
    "__cmpns",
    xp,
    kR,
    AR,
    yx,
    Bh,
    RR,
    dl,
    pb,
    LR,
    _u,
    Ep,
    DR,
    bx,
    PR,
    MR,
    NR,
    OR,
    wx,
    xx,
  ];
function OF(n) {
  return (
    n instanceof Element &&
    (n.id === S8 ||
      !(n.closest == null || !n.closest(".toolbar-global-fade-container")))
  );
}
function mE(n) {
  return !!n && n.nodeType === 1;
}
function Ic(n, e) {
  return !!n && !!n.tagName && n.tagName.toLowerCase() === e.toLowerCase();
}
function T8(n) {
  return !!n && n.nodeType === 3;
}
function _8(n) {
  return !!n && n.nodeType === 11;
}
function YI(n) {
  return n ? dE(n).split(/\s+/) : [];
}
function jF(n) {
  var e = Re?.location.href;
  return !!(e && n && n.some((t) => e.match(t)));
}
function Ex(n) {
  var e = "";
  switch (typeof n.className) {
    case "string":
      e = n.className;
      break;
    case "object":
      e =
        (n.className && "baseVal" in n.className
          ? n.className.baseVal
          : null) ||
        n.getAttribute("class") ||
        "";
      break;
    default:
      e = "";
  }
  return YI(e);
}
function A8(n) {
  return yn(n)
    ? null
    : dE(n)
        .split(/(\s+)/)
        .filter((e) => yf(e))
        .join("")
        .replace(/[\r\n]/g, " ")
        .replace(/[ ]+/g, " ")
        .substring(0, 255);
}
function pE(n) {
  var e = "";
  return (
    FR(n) &&
      !C8(n) &&
      n.childNodes &&
      n.childNodes.length &&
      Dn(n.childNodes, function (t) {
        var s;
        T8(t) &&
          t.textContent &&
          (e += (s = A8(t.textContent)) !== null && s !== void 0 ? s : "");
      }),
    dE(e)
  );
}
function R8(n) {
  return We(n.target)
    ? n.srcElement || null
    : (e = n.target) != null && e.shadowRoot
    ? n.composedPath()[0] || null
    : n.target || null;
  var e;
}
var jR = ["a", "button", "form", "input", "select", "textarea", "label"];
function k8(n) {
  var e = n.parentNode;
  return !(!e || !mE(e)) && e;
}
function Hie(n, e, t, s, r) {
  var i, a, o;
  if (
    (t === void 0 && (t = void 0),
    !Re ||
      !n ||
      Ic(n, "html") ||
      !mE(n) ||
      ((i = t) != null && i.url_allowlist && !jF(t.url_allowlist)) ||
      ((a = t) != null && a.url_ignorelist && jF(t.url_ignorelist)))
  )
    return !1;
  if ((o = t) != null && o.dom_event_allowlist) {
    var l = t.dom_event_allowlist;
    if (l && !l.some((w) => e.type === w)) return !1;
  }
  for (var c = !1, h = [n], m = !0, p = n; p.parentNode && !Ic(p, "body"); )
    if (_8(p.parentNode)) h.push(p.parentNode.host), (p = p.parentNode.host);
    else {
      if (!(m = k8(p))) break;
      if (s || jR.indexOf(m.tagName.toLowerCase()) > -1) c = !0;
      else {
        var g = Re.getComputedStyle(m);
        g && g.getPropertyValue("cursor") === "pointer" && (c = !0);
      }
      h.push(m), (p = m);
    }
  if (
    !(function (w, S) {
      var A = S?.element_allowlist;
      if (We(A)) return !0;
      var _,
        R = function (D) {
          if (A.some((L) => D.tagName.toLowerCase() === L)) return { v: !0 };
        };
      for (var C of w) if ((_ = R(C))) return _.v;
      return !1;
    })(h, t) ||
    !(function (w, S) {
      var A = S?.css_selector_allowlist;
      if (We(A)) return !0;
      var _,
        R = function (D) {
          if (A.some((L) => D.matches(L))) return { v: !0 };
        };
      for (var C of w) if ((_ = R(C))) return _.v;
      return !1;
    })(h, t)
  )
    return !1;
  var y = Re.getComputedStyle(n);
  if (y && y.getPropertyValue("cursor") === "pointer" && e.type === "click")
    return !0;
  var b = n.tagName.toLowerCase();
  switch (b) {
    case "html":
      return !1;
    case "form":
      return (r || ["submit"]).indexOf(e.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (r || ["change", "click"]).indexOf(e.type) >= 0;
    default:
      return c
        ? (r || ["click"]).indexOf(e.type) >= 0
        : (r || ["click"]).indexOf(e.type) >= 0 &&
            (jR.indexOf(b) > -1 ||
              n.getAttribute("contenteditable") === "true");
  }
}
function FR(n) {
  for (var e = n; e.parentNode && !Ic(e, "body"); e = e.parentNode) {
    var t = Ex(e);
    if (rn(t, "ph-sensitive") || rn(t, "ph-no-capture")) return !1;
  }
  if (rn(Ex(n), "ph-include")) return !0;
  var s = n.type || "";
  if (ms(s))
    switch (s.toLowerCase()) {
      case "hidden":
      case "password":
        return !1;
    }
  var r = n.name || n.id || "";
  return !(
    ms(r) &&
    /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(
      r.replace(/[^a-zA-Z0-9]/g, "")
    )
  );
}
function C8(n) {
  return !!(
    (Ic(n, "input") &&
      !["button", "checkbox", "submit", "reset"].includes(n.type)) ||
    Ic(n, "select") ||
    Ic(n, "textarea") ||
    n.getAttribute("contenteditable") === "true"
  );
}
var I8 =
    "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})",
  Vie = new RegExp("^(?:" + I8 + ")$"),
  zie = new RegExp(I8),
  L8 = "\\d{3}-?\\d{2}-?\\d{4}",
  Gie = new RegExp("^(" + L8 + ")$"),
  qie = new RegExp("(" + L8 + ")");
function yf(n, e) {
  return (
    e === void 0 && (e = !0),
    !(
      yn(n) ||
      (ms(n) &&
        ((n = dE(n)),
        (e ? Vie : zie).test((n || "").replace(/[- ]/g, "")) ||
          (e ? Gie : qie).test(n)))
    )
  );
}
function D8(n) {
  var e = pE(n);
  return yf((e = (e + " " + P8(n)).trim())) ? e : "";
}
function P8(n) {
  var e = "";
  return (
    n &&
      n.childNodes &&
      n.childNodes.length &&
      Dn(n.childNodes, function (t) {
        var s;
        if (
          t &&
          ((s = t.tagName) == null ? void 0 : s.toLowerCase()) === "span"
        )
          try {
            var r = pE(t);
            (e = (e + " " + r).trim()),
              t.childNodes &&
                t.childNodes.length &&
                (e = (e + " " + P8(t)).trim());
          } catch (i) {
            at.error("[AutoCapture]", i);
          }
      }),
    e
  );
}
function Wie(n) {
  return (function (e) {
    var t = e.map((s) => {
      var r,
        i,
        a = "";
      if ((s.tag_name && (a += s.tag_name), s.attr_class))
        for (var o of (s.attr_class.sort(), s.attr_class))
          a += "." + o.replace(/"/g, "");
      var l = nt(
          {},
          s.text ? { text: s.text } : {},
          {
            "nth-child": (r = s.nth_child) !== null && r !== void 0 ? r : 0,
            "nth-of-type": (i = s.nth_of_type) !== null && i !== void 0 ? i : 0,
          },
          s.href ? { href: s.href } : {},
          s.attr_id ? { attr_id: s.attr_id } : {},
          s.attributes
        ),
        c = {};
      return (
        mb(l)
          .sort((h, m) => {
            var [p] = h,
              [g] = m;
            return p.localeCompare(g);
          })
          .forEach((h) => {
            var [m, p] = h;
            return (c[FF(m.toString())] = FF(p.toString()));
          }),
        (a += ":"),
        (a += mb(c)
          .map((h) => {
            var [m, p] = h;
            return m + '="' + p + '"';
          })
          .join(""))
      );
    });
    return t.join(";");
  })(
    (function (e) {
      return e.map((t) => {
        var s,
          r,
          i = {
            text: (s = t.$el_text) == null ? void 0 : s.slice(0, 400),
            tag_name: t.tag_name,
            href: (r = t.attr__href) == null ? void 0 : r.slice(0, 2048),
            attr_class: Kie(t),
            attr_id: t.attr__id,
            nth_child: t.nth_child,
            nth_of_type: t.nth_of_type,
            attributes: {},
          };
        return (
          mb(t)
            .filter((a) => {
              var [o] = a;
              return o.indexOf("attr__") === 0;
            })
            .forEach((a) => {
              var [o, l] = a;
              return (i.attributes[o] = l);
            }),
          i
        );
      });
    })(n)
  );
}
function FF(n) {
  return n.replace(/"|\\"/g, '\\"');
}
function Kie(n) {
  var e = n.attr__class;
  return e ? (zn(e) ? e : YI(e)) : void 0;
}
class M8 {
  constructor() {
    this.clicks = [];
  }
  isRageClick(e, t, s) {
    var r = this.clicks[this.clicks.length - 1];
    if (
      r &&
      Math.abs(e - r.x) + Math.abs(t - r.y) < 30 &&
      s - r.timestamp < 1e3
    ) {
      if (
        (this.clicks.push({ x: e, y: t, timestamp: s }),
        this.clicks.length === 3)
      )
        return !0;
    } else this.clicks = [{ x: e, y: t, timestamp: s }];
    return !1;
  }
}
var Yie = ["localhost", "127.0.0.1"],
  bf = (n) => {
    var e = rt?.createElement("a");
    return We(e) ? null : ((e.href = n), e);
  },
  Xie = function (n, e) {
    var t, s;
    e === void 0 && (e = "&");
    var r = [];
    return (
      Dn(n, function (i, a) {
        We(i) ||
          We(a) ||
          a === "undefined" ||
          ((t = encodeURIComponent(
            ((o) => o instanceof File)(i) ? i.name : i.toString()
          )),
          (s = encodeURIComponent(a)),
          (r[r.length] = s + "=" + t));
      }),
      r.join(e)
    );
  },
  Sx = function (n, e) {
    for (
      var t,
        s = ((n.split("#")[0] || "").split(/\?(.*)/)[1] || "")
          .replace(/^\?+/g, "")
          .split("&"),
        r = 0;
      r < s.length;
      r++
    ) {
      var i = s[r].split("=");
      if (i[0] === e) {
        t = i;
        break;
      }
    }
    if (!zn(t) || t.length < 2) return "";
    var a = t[1];
    try {
      a = decodeURIComponent(a);
    } catch {
      at.error("Skipping decoding for malformed query param: " + a);
    }
    return a.replace(/\+/g, " ");
  },
  XI = function (n, e, t) {
    if (!n || !e || !e.length) return n;
    for (
      var s = n.split("#"),
        r = s[0] || "",
        i = s[1],
        a = r.split("?"),
        o = a[1],
        l = a[0],
        c = (o || "").split("&"),
        h = [],
        m = 0;
      m < c.length;
      m++
    ) {
      var p = c[m].split("=");
      zn(p) && (e.includes(p[0]) ? h.push(p[0] + "=" + t) : h.push(c[m]));
    }
    var g = l;
    return (
      o != null && (g += "?" + h.join("&")), i != null && (g += "#" + i), g
    );
  },
  Tx = function (n, e) {
    var t = n.match(new RegExp(e + "=([^&]*)"));
    return t ? t[1] : null;
  },
  UF = cr("[AutoCapture]");
function t1(n, e) {
  return e.length > n ? e.slice(0, n) + "..." : e;
}
function Qie(n) {
  if (n.previousElementSibling) return n.previousElementSibling;
  var e = n;
  do e = e.previousSibling;
  while (e && !mE(e));
  return e;
}
function Zie(n, e, t, s) {
  var r = n.tagName.toLowerCase(),
    i = { tag_name: r };
  jR.indexOf(r) > -1 &&
    !t &&
    (r.toLowerCase() === "a" || r.toLowerCase() === "button"
      ? (i.$el_text = t1(1024, D8(n)))
      : (i.$el_text = t1(1024, pE(n))));
  var a = Ex(n);
  a.length > 0 &&
    (i.classes = a.filter(function (h) {
      return h !== "";
    })),
    Dn(n.attributes, function (h) {
      var m;
      if (
        (!C8(n) ||
          ["name", "id", "class", "aria-label"].indexOf(h.name) !== -1) &&
        (s == null || !s.includes(h.name)) &&
        !e &&
        yf(h.value) &&
        ((m = h.name),
        !ms(m) ||
          (m.substring(0, 10) !== "_ngcontent" &&
            m.substring(0, 7) !== "_nghost"))
      ) {
        var p = h.value;
        h.name === "class" && (p = YI(p).join(" ")),
          (i["attr__" + h.name] = t1(1024, p));
      }
    });
  for (var o = 1, l = 1, c = n; (c = Qie(c)); )
    o++, c.tagName === n.tagName && l++;
  return (i.nth_child = o), (i.nth_of_type = l), i;
}
function Jie(n, e) {
  for (
    var t,
      s,
      {
        e: r,
        maskAllElementAttributes: i,
        maskAllText: a,
        elementAttributeIgnoreList: o,
        elementsChainAsString: l,
      } = e,
      c = [n],
      h = n;
    h.parentNode && !Ic(h, "body");

  )
    _8(h.parentNode)
      ? (c.push(h.parentNode.host), (h = h.parentNode.host))
      : (c.push(h.parentNode), (h = h.parentNode));
  var m,
    p = [],
    g = {},
    y = !1,
    b = !1;
  if (
    (Dn(c, (R) => {
      var C = FR(R);
      R.tagName.toLowerCase() === "a" &&
        ((y = R.getAttribute("href")), (y = C && y && yf(y) && y)),
        rn(Ex(R), "ph-no-capture") && (b = !0),
        p.push(Zie(R, i, a, o));
      var D = (function (L) {
        if (!FR(L)) return {};
        var P = {};
        return (
          Dn(L.attributes, function (V) {
            if (V.name && V.name.indexOf("data-ph-capture-attribute") === 0) {
              var N = V.name.replace("data-ph-capture-attribute-", ""),
                W = V.value;
              N && W && yf(W) && (P[N] = W);
            }
          }),
          P
        );
      })(R);
      As(g, D);
    }),
    b)
  )
    return { props: {}, explicitNoCapture: b };
  if (
    (a ||
      (n.tagName.toLowerCase() === "a" || n.tagName.toLowerCase() === "button"
        ? (p[0].$el_text = D8(n))
        : (p[0].$el_text = pE(n))),
    y)
  ) {
    var w, S;
    p[0].attr__href = y;
    var A = (w = bf(y)) == null ? void 0 : w.host,
      _ = Re == null || (S = Re.location) == null ? void 0 : S.host;
    A && _ && A !== _ && (m = y);
  }
  return {
    props: As(
      { $event_type: r.type, $ce_version: 1 },
      l ? {} : { $elements: p },
      { $elements_chain: Wie(p) },
      (t = p[0]) != null && t.$el_text
        ? { $el_text: (s = p[0]) == null ? void 0 : s.$el_text }
        : {},
      m && r.type === "click" ? { $external_click_url: m } : {},
      g
    ),
  };
}
class eae {
  constructor(e) {
    (this.i = !1),
      (this.o = null),
      (this.rageclicks = new M8()),
      (this.h = !1),
      (this.instance = e),
      (this.m = null);
  }
  get S() {
    var e,
      t,
      s = fs(this.instance.config.autocapture)
        ? this.instance.config.autocapture
        : {};
    return (
      (s.url_allowlist =
        (e = s.url_allowlist) == null ? void 0 : e.map((r) => new RegExp(r))),
      (s.url_ignorelist =
        (t = s.url_ignorelist) == null ? void 0 : t.map((r) => new RegExp(r))),
      s
    );
  }
  $() {
    if (this.isBrowserSupported()) {
      if (Re && rt) {
        var e = (s) => {
          s = s || Re?.event;
          try {
            this.k(s);
          } catch (r) {
            UF.error("Failed to capture event", r);
          }
        };
        if (
          (is(rt, "submit", e, { capture: !0 }),
          is(rt, "change", e, { capture: !0 }),
          is(rt, "click", e, { capture: !0 }),
          this.S.capture_copied_text)
        ) {
          var t = (s) => {
            (s = s || Re?.event), this.k(s, e1);
          };
          is(rt, "copy", t, { capture: !0 }), is(rt, "cut", t, { capture: !0 });
        }
      }
    } else
      UF.info(
        "Disabling Automatic Event Collection because this browser is not supported"
      );
  }
  startIfEnabled() {
    this.isEnabled && !this.i && (this.$(), (this.i = !0));
  }
  onRemoteConfig(e) {
    e.elementsChainAsString && (this.h = e.elementsChainAsString),
      this.instance.persistence &&
        this.instance.persistence.register({ [TF]: !!e.autocapture_opt_out }),
      (this.o = !!e.autocapture_opt_out),
      this.startIfEnabled();
  }
  setElementSelectors(e) {
    this.m = e;
  }
  getElementSelectors(e) {
    var t,
      s = [];
    return (
      (t = this.m) == null ||
        t.forEach((r) => {
          var i = rt?.querySelectorAll(r);
          i?.forEach((a) => {
            e === a && s.push(r);
          });
        }),
      s
    );
  }
  get isEnabled() {
    var e,
      t,
      s = (e = this.instance.persistence) == null ? void 0 : e.props[TF],
      r = this.o;
    if (zc(r) && !bo(s) && !this.instance.I()) return !1;
    var i = (t = this.o) !== null && t !== void 0 ? t : !!s;
    return !!this.instance.config.autocapture && !i;
  }
  k(e, t) {
    if ((t === void 0 && (t = "$autocapture"), this.isEnabled)) {
      var s,
        r = R8(e);
      T8(r) && (r = r.parentNode || null),
        t === "$autocapture" &&
          e.type === "click" &&
          e instanceof MouseEvent &&
          this.instance.config.rageclick &&
          (s = this.rageclicks) != null &&
          s.isRageClick(e.clientX, e.clientY, new Date().getTime()) &&
          this.k(e, "$rageclick");
      var i = t === e1;
      if (r && Hie(r, e, this.S, i, i ? ["copy", "cut"] : void 0)) {
        var { props: a, explicitNoCapture: o } = Jie(r, {
          e,
          maskAllElementAttributes:
            this.instance.config.mask_all_element_attributes,
          maskAllText: this.instance.config.mask_all_text,
          elementAttributeIgnoreList: this.S.element_attribute_ignorelist,
          elementsChainAsString: this.h,
        });
        if (o) return !1;
        var l = this.getElementSelectors(r);
        if ((l && l.length > 0 && (a.$element_selectors = l), t === e1)) {
          var c,
            h = A8(
              Re == null || (c = Re.getSelection()) == null
                ? void 0
                : c.toString()
            ),
            m = e.type || "clipboard";
          if (!h) return !1;
          (a.$selected_content = h), (a.$copy_type = m);
        }
        return this.instance.capture(t, a), !0;
      }
    }
  }
  isBrowserSupported() {
    return sa(rt?.querySelectorAll);
  }
}
Math.trunc ||
  (Math.trunc = function (n) {
    return n < 0 ? Math.ceil(n) : Math.floor(n);
  }),
  Number.isInteger ||
    (Number.isInteger = function (n) {
      return Cr(n) && isFinite(n) && Math.floor(n) === n;
    });
var $F = "0123456789abcdef";
class _x {
  constructor(e) {
    if (((this.bytes = e), e.length !== 16))
      throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(e, t, s, r) {
    if (
      !Number.isInteger(e) ||
      !Number.isInteger(t) ||
      !Number.isInteger(s) ||
      !Number.isInteger(r) ||
      e < 0 ||
      t < 0 ||
      s < 0 ||
      r < 0 ||
      e > 0xffffffffffff ||
      t > 4095 ||
      s > 1073741823 ||
      r > 4294967295
    )
      throw new RangeError("invalid field value");
    var i = new Uint8Array(16);
    return (
      (i[0] = e / Math.pow(2, 40)),
      (i[1] = e / Math.pow(2, 32)),
      (i[2] = e / Math.pow(2, 24)),
      (i[3] = e / Math.pow(2, 16)),
      (i[4] = e / Math.pow(2, 8)),
      (i[5] = e),
      (i[6] = 112 | (t >>> 8)),
      (i[7] = t),
      (i[8] = 128 | (s >>> 24)),
      (i[9] = s >>> 16),
      (i[10] = s >>> 8),
      (i[11] = s),
      (i[12] = r >>> 24),
      (i[13] = r >>> 16),
      (i[14] = r >>> 8),
      (i[15] = r),
      new _x(i)
    );
  }
  toString() {
    for (var e = "", t = 0; t < this.bytes.length; t++)
      (e = e + $F.charAt(this.bytes[t] >>> 4) + $F.charAt(15 & this.bytes[t])),
        (t !== 3 && t !== 5 && t !== 7 && t !== 9) || (e += "-");
    if (e.length !== 36) throw new Error("Invalid UUIDv7 was generated");
    return e;
  }
  clone() {
    return new _x(this.bytes.slice(0));
  }
  equals(e) {
    return this.compareTo(e) === 0;
  }
  compareTo(e) {
    for (var t = 0; t < 16; t++) {
      var s = this.bytes[t] - e.bytes[t];
      if (s !== 0) return Math.sign(s);
    }
    return 0;
  }
}
class tae {
  constructor() {
    (this.P = 0), (this.R = 0), (this.T = new nae());
  }
  generate() {
    var e = this.generateOrAbort();
    if (We(e)) {
      this.P = 0;
      var t = this.generateOrAbort();
      if (We(t))
        throw new Error("Could not generate UUID after timestamp reset");
      return t;
    }
    return e;
  }
  generateOrAbort() {
    var e = Date.now();
    if (e > this.P) (this.P = e), this.M();
    else {
      if (!(e + 1e4 > this.P)) return;
      this.R++, this.R > 4398046511103 && (this.P++, this.M());
    }
    return _x.fromFieldsV7(
      this.P,
      Math.trunc(this.R / Math.pow(2, 30)),
      this.R & (Math.pow(2, 30) - 1),
      this.T.nextUint32()
    );
  }
  M() {
    this.R = 1024 * this.T.nextUint32() + (1023 & this.T.nextUint32());
  }
}
var BF,
  N8 = (n) => {
    if (typeof UUIDV7_DENY_WEAK_RNG < "u" && UUIDV7_DENY_WEAK_RNG)
      throw new Error("no cryptographically strong RNG available");
    for (var e = 0; e < n.length; e++)
      n[e] =
        65536 * Math.trunc(65536 * Math.random()) +
        Math.trunc(65536 * Math.random());
    return n;
  };
Re &&
  !We(Re.crypto) &&
  crypto.getRandomValues &&
  (N8 = (n) => crypto.getRandomValues(n));
class nae {
  constructor() {
    (this.C = new Uint32Array(8)), (this.F = 1 / 0);
  }
  nextUint32() {
    return (
      this.F >= this.C.length && (N8(this.C), (this.F = 0)), this.C[this.F++]
    );
  }
}
var Rc = () => sae().toString(),
  sae = () => (BF || (BF = new tae())).generate(),
  tp = "",
  rae = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function iae(n, e) {
  if (e) {
    var t = (function (r, i) {
      if ((i === void 0 && (i = rt), tp)) return tp;
      if (!i || ["localhost", "127.0.0.1"].includes(r)) return "";
      for (
        var a = r.split("."), o = Math.min(a.length, 8), l = "dmn_chk_" + Rc();
        !tp && o--;

      ) {
        var c = a.slice(o).join("."),
          h = l + "=1;domain=." + c + ";path=/";
        (i.cookie = h + ";max-age=3"),
          i.cookie.includes(l) && ((i.cookie = h + ";max-age=0"), (tp = c));
      }
      return tp;
    })(n);
    if (!t) {
      var s = ((r) => {
        var i = r.match(rae);
        return i ? i[0] : "";
      })(n);
      s !== t && at.info("Warning: cookie subdomain discovery mismatch", s, t),
        (t = s);
    }
    return t ? "; domain=." + t : "";
  }
  return "";
}
var Ao = {
    O: () => !!rt,
    A: function (n) {
      at.error("cookieStore error: " + n);
    },
    D: function (n) {
      if (rt) {
        try {
          for (
            var e = n + "=",
              t = rt.cookie.split(";").filter((i) => i.length),
              s = 0;
            s < t.length;
            s++
          ) {
            for (var r = t[s]; r.charAt(0) == " "; )
              r = r.substring(1, r.length);
            if (r.indexOf(e) === 0)
              return decodeURIComponent(r.substring(e.length, r.length));
          }
        } catch {}
        return null;
      }
    },
    L: function (n) {
      var e;
      try {
        e = JSON.parse(Ao.D(n)) || {};
      } catch {}
      return e;
    },
    j: function (n, e, t, s, r) {
      if (rt)
        try {
          var i = "",
            a = "",
            o = iae(rt.location.hostname, s);
          if (t) {
            var l = new Date();
            l.setTime(l.getTime() + 24 * t * 60 * 60 * 1e3),
              (i = "; expires=" + l.toUTCString());
          }
          r && (a = "; secure");
          var c =
            n +
            "=" +
            encodeURIComponent(JSON.stringify(e)) +
            i +
            "; SameSite=Lax; path=/" +
            o +
            a;
          return (
            c.length > 3686.4 &&
              at.warn("cookieStore warning: large cookie, len=" + c.length),
            (rt.cookie = c),
            c
          );
        } catch {
          return;
        }
    },
    N: function (n, e) {
      try {
        Ao.j(n, "", -1, e);
      } catch {
        return;
      }
    },
  },
  n1 = null,
  Vs = {
    O: function () {
      if (!zc(n1)) return n1;
      var n = !0;
      if (We(Re)) n = !1;
      else
        try {
          var e = "__mplssupport__";
          Vs.j(e, "xyz"), Vs.D(e) !== '"xyz"' && (n = !1), Vs.N(e);
        } catch {
          n = !1;
        }
      return (
        n || at.error("localStorage unsupported; falling back to cookie store"),
        (n1 = n),
        n
      );
    },
    A: function (n) {
      at.error("localStorage error: " + n);
    },
    D: function (n) {
      try {
        return Re?.localStorage.getItem(n);
      } catch (e) {
        Vs.A(e);
      }
      return null;
    },
    L: function (n) {
      try {
        return JSON.parse(Vs.D(n)) || {};
      } catch {}
      return null;
    },
    j: function (n, e) {
      try {
        Re?.localStorage.setItem(n, JSON.stringify(e));
      } catch (t) {
        Vs.A(t);
      }
    },
    N: function (n) {
      try {
        Re?.localStorage.removeItem(n);
      } catch (e) {
        Vs.A(e);
      }
    },
  },
  aae = ["distinct_id", yx, wp, wx, xx],
  py = nt({}, Vs, {
    L: function (n) {
      try {
        var e = {};
        try {
          e = Ao.L(n) || {};
        } catch {}
        var t = As(e, JSON.parse(Vs.D(n) || "{}"));
        return Vs.j(n, t), t;
      } catch {}
      return null;
    },
    j: function (n, e, t, s, r, i) {
      try {
        Vs.j(n, e, void 0, void 0, i);
        var a = {};
        aae.forEach((o) => {
          e[o] && (a[o] = e[o]);
        }),
          Object.keys(a).length && Ao.j(n, a, t, s, r, i);
      } catch (o) {
        Vs.A(o);
      }
    },
    N: function (n, e) {
      try {
        Re?.localStorage.removeItem(n), Ao.N(n, e);
      } catch (t) {
        Vs.A(t);
      }
    },
  }),
  gy = {},
  oae = {
    O: function () {
      return !0;
    },
    A: function (n) {
      at.error("memoryStorage error: " + n);
    },
    D: function (n) {
      return gy[n] || null;
    },
    L: function (n) {
      return gy[n] || null;
    },
    j: function (n, e) {
      gy[n] = e;
    },
    N: function (n) {
      delete gy[n];
    },
  },
  vu = null,
  vr = {
    O: function () {
      if (!zc(vu)) return vu;
      if (((vu = !0), We(Re))) vu = !1;
      else
        try {
          var n = "__support__";
          vr.j(n, "xyz"), vr.D(n) !== '"xyz"' && (vu = !1), vr.N(n);
        } catch {
          vu = !1;
        }
      return vu;
    },
    A: function (n) {
      at.error("sessionStorage error: ", n);
    },
    D: function (n) {
      try {
        return Re?.sessionStorage.getItem(n);
      } catch (e) {
        vr.A(e);
      }
      return null;
    },
    L: function (n) {
      try {
        return JSON.parse(vr.D(n)) || null;
      } catch {}
      return null;
    },
    j: function (n, e) {
      try {
        Re?.sessionStorage.setItem(n, JSON.stringify(e));
      } catch (t) {
        vr.A(t);
      }
    },
    N: function (n) {
      try {
        Re?.sessionStorage.removeItem(n);
      } catch (e) {
        vr.A(e);
      }
    },
  },
  ih = (function (n) {
    return (
      (n[(n.PENDING = -1)] = "PENDING"),
      (n[(n.DENIED = 0)] = "DENIED"),
      (n[(n.GRANTED = 1)] = "GRANTED"),
      n
    );
  })({});
class lae {
  constructor(e) {
    this._instance = e;
  }
  get S() {
    return this._instance.config;
  }
  get consent() {
    return this.U() ? ih.DENIED : this.q;
  }
  isOptedOut() {
    return (
      this.consent === ih.DENIED ||
      (this.consent === ih.PENDING && this.S.opt_out_capturing_by_default)
    );
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(e) {
    this.B.j(
      this.H,
      e ? 1 : 0,
      this.S.cookie_expiration,
      this.S.cross_subdomain_cookie,
      this.S.secure_cookie
    );
  }
  reset() {
    this.B.N(this.H, this.S.cross_subdomain_cookie);
  }
  get H() {
    var { token: e, opt_out_capturing_cookie_prefix: t } =
      this._instance.config;
    return (t || "__ph_opt_in_out_") + e;
  }
  get q() {
    var e = this.B.D(this.H);
    return e === "1" ? ih.GRANTED : e === "0" ? ih.DENIED : ih.PENDING;
  }
  get B() {
    if (!this.W) {
      var e = this.S.opt_out_capturing_persistence_type;
      this.W = e === "localStorage" ? Vs : Ao;
      var t = e === "localStorage" ? Ao : Vs;
      t.D(this.H) &&
        (this.W.D(this.H) || this.optInOut(t.D(this.H) === "1"),
        t.N(this.H, this.S.cross_subdomain_cookie));
    }
    return this.W;
  }
  U() {
    return (
      !!this.S.respect_dnt &&
      !!x8([_i?.doNotTrack, _i?.msDoNotTrack, Mt.doNotTrack], (e) =>
        rn([!0, 1, "1", "yes"], e)
      )
    );
  }
}
var vy = cr("[Dead Clicks]"),
  cae = () => !0,
  uae = (n) => {
    var e,
      t = !((e = n.instance.persistence) == null || !e.get_property(E8)),
      s = n.instance.config.capture_dead_clicks;
    return bo(s) ? s : t;
  };
class O8 {
  get lazyLoadedDeadClicksAutocapture() {
    return this.G;
  }
  constructor(e, t, s) {
    (this.instance = e),
      (this.isEnabled = t),
      (this.onCapture = s),
      this.startIfEnabled();
  }
  onRemoteConfig(e) {
    this.instance.persistence &&
      this.instance.persistence.register({ [E8]: e?.captureDeadClicks }),
      this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) &&
      this.J(() => {
        this.V();
      });
  }
  J(e) {
    var t, s;
    (t = Mt.__PosthogExtensions__) != null &&
      t.initDeadClicksAutocapture &&
      e(),
      (s = Mt.__PosthogExtensions__) == null ||
        s.loadExternalDependency == null ||
        s.loadExternalDependency(
          this.instance,
          "dead-clicks-autocapture",
          (r) => {
            r ? vy.error("failed to load script", r) : e();
          }
        );
  }
  V() {
    var e;
    if (rt) {
      if (
        !this.G &&
        (e = Mt.__PosthogExtensions__) != null &&
        e.initDeadClicksAutocapture
      ) {
        var t = fs(this.instance.config.capture_dead_clicks)
          ? this.instance.config.capture_dead_clicks
          : {};
        (t.__onCapture = this.onCapture),
          (this.G = Mt.__PosthogExtensions__.initDeadClicksAutocapture(
            this.instance,
            t
          )),
          this.G.start(rt),
          vy.info("starting...");
      }
    } else vy.error("`document` not found. Cannot start.");
  }
  stop() {
    this.G && (this.G.stop(), (this.G = void 0), vy.info("stopping..."));
  }
}
function Ai(n, e, t, s, r) {
  return (
    e > t && (at.warn("min cannot be greater than max."), (e = t)),
    Cr(n)
      ? n > t
        ? (s &&
            at.warn(
              s +
                " cannot be  greater than max: " +
                t +
                ". Using max value instead."
            ),
          t)
        : n < e
        ? (s &&
            at.warn(
              s +
                " cannot be less than min: " +
                e +
                ". Using min value instead."
            ),
          e)
        : n
      : (s &&
          at.warn(
            s +
              " must be a number. using max or fallback. max: " +
              t +
              ", fallback: " +
              r
          ),
        Ai(r || t, e, t, s))
  );
}
class j8 {
  constructor(e) {
    (this.K = {}),
      (this.Y = () => {
        Object.keys(this.K).forEach((t) => {
          var s = this.X(t) + this.Z;
          s >= this.tt ? delete this.K[t] : this.it(t, s);
        });
      }),
      (this.X = (t) => this.K[String(t)]),
      (this.it = (t, s) => {
        this.K[String(t)] = s;
      }),
      (this.consumeRateLimit = (t) => {
        var s,
          r = (s = this.X(t)) !== null && s !== void 0 ? s : this.tt;
        if ((r = Math.max(r - 1, 0)) === 0) return !0;
        this.it(t, r);
        var i,
          a = r === 0;
        return a && ((i = this.et) == null || i.call(this, t)), a;
      }),
      (this.rt = e),
      (this.et = this.rt.et),
      (this.tt = Ai(this.rt.bucketSize, 0, 100, "rate limiter bucket size")),
      (this.Z = Ai(this.rt.refillRate, 0, this.tt, "rate limiter refill rate")),
      (this.st = Ai(
        this.rt.refillInterval,
        0,
        864e5,
        "rate limiter refill interval"
      )),
      setInterval(() => {
        this.Y();
      }, this.st);
  }
}
var yy = cr("[ExceptionAutocapture]");
class dae {
  constructor(e) {
    var t, s, r;
    (this.nt = () => {
      var i;
      if (
        Re &&
        this.isEnabled &&
        (i = Mt.__PosthogExtensions__) != null &&
        i.errorWrappingFunctions
      ) {
        var a = Mt.__PosthogExtensions__.errorWrappingFunctions.wrapOnError,
          o =
            Mt.__PosthogExtensions__.errorWrappingFunctions
              .wrapUnhandledRejection,
          l = Mt.__PosthogExtensions__.errorWrappingFunctions.wrapConsoleError;
        try {
          !this.ot &&
            this.S.capture_unhandled_errors &&
            (this.ot = a(this.captureException.bind(this))),
            !this.lt &&
              this.S.capture_unhandled_rejections &&
              (this.lt = o(this.captureException.bind(this))),
            !this.ut &&
              this.S.capture_console_errors &&
              (this.ut = l(this.captureException.bind(this)));
        } catch (c) {
          yy.error("failed to start", c), this.ht();
        }
      }
    }),
      (this._instance = e),
      (this.dt = !((t = this._instance.persistence) == null || !t.props[_F])),
      (this.S = this.vt()),
      (this.ct = new j8({
        refillRate:
          (s =
            this._instance.config.error_tracking
              .__exceptionRateLimiterRefillRate) !== null && s !== void 0
            ? s
            : 1,
        bucketSize:
          (r =
            this._instance.config.error_tracking
              .__exceptionRateLimiterBucketSize) !== null && r !== void 0
            ? r
            : 10,
        refillInterval: 1e4,
      })),
      this.startIfEnabled();
  }
  vt() {
    var e = this._instance.config.capture_exceptions,
      t = {
        capture_unhandled_errors: !1,
        capture_unhandled_rejections: !1,
        capture_console_errors: !1,
      };
    return (
      fs(e)
        ? (t = nt({}, t, e))
        : (We(e) ? this.dt : e) &&
          (t = nt({}, t, {
            capture_unhandled_errors: !0,
            capture_unhandled_rejections: !0,
          })),
      t
    );
  }
  get isEnabled() {
    return (
      this.S.capture_console_errors ||
      this.S.capture_unhandled_errors ||
      this.S.capture_unhandled_rejections
    );
  }
  startIfEnabled() {
    this.isEnabled && (yy.info("enabled"), this.J(this.nt));
  }
  J(e) {
    var t, s;
    (t = Mt.__PosthogExtensions__) != null && t.errorWrappingFunctions && e(),
      (s = Mt.__PosthogExtensions__) == null ||
        s.loadExternalDependency == null ||
        s.loadExternalDependency(
          this._instance,
          "exception-autocapture",
          (r) => {
            if (r) return yy.error("failed to load script", r);
            e();
          }
        );
  }
  ht() {
    var e, t, s;
    (e = this.ot) == null || e.call(this),
      (this.ot = void 0),
      (t = this.lt) == null || t.call(this),
      (this.lt = void 0),
      (s = this.ut) == null || s.call(this),
      (this.ut = void 0);
  }
  onRemoteConfig(e) {
    var t = e.autocaptureExceptions;
    (this.dt = !!t || !1),
      (this.S = this.vt()),
      this._instance.persistence &&
        this._instance.persistence.register({ [_F]: this.dt }),
      this.startIfEnabled();
  }
  captureException(e) {
    var t,
      s = this._instance.requestRouter.endpointFor("ui");
    e.$exception_personURL =
      s +
      "/project/" +
      this._instance.config.token +
      "/person/" +
      this._instance.get_distinct_id();
    var r =
      (t = e.$exception_list[0].type) !== null && t !== void 0
        ? t
        : "Exception";
    this.ct.consumeRateLimit(r)
      ? yy.info("Skipping exception capture because of client rate limiting.", {
          exception: e.$exception_list[0].type,
        })
      : this._instance.exceptions.sendExceptionEvent(e);
  }
}
function F8(n) {
  return !We(Event) && U8(n, Event);
}
function U8(n, e) {
  try {
    return n instanceof e;
  } catch {
    return !1;
  }
}
function $8(n) {
  switch (Object.prototype.toString.call(n)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object DOMError]":
      return !0;
    default:
      return U8(n, Error);
  }
}
function gb(n, e) {
  return Object.prototype.toString.call(n) === "[object " + e + "]";
}
function s1(n) {
  return gb(n, "DOMError");
}
var HF = /\(error: (.*)\)/,
  VF = 50,
  Hh = "?";
function r1(n, e, t, s) {
  var r = {
    platform: "web:javascript",
    filename: n,
    function: e === "<anonymous>" ? Hh : e,
    in_app: !0,
  };
  return We(t) || (r.lineno = t), We(s) || (r.colno = s), r;
}
var hae = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  fae =
    /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  mae = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  pae =
    /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  gae = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  vae = (function () {
    for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
      e[t] = arguments[t];
    var s = e.sort((r, i) => r[0] - i[0]).map((r) => r[1]);
    return function (r, i) {
      i === void 0 && (i = 0);
      for (
        var a = [],
          o = r.split(`
`),
          l = i;
        l < o.length;
        l++
      ) {
        var c = o[l];
        if (!(c.length > 1024)) {
          var h = HF.test(c) ? c.replace(HF, "$1") : c;
          if (!h.match(/\S*Error: /)) {
            for (var m of s) {
              var p = m(h);
              if (p) {
                a.push(p);
                break;
              }
            }
            if (a.length >= VF) break;
          }
        }
      }
      return (function (g) {
        if (!g.length) return [];
        var y = Array.from(g);
        return (
          y.reverse(),
          y
            .slice(0, VF)
            .map((b) =>
              nt({}, b, {
                filename: b.filename || yae(y).filename,
                function: b.function || Hh,
              })
            )
        );
      })(a);
    };
  })(
    [
      30,
      (n) => {
        var e = hae.exec(n);
        if (e) {
          var [, t, s, r] = e;
          return r1(t, Hh, +s, +r);
        }
        var i = fae.exec(n);
        if (i) {
          if (i[2] && i[2].indexOf("eval") === 0) {
            var a = mae.exec(i[2]);
            a && ((i[2] = a[1]), (i[3] = a[2]), (i[4] = a[3]));
          }
          var [o, l] = GF(i[1] || Hh, i[2]);
          return r1(l, o, i[3] ? +i[3] : void 0, i[4] ? +i[4] : void 0);
        }
      },
    ],
    [
      50,
      (n) => {
        var e = pae.exec(n);
        if (e) {
          if (e[3] && e[3].indexOf(" > eval") > -1) {
            var t = gae.exec(e[3]);
            t &&
              ((e[1] = e[1] || "eval"),
              (e[3] = t[1]),
              (e[4] = t[2]),
              (e[5] = ""));
          }
          var s = e[3],
            r = e[1] || Hh;
          return (
            ([r, s] = GF(r, s)),
            r1(s, r, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
          );
        }
      },
    ]
  );
function yae(n) {
  return n[n.length - 1] || {};
}
var by,
  zF,
  i1,
  GF = (n, e) => {
    var t = n.indexOf("safari-extension") !== -1,
      s = n.indexOf("safari-web-extension") !== -1;
    return t || s
      ? [
          n.indexOf("@") !== -1 ? n.split("@")[0] : Hh,
          t ? "safari-extension:" + e : "safari-web-extension:" + e,
        ]
      : [n, e];
  },
  bae =
    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
function QI(n, e) {
  e === void 0 && (e = 0);
  var t = n.stacktrace || n.stack || "",
    s = (function (a) {
      return a && xae.test(a.message) ? 1 : 0;
    })(n);
  try {
    var r = vae,
      i = (function (a, o) {
        var l = (function (c) {
          var h = globalThis._posthogChunkIds;
          if (!h) return {};
          var m = Object.keys(h);
          return (
            (i1 && m.length === zF) ||
              ((zF = m.length),
              (i1 = m.reduce((p, g) => {
                by || (by = {});
                var y = by[g];
                if (y) p[y[0]] = y[1];
                else
                  for (var b = c(g), w = b.length - 1; w >= 0; w--) {
                    var S = b[w],
                      A = S?.filename,
                      _ = h[g];
                    if (A && _) {
                      (p[A] = _), (by[g] = [A, _]);
                      break;
                    }
                  }
                return p;
              }, {}))),
            i1
          );
        })(o);
        return (
          a.forEach((c) => {
            c.filename && (c.chunk_id = l[c.filename]);
          }),
          a
        );
      })(r(t, s), r);
    return i.slice(0, i.length - e);
  } catch {}
  return [];
}
var xae = /Minified React error #\d+;/i;
function wae(n, e) {
  var t,
    s,
    r = QI(n),
    i = (t = e?.handled) === null || t === void 0 || t,
    a = (s = e?.synthetic) !== null && s !== void 0 && s;
  return {
    type:
      e != null && e.overrideExceptionType ? e.overrideExceptionType : n.name,
    value: (function (o) {
      var l = o.message;
      return l.error && typeof l.error.message == "string"
        ? String(l.error.message)
        : String(l);
    })(n),
    stacktrace: { frames: r, type: "raw" },
    mechanism: { handled: i, synthetic: a },
  };
}
function B8(n, e) {
  var t = wae(n, e);
  return n.cause && $8(n.cause) && n.cause !== n
    ? [t, ...B8(n.cause, { handled: e?.handled, synthetic: e?.synthetic })]
    : [t];
}
function a1(n, e) {
  return { $exception_list: B8(n, e), $exception_level: "error" };
}
function o1(n, e) {
  var t,
    s,
    r,
    i = (t = e?.handled) === null || t === void 0 || t,
    a = (s = e?.synthetic) === null || s === void 0 || s,
    o = {
      type:
        e != null && e.overrideExceptionType
          ? e.overrideExceptionType
          : (r = e?.defaultExceptionType) !== null && r !== void 0
          ? r
          : "Error",
      value: n || e?.defaultExceptionMessage,
      mechanism: { handled: i, synthetic: a },
    };
  if (e != null && e.syntheticException) {
    var l = QI(e.syntheticException, 1);
    l.length && (o.stacktrace = { frames: l, type: "raw" });
  }
  return { $exception_list: [o], $exception_level: "error" };
}
function Eae(n) {
  return ms(n) && !_R(n) && Die.indexOf(n) >= 0;
}
function Sae(n, e) {
  var t,
    s,
    r = (t = e?.handled) === null || t === void 0 || t,
    i = (s = e?.synthetic) === null || s === void 0 || s,
    a =
      e != null && e.overrideExceptionType
        ? e.overrideExceptionType
        : F8(n)
        ? n.constructor.name
        : "Error",
    o =
      "Non-Error 'exception' captured with keys: " +
      (function (h, m) {
        m === void 0 && (m = 40);
        var p = Object.keys(h);
        if ((p.sort(), !p.length)) return "[object has no keys]";
        for (var g = p.length; g > 0; g--) {
          var y = p.slice(0, g).join(", ");
          if (!(y.length > m))
            return g === p.length || y.length <= m ? y : y.slice(0, m) + "...";
        }
        return "";
      })(n),
    l = { type: a, value: o, mechanism: { handled: r, synthetic: i } };
  if (e != null && e.syntheticException) {
    var c = QI(e?.syntheticException, 1);
    c.length && (l.stacktrace = { frames: c, type: "raw" });
  }
  return {
    $exception_list: [l],
    $exception_level: Eae(n.level) ? n.level : "error",
  };
}
function Tae(n, e) {
  var { error: t, event: s } = n,
    r = { $exception_list: [] },
    i = t || s;
  if (
    s1(i) ||
    (function (p) {
      return gb(p, "DOMException");
    })(i)
  ) {
    var a = i;
    if (
      (function (p) {
        return "stack" in p;
      })(i)
    )
      r = a1(i, e);
    else {
      var o = a.name || (s1(a) ? "DOMError" : "DOMException"),
        l = a.message ? o + ": " + a.message : o;
      r = o1(
        l,
        nt({}, e, {
          overrideExceptionType: s1(a) ? "DOMError" : "DOMException",
          defaultExceptionMessage: l,
        })
      );
    }
    return "code" in a && (r.$exception_DOMException_code = "" + a.code), r;
  }
  if (
    (function (p) {
      return gb(p, "ErrorEvent");
    })(i) &&
    i.error
  )
    return a1(i.error, e);
  if ($8(i)) return a1(i, e);
  if (
    (function (p) {
      return gb(p, "Object");
    })(i) ||
    F8(i)
  )
    return Sae(i, e);
  if (We(t) && ms(s)) {
    var c = "Error",
      h = s,
      m = s.match(bae);
    return (
      m && ((c = m[1]), (h = m[2])),
      o1(h, nt({}, e, { overrideExceptionType: c, defaultExceptionMessage: h }))
    );
  }
  return o1(i, e);
}
function qF(n, e, t) {
  try {
    if (!(e in n)) return () => {};
    var s = n[e],
      r = t(s);
    return (
      sa(r) &&
        ((r.prototype = r.prototype || {}),
        Object.defineProperties(r, {
          __posthog_wrapped__: { enumerable: !1, value: !0 },
        })),
      (n[e] = r),
      () => {
        n[e] = s;
      }
    );
  } catch {
    return () => {};
  }
}
class _ae {
  constructor(e) {
    var t;
    (this._instance = e),
      (this.ft =
        (Re == null || (t = Re.location) == null ? void 0 : t.pathname) || "");
  }
  get isEnabled() {
    return this._instance.config.capture_pageview === "history_change";
  }
  startIfEnabled() {
    this.isEnabled &&
      (at.info("History API monitoring enabled, starting..."),
      this.monitorHistoryChanges());
  }
  stop() {
    this._t && this._t(),
      (this._t = void 0),
      at.info("History API monitoring stopped");
  }
  monitorHistoryChanges() {
    var e, t;
    if (Re && Re.history) {
      var s = this;
      ((e = Re.history.pushState) != null && e.__posthog_wrapped__) ||
        qF(
          Re.history,
          "pushState",
          (r) =>
            function (i, a, o) {
              r.call(this, i, a, o), s.gt("pushState");
            }
        ),
        ((t = Re.history.replaceState) != null && t.__posthog_wrapped__) ||
          qF(
            Re.history,
            "replaceState",
            (r) =>
              function (i, a, o) {
                r.call(this, i, a, o), s.gt("replaceState");
              }
          ),
        this.bt();
    }
  }
  gt(e) {
    try {
      var t,
        s = Re == null || (t = Re.location) == null ? void 0 : t.pathname;
      if (!s) return;
      s !== this.ft &&
        this.isEnabled &&
        this._instance.capture("$pageview", { navigation_type: e }),
        (this.ft = s);
    } catch (r) {
      at.error("Error capturing " + e + " pageview", r);
    }
  }
  bt() {
    if (!this._t) {
      var e = () => {
        this.gt("popstate");
      };
      is(Re, "popstate", e),
        (this._t = () => {
          Re && Re.removeEventListener("popstate", e);
        });
    }
  }
}
function Ax(n) {
  var e, t;
  return (
    ((e = JSON.stringify(
      n,
      ((t = []),
      function (s, r) {
        if (fs(r)) {
          for (; t.length > 0 && t[t.length - 1] !== this; ) t.pop();
          return t.includes(r) ? "[Circular]" : (t.push(r), r);
        }
        return r;
      })
    )) == null
      ? void 0
      : e.length) || 0
  );
}
function UR(n, e) {
  if ((e === void 0 && (e = 66060288e-1), n.size >= e && n.data.length > 1)) {
    var t = Math.floor(n.data.length / 2),
      s = n.data.slice(0, t),
      r = n.data.slice(t);
    return [
      UR({
        size: Ax(s),
        data: s,
        sessionId: n.sessionId,
        windowId: n.windowId,
      }),
      UR({
        size: Ax(r),
        data: r,
        sessionId: n.sessionId,
        windowId: n.windowId,
      }),
    ].flatMap((i) => i);
  }
  return [n];
}
var hl = ((n) => (
    (n[(n.DomContentLoaded = 0)] = "DomContentLoaded"),
    (n[(n.Load = 1)] = "Load"),
    (n[(n.FullSnapshot = 2)] = "FullSnapshot"),
    (n[(n.IncrementalSnapshot = 3)] = "IncrementalSnapshot"),
    (n[(n.Meta = 4)] = "Meta"),
    (n[(n.Custom = 5)] = "Custom"),
    (n[(n.Plugin = 6)] = "Plugin"),
    n
  ))(hl || {}),
  Sa = ((n) => (
    (n[(n.Mutation = 0)] = "Mutation"),
    (n[(n.MouseMove = 1)] = "MouseMove"),
    (n[(n.MouseInteraction = 2)] = "MouseInteraction"),
    (n[(n.Scroll = 3)] = "Scroll"),
    (n[(n.ViewportResize = 4)] = "ViewportResize"),
    (n[(n.Input = 5)] = "Input"),
    (n[(n.TouchMove = 6)] = "TouchMove"),
    (n[(n.MediaInteraction = 7)] = "MediaInteraction"),
    (n[(n.StyleSheetRule = 8)] = "StyleSheetRule"),
    (n[(n.CanvasMutation = 9)] = "CanvasMutation"),
    (n[(n.Font = 10)] = "Font"),
    (n[(n.Log = 11)] = "Log"),
    (n[(n.Drag = 12)] = "Drag"),
    (n[(n.StyleDeclaration = 13)] = "StyleDeclaration"),
    (n[(n.Selection = 14)] = "Selection"),
    (n[(n.AdoptedStyleSheet = 15)] = "AdoptedStyleSheet"),
    (n[(n.CustomElement = 16)] = "CustomElement"),
    n
  ))(Sa || {}),
  $R = "[SessionRecording]",
  BR = "redacted",
  xy = {
    initiatorTypes: [
      "audio",
      "beacon",
      "body",
      "css",
      "early-hint",
      "embed",
      "fetch",
      "frame",
      "iframe",
      "icon",
      "image",
      "img",
      "input",
      "link",
      "navigation",
      "object",
      "ping",
      "script",
      "track",
      "video",
      "xmlhttprequest",
    ],
    maskRequestFn: (n) => n,
    recordHeaders: !1,
    recordBody: !1,
    recordInitialRequests: !1,
    recordPerformance: !1,
    performanceEntryTypeToObserve: [
      "first-input",
      "navigation",
      "paint",
      "resource",
    ],
    payloadSizeLimitBytes: 1e6,
    payloadHostDenyList: [
      ".lr-ingest.io",
      ".ingest.sentry.io",
      ".clarity.ms",
      "analytics.google.com",
      "bam.nr-data.net",
    ],
  },
  Aae = [
    "authorization",
    "x-forwarded-for",
    "authorization",
    "cookie",
    "set-cookie",
    "x-api-key",
    "x-real-ip",
    "remote-addr",
    "forwarded",
    "proxy-authorization",
    "x-csrf-token",
    "x-csrftoken",
    "x-xsrf-token",
  ],
  Rae = [
    "password",
    "secret",
    "passwd",
    "api_key",
    "apikey",
    "auth",
    "credentials",
    "mysql_pwd",
    "privatekey",
    "private_key",
    "token",
  ],
  kae = ["/s/", "/e/", "/i/"];
function WF(n, e, t, s) {
  if (yn(n)) return n;
  var r =
    e?.["content-length"] ||
    (function (i) {
      return new Blob([i]).size;
    })(n);
  return (
    ms(r) && (r = parseInt(r)),
    r > t ? $R + " " + s + " body too large to record (" + r + " bytes)" : n
  );
}
function KF(n, e) {
  if (yn(n)) return n;
  var t = n;
  return (
    yf(t, !1) || (t = $R + " " + e + " body " + BR),
    Dn(Rae, (s) => {
      var r, i;
      (r = t) != null &&
        r.length &&
        ((i = t) == null ? void 0 : i.indexOf(s)) !== -1 &&
        (t = $R + " " + e + " body " + BR + " as might contain: " + s);
    }),
    t
  );
}
var Cae = (n, e) => {
  var t,
    s,
    r,
    i = {
      payloadSizeLimitBytes: xy.payloadSizeLimitBytes,
      performanceEntryTypeToObserve: [...xy.performanceEntryTypeToObserve],
      payloadHostDenyList: [
        ...(e.payloadHostDenyList || []),
        ...xy.payloadHostDenyList,
      ],
    },
    a = n.session_recording.recordHeaders !== !1 && e.recordHeaders,
    o = n.session_recording.recordBody !== !1 && e.recordBody,
    l = n.capture_performance !== !1 && e.recordPerformance,
    c =
      ((t = i),
      (r = Math.min(
        1e6,
        (s = t.payloadSizeLimitBytes) !== null && s !== void 0 ? s : 1e6
      )),
      (p) => (
        p != null &&
          p.requestBody &&
          (p.requestBody = WF(p.requestBody, p.requestHeaders, r, "Request")),
        p != null &&
          p.responseBody &&
          (p.responseBody = WF(
            p.responseBody,
            p.responseHeaders,
            r,
            "Response"
          )),
        p
      )),
    h = (p) => {
      return c(
        ((b, w) => {
          var S,
            A = bf(b.name),
            _ =
              w.indexOf("http") === 0
                ? (S = bf(w)) == null
                  ? void 0
                  : S.pathname
                : w;
          _ === "/" && (_ = "");
          var R = A?.pathname.replace(_ || "", "");
          if (!(A && R && kae.some((C) => R.indexOf(C) === 0))) return b;
        })(
          ((y = (g = p).requestHeaders),
          yn(y) ||
            Dn(Object.keys(y ?? {}), (b) => {
              Aae.includes(b.toLowerCase()) && (y[b] = BR);
            }),
          g),
          n.api_host
        )
      );
      var g, y;
    },
    m = sa(n.session_recording.maskNetworkRequestFn);
  return (
    m &&
      sa(n.session_recording.maskCapturedNetworkRequestFn) &&
      at.warn(
        "Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."
      ),
    m &&
      (n.session_recording.maskCapturedNetworkRequestFn = (p) => {
        var g = n.session_recording.maskNetworkRequestFn({ url: p.name });
        return nt({}, p, { name: g?.url });
      }),
    (i.maskRequestFn = sa(n.session_recording.maskCapturedNetworkRequestFn)
      ? (p) => {
          var g,
            y = h(p);
          return y &&
            (g =
              n.session_recording.maskCapturedNetworkRequestFn == null
                ? void 0
                : n.session_recording.maskCapturedNetworkRequestFn(y)) !==
              null &&
            g !== void 0
            ? g
            : void 0;
        }
      : (p) =>
          (function (g) {
            if (!We(g))
              return (
                (g.requestBody = KF(g.requestBody, "Request")),
                (g.responseBody = KF(g.responseBody, "Response")),
                g
              );
          })(h(p))),
    nt({}, xy, i, {
      recordHeaders: a,
      recordBody: o,
      recordPerformance: l,
      recordInitialRequests: l,
    })
  );
};
let Iae = class {
  constructor(e, t) {
    var s, r;
    t === void 0 && (t = {}),
      (this.yt = {}),
      (this.wt = (i) => {
        if (!this.yt[i]) {
          var a, o;
          this.yt[i] = !0;
          var l = this.St(i);
          (a = (o = this.rt).onBlockedNode) == null || a.call(o, i, l);
        }
      }),
      (this.$t = (i) => {
        var a = this.St(i);
        if (a?.nodeName !== "svg" && a instanceof Element) {
          var o = a.closest("svg");
          if (o) return [this._rrweb.mirror.getId(o), o];
        }
        return [i, a];
      }),
      (this.St = (i) => this._rrweb.mirror.getNode(i)),
      (this.xt = (i) => {
        var a, o, l, c, h, m, p, g;
        return (
          ((a = (o = i.removes) == null ? void 0 : o.length) !== null &&
          a !== void 0
            ? a
            : 0) +
          ((l = (c = i.attributes) == null ? void 0 : c.length) !== null &&
          l !== void 0
            ? l
            : 0) +
          ((h = (m = i.texts) == null ? void 0 : m.length) !== null &&
          h !== void 0
            ? h
            : 0) +
          ((p = (g = i.adds) == null ? void 0 : g.length) !== null &&
          p !== void 0
            ? p
            : 0)
        );
      }),
      (this.throttleMutations = (i) => {
        if (i.type !== 3 || i.data.source !== 0) return i;
        var a = i.data,
          o = this.xt(a);
        a.attributes &&
          (a.attributes = a.attributes.filter((c) => {
            var [h] = this.$t(c.id);
            return !this.ct.consumeRateLimit(h) && c;
          }));
        var l = this.xt(a);
        return l !== 0 || o === l ? i : void 0;
      }),
      (this._rrweb = e),
      (this.rt = t),
      (this.ct = new j8({
        bucketSize: (s = this.rt.bucketSize) !== null && s !== void 0 ? s : 100,
        refillRate: (r = this.rt.refillRate) !== null && r !== void 0 ? r : 10,
        refillInterval: 1e3,
        et: this.wt,
      }));
  }
};
var ra = Uint8Array,
  ai = Uint16Array,
  xf = Uint32Array,
  ZI = new ra([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  JI = new ra([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  YF = new ra([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  H8 = function (n, e) {
    for (var t = new ai(31), s = 0; s < 31; ++s) t[s] = e += 1 << n[s - 1];
    var r = new xf(t[30]);
    for (s = 1; s < 30; ++s)
      for (var i = t[s]; i < t[s + 1]; ++i) r[i] = ((i - t[s]) << 5) | s;
    return [t, r];
  },
  V8 = H8(ZI, 2),
  Lae = V8[0],
  HR = V8[1];
(Lae[28] = 258), (HR[258] = 28);
for (var XF = H8(JI, 0)[1], z8 = new ai(32768), Gn = 0; Gn < 32768; ++Gn) {
  var yu = ((43690 & Gn) >>> 1) | ((21845 & Gn) << 1);
  (yu =
    ((61680 & (yu = ((52428 & yu) >>> 2) | ((13107 & yu) << 2))) >>> 4) |
    ((3855 & yu) << 4)),
    (z8[Gn] = (((65280 & yu) >>> 8) | ((255 & yu) << 8)) >>> 1);
}
var Gp = function (n, e, t) {
    for (var s = n.length, r = 0, i = new ai(e); r < s; ++r) ++i[n[r] - 1];
    var a,
      o = new ai(e);
    for (r = 0; r < e; ++r) o[r] = (o[r - 1] + i[r - 1]) << 1;
    for (a = new ai(s), r = 0; r < s; ++r)
      a[r] = z8[o[n[r] - 1]++] >>> (15 - n[r]);
    return a;
  },
  Yu = new ra(288);
for (Gn = 0; Gn < 144; ++Gn) Yu[Gn] = 8;
for (Gn = 144; Gn < 256; ++Gn) Yu[Gn] = 9;
for (Gn = 256; Gn < 280; ++Gn) Yu[Gn] = 7;
for (Gn = 280; Gn < 288; ++Gn) Yu[Gn] = 8;
var Rx = new ra(32);
for (Gn = 0; Gn < 32; ++Gn) Rx[Gn] = 5;
var Dae = Gp(Yu, 9),
  Pae = Gp(Rx, 5),
  G8 = function (n) {
    return ((n / 8) >> 0) + (7 & n && 1);
  },
  q8 = function (n, e, t) {
    (t == null || t > n.length) && (t = n.length);
    var s = new (n instanceof ai ? ai : n instanceof xf ? xf : ra)(t - e);
    return s.set(n.subarray(e, t)), s;
  },
  Zo = function (n, e, t) {
    t <<= 7 & e;
    var s = (e / 8) >> 0;
    (n[s] |= t), (n[s + 1] |= t >>> 8);
  },
  np = function (n, e, t) {
    t <<= 7 & e;
    var s = (e / 8) >> 0;
    (n[s] |= t), (n[s + 1] |= t >>> 8), (n[s + 2] |= t >>> 16);
  },
  l1 = function (n, e) {
    for (var t = [], s = 0; s < n.length; ++s) n[s] && t.push({ s, f: n[s] });
    var r = t.length,
      i = t.slice();
    if (!r) return [new ra(0), 0];
    if (r == 1) {
      var a = new ra(t[0].s + 1);
      return (a[t[0].s] = 1), [a, 1];
    }
    t.sort(function (C, D) {
      return C.f - D.f;
    }),
      t.push({ s: -1, f: 25001 });
    var o = t[0],
      l = t[1],
      c = 0,
      h = 1,
      m = 2;
    for (t[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != r - 1; )
      (o = t[t[c].f < t[m].f ? c++ : m++]),
        (l = t[c != h && t[c].f < t[m].f ? c++ : m++]),
        (t[h++] = { s: -1, f: o.f + l.f, l: o, r: l });
    var p = i[0].s;
    for (s = 1; s < r; ++s) i[s].s > p && (p = i[s].s);
    var g = new ai(p + 1),
      y = VR(t[h - 1], g, 0);
    if (y > e) {
      s = 0;
      var b = 0,
        w = y - e,
        S = 1 << w;
      for (
        i.sort(function (C, D) {
          return g[D.s] - g[C.s] || C.f - D.f;
        });
        s < r;
        ++s
      ) {
        var A = i[s].s;
        if (!(g[A] > e)) break;
        (b += S - (1 << (y - g[A]))), (g[A] = e);
      }
      for (b >>>= w; b > 0; ) {
        var _ = i[s].s;
        g[_] < e ? (b -= 1 << (e - g[_]++ - 1)) : ++s;
      }
      for (; s >= 0 && b; --s) {
        var R = i[s].s;
        g[R] == e && (--g[R], ++b);
      }
      y = e;
    }
    return [new ra(g), y];
  },
  VR = function (n, e, t) {
    return n.s == -1
      ? Math.max(VR(n.l, e, t + 1), VR(n.r, e, t + 1))
      : (e[n.s] = t);
  },
  QF = function (n) {
    for (var e = n.length; e && !n[--e]; );
    for (
      var t = new ai(++e),
        s = 0,
        r = n[0],
        i = 1,
        a = function (l) {
          t[s++] = l;
        },
        o = 1;
      o <= e;
      ++o
    )
      if (n[o] == r && o != e) ++i;
      else {
        if (!r && i > 2) {
          for (; i > 138; i -= 138) a(32754);
          i > 2 &&
            (a(i > 10 ? ((i - 11) << 5) | 28690 : ((i - 3) << 5) | 12305),
            (i = 0));
        } else if (i > 3) {
          for (a(r), --i; i > 6; i -= 6) a(8304);
          i > 2 && (a(((i - 3) << 5) | 8208), (i = 0));
        }
        for (; i--; ) a(r);
        (i = 1), (r = n[o]);
      }
    return [t.subarray(0, s), e];
  },
  sp = function (n, e) {
    for (var t = 0, s = 0; s < e.length; ++s) t += n[s] * e[s];
    return t;
  },
  zR = function (n, e, t) {
    var s = t.length,
      r = G8(e + 2);
    (n[r] = 255 & s),
      (n[r + 1] = s >>> 8),
      (n[r + 2] = 255 ^ n[r]),
      (n[r + 3] = 255 ^ n[r + 1]);
    for (var i = 0; i < s; ++i) n[r + i + 4] = t[i];
    return 8 * (r + 4 + s);
  },
  ZF = function (n, e, t, s, r, i, a, o, l, c, h) {
    Zo(e, h++, t), ++r[256];
    for (
      var m = l1(r, 15),
        p = m[0],
        g = m[1],
        y = l1(i, 15),
        b = y[0],
        w = y[1],
        S = QF(p),
        A = S[0],
        _ = S[1],
        R = QF(b),
        C = R[0],
        D = R[1],
        L = new ai(19),
        P = 0;
      P < A.length;
      ++P
    )
      L[31 & A[P]]++;
    for (P = 0; P < C.length; ++P) L[31 & C[P]]++;
    for (
      var V = l1(L, 7), N = V[0], W = V[1], H = 19;
      H > 4 && !N[YF[H - 1]];
      --H
    );
    var z,
      B,
      q,
      O,
      U = (c + 5) << 3,
      j = sp(r, Yu) + sp(i, Rx) + a,
      Q =
        sp(r, p) +
        sp(i, b) +
        a +
        14 +
        3 * H +
        sp(L, N) +
        (2 * L[16] + 3 * L[17] + 7 * L[18]);
    if (U <= j && U <= Q) return zR(e, h, n.subarray(l, l + c));
    if ((Zo(e, h, 1 + (Q < j)), (h += 2), Q < j)) {
      (z = Gp(p, g)), (B = p), (q = Gp(b, w)), (O = b);
      var M = Gp(N, W);
      for (
        Zo(e, h, _ - 257),
          Zo(e, h + 5, D - 1),
          Zo(e, h + 10, H - 4),
          h += 14,
          P = 0;
        P < H;
        ++P
      )
        Zo(e, h + 3 * P, N[YF[P]]);
      h += 3 * H;
      for (var I = [A, C], F = 0; F < 2; ++F) {
        var Y = I[F];
        for (P = 0; P < Y.length; ++P) {
          var J = 31 & Y[P];
          Zo(e, h, M[J]),
            (h += N[J]),
            J > 15 && (Zo(e, h, (Y[P] >>> 5) & 127), (h += Y[P] >>> 12));
        }
      }
    } else (z = Dae), (B = Yu), (q = Pae), (O = Rx);
    for (P = 0; P < o; ++P)
      if (s[P] > 255) {
        (J = (s[P] >>> 18) & 31),
          np(e, h, z[J + 257]),
          (h += B[J + 257]),
          J > 7 && (Zo(e, h, (s[P] >>> 23) & 31), (h += ZI[J]));
        var X = 31 & s[P];
        np(e, h, q[X]),
          (h += O[X]),
          X > 3 && (np(e, h, (s[P] >>> 5) & 8191), (h += JI[X]));
      } else np(e, h, z[s[P]]), (h += B[s[P]]);
    return np(e, h, z[256]), h + B[256];
  },
  Mae = new xf([
    65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632,
  ]),
  Nae = (function () {
    for (var n = new xf(256), e = 0; e < 256; ++e) {
      for (var t = e, s = 9; --s; ) t = (1 & t && 3988292384) ^ (t >>> 1);
      n[e] = t;
    }
    return n;
  })(),
  Oae = function () {
    var n = 4294967295;
    return {
      p: function (e) {
        for (var t = n, s = 0; s < e.length; ++s)
          t = Nae[(255 & t) ^ e[s]] ^ (t >>> 8);
        n = t;
      },
      d: function () {
        return 4294967295 ^ n;
      },
    };
  },
  jae = function (n, e, t, s, r) {
    return (function (i, a, o, l, c, h) {
      var m = i.length,
        p = new ra(l + m + 5 * (1 + Math.floor(m / 7e3)) + c),
        g = p.subarray(l, p.length - c),
        y = 0;
      if (!a || m < 8)
        for (var b = 0; b <= m; b += 65535) {
          var w = b + 65535;
          w < m
            ? (y = zR(g, y, i.subarray(b, w)))
            : ((g[b] = h), (y = zR(g, y, i.subarray(b, m))));
        }
      else {
        for (
          var S = Mae[a - 1],
            A = S >>> 13,
            _ = 8191 & S,
            R = (1 << o) - 1,
            C = new ai(32768),
            D = new ai(R + 1),
            L = Math.ceil(o / 3),
            P = 2 * L,
            V = function (re) {
              return (i[re] ^ (i[re + 1] << L) ^ (i[re + 2] << P)) & R;
            },
            N = new xf(25e3),
            W = new ai(288),
            H = new ai(32),
            z = 0,
            B = 0,
            q = ((b = 0), 0),
            O = 0,
            U = 0;
          b < m;
          ++b
        ) {
          var j = V(b),
            Q = 32767 & b,
            M = D[j];
          if (((C[Q] = M), (D[j] = Q), O <= b)) {
            var I = m - b;
            if ((z > 7e3 || q > 24576) && I > 423) {
              (y = ZF(i, g, 0, N, W, H, B, q, U, b - U, y)),
                (q = z = B = 0),
                (U = b);
              for (var F = 0; F < 286; ++F) W[F] = 0;
              for (F = 0; F < 30; ++F) H[F] = 0;
            }
            var Y = 2,
              J = 0,
              X = _,
              Z = (Q - M) & 32767;
            if (I > 2 && j == V(b - Z))
              for (
                var te = Math.min(A, I) - 1,
                  ce = Math.min(32767, b),
                  pe = Math.min(258, I);
                Z <= ce && --X && Q != M;

              ) {
                if (i[b + Y] == i[b + Y - Z]) {
                  for (var se = 0; se < pe && i[b + se] == i[b + se - Z]; ++se);
                  if (se > Y) {
                    if (((Y = se), (J = Z), se > te)) break;
                    var be = Math.min(Z, se - 2),
                      K = 0;
                    for (F = 0; F < be; ++F) {
                      var ve = (b - Z + F + 32768) & 32767,
                        Ee = (ve - C[ve] + 32768) & 32767;
                      Ee > K && ((K = Ee), (M = ve));
                    }
                  }
                }
                Z += ((Q = M) - (M = C[Q]) + 32768) & 32767;
              }
            if (J) {
              N[q++] = 268435456 | (HR[Y] << 18) | XF[J];
              var De = 31 & HR[Y],
                ge = 31 & XF[J];
              (B += ZI[De] + JI[ge]), ++W[257 + De], ++H[ge], (O = b + Y), ++z;
            } else (N[q++] = i[b]), ++W[i[b]];
          }
        }
        y = ZF(i, g, h, N, W, H, B, q, U, b - U, y);
      }
      return q8(p, 0, l + G8(y) + c);
    })(
      n,
      e.level == null ? 6 : e.level,
      e.mem == null
        ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(n.length))))
        : 12 + e.mem,
      t,
      s,
      !0
    );
  },
  GR = function (n, e, t) {
    for (; t; ++e) (n[e] = t), (t >>>= 8);
  },
  Fae = function (n, e) {
    var t = e.filename;
    if (
      ((n[0] = 31),
      (n[1] = 139),
      (n[2] = 8),
      (n[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0),
      (n[9] = 3),
      e.mtime != 0 &&
        GR(n, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
      t)
    ) {
      n[3] = 8;
      for (var s = 0; s <= t.length; ++s) n[s + 10] = t.charCodeAt(s);
    }
  },
  Uae = function (n) {
    return 10 + ((n.filename && n.filename.length + 1) || 0);
  };
function W8(n, e) {
  e === void 0 && (e = {});
  var t = Oae(),
    s = n.length;
  t.p(n);
  var r = jae(n, e, Uae(e), 8),
    i = r.length;
  return Fae(r, e), GR(r, i - 8, t.d()), GR(r, i - 4, s), r;
}
function K8(n, e) {
  var t = n.length;
  if (typeof TextEncoder < "u") return new TextEncoder().encode(n);
  for (
    var s = new ra(n.length + (n.length >>> 1)),
      r = 0,
      i = function (c) {
        s[r++] = c;
      },
      a = 0;
    a < t;
    ++a
  ) {
    if (r + 5 > s.length) {
      var o = new ra(r + 8 + ((t - a) << 1));
      o.set(s), (s = o);
    }
    var l = n.charCodeAt(a);
    l < 128 || e
      ? i(l)
      : l < 2048
      ? (i(192 | (l >>> 6)), i(128 | (63 & l)))
      : l > 55295 && l < 57344
      ? (i(
          240 |
            ((l = (65536 + (1047552 & l)) | (1023 & n.charCodeAt(++a))) >>> 18)
        ),
        i(128 | ((l >>> 12) & 63)),
        i(128 | ((l >>> 6) & 63)),
        i(128 | (63 & l)))
      : (i(224 | (l >>> 12)), i(128 | ((l >>> 6) & 63)), i(128 | (63 & l)));
  }
  return q8(s, 0, r);
}
function $ae(n, e) {
  return (
    (function (t) {
      for (var s = 0, r = 0; r < t.length; r++)
        (s = (s << 5) - s + t.charCodeAt(r)), (s |= 0);
      return Math.abs(s);
    })(n) %
      100 <
    Ai(100 * e, 0, 100)
  );
}
var Pc = "disabled",
  eL = "sampled",
  kx = "active",
  Xu = "buffering",
  tL = "paused",
  nL = "trigger",
  Ro = nL + "_activated",
  Lr = nL + "_pending",
  Po = nL + "_" + Pc;
function JF(n, e) {
  return e.some((t) => t.matching === "regex" && new RegExp(t.url).test(n));
}
class Y8 {
  constructor(e) {
    this.kt = e;
  }
  triggerStatus(e) {
    var t = this.kt.map((s) => s.triggerStatus(e));
    return t.includes(Ro) ? Ro : t.includes(Lr) ? Lr : Po;
  }
  stop() {
    this.kt.forEach((e) => e.stop());
  }
}
class X8 {
  constructor(e) {
    this.kt = e;
  }
  triggerStatus(e) {
    var t = new Set();
    for (var s of this.kt) t.add(s.triggerStatus(e));
    switch ((t.delete(Po), t.size)) {
      case 0:
        return Po;
      case 1:
        return Array.from(t)[0];
      default:
        return Lr;
    }
  }
  stop() {
    this.kt.forEach((e) => e.stop());
  }
}
class Bae {
  triggerStatus() {
    return Lr;
  }
  stop() {}
}
class Hae {
  constructor(e) {
    (this.Et = []),
      (this.It = []),
      (this.urlBlocked = !1),
      (this._instance = e);
  }
  onRemoteConfig(e) {
    var t, s;
    (this.Et =
      ((t = e.sessionRecording) == null ? void 0 : t.urlTriggers) || []),
      (this.It =
        ((s = e.sessionRecording) == null ? void 0 : s.urlBlocklist) || []);
  }
  Pt(e) {
    var t;
    return this.Et.length === 0
      ? Po
      : ((t = this._instance) == null ? void 0 : t.get_property(CR)) === e
      ? Ro
      : Lr;
  }
  triggerStatus(e) {
    var t = this.Pt(e),
      s = t === Ro ? Ro : t === Lr ? Lr : Po;
    return (
      this._instance.register_for_session({
        $sdk_debug_replay_url_trigger_status: s,
      }),
      s
    );
  }
  checkUrlTriggerConditions(e, t, s) {
    if (Re !== void 0 && Re.location.href) {
      var r = Re.location.href,
        i = this.urlBlocked,
        a = JF(r, this.It);
      (i && a) || (a && !i ? e() : !a && i && t(), JF(r, this.Et) && s("url"));
    }
  }
  stop() {}
}
let Vae = class {
  constructor(e) {
    (this.linkedFlag = null),
      (this.linkedFlagSeen = !1),
      (this.Rt = () => {}),
      (this._instance = e);
  }
  triggerStatus() {
    var e = Lr;
    return (
      yn(this.linkedFlag) && (e = Po),
      this.linkedFlagSeen && (e = Ro),
      this._instance.register_for_session({
        $sdk_debug_replay_linked_flag_trigger_status: e,
      }),
      e
    );
  }
  onRemoteConfig(e, t) {
    var s;
    if (
      ((this.linkedFlag =
        ((s = e.sessionRecording) == null ? void 0 : s.linkedFlag) || null),
      !yn(this.linkedFlag) && !this.linkedFlagSeen)
    ) {
      var r = ms(this.linkedFlag) ? this.linkedFlag : this.linkedFlag.flag,
        i = ms(this.linkedFlag) ? null : this.linkedFlag.variant;
      this.Rt = this._instance.onFeatureFlags((a, o) => {
        var l = !1;
        if (fs(o) && r in o) {
          var c = o[r];
          l = bo(c) ? c === !0 : i ? c === i : !!c;
        }
        (this.linkedFlagSeen = l), l && t(r, i);
      });
    }
  }
  stop() {
    this.Rt();
  }
};
class zae {
  constructor(e) {
    (this.Tt = []), (this._instance = e);
  }
  onRemoteConfig(e) {
    var t;
    this.Tt =
      ((t = e.sessionRecording) == null ? void 0 : t.eventTriggers) || [];
  }
  Mt(e) {
    var t;
    return this.Tt.length === 0
      ? Po
      : ((t = this._instance) == null ? void 0 : t.get_property(IR)) === e
      ? Ro
      : Lr;
  }
  triggerStatus(e) {
    var t = this.Mt(e),
      s = t === Ro ? Ro : t === Lr ? Lr : Po;
    return (
      this._instance.register_for_session({
        $sdk_debug_replay_event_trigger_status: s,
      }),
      s
    );
  }
  stop() {}
}
function Gae(n) {
  return n.isRecordingEnabled ? Xu : Pc;
}
function qae(n) {
  if (!n.receivedFlags) return Xu;
  if (!n.isRecordingEnabled) return Pc;
  if (n.urlTriggerMatching.urlBlocked) return tL;
  var e = n.isSampled === !0,
    t = new Y8([
      n.eventTriggerMatching,
      n.urlTriggerMatching,
      n.linkedFlagMatching,
    ]).triggerStatus(n.sessionId);
  return e ? eL : t === Ro ? kx : t === Lr ? Xu : n.isSampled === !1 ? Pc : kx;
}
function Wae(n) {
  if (!n.receivedFlags) return Xu;
  if (!n.isRecordingEnabled) return Pc;
  if (n.urlTriggerMatching.urlBlocked) return tL;
  var e = new X8([
      n.eventTriggerMatching,
      n.urlTriggerMatching,
      n.linkedFlagMatching,
    ]).triggerStatus(n.sessionId),
    t = e !== Po,
    s = bo(n.isSampled);
  return t && e === Lr
    ? Xu
    : (t && e === Po) || (s && !n.isSampled)
    ? Pc
    : n.isSampled === !0
    ? eL
    : kx;
}
var Sp = "[SessionRecording]",
  Sr = cr(Sp);
function wy() {
  var n;
  return Mt == null ||
    (n = Mt.__PosthogExtensions__) == null ||
    (n = n.rrweb) == null
    ? void 0
    : n.record;
}
var Kae = 3e5,
  Yae = [
    Sa.MouseMove,
    Sa.MouseInteraction,
    Sa.Scroll,
    Sa.ViewportResize,
    Sa.Input,
    Sa.TouchMove,
    Sa.MediaInteraction,
    Sa.Drag,
  ],
  eU = (n) => ({ rrwebMethod: n, enqueuedAt: Date.now(), attempt: 1 });
function bu(n) {
  return (function (e, t) {
    for (var s = "", r = 0; r < e.length; ) {
      var i = e[r++];
      s += String.fromCharCode(i);
    }
    return s;
  })(W8(K8(JSON.stringify(n))));
}
function tU(n) {
  return n.type === hl.Custom && n.data.tag === "sessionIdle";
}
class Xae {
  get sessionId() {
    return this.Ct;
  }
  get Ft() {
    return (
      this._instance.config.session_recording.session_idle_threshold_ms || 3e5
    );
  }
  get started() {
    return this.Ot;
  }
  get At() {
    if (!this._instance.sessionManager)
      throw new Error(Sp + " must be started with a valid sessionManager.");
    return this._instance.sessionManager;
  }
  get Dt() {
    var e, t;
    return this.Lt.triggerStatus(this.sessionId) === Lr
      ? 6e4
      : (e =
          (t = this._instance.config.session_recording) == null
            ? void 0
            : t.full_snapshot_interval_millis) !== null && e !== void 0
      ? e
      : Kae;
  }
  get jt() {
    var e = this._instance.get_property(wp);
    return bo(e) ? e : null;
  }
  get Nt() {
    var e,
      t,
      s =
        (e = this.C) == null
          ? void 0
          : e.data[((t = this.C) == null ? void 0 : t.data.length) - 1],
      { sessionStartTimestamp: r } = this.At.checkAndGetSessionAndWindowId(!0);
    return s ? s.timestamp - r : null;
  }
  get zt() {
    var e = !!this._instance.get_property(kR),
      t = !this._instance.config.disable_session_recording;
    return Re && e && t;
  }
  get Ut() {
    var e = !!this._instance.get_property(CF),
      t = this._instance.config.enable_recording_console_log;
    return t ?? e;
  }
  get qt() {
    var e,
      t,
      s,
      r,
      i,
      a,
      o = this._instance.config.session_recording.captureCanvas,
      l = this._instance.get_property(DF),
      c =
        (e =
          (t = o?.recordCanvas) !== null && t !== void 0 ? t : l?.enabled) !==
          null &&
        e !== void 0 &&
        e,
      h =
        (s = (r = o?.canvasFps) !== null && r !== void 0 ? r : l?.fps) !==
          null && s !== void 0
          ? s
          : 4,
      m =
        (i =
          (a = o?.canvasQuality) !== null && a !== void 0 ? a : l?.quality) !==
          null && i !== void 0
          ? i
          : 0.4;
    if (typeof m == "string") {
      var p = parseFloat(m);
      m = isNaN(p) ? 0.4 : p;
    }
    return {
      enabled: c,
      fps: Ai(h, 0, 12, "canvas recording fps", 4),
      quality: Ai(m, 0, 1, "canvas recording quality", 0.4),
    };
  }
  get Bt() {
    var e,
      t,
      s = this._instance.get_property(IF),
      r = {
        recordHeaders:
          (e = this._instance.config.session_recording) == null
            ? void 0
            : e.recordHeaders,
        recordBody:
          (t = this._instance.config.session_recording) == null
            ? void 0
            : t.recordBody,
      },
      i = r?.recordHeaders || s?.recordHeaders,
      a = r?.recordBody || s?.recordBody,
      o = fs(this._instance.config.capture_performance)
        ? this._instance.config.capture_performance.network_timing
        : this._instance.config.capture_performance,
      l = !!(bo(o) ? o : s?.capturePerformance);
    return i || a || l
      ? { recordHeaders: i, recordBody: a, recordPerformance: l }
      : void 0;
  }
  get Ht() {
    var e,
      t,
      s,
      r,
      i,
      a,
      o = this._instance.get_property(LF),
      l = {
        maskAllInputs:
          (e = this._instance.config.session_recording) == null
            ? void 0
            : e.maskAllInputs,
        maskTextSelector:
          (t = this._instance.config.session_recording) == null
            ? void 0
            : t.maskTextSelector,
        blockSelector:
          (s = this._instance.config.session_recording) == null
            ? void 0
            : s.blockSelector,
      },
      c =
        (r = l?.maskAllInputs) !== null && r !== void 0 ? r : o?.maskAllInputs,
      h =
        (i = l?.maskTextSelector) !== null && i !== void 0
          ? i
          : o?.maskTextSelector,
      m =
        (a = l?.blockSelector) !== null && a !== void 0 ? a : o?.blockSelector;
    return We(c) && We(h) && We(m)
      ? void 0
      : {
          maskAllInputs: c == null || c,
          maskTextSelector: h,
          blockSelector: m,
        };
  }
  get Wt() {
    var e = this._instance.get_property(PF);
    return Cr(e) ? e : null;
  }
  get Gt() {
    var e = this._instance.get_property(MF);
    return Cr(e) ? e : null;
  }
  get status() {
    return this.Jt
      ? this.Vt({
          receivedFlags: this.Jt,
          isRecordingEnabled: this.zt,
          isSampled: this.jt,
          urlTriggerMatching: this.Kt,
          eventTriggerMatching: this.Yt,
          linkedFlagMatching: this.Xt,
          sessionId: this.sessionId,
        })
      : Xu;
  }
  constructor(e) {
    if (
      ((this.Vt = Gae),
      (this.Jt = !1),
      (this.Qt = []),
      (this.Zt = "unknown"),
      (this.ti = Date.now()),
      (this.Lt = new Bae()),
      (this.ii = void 0),
      (this.ei = void 0),
      (this.ri = void 0),
      (this.si = void 0),
      (this.ni = void 0),
      (this._forceAllowLocalhostNetworkCapture = !1),
      (this.oi = () => {
        this.ai();
      }),
      (this.li = () => {
        this.ui("browser offline", {});
      }),
      (this.hi = () => {
        this.ui("browser online", {});
      }),
      (this.di = () => {
        if (rt != null && rt.visibilityState) {
          var r = "window " + rt.visibilityState;
          this.ui(r, {});
        }
      }),
      (this._instance = e),
      (this.Ot = !1),
      (this.vi = "/s/"),
      (this.ci = void 0),
      (this.Jt = !1),
      !this._instance.sessionManager)
    )
      throw (
        (Sr.error("started without valid sessionManager"),
        new Error(Sp + " started without valid sessionManager. This is a bug."))
      );
    if (this._instance.config.__preview_experimental_cookieless_mode)
      throw new Error(
        Sp + " cannot be used with __preview_experimental_cookieless_mode."
      );
    (this.Xt = new Vae(this._instance)),
      (this.Kt = new Hae(this._instance)),
      (this.Yt = new zae(this._instance));
    var { sessionId: t, windowId: s } = this.At.checkAndGetSessionAndWindowId();
    (this.Ct = t),
      (this.fi = s),
      (this.C = this.pi()),
      this.Ft >= this.At.sessionTimeoutMs &&
        Sr.warn(
          "session_idle_threshold_ms (" +
            this.Ft +
            ") is greater than the session timeout (" +
            this.At.sessionTimeoutMs +
            "). Session will never be detected as idle"
        );
  }
  startIfEnabledOrStop(e) {
    this.zt
      ? (this.gi(e),
        is(Re, "beforeunload", this.oi),
        is(Re, "offline", this.li),
        is(Re, "online", this.hi),
        is(Re, "visibilitychange", this.di),
        this.mi(),
        this.bi(),
        yn(this.ii) &&
          (this.ii = this._instance.on("eventCaptured", (t) => {
            try {
              if (t.event === "$pageview") {
                var s =
                  t != null && t.properties.$current_url
                    ? this.yi(t?.properties.$current_url)
                    : "";
                if (!s) return;
                this.ui("$pageview", { href: s });
              }
            } catch (r) {
              Sr.error("Could not add $pageview to rrweb session", r);
            }
          })),
        this.ei ||
          (this.ei = this.At.onSessionId((t, s, r) => {
            var i, a;
            r &&
              (this.ui("$session_id_change", {
                sessionId: t,
                windowId: s,
                changeReason: r,
              }),
              (i = this._instance) == null ||
                (i = i.persistence) == null ||
                i.unregister(IR),
              (a = this._instance) == null ||
                (a = a.persistence) == null ||
                a.unregister(CR));
          })))
      : this.stopRecording();
  }
  stopRecording() {
    var e, t, s, r;
    this.Ot &&
      this.ci &&
      (this.ci(),
      (this.ci = void 0),
      (this.Ot = !1),
      Re?.removeEventListener("beforeunload", this.oi),
      Re?.removeEventListener("offline", this.li),
      Re?.removeEventListener("online", this.hi),
      Re?.removeEventListener("visibilitychange", this.di),
      this.pi(),
      clearInterval(this.wi),
      (e = this.ii) == null || e.call(this),
      (this.ii = void 0),
      (t = this.ni) == null || t.call(this),
      (this.ni = void 0),
      (s = this.ei) == null || s.call(this),
      (this.ei = void 0),
      (r = this.si) == null || r.call(this),
      (this.si = void 0),
      this.Yt.stop(),
      this.Kt.stop(),
      this.Xt.stop(),
      Sr.info("stopped"));
  }
  Si() {
    var e;
    (e = this._instance.persistence) == null || e.unregister(wp);
  }
  $i(e) {
    var t,
      s = this.Ct !== e,
      r = this.Wt;
    if (Cr(r)) {
      var i = this.jt,
        a = s || !bo(i),
        o = a ? $ae(e, r) : i;
      a &&
        (o
          ? this.xi(eL)
          : Sr.warn(
              "Sample rate (" +
                r +
                ") has determined that this sessionId (" +
                e +
                ") will not be sent to the server."
            ),
        this.ui("samplingDecisionMade", { sampleRate: r, isSampled: o })),
        (t = this._instance.persistence) == null || t.register({ [wp]: o });
    } else this.Si();
  }
  onRemoteConfig(e) {
    var t, s, r, i;
    this.ui("$remote_config_received", e),
      this.ki(e),
      (t = e.sessionRecording) != null &&
        t.endpoint &&
        (this.vi = (i = e.sessionRecording) == null ? void 0 : i.endpoint),
      this.mi(),
      ((s = e.sessionRecording) == null ? void 0 : s.triggerMatchType) === "any"
        ? ((this.Vt = qae), (this.Lt = new Y8([this.Yt, this.Kt])))
        : ((this.Vt = Wae), (this.Lt = new X8([this.Yt, this.Kt]))),
      this._instance.register_for_session({
        $sdk_debug_replay_remote_trigger_matching_config:
          (r = e.sessionRecording) == null ? void 0 : r.triggerMatchType,
      }),
      this.Kt.onRemoteConfig(e),
      this.Yt.onRemoteConfig(e),
      this.Xt.onRemoteConfig(e, (a, o) => {
        this.xi("linked_flag_matched", { flag: a, variant: o });
      }),
      (this.Jt = !0),
      this.startIfEnabledOrStop();
  }
  mi() {
    Cr(this.Wt) &&
      yn(this.si) &&
      (this.si = this.At.onSessionId((e) => {
        this.$i(e);
      }));
  }
  ki(e) {
    if (this._instance.persistence) {
      var t,
        s = this._instance.persistence,
        r = () => {
          var i,
            a,
            o,
            l,
            c,
            h,
            m,
            p,
            g,
            y = (i = e.sessionRecording) == null ? void 0 : i.sampleRate,
            b = yn(y) ? null : parseFloat(y);
          yn(b) && this.Si();
          var w =
            (a = e.sessionRecording) == null
              ? void 0
              : a.minimumDurationMilliseconds;
          s.register({
            [kR]: !!e.sessionRecording,
            [CF]:
              (o = e.sessionRecording) == null
                ? void 0
                : o.consoleLogRecordingEnabled,
            [IF]: nt(
              { capturePerformance: e.capturePerformance },
              (l = e.sessionRecording) == null
                ? void 0
                : l.networkPayloadCapture
            ),
            [LF]: (c = e.sessionRecording) == null ? void 0 : c.masking,
            [DF]: {
              enabled:
                (h = e.sessionRecording) == null ? void 0 : h.recordCanvas,
              fps: (m = e.sessionRecording) == null ? void 0 : m.canvasFps,
              quality:
                (p = e.sessionRecording) == null ? void 0 : p.canvasQuality,
            },
            [PF]: b,
            [MF]: We(w) ? null : w,
            [NF]: (g = e.sessionRecording) == null ? void 0 : g.scriptConfig,
          });
        };
      r(),
        (t = this.ri) == null || t.call(this),
        (this.ri = this.At.onSessionId(r));
    }
  }
  log(e, t) {
    var s;
    t === void 0 && (t = "log"),
      (s = this._instance.sessionRecording) == null ||
        s.onRRwebEmit({
          type: 6,
          data: {
            plugin: "rrweb/console@1",
            payload: { level: t, trace: [], payload: [JSON.stringify(e)] },
          },
          timestamp: Date.now(),
        });
  }
  gi(e) {
    if (
      !We(Object.assign) &&
      !We(Array.from) &&
      !(
        this.Ot ||
        this._instance.config.disable_session_recording ||
        this._instance.consent.isOptedOut()
      )
    ) {
      var t;
      (this.Ot = !0),
        this.At.checkAndGetSessionAndWindowId(),
        wy()
          ? this.Ei()
          : (t = Mt.__PosthogExtensions__) == null ||
            t.loadExternalDependency == null ||
            t.loadExternalDependency(this._instance, this.Ii, (s) => {
              if (s) return Sr.error("could not load recorder", s);
              this.Ei();
            }),
        Sr.info("starting"),
        this.status === kx && this.xi(e || "recording_initialized");
    }
  }
  get Ii() {
    var e;
    return (
      ((e = this._instance) == null ||
      (e = e.persistence) == null ||
      (e = e.get_property(NF)) == null
        ? void 0
        : e.script) || "recorder"
    );
  }
  Pi(e) {
    var t;
    return (
      e.type === 3 &&
      Yae.indexOf((t = e.data) == null ? void 0 : t.source) !== -1
    );
  }
  Ri(e) {
    var t = this.Pi(e);
    t ||
      this.Zt ||
      (e.timestamp - this.ti > this.Ft &&
        ((this.Zt = !0),
        clearInterval(this.wi),
        this.ui("sessionIdle", {
          eventTimestamp: e.timestamp,
          lastActivityTimestamp: this.ti,
          threshold: this.Ft,
          bufferLength: this.C.data.length,
          bufferSize: this.C.size,
        }),
        this.ai()));
    var s = !1;
    if (t && ((this.ti = e.timestamp), this.Zt)) {
      var r = this.Zt === "unknown";
      (this.Zt = !1),
        r ||
          (this.ui("sessionNoLongerIdle", {
            reason: "user activity",
            type: e.type,
          }),
          (s = !0));
    }
    if (!this.Zt) {
      var { windowId: i, sessionId: a } = this.At.checkAndGetSessionAndWindowId(
          !t,
          e.timestamp
        ),
        o = this.Ct !== a,
        l = this.fi !== i;
      (this.fi = i),
        (this.Ct = a),
        o || l
          ? (this.stopRecording(),
            this.startIfEnabledOrStop("session_id_changed"))
          : s && this.Ti();
    }
  }
  Mi(e) {
    try {
      return e.rrwebMethod(), !0;
    } catch (t) {
      return (
        this.Qt.length < 10
          ? this.Qt.push({
              enqueuedAt: e.enqueuedAt || Date.now(),
              attempt: e.attempt++,
              rrwebMethod: e.rrwebMethod,
            })
          : Sr.warn("could not emit queued rrweb event.", t, e),
        !1
      );
    }
  }
  ui(e, t) {
    return this.Mi(eU(() => wy().addCustomEvent(e, t)));
  }
  Ci() {
    return this.Mi(eU(() => wy().takeFullSnapshot()));
  }
  Ei() {
    var e,
      t,
      s,
      r,
      i = {
        blockClass: "ph-no-capture",
        blockSelector: void 0,
        ignoreClass: "ph-ignore-input",
        maskTextClass: "ph-mask",
        maskTextSelector: void 0,
        maskTextFn: void 0,
        maskAllInputs: !0,
        maskInputOptions: { password: !0 },
        maskInputFn: void 0,
        slimDOMOptions: {},
        collectFonts: !1,
        inlineStylesheet: !0,
        recordCrossOriginIframes: !1,
      },
      a = this._instance.config.session_recording;
    for (var [o, l] of Object.entries(a || {}))
      o in i &&
        (o === "maskInputOptions"
          ? (i.maskInputOptions = nt({ password: !0 }, l))
          : (i[o] = l));
    this.qt &&
      this.qt.enabled &&
      ((i.recordCanvas = !0),
      (i.sampling = { canvas: this.qt.fps }),
      (i.dataURLOptions = { type: "image/webp", quality: this.qt.quality })),
      this.Ht &&
        ((i.maskAllInputs =
          (t = this.Ht.maskAllInputs) === null || t === void 0 || t),
        (i.maskTextSelector =
          (s = this.Ht.maskTextSelector) !== null && s !== void 0 ? s : void 0),
        (i.blockSelector =
          (r = this.Ht.blockSelector) !== null && r !== void 0 ? r : void 0));
    var c = wy();
    if (c) {
      this.Fi =
        (e = this.Fi) !== null && e !== void 0
          ? e
          : new Iae(c, {
              refillRate:
                this._instance.config.session_recording
                  .__mutationThrottlerRefillRate,
              bucketSize:
                this._instance.config.session_recording
                  .__mutationThrottlerBucketSize,
              onBlockedNode: (m, p) => {
                var g =
                  "Too many mutations on node '" +
                  m +
                  "'. Rate limiting. This could be due to SVG animations or something similar";
                Sr.info(g, { node: p }), this.log(Sp + " " + g, "warn");
              },
            });
      var h = this.Oi();
      (this.ci = c(
        nt(
          {
            emit: (m) => {
              this.onRRwebEmit(m);
            },
            plugins: h,
          },
          i
        )
      )),
        (this.ti = Date.now()),
        (this.Zt = bo(this.Zt) ? this.Zt : "unknown"),
        this.ui("$session_options", {
          sessionRecordingOptions: i,
          activePlugins: h.map((m) => m?.name),
        }),
        this.ui("$posthog_config", { config: this._instance.config });
    } else
      Sr.error(
        "onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong."
      );
  }
  Ti() {
    if ((this.wi && clearInterval(this.wi), this.Zt !== !0)) {
      var e = this.Dt;
      e &&
        (this.wi = setInterval(() => {
          this.Ci();
        }, e));
    }
  }
  Oi() {
    var e,
      t,
      s = [],
      r =
        (e = Mt.__PosthogExtensions__) == null || (e = e.rrwebPlugins) == null
          ? void 0
          : e.getRecordConsolePlugin;
    r && this.Ut && s.push(r());
    var i =
      (t = Mt.__PosthogExtensions__) == null || (t = t.rrwebPlugins) == null
        ? void 0
        : t.getRecordNetworkPlugin;
    return (
      this.Bt &&
        sa(i) &&
        (!Yie.includes(location.hostname) ||
        this._forceAllowLocalhostNetworkCapture
          ? s.push(i(Cae(this._instance.config, this.Bt)))
          : Sr.info("NetworkCapture not started because we are on localhost.")),
      s
    );
  }
  onRRwebEmit(e) {
    var t;
    if ((this.Ai(), e && fs(e))) {
      if (e.type === hl.Meta) {
        var s = this.yi(e.data.href);
        if (((this.Di = s), !s)) return;
        e.data.href = s;
      } else this.Li();
      if (
        (this.Kt.checkUrlTriggerConditions(
          () => this.ji(),
          () => this.Ni(),
          (p) => this.zi(p)
        ),
        !this.Kt.urlBlocked ||
          ((r = e).type === hl.Custom && r.data.tag === "recording paused"))
      ) {
        var r;
        e.type === hl.FullSnapshot && this.Ti(),
          e.type === hl.FullSnapshot &&
            this.Jt &&
            this.Lt.triggerStatus(this.sessionId) === Lr &&
            this.pi();
        var i = this.Fi ? this.Fi.throttleMutations(e) : e;
        if (i) {
          var a = (function (p) {
            var g = p;
            if (
              g &&
              fs(g) &&
              g.type === 6 &&
              fs(g.data) &&
              g.data.plugin === "rrweb/console@1"
            ) {
              g.data.payload.payload.length > 10 &&
                ((g.data.payload.payload = g.data.payload.payload.slice(0, 10)),
                g.data.payload.payload.push("...[truncated]"));
              for (var y = [], b = 0; b < g.data.payload.payload.length; b++)
                g.data.payload.payload[b] &&
                g.data.payload.payload[b].length > 2e3
                  ? y.push(
                      g.data.payload.payload[b].slice(0, 2e3) + "...[truncated]"
                    )
                  : y.push(g.data.payload.payload[b]);
              return (g.data.payload.payload = y), p;
            }
            return p;
          })(i);
          if ((this.Ri(a), this.Zt !== !0 || tU(a))) {
            if (tU(a)) {
              var o = a.data.payload;
              if (o) {
                var l = o.lastActivityTimestamp,
                  c = o.threshold;
                a.timestamp = l + c;
              }
            }
            var h =
                (t =
                  this._instance.config.session_recording.compress_events) ===
                  null ||
                t === void 0 ||
                t
                  ? (function (p) {
                      if (Ax(p) < 1024) return p;
                      try {
                        if (p.type === hl.FullSnapshot)
                          return nt({}, p, { data: bu(p.data), cv: "2024-10" });
                        if (
                          p.type === hl.IncrementalSnapshot &&
                          p.data.source === Sa.Mutation
                        )
                          return nt({}, p, {
                            cv: "2024-10",
                            data: nt({}, p.data, {
                              texts: bu(p.data.texts),
                              attributes: bu(p.data.attributes),
                              removes: bu(p.data.removes),
                              adds: bu(p.data.adds),
                            }),
                          });
                        if (
                          p.type === hl.IncrementalSnapshot &&
                          p.data.source === Sa.StyleSheetRule
                        )
                          return nt({}, p, {
                            cv: "2024-10",
                            data: nt({}, p.data, {
                              adds: p.data.adds ? bu(p.data.adds) : void 0,
                              removes: p.data.removes
                                ? bu(p.data.removes)
                                : void 0,
                            }),
                          });
                      } catch (g) {
                        Sr.error(
                          "could not compress event - will use uncompressed event",
                          g
                        );
                      }
                      return p;
                    })(a)
                  : a,
              m = {
                $snapshot_bytes: Ax(h),
                $snapshot_data: h,
                $session_id: this.Ct,
                $window_id: this.fi,
              };
            this.status !== Pc ? this.Ui(m) : this.pi();
          }
        }
      }
    }
  }
  Li() {
    if (!this._instance.config.capture_pageview && Re) {
      var e = this.yi(Re.location.href);
      this.Di !== e && (this.ui("$url_changed", { href: e }), (this.Di = e));
    }
  }
  Ai() {
    if (this.Qt.length) {
      var e = [...this.Qt];
      (this.Qt = []),
        e.forEach((t) => {
          Date.now() - t.enqueuedAt <= 2e3 && this.Mi(t);
        });
    }
  }
  yi(e) {
    var t = this._instance.config.session_recording;
    if (t.maskNetworkRequestFn) {
      var s,
        r = { url: e };
      return (s = r = t.maskNetworkRequestFn(r)) == null ? void 0 : s.url;
    }
    return e;
  }
  pi() {
    return (
      (this.C = { size: 0, data: [], sessionId: this.Ct, windowId: this.fi }),
      this.C
    );
  }
  ai() {
    this.qi && (clearTimeout(this.qi), (this.qi = void 0));
    var e = this.Gt,
      t = this.Nt,
      s = Cr(t) && t >= 0,
      r = Cr(e) && s && t < e;
    return this.status === Xu || this.status === tL || this.status === Pc || r
      ? ((this.qi = setTimeout(() => {
          this.ai();
        }, 2e3)),
        this.C)
      : (this.C.data.length > 0 &&
          UR(this.C).forEach((i) => {
            this.Bi({
              $snapshot_bytes: i.size,
              $snapshot_data: i.data,
              $session_id: i.sessionId,
              $window_id: i.windowId,
              $lib: "web",
              $lib_version: yl.LIB_VERSION,
            });
          }),
        this.pi());
  }
  Ui(e) {
    var t,
      s = 2 + (((t = this.C) == null ? void 0 : t.data.length) || 0);
    !this.Zt &&
      (this.C.size + e.$snapshot_bytes + s > 943718.4 ||
        this.C.sessionId !== this.Ct) &&
      (this.C = this.ai()),
      (this.C.size += e.$snapshot_bytes),
      this.C.data.push(e.$snapshot_data),
      this.qi ||
        this.Zt ||
        (this.qi = setTimeout(() => {
          this.ai();
        }, 2e3));
  }
  Bi(e) {
    this._instance.capture("$snapshot", e, {
      _url: this._instance.requestRouter.endpointFor("api", this.vi),
      _noTruncate: !0,
      _batchKey: "recordings",
      skip_client_rate_limiting: !0,
    });
  }
  zi(e) {
    var t;
    this.Lt.triggerStatus(this.sessionId) === Lr &&
      ((t = this._instance) == null ||
        (t = t.persistence) == null ||
        t.register({ [e === "url" ? CR : IR]: this.Ct }),
      this.ai(),
      this.xi(e + "_trigger_matched"));
  }
  ji() {
    this.Kt.urlBlocked ||
      ((this.Kt.urlBlocked = !0),
      clearInterval(this.wi),
      Sr.info("recording paused due to URL blocker"),
      this.ui("recording paused", { reason: "url blocker" }));
  }
  Ni() {
    this.Kt.urlBlocked &&
      ((this.Kt.urlBlocked = !1),
      this.Ci(),
      this.Ti(),
      this.ui("recording resumed", { reason: "left blocked url" }),
      Sr.info("recording resumed"));
  }
  bi() {
    this.Yt.Tt.length !== 0 &&
      yn(this.ni) &&
      (this.ni = this._instance.on("eventCaptured", (e) => {
        try {
          this.Yt.Tt.includes(e.event) && this.zi("event");
        } catch (t) {
          Sr.error("Could not activate event trigger", t);
        }
      }));
  }
  overrideLinkedFlag() {
    (this.Xt.linkedFlagSeen = !0), this.Ci(), this.xi("linked_flag_overridden");
  }
  overrideSampling() {
    var e;
    (e = this._instance.persistence) == null || e.register({ [wp]: !0 }),
      this.Ci(),
      this.xi("sampling_overridden");
  }
  overrideTrigger(e) {
    this.zi(e);
  }
  xi(e, t) {
    this._instance.register_for_session({ $session_recording_start_reason: e }),
      Sr.info(e.replace("_", " "), t),
      rn(["recording_initialized", "session_id_changed"], e) || this.ui(e, t);
  }
  get sdkDebugProperties() {
    var { sessionStartTimestamp: e } = this.At.checkAndGetSessionAndWindowId(
      !0
    );
    return {
      $recording_status: this.status,
      $sdk_debug_replay_internal_buffer_length: this.C.data.length,
      $sdk_debug_replay_internal_buffer_size: this.C.size,
      $sdk_debug_current_session_duration: this.Nt,
      $sdk_debug_session_start: e,
    };
  }
}
var c1 = cr("[SegmentIntegration]");
function Qae(n, e) {
  var t = n.config.segment;
  if (!t) return e();
  (function (s, r) {
    var i = s.config.segment;
    if (!i) return r();
    var a = (l) => {
        var c = () => l.anonymousId() || Rc();
        (s.config.get_device_id = c),
          l.id() &&
            (s.register({ distinct_id: l.id(), $device_id: c() }),
            s.persistence.set_property(dl, "identified")),
          r();
      },
      o = i.user();
    "then" in o && sa(o.then) ? o.then((l) => a(l)) : a(o);
  })(n, () => {
    t.register(
      ((s) => {
        (Promise && Promise.resolve) ||
          c1.warn(
            "This browser does not have Promise support, and can not use the segment integration"
          );
        var r = (i, a) => {
          if (!a) return i;
          i.event.userId ||
            i.event.anonymousId === s.get_distinct_id() ||
            (c1.info("No userId set, resetting PostHog"), s.reset()),
            i.event.userId &&
              i.event.userId !== s.get_distinct_id() &&
              (c1.info("UserId set, identifying with PostHog"),
              s.identify(i.event.userId));
          var o = s.calculateEventProperties(a, i.event.properties);
          return (
            (i.event.properties = Object.assign({}, o, i.event.properties)), i
          );
        };
        return {
          name: "PostHog JS",
          type: "enrichment",
          version: "1.0.0",
          isLoaded: () => !0,
          load: () => Promise.resolve(),
          track: (i) => r(i, i.event.event),
          page: (i) => r(i, "$pageview"),
          identify: (i) => r(i, "$identify"),
          screen: (i) => r(i, "$screen"),
        };
      })(n)
    ).then(() => {
      e();
    });
  });
}
var Q8 = "posthog-js";
function Z8(n, e) {
  var {
    organization: t,
    projectId: s,
    prefix: r,
    severityAllowList: i = ["error"],
  } = e === void 0 ? {} : e;
  return (a) => {
    var o, l, c, h, m;
    if (!(i === "*" || i.includes(a.level)) || !n.__loaded) return a;
    a.tags || (a.tags = {});
    var p = n.requestRouter.endpointFor(
      "ui",
      "/project/" + n.config.token + "/person/" + n.get_distinct_id()
    );
    (a.tags["PostHog Person URL"] = p),
      n.sessionRecordingStarted() &&
        (a.tags["PostHog Recording URL"] = n.get_session_replay_url({
          withTimestamp: !0,
        }));
    var g = ((o = a.exception) == null ? void 0 : o.values) || [],
      y = g.map((w) =>
        nt({}, w, {
          stacktrace: w.stacktrace
            ? nt({}, w.stacktrace, {
                type: "raw",
                frames: (w.stacktrace.frames || []).map((S) =>
                  nt({}, S, { platform: "web:javascript" })
                ),
              })
            : void 0,
        })
      ),
      b = {
        $exception_message:
          ((l = g[0]) == null ? void 0 : l.value) || a.message,
        $exception_type: (c = g[0]) == null ? void 0 : c.type,
        $exception_personURL: p,
        $exception_level: a.level,
        $exception_list: y,
        $sentry_event_id: a.event_id,
        $sentry_exception: a.exception,
        $sentry_exception_message:
          ((h = g[0]) == null ? void 0 : h.value) || a.message,
        $sentry_exception_type: (m = g[0]) == null ? void 0 : m.type,
        $sentry_tags: a.tags,
      };
    return (
      t &&
        s &&
        (b.$sentry_url =
          (r || "https://sentry.io/organizations/") +
          t +
          "/issues/?project=" +
          s +
          "&query=" +
          a.event_id),
      n.exceptions.sendExceptionEvent(b),
      a
    );
  };
}
class Zae {
  constructor(e, t, s, r, i) {
    (this.name = Q8),
      (this.setupOnce = function (a) {
        a(
          Z8(e, {
            organization: t,
            projectId: s,
            prefix: r,
            severityAllowList: i,
          })
        );
      });
  }
}
var Jae =
    Re != null && Re.location
      ? Tx(Re.location.hash, "__posthog") || Tx(location.hash, "state")
      : null,
  nU = "_postHogToolbarParams",
  sU = cr("[Toolbar]"),
  hc = (function (n) {
    return (
      (n[(n.UNINITIALIZED = 0)] = "UNINITIALIZED"),
      (n[(n.LOADING = 1)] = "LOADING"),
      (n[(n.LOADED = 2)] = "LOADED"),
      n
    );
  })(hc || {});
class eoe {
  constructor(e) {
    this.instance = e;
  }
  Hi(e) {
    Mt.ph_toolbar_state = e;
  }
  Wi() {
    var e;
    return (e = Mt.ph_toolbar_state) !== null && e !== void 0
      ? e
      : hc.UNINITIALIZED;
  }
  maybeLoadToolbar(e, t, s) {
    if (
      (e === void 0 && (e = void 0),
      t === void 0 && (t = void 0),
      s === void 0 && (s = void 0),
      !Re || !rt)
    )
      return !1;
    (e = e ?? Re.location), (s = s ?? Re.history);
    try {
      if (!t) {
        try {
          Re.localStorage.setItem("test", "test"),
            Re.localStorage.removeItem("test");
        } catch {
          return !1;
        }
        t = Re?.localStorage;
      }
      var r,
        i = Jae || Tx(e.hash, "__posthog") || Tx(e.hash, "state"),
        a = i
          ? SF(() => JSON.parse(atob(decodeURIComponent(i)))) ||
            SF(() => JSON.parse(decodeURIComponent(i)))
          : null;
      return (
        a && a.action === "ph_authorize"
          ? (((r = a).source = "url"),
            r &&
              Object.keys(r).length > 0 &&
              (a.desiredHash
                ? (e.hash = a.desiredHash)
                : s
                ? s.replaceState(s.state, "", e.pathname + e.search)
                : (e.hash = "")))
          : (((r = JSON.parse(t.getItem(nU) || "{}")).source = "localstorage"),
            delete r.userIntent),
        !(!r.token || this.instance.config.token !== r.token) &&
          (this.loadToolbar(r), !0)
      );
    } catch {
      return !1;
    }
  }
  Gi(e) {
    var t = Mt.ph_load_toolbar || Mt.ph_load_editor;
    !yn(t) && sa(t)
      ? t(e, this.instance)
      : sU.warn("No toolbar load function found");
  }
  loadToolbar(e) {
    var t = !(rt == null || !rt.getElementById(S8));
    if (!Re || t) return !1;
    var s =
        this.instance.requestRouter.region === "custom" &&
        this.instance.config.advanced_disable_toolbar_metrics,
      r = nt(
        { token: this.instance.config.token },
        e,
        { apiURL: this.instance.requestRouter.endpointFor("ui") },
        s ? { instrument: !1 } : {}
      );
    if (
      (Re.localStorage.setItem(
        nU,
        JSON.stringify(nt({}, r, { source: void 0 }))
      ),
      this.Wi() === hc.LOADED)
    )
      this.Gi(r);
    else if (this.Wi() === hc.UNINITIALIZED) {
      var i;
      this.Hi(hc.LOADING),
        (i = Mt.__PosthogExtensions__) == null ||
          i.loadExternalDependency == null ||
          i.loadExternalDependency(this.instance, "toolbar", (a) => {
            if (a)
              return (
                sU.error("[Toolbar] Failed to load", a),
                void this.Hi(hc.UNINITIALIZED)
              );
            this.Hi(hc.LOADED), this.Gi(r);
          }),
        is(Re, "turbolinks:load", () => {
          this.Hi(hc.UNINITIALIZED), this.loadToolbar(r);
        });
    }
    return !0;
  }
  Ji(e) {
    return this.loadToolbar(e);
  }
  maybeLoadEditor(e, t, s) {
    return (
      e === void 0 && (e = void 0),
      t === void 0 && (t = void 0),
      s === void 0 && (s = void 0),
      this.maybeLoadToolbar(e, t, s)
    );
  }
}
var toe = cr("[TracingHeaders]");
class noe {
  constructor(e) {
    (this.Vi = void 0),
      (this.Ki = void 0),
      (this.nt = () => {
        var t, s;
        We(this.Vi) &&
          ((t = Mt.__PosthogExtensions__) == null ||
            (t = t.tracingHeadersPatchFns) == null ||
            t._patchXHR(
              this._instance.config.__add_tracing_headers || [],
              this._instance.get_distinct_id(),
              this._instance.sessionManager
            )),
          We(this.Ki) &&
            ((s = Mt.__PosthogExtensions__) == null ||
              (s = s.tracingHeadersPatchFns) == null ||
              s._patchFetch(
                this._instance.config.__add_tracing_headers || [],
                this._instance.get_distinct_id(),
                this._instance.sessionManager
              ));
      }),
      (this._instance = e);
  }
  J(e) {
    var t, s;
    (t = Mt.__PosthogExtensions__) != null && t.tracingHeadersPatchFns && e(),
      (s = Mt.__PosthogExtensions__) == null ||
        s.loadExternalDependency == null ||
        s.loadExternalDependency(this._instance, "tracing-headers", (r) => {
          if (r) return toe.error("failed to load script", r);
          e();
        });
  }
  startIfEnabledOrStop() {
    var e, t;
    this._instance.config.__add_tracing_headers
      ? this.J(this.nt)
      : ((e = this.Vi) == null || e.call(this),
        (t = this.Ki) == null || t.call(this),
        (this.Vi = void 0),
        (this.Ki = void 0));
  }
}
var ec = cr("[Web Vitals]"),
  rU = 9e5;
class soe {
  constructor(e) {
    var t;
    (this.Yi = !1),
      (this.i = !1),
      (this.C = { url: void 0, metrics: [], firstMetricTimestamp: void 0 }),
      (this.Xi = () => {
        clearTimeout(this.Qi),
          this.C.metrics.length !== 0 &&
            (this._instance.capture(
              "$web_vitals",
              this.C.metrics.reduce(
                (s, r) =>
                  nt({}, s, {
                    ["$web_vitals_" + r.name + "_event"]: nt({}, r),
                    ["$web_vitals_" + r.name + "_value"]: r.value,
                  }),
                {}
              )
            ),
            (this.C = {
              url: void 0,
              metrics: [],
              firstMetricTimestamp: void 0,
            }));
      }),
      (this.Zi = (s) => {
        var r,
          i =
            (r = this._instance.sessionManager) == null
              ? void 0
              : r.checkAndGetSessionAndWindowId(!0);
        if (We(i)) ec.error("Could not read session ID. Dropping metrics!");
        else {
          this.C = this.C || {
            url: void 0,
            metrics: [],
            firstMetricTimestamp: void 0,
          };
          var a = this.te();
          We(a) ||
            (yn(s?.name) || yn(s?.value)
              ? ec.error("Invalid metric received", s)
              : this.ie && s.value >= this.ie
              ? ec.error("Ignoring metric with value >= " + this.ie, s)
              : (this.C.url !== a &&
                  (this.Xi(),
                  (this.Qi = setTimeout(
                    this.Xi,
                    this.flushToCaptureTimeoutMs
                  ))),
                We(this.C.url) && (this.C.url = a),
                (this.C.firstMetricTimestamp = We(this.C.firstMetricTimestamp)
                  ? Date.now()
                  : this.C.firstMetricTimestamp),
                s.attribution &&
                  s.attribution.interactionTargetElement &&
                  (s.attribution.interactionTargetElement = void 0),
                this.C.metrics.push(
                  nt({}, s, {
                    $current_url: a,
                    $session_id: i.sessionId,
                    $window_id: i.windowId,
                    timestamp: Date.now(),
                  })
                ),
                this.C.metrics.length === this.allowedMetrics.length &&
                  this.Xi()));
        }
      }),
      (this.nt = () => {
        var s,
          r,
          i,
          a,
          o = Mt.__PosthogExtensions__;
        We(o) ||
          We(o.postHogWebVitalsCallbacks) ||
          ({
            onLCP: s,
            onCLS: r,
            onFCP: i,
            onINP: a,
          } = o.postHogWebVitalsCallbacks),
          s && r && i && a
            ? (this.allowedMetrics.indexOf("LCP") > -1 && s(this.Zi.bind(this)),
              this.allowedMetrics.indexOf("CLS") > -1 && r(this.Zi.bind(this)),
              this.allowedMetrics.indexOf("FCP") > -1 && i(this.Zi.bind(this)),
              this.allowedMetrics.indexOf("INP") > -1 && a(this.Zi.bind(this)),
              (this.i = !0))
            : ec.error("web vitals callbacks not loaded - not starting");
      }),
      (this._instance = e),
      (this.Yi = !((t = this._instance.persistence) == null || !t.props[RF])),
      this.startIfEnabled();
  }
  get allowedMetrics() {
    var e,
      t,
      s = fs(this._instance.config.capture_performance)
        ? (e = this._instance.config.capture_performance) == null
          ? void 0
          : e.web_vitals_allowed_metrics
        : void 0;
    return We(s)
      ? ((t = this._instance.persistence) == null ? void 0 : t.props[kF]) || [
          "CLS",
          "FCP",
          "INP",
          "LCP",
        ]
      : s;
  }
  get flushToCaptureTimeoutMs() {
    return (
      (fs(this._instance.config.capture_performance)
        ? this._instance.config.capture_performance.web_vitals_delayed_flush_ms
        : void 0) || 5e3
    );
  }
  get ie() {
    var e =
      fs(this._instance.config.capture_performance) &&
      Cr(this._instance.config.capture_performance.__web_vitals_max_value)
        ? this._instance.config.capture_performance.__web_vitals_max_value
        : rU;
    return 0 < e && e <= 6e4 ? rU : e;
  }
  get isEnabled() {
    var e = ti?.protocol;
    if (e !== "http:" && e !== "https:")
      return ec.info("Web Vitals are disabled on non-http/https protocols"), !1;
    var t = fs(this._instance.config.capture_performance)
      ? this._instance.config.capture_performance.web_vitals
      : bo(this._instance.config.capture_performance)
      ? this._instance.config.capture_performance
      : void 0;
    return bo(t) ? t : this.Yi;
  }
  startIfEnabled() {
    this.isEnabled &&
      !this.i &&
      (ec.info("enabled, starting..."), this.J(this.nt));
  }
  onRemoteConfig(e) {
    var t = fs(e.capturePerformance) && !!e.capturePerformance.web_vitals,
      s = fs(e.capturePerformance)
        ? e.capturePerformance.web_vitals_allowed_metrics
        : void 0;
    this._instance.persistence &&
      (this._instance.persistence.register({ [RF]: t }),
      this._instance.persistence.register({ [kF]: s })),
      (this.Yi = t),
      this.startIfEnabled();
  }
  J(e) {
    var t, s;
    (t = Mt.__PosthogExtensions__) != null &&
      t.postHogWebVitalsCallbacks &&
      e(),
      (s = Mt.__PosthogExtensions__) == null ||
        s.loadExternalDependency == null ||
        s.loadExternalDependency(this._instance, "web-vitals", (r) => {
          r ? ec.error("failed to load script", r) : e();
        });
  }
  te() {
    var e = Re ? Re.location.href : void 0;
    return e || ec.error("Could not determine current URL"), e;
  }
}
var roe = cr("[Heatmaps]");
function iU(n) {
  return (
    fs(n) && "clientX" in n && "clientY" in n && Cr(n.clientX) && Cr(n.clientY)
  );
}
class ioe {
  constructor(e) {
    var t;
    (this.rageclicks = new M8()),
      (this.Yi = !1),
      (this.i = !1),
      (this.ee = null),
      (this.instance = e),
      (this.Yi = !((t = this.instance.persistence) == null || !t.props[AR]));
  }
  get flushIntervalMilliseconds() {
    var e = 5e3;
    return (
      fs(this.instance.config.capture_heatmaps) &&
        this.instance.config.capture_heatmaps.flush_interval_milliseconds &&
        (e = this.instance.config.capture_heatmaps.flush_interval_milliseconds),
      e
    );
  }
  get isEnabled() {
    return We(this.instance.config.capture_heatmaps)
      ? We(this.instance.config.enable_heatmaps)
        ? this.Yi
        : this.instance.config.enable_heatmaps
      : this.instance.config.capture_heatmaps !== !1;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this.i) return;
      roe.info("starting..."),
        this.re(),
        (this.ee = setInterval(
          this.se.bind(this),
          this.flushIntervalMilliseconds
        ));
    } else {
      var e, t;
      clearInterval((e = this.ee) !== null && e !== void 0 ? e : void 0),
        (t = this.ne) == null || t.stop(),
        this.getAndClearBuffer();
    }
  }
  onRemoteConfig(e) {
    var t = !!e.heatmaps;
    this.instance.persistence &&
      this.instance.persistence.register({ [AR]: t }),
      (this.Yi = t),
      this.startIfEnabled();
  }
  getAndClearBuffer() {
    var e = this.C;
    return (this.C = void 0), e;
  }
  oe(e) {
    this.ae(e.originalEvent, "deadclick");
  }
  re() {
    Re &&
      rt &&
      (is(Re, "beforeunload", this.se.bind(this)),
      is(rt, "click", (e) => this.ae(e || Re?.event), { capture: !0 }),
      is(rt, "mousemove", (e) => this.le(e || Re?.event), { capture: !0 }),
      (this.ne = new O8(this.instance, cae, this.oe.bind(this))),
      this.ne.startIfEnabled(),
      (this.i = !0));
  }
  ue(e, t) {
    var s = this.instance.scrollManager.scrollY(),
      r = this.instance.scrollManager.scrollX(),
      i = this.instance.scrollManager.scrollElement(),
      a = (function (o, l, c) {
        for (var h = o; h && mE(h) && !Ic(h, "body"); ) {
          if (h === c) return !1;
          if (rn(l, Re?.getComputedStyle(h).position)) return !0;
          h = k8(h);
        }
        return !1;
      })(R8(e), ["fixed", "sticky"], i);
    return {
      x: e.clientX + (a ? 0 : r),
      y: e.clientY + (a ? 0 : s),
      target_fixed: a,
      type: t,
    };
  }
  ae(e, t) {
    var s;
    if ((t === void 0 && (t = "click"), !OF(e.target) && iU(e))) {
      var r = this.ue(e, t);
      (s = this.rageclicks) != null &&
        s.isRageClick(e.clientX, e.clientY, new Date().getTime()) &&
        this.he(nt({}, r, { type: "rageclick" })),
        this.he(r);
    }
  }
  le(e) {
    !OF(e.target) &&
      iU(e) &&
      (clearTimeout(this.de),
      (this.de = setTimeout(() => {
        this.he(this.ue(e, "mousemove"));
      }, 500)));
  }
  he(e) {
    if (Re) {
      var t = Re.location.href;
      (this.C = this.C || {}), this.C[t] || (this.C[t] = []), this.C[t].push(e);
    }
  }
  se() {
    this.C &&
      !$h(this.C) &&
      this.instance.capture("$$heatmap", {
        $heatmap_data: this.getAndClearBuffer(),
      });
  }
}
class aoe {
  constructor(e) {
    this._instance = e;
  }
  doPageView(e, t) {
    var s,
      r = this.ve(e, t);
    return (
      (this.ce = {
        pathname: (s = Re?.location.pathname) !== null && s !== void 0 ? s : "",
        pageViewId: t,
        timestamp: e,
      }),
      this._instance.scrollManager.resetContext(),
      r
    );
  }
  doPageLeave(e) {
    var t;
    return this.ve(e, (t = this.ce) == null ? void 0 : t.pageViewId);
  }
  doEvent() {
    var e;
    return { $pageview_id: (e = this.ce) == null ? void 0 : e.pageViewId };
  }
  ve(e, t) {
    var s = this.ce;
    if (!s) return { $pageview_id: t };
    var r = { $pageview_id: t, $prev_pageview_id: s.pageViewId },
      i = this._instance.scrollManager.getContext();
    if (i && !this._instance.config.disable_scroll_properties) {
      var {
        maxScrollHeight: a,
        lastScrollY: o,
        maxScrollY: l,
        maxContentHeight: c,
        lastContentY: h,
        maxContentY: m,
      } = i;
      if (!(We(a) || We(o) || We(l) || We(c) || We(h) || We(m))) {
        (a = Math.ceil(a)),
          (o = Math.ceil(o)),
          (l = Math.ceil(l)),
          (c = Math.ceil(c)),
          (h = Math.ceil(h)),
          (m = Math.ceil(m));
        var p = a <= 1 ? 1 : Ai(o / a, 0, 1),
          g = a <= 1 ? 1 : Ai(l / a, 0, 1),
          y = c <= 1 ? 1 : Ai(h / c, 0, 1),
          b = c <= 1 ? 1 : Ai(m / c, 0, 1);
        r = As(r, {
          $prev_pageview_last_scroll: o,
          $prev_pageview_last_scroll_percentage: p,
          $prev_pageview_max_scroll: l,
          $prev_pageview_max_scroll_percentage: g,
          $prev_pageview_last_content: h,
          $prev_pageview_last_content_percentage: y,
          $prev_pageview_max_content: m,
          $prev_pageview_max_content_percentage: b,
        });
      }
    }
    return (
      s.pathname && (r.$prev_pageview_pathname = s.pathname),
      s.timestamp &&
        (r.$prev_pageview_duration =
          (e.getTime() - s.timestamp.getTime()) / 1e3),
      r
    );
  }
}
var ooe = function (n) {
    var e,
      t,
      s,
      r,
      i = "";
    for (
      e = t = 0,
        s = (n = (n + "")
          .replace(
            /\r\n/g,
            `
`
          )
          .replace(
            /\r/g,
            `
`
          )).length,
        r = 0;
      r < s;
      r++
    ) {
      var a = n.charCodeAt(r),
        o = null;
      a < 128
        ? t++
        : (o =
            a > 127 && a < 2048
              ? String.fromCharCode((a >> 6) | 192, (63 & a) | 128)
              : String.fromCharCode(
                  (a >> 12) | 224,
                  ((a >> 6) & 63) | 128,
                  (63 & a) | 128
                )),
        zc(o) || (t > e && (i += n.substring(e, t)), (i += o), (e = t = r + 1));
    }
    return t > e && (i += n.substring(e, n.length)), i;
  },
  loe = !!SR || !!ER,
  aU = "text/plain",
  Cx = (n, e) => {
    var [t, s] = n.split("?"),
      r = nt({}, e);
    s?.split("&").forEach((a) => {
      var [o] = a.split("=");
      delete r[o];
    });
    var i = Xie(r);
    return t + "?" + (i = i ? (s ? s + "&" : "") + i : s);
  },
  Tp = (n, e) =>
    JSON.stringify(n, (t, s) => (typeof s == "bigint" ? s.toString() : s), e),
  u1 = (n) => {
    var { data: e, compression: t } = n;
    if (e) {
      if (t === xl.GZipJS) {
        var s = W8(K8(Tp(e)), { mtime: 0 }),
          r = new Blob([s], { type: aU });
        return { contentType: aU, body: r, estimatedSize: r.size };
      }
      if (t === xl.Base64) {
        var i = (function (l) {
            var c,
              h,
              m,
              p,
              g,
              y =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              b = 0,
              w = 0,
              S = "",
              A = [];
            if (!l) return l;
            l = ooe(l);
            do
              (c =
                ((g =
                  (l.charCodeAt(b++) << 16) |
                  (l.charCodeAt(b++) << 8) |
                  l.charCodeAt(b++)) >>
                  18) &
                63),
                (h = (g >> 12) & 63),
                (m = (g >> 6) & 63),
                (p = 63 & g),
                (A[w++] =
                  y.charAt(c) + y.charAt(h) + y.charAt(m) + y.charAt(p));
            while (b < l.length);
            switch (((S = A.join("")), l.length % 3)) {
              case 1:
                S = S.slice(0, -2) + "==";
                break;
              case 2:
                S = S.slice(0, -1) + "=";
            }
            return S;
          })(Tp(e)),
          a = ((l) =>
            "data=" + encodeURIComponent(typeof l == "string" ? l : Tp(l)))(i);
        return {
          contentType: "application/x-www-form-urlencoded",
          body: a,
          estimatedSize: new Blob([a]).size,
        };
      }
      var o = Tp(e);
      return {
        contentType: "application/json",
        body: o,
        estimatedSize: new Blob([o]).size,
      };
    }
  },
  qp = [];
ER &&
  qp.push({
    transport: "fetch",
    method: (n) => {
      var e,
        t,
        {
          contentType: s,
          body: r,
          estimatedSize: i,
        } = (e = u1(n)) !== null && e !== void 0 ? e : {},
        a = new Headers();
      Dn(n.headers, function (h, m) {
        a.append(m, h);
      }),
        s && a.append("Content-Type", s);
      var o = n.url,
        l = null;
      if (wF) {
        var c = new wF();
        l = {
          signal: c.signal,
          timeout: setTimeout(() => c.abort(), n.timeout),
        };
      }
      ER(
        o,
        nt(
          {
            method: n?.method || "GET",
            headers: a,
            keepalive: n.method === "POST" && (i || 0) < 52428.8,
            body: r,
            signal: (t = l) == null ? void 0 : t.signal,
          },
          n.fetchOptions
        )
      )
        .then((h) =>
          h.text().then((m) => {
            var p = { statusCode: h.status, text: m };
            if (h.status === 200)
              try {
                p.json = JSON.parse(m);
              } catch (g) {
                at.error(g);
              }
            n.callback == null || n.callback(p);
          })
        )
        .catch((h) => {
          at.error(h),
            n.callback == null || n.callback({ statusCode: 0, text: h });
        })
        .finally(() => (l ? clearTimeout(l.timeout) : null));
    },
  }),
  SR &&
    qp.push({
      transport: "XHR",
      method: (n) => {
        var e,
          t = new SR();
        t.open(n.method || "GET", n.url, !0);
        var { contentType: s, body: r } =
          (e = u1(n)) !== null && e !== void 0 ? e : {};
        Dn(n.headers, function (i, a) {
          t.setRequestHeader(a, i);
        }),
          s && t.setRequestHeader("Content-Type", s),
          n.timeout && (t.timeout = n.timeout),
          (t.withCredentials = !0),
          (t.onreadystatechange = () => {
            if (t.readyState === 4) {
              var i = { statusCode: t.status, text: t.responseText };
              if (t.status === 200)
                try {
                  i.json = JSON.parse(t.responseText);
                } catch {}
              n.callback == null || n.callback(i);
            }
          }),
          t.send(r);
      },
    }),
  _i != null &&
    _i.sendBeacon &&
    qp.push({
      transport: "sendBeacon",
      method: (n) => {
        var e = Cx(n.url, { beacon: "1" });
        try {
          var t,
            { contentType: s, body: r } =
              (t = u1(n)) !== null && t !== void 0 ? t : {},
            i = typeof r == "string" ? new Blob([r], { type: s }) : r;
          _i.sendBeacon(e, i);
        } catch {}
      },
    });
var wf = function (n, e) {
  if (
    !(function (t) {
      try {
        new RegExp(t);
      } catch {
        return !1;
      }
      return !0;
    })(e)
  )
    return !1;
  try {
    return new RegExp(e).test(n);
  } catch {
    return !1;
  }
};
function oU(n, e, t) {
  return Tp({
    distinct_id: n,
    userPropertiesToSet: e,
    userPropertiesToSetOnce: t,
  });
}
var coe = {
    exact: (n, e) => e.some((t) => n.some((s) => t === s)),
    is_not: (n, e) => e.every((t) => n.every((s) => t !== s)),
    regex: (n, e) => e.some((t) => n.some((s) => wf(t, s))),
    not_regex: (n, e) => e.every((t) => n.every((s) => !wf(t, s))),
    icontains: (n, e) =>
      e.map(Ey).some((t) => n.map(Ey).some((s) => t.includes(s))),
    not_icontains: (n, e) =>
      e.map(Ey).every((t) => n.map(Ey).every((s) => !t.includes(s))),
  },
  Ey = (n) => n.toLowerCase(),
  lU = cr("[Error tracking]");
class uoe {
  constructor(e) {
    var t, s;
    (this.fe = []),
      (this._instance = e),
      (this.fe =
        (t =
          (s = this._instance.persistence) == null
            ? void 0
            : s.get_property(RR)) !== null && t !== void 0
          ? t
          : []);
  }
  onRemoteConfig(e) {
    var t,
      s,
      r,
      i =
        (t = (s = e.errorTracking) == null ? void 0 : s.suppressionRules) !==
          null && t !== void 0
          ? t
          : [],
      a = (r = e.errorTracking) == null ? void 0 : r.captureExtensionExceptions;
    (this.fe = i),
      this._instance.persistence &&
        this._instance.persistence.register({ [RR]: this.fe, [AF]: a });
  }
  get pe() {
    var e,
      t = !!this._instance.get_property(AF),
      s = this._instance.config.error_tracking.captureExtensionExceptions;
    return (e = s ?? t) !== null && e !== void 0 && e;
  }
  sendExceptionEvent(e) {
    if (this._e(e))
      lU.info("Skipping exception capture because a suppression rule matched");
    else {
      if (this.pe || !this.ge(e))
        return this._instance.capture("$exception", e, {
          _noTruncate: !0,
          _batchKey: "exceptionEvent",
        });
      lU.info(
        "Skipping exception capture because it was thrown by an extension"
      );
    }
  }
  _e(e) {
    var t = e.$exception_list;
    if (!t || !zn(t) || t.length === 0) return !1;
    var s = t.reduce(
      (r, i) => {
        var { type: a, value: o } = i;
        return (
          ms(a) && a.length > 0 && r.$exception_types.push(a),
          ms(o) && o.length > 0 && r.$exception_values.push(o),
          r
        );
      },
      { $exception_types: [], $exception_values: [] }
    );
    return this.fe.some((r) => {
      var i = r.values.map((a) => {
        var o,
          l = coe[a.operator],
          c = zn(a.value) ? a.value : [a.value],
          h = (o = s[a.key]) !== null && o !== void 0 ? o : [];
        return c.length > 0 && l(c, h);
      });
      return r.type === "OR" ? i.some(Boolean) : i.every(Boolean);
    });
  }
  ge(e) {
    var t = e.$exception_list;
    return (
      !(!t || !zn(t)) &&
      t
        .flatMap((s) => {
          var r, i;
          return (r = (i = s.stacktrace) == null ? void 0 : i.frames) !==
            null && r !== void 0
            ? r
            : [];
        })
        .some((s) => s.filename && s.filename.startsWith("chrome-extension://"))
    );
  }
}
var ia = "Mobile",
  Ix = "iOS",
  xo = "Android",
  Ag = "Tablet",
  J8 = xo + " " + Ag,
  eH = "iPad",
  tH = "Apple",
  nH = tH + " Watch",
  Rg = "Safari",
  Ef = "BlackBerry",
  sH = "Samsung",
  rH = sH + "Browser",
  iH = sH + " Internet",
  Qu = "Chrome",
  doe = Qu + " OS",
  aH = Qu + " " + Ix,
  sL = "Internet Explorer",
  oH = sL + " " + ia,
  rL = "Opera",
  hoe = rL + " Mini",
  iL = "Edge",
  lH = "Microsoft " + iL,
  ef = "Firefox",
  cH = ef + " " + Ix,
  kg = "Nintendo",
  Cg = "PlayStation",
  tf = "Xbox",
  uH = xo + " " + ia,
  dH = ia + " " + Rg,
  _p = "Windows",
  qR = _p + " Phone",
  cU = "Nokia",
  WR = "Ouya",
  hH = "Generic",
  foe = hH + " " + ia.toLowerCase(),
  fH = hH + " " + Ag.toLowerCase(),
  KR = "Konqueror",
  jr = "(\\d+(\\.\\d+)?)",
  d1 = new RegExp("Version/" + jr),
  moe = new RegExp(tf, "i"),
  poe = new RegExp(Cg + " \\w+", "i"),
  goe = new RegExp(kg + " \\w+", "i"),
  aL = new RegExp(Ef + "|PlayBook|BB10", "i"),
  voe = {
    "NT3.51": "NT 3.11",
    "NT4.0": "NT 4.0",
    "5.0": "2000",
    5.1: "XP",
    5.2: "XP",
    "6.0": "Vista",
    6.1: "7",
    6.2: "8",
    6.3: "8.1",
    6.4: "10",
    "10.0": "10",
  },
  yoe = (n, e) =>
    (e && rn(e, tH)) ||
    (function (t) {
      return rn(t, Rg) && !rn(t, Qu) && !rn(t, xo);
    })(n),
  mH = function (n, e) {
    return (
      (e = e || ""),
      rn(n, " OPR/") && rn(n, "Mini")
        ? hoe
        : rn(n, " OPR/")
        ? rL
        : aL.test(n)
        ? Ef
        : rn(n, "IE" + ia) || rn(n, "WPDesktop")
        ? oH
        : rn(n, rH)
        ? iH
        : rn(n, iL) || rn(n, "Edg/")
        ? lH
        : rn(n, "FBIOS")
        ? "Facebook " + ia
        : rn(n, "UCWEB") || rn(n, "UCBrowser")
        ? "UC Browser"
        : rn(n, "CriOS")
        ? aH
        : rn(n, "CrMo") || rn(n, Qu)
        ? Qu
        : rn(n, xo) && rn(n, Rg)
        ? uH
        : rn(n, "FxiOS")
        ? cH
        : rn(n.toLowerCase(), KR.toLowerCase())
        ? KR
        : yoe(n, e)
        ? rn(n, ia)
          ? dH
          : Rg
        : rn(n, ef)
        ? ef
        : rn(n, "MSIE") || rn(n, "Trident/")
        ? sL
        : rn(n, "Gecko")
        ? ef
        : ""
    );
  },
  boe = {
    [oH]: [new RegExp("rv:" + jr)],
    [lH]: [new RegExp(iL + "?\\/" + jr)],
    [Qu]: [new RegExp("(" + Qu + "|CrMo)\\/" + jr)],
    [aH]: [new RegExp("CriOS\\/" + jr)],
    "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + jr)],
    [Rg]: [d1],
    [dH]: [d1],
    [rL]: [new RegExp("(Opera|OPR)\\/" + jr)],
    [ef]: [new RegExp(ef + "\\/" + jr)],
    [cH]: [new RegExp("FxiOS\\/" + jr)],
    [KR]: [new RegExp("Konqueror[:/]?" + jr, "i")],
    [Ef]: [new RegExp(Ef + " " + jr), d1],
    [uH]: [new RegExp("android\\s" + jr, "i")],
    [iH]: [new RegExp(rH + "\\/" + jr)],
    [sL]: [new RegExp("(rv:|MSIE )" + jr)],
    Mozilla: [new RegExp("rv:" + jr)],
  },
  xoe = function (n, e) {
    var t = mH(n, e),
      s = boe[t];
    if (We(s)) return null;
    for (var r = 0; r < s.length; r++) {
      var i = s[r],
        a = n.match(i);
      if (a) return parseFloat(a[a.length - 2]);
    }
    return null;
  },
  uU = [
    [
      new RegExp(tf + "; " + tf + " (.*?)[);]", "i"),
      (n) => [tf, (n && n[1]) || ""],
    ],
    [new RegExp(kg, "i"), [kg, ""]],
    [new RegExp(Cg, "i"), [Cg, ""]],
    [aL, [Ef, ""]],
    [
      new RegExp(_p, "i"),
      (n, e) => {
        if (/Phone/.test(e) || /WPDesktop/.test(e)) return [qR, ""];
        if (new RegExp(ia).test(e) && !/IEMobile\b/.test(e))
          return [_p + " " + ia, ""];
        var t = /Windows NT ([0-9.]+)/i.exec(e);
        if (t && t[1]) {
          var s = t[1],
            r = voe[s] || "";
          return /arm/i.test(e) && (r = "RT"), [_p, r];
        }
        return [_p, ""];
      },
    ],
    [
      /((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/,
      (n) => {
        if (n && n[3]) {
          var e = [n[3], n[4], n[5] || "0"];
          return [Ix, e.join(".")];
        }
        return [Ix, ""];
      },
    ],
    [
      /(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i,
      (n) => {
        var e = "";
        return (
          n && n.length >= 3 && (e = We(n[2]) ? n[3] : n[2]), ["watchOS", e]
        );
      },
    ],
    [
      new RegExp("(" + xo + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + xo + ")", "i"),
      (n) => {
        if (n && n[2]) {
          var e = [n[2], n[3], n[4] || "0"];
          return [xo, e.join(".")];
        }
        return [xo, ""];
      },
    ],
    [
      /Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i,
      (n) => {
        var e = ["Mac OS X", ""];
        if (n && n[1]) {
          var t = [n[1], n[2], n[3] || "0"];
          e[1] = t.join(".");
        }
        return e;
      },
    ],
    [/Mac/i, ["Mac OS X", ""]],
    [/CrOS/, [doe, ""]],
    [/Linux|debian/i, ["Linux", ""]],
  ],
  dU = function (n) {
    return goe.test(n)
      ? kg
      : poe.test(n)
      ? Cg
      : moe.test(n)
      ? tf
      : new RegExp(WR, "i").test(n)
      ? WR
      : new RegExp("(" + qR + "|WPDesktop)", "i").test(n)
      ? qR
      : /iPad/.test(n)
      ? eH
      : /iPod/.test(n)
      ? "iPod Touch"
      : /iPhone/.test(n)
      ? "iPhone"
      : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(n)
      ? nH
      : aL.test(n)
      ? Ef
      : /(kobo)\s(ereader|touch)/i.test(n)
      ? "Kobo"
      : new RegExp(cU, "i").test(n)
      ? cU
      : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(n) ||
        /(kf[a-z]+)( bui|\)).+silk\//i.test(n)
      ? "Kindle Fire"
      : /(Android|ZTE)/i.test(n)
      ? !new RegExp(ia).test(n) ||
        /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(
          n
        )
        ? (/pixel[\daxl ]{1,6}/i.test(n) && !/pixel c/i.test(n)) ||
          /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(n) ||
          (/lmy47v/i.test(n) && !/QTAQZ3/i.test(n))
          ? xo
          : J8
        : xo
      : new RegExp("(pda|" + ia + ")", "i").test(n)
      ? foe
      : new RegExp(Ag, "i").test(n) && !new RegExp(Ag + " pc", "i").test(n)
      ? fH
      : "";
  },
  Sy = "https?://(.*)",
  gE = [
    "gclid",
    "gclsrc",
    "dclid",
    "gbraid",
    "wbraid",
    "fbclid",
    "msclkid",
    "twclid",
    "li_fat_id",
    "igshid",
    "ttclid",
    "rdt_cid",
    "epik",
    "qclid",
    "sccid",
    "irclid",
    "_kx",
  ],
  woe = fE(
    [
      "utm_source",
      "utm_medium",
      "utm_campaign",
      "utm_content",
      "utm_term",
      "gad_source",
      "mc_cid",
    ],
    gE
  ),
  oL = "<masked>",
  Eoe = ["li_fat_id"];
function pH(n, e, t) {
  if (!rt) return {};
  var s,
    r = e ? fE([], gE, t || []) : [],
    i = gH(XI(rt.URL, r, oL), n),
    a =
      ((s = {}),
      Dn(Eoe, function (o) {
        var l = Ao.D(o);
        s[o] = l || null;
      }),
      s);
  return As(a, i);
}
function gH(n, e) {
  var t = woe.concat(e || []),
    s = {};
  return (
    Dn(t, function (r) {
      var i = Sx(n, r);
      s[r] = i || null;
    }),
    s
  );
}
function vH(n) {
  var e = (function (i) {
      return i
        ? i.search(Sy + "google.([^/?]*)") === 0
          ? "google"
          : i.search(Sy + "bing.com") === 0
          ? "bing"
          : i.search(Sy + "yahoo.com") === 0
          ? "yahoo"
          : i.search(Sy + "duckduckgo.com") === 0
          ? "duckduckgo"
          : null
        : null;
    })(n),
    t = e != "yahoo" ? "q" : "p",
    s = {};
  if (!zc(e)) {
    s.$search_engine = e;
    var r = rt ? Sx(rt.referrer, t) : "";
    r.length && (s.ph_keyword = r);
  }
  return s;
}
function hU() {
  return navigator.language || navigator.userLanguage;
}
function yH() {
  return rt?.referrer || "$direct";
}
function bH(n, e) {
  var t = n ? fE([], gE, e || []) : [],
    s = ti?.href.substring(0, 1e3);
  return { r: yH().substring(0, 1e3), u: s ? XI(s, t, oL) : void 0 };
}
function xH(n) {
  var e,
    { r: t, u: s } = n,
    r = {
      $referrer: t,
      $referring_domain:
        t == null
          ? void 0
          : t == "$direct"
          ? "$direct"
          : (e = bf(t)) == null
          ? void 0
          : e.host,
    };
  if (s) {
    r.$current_url = s;
    var i = bf(s);
    (r.$host = i?.host), (r.$pathname = i?.pathname);
    var a = gH(s);
    As(r, a);
  }
  if (t) {
    var o = vH(t);
    As(r, o);
  }
  return r;
}
function wH() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch {
    return;
  }
}
function Soe() {
  try {
    return new Date().getTimezoneOffset();
  } catch {
    return;
  }
}
function Toe(n, e) {
  if (!Zr) return {};
  var t,
    s,
    r,
    i = n ? fE([], gE, e || []) : [],
    [a, o] = (function (l) {
      for (var c = 0; c < uU.length; c++) {
        var [h, m] = uU[c],
          p = h.exec(l),
          g = p && (sa(m) ? m(p, l) : m);
        if (g) return g;
      }
      return ["", ""];
    })(Zr);
  return As(
    KI({
      $os: a,
      $os_version: o,
      $browser: mH(Zr, navigator.vendor),
      $device: dU(Zr),
      $device_type:
        ((s = Zr),
        (r = dU(s)),
        r === eH || r === J8 || r === "Kobo" || r === "Kindle Fire" || r === fH
          ? Ag
          : r === kg || r === tf || r === Cg || r === WR
          ? "Console"
          : r === nH
          ? "Wearable"
          : r
          ? ia
          : "Desktop"),
      $timezone: wH(),
      $timezone_offset: Soe(),
    }),
    {
      $current_url: XI(ti?.href, i, oL),
      $host: ti?.host,
      $pathname: ti?.pathname,
      $raw_user_agent: Zr.length > 1e3 ? Zr.substring(0, 997) + "..." : Zr,
      $browser_version: xoe(Zr, navigator.vendor),
      $browser_language: hU(),
      $browser_language_prefix:
        ((t = hU()), typeof t == "string" ? t.split("-")[0] : void 0),
      $screen_height: Re?.screen.height,
      $screen_width: Re?.screen.width,
      $viewport_height: Re?.innerHeight,
      $viewport_width: Re?.innerWidth,
      $lib: "web",
      $lib_version: yl.LIB_VERSION,
      $insert_id:
        Math.random().toString(36).substring(2, 10) +
        Math.random().toString(36).substring(2, 10),
      $time: Date.now() / 1e3,
    }
  );
}
var eo = cr("[FeatureFlags]"),
  h1 = "$active_feature_flags",
  ah = "$override_feature_flags",
  fU = "$feature_flag_payloads",
  rp = "$override_feature_flag_payloads",
  mU = "$feature_flag_request_id",
  pU = (n) => {
    var e = {};
    for (var [t, s] of mb(n || {})) s && (e[t] = s);
    return e;
  },
  _oe = (n) => {
    var e = n.flags;
    return (
      e
        ? ((n.featureFlags = Object.fromEntries(
            Object.keys(e).map((t) => {
              var s;
              return [
                t,
                (s = e[t].variant) !== null && s !== void 0 ? s : e[t].enabled,
              ];
            })
          )),
          (n.featureFlagPayloads = Object.fromEntries(
            Object.keys(e)
              .filter((t) => e[t].enabled)
              .filter((t) => {
                var s;
                return (s = e[t].metadata) == null ? void 0 : s.payload;
              })
              .map((t) => {
                var s;
                return [t, (s = e[t].metadata) == null ? void 0 : s.payload];
              })
          )))
        : eo.warn(
            "Using an older version of the feature flags endpoint. Please upgrade your PostHog server to the latest version"
          ),
      n
    );
  },
  Aoe = (function (n) {
    return (n.FeatureFlags = "feature_flags"), (n.Recordings = "recordings"), n;
  })({});
class Roe {
  constructor(e) {
    (this.me = !1),
      (this.be = !1),
      (this.ye = !1),
      (this.we = !1),
      (this.Se = !1),
      (this.$e = !1),
      (this.xe = !1),
      (this._instance = e),
      (this.featureFlagEventHandlers = []);
  }
  flags() {
    if (this._instance.config.__preview_remote_config) this.$e = !0;
    else {
      var e =
        !this.ke &&
        (this._instance.config.advanced_disable_feature_flags ||
          this._instance.config.advanced_disable_feature_flags_on_first_load);
      this.Ee({ disableFlags: e });
    }
  }
  get hasLoadedFlags() {
    return this.be;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagsWithDetails() {
    var e = this._instance.get_property(LR),
      t = this._instance.get_property(ah),
      s = this._instance.get_property(rp);
    if (!s && !t) return e || {};
    var r = As({}, e || {}),
      i = [...new Set([...Object.keys(s || {}), ...Object.keys(t || {})])];
    for (var a of i) {
      var o,
        l,
        c = r[a],
        h = t?.[a],
        m = We(h) ? (o = c?.enabled) !== null && o !== void 0 && o : !!h,
        p = We(h) ? c.variant : typeof h == "string" ? h : void 0,
        g = s?.[a],
        y = nt({}, c, { enabled: m, variant: m ? p ?? c?.variant : void 0 });
      m !== c?.enabled && (y.original_enabled = c?.enabled),
        p !== c?.variant && (y.original_variant = c?.variant),
        g &&
          (y.metadata = nt({}, c?.metadata, {
            payload: g,
            original_payload:
              c == null || (l = c.metadata) == null ? void 0 : l.payload,
          })),
        (r[a] = y);
    }
    return (
      this.me ||
        (eo.warn(" Overriding feature flag details!", {
          flagDetails: e,
          overriddenPayloads: s,
          finalDetails: r,
        }),
        (this.me = !0)),
      r
    );
  }
  getFlagVariants() {
    var e = this._instance.get_property(Bh),
      t = this._instance.get_property(ah);
    if (!t) return e || {};
    for (var s = As({}, e), r = Object.keys(t), i = 0; i < r.length; i++)
      s[r[i]] = t[r[i]];
    return (
      this.me ||
        (eo.warn(" Overriding feature flags!", {
          enabledFlags: e,
          overriddenFlags: t,
          finalFlags: s,
        }),
        (this.me = !0)),
      s
    );
  }
  getFlagPayloads() {
    var e = this._instance.get_property(fU),
      t = this._instance.get_property(rp);
    if (!t) return e || {};
    for (var s = As({}, e || {}), r = Object.keys(t), i = 0; i < r.length; i++)
      s[r[i]] = t[r[i]];
    return (
      this.me ||
        (eo.warn(" Overriding feature flag payloads!", {
          flagPayloads: e,
          overriddenPayloads: t,
          finalPayloads: s,
        }),
        (this.me = !0)),
      s
    );
  }
  reloadFeatureFlags() {
    this.we ||
      this._instance.config.advanced_disable_feature_flags ||
      this.ke ||
      (this.ke = setTimeout(() => {
        this.Ee();
      }, 5));
  }
  Ie() {
    clearTimeout(this.ke), (this.ke = void 0);
  }
  ensureFlagsLoaded() {
    this.be || this.ye || this.ke || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(e) {
    this.$anon_distinct_id = e;
  }
  setReloadingPaused(e) {
    this.we = e;
  }
  Ee(e) {
    var t;
    if ((this.Ie(), !this._instance.I()))
      if (this.ye) this.Se = !0;
      else {
        var s = {
          token: this._instance.config.token,
          distinct_id: this._instance.get_distinct_id(),
          groups: this._instance.getGroups(),
          $anon_distinct_id: this.$anon_distinct_id,
          person_properties: nt(
            {},
            ((t = this._instance.persistence) == null
              ? void 0
              : t.get_initial_props()) || {},
            this._instance.get_property(Ep) || {}
          ),
          group_properties: this._instance.get_property(_u),
        };
        ((e != null && e.disableFlags) ||
          this._instance.config.advanced_disable_feature_flags) &&
          (s.disable_flags = !0);
        var r = this._instance.config.__preview_remote_config,
          i = r ? "/flags/?v=2" : "/flags/?v=2&config=true",
          a = this._instance.config.advanced_only_evaluate_survey_feature_flags
            ? "&only_evaluate_survey_feature_flags=true"
            : "",
          o = this._instance.requestRouter.endpointFor("api", i + a);
        r && (s.timezone = wH()),
          (this.ye = !0),
          this._instance.Pe({
            method: "POST",
            url: o,
            data: s,
            compression: this._instance.config.disable_compression
              ? void 0
              : xl.Base64,
            timeout: this._instance.config.feature_flag_request_timeout_ms,
            callback: (l) => {
              var c,
                h,
                m = !0;
              if (
                (l.statusCode === 200 &&
                  (this.Se || (this.$anon_distinct_id = void 0), (m = !1)),
                (this.ye = !1),
                this.$e ||
                  ((this.$e = !0),
                  this._instance.Re(
                    (h = l.json) !== null && h !== void 0 ? h : {}
                  )),
                !s.disable_flags || this.Se)
              )
                if (
                  ((this.xe = !m),
                  l.json &&
                    (c = l.json.quotaLimited) != null &&
                    c.includes(Aoe.FeatureFlags))
                )
                  eo.warn(
                    "You have hit your feature flags quota limit, and will not be able to load feature flags until the quota is reset.  Please visit https://posthog.com/docs/billing/limits-alerts to learn more."
                  );
                else {
                  var p;
                  s.disable_flags ||
                    this.receivedFeatureFlags(
                      (p = l.json) !== null && p !== void 0 ? p : {},
                      m
                    ),
                    this.Se && ((this.Se = !1), this.Ee());
                }
            },
          });
      }
  }
  getFeatureFlag(e, t) {
    if (
      (t === void 0 && (t = {}),
      this.be || (this.getFlags() && this.getFlags().length > 0))
    ) {
      var s = this.getFlagVariants()[e],
        r = "" + s,
        i = this._instance.get_property(mU) || void 0,
        a = this._instance.get_property(bx) || {};
      if (
        (t.send_event || !("send_event" in t)) &&
        (!(e in a) || !a[e].includes(r))
      ) {
        var o, l, c, h, m, p, g, y, b;
        zn(a[e]) ? a[e].push(r) : (a[e] = [r]),
          (o = this._instance.persistence) == null || o.register({ [bx]: a });
        var w = this.getFeatureFlagDetails(e),
          S = {
            $feature_flag: e,
            $feature_flag_response: s,
            $feature_flag_payload: this.getFeatureFlagPayload(e) || null,
            $feature_flag_request_id: i,
            $feature_flag_bootstrapped_response:
              ((l = this._instance.config.bootstrap) == null ||
              (l = l.featureFlags) == null
                ? void 0
                : l[e]) || null,
            $feature_flag_bootstrapped_payload:
              ((c = this._instance.config.bootstrap) == null ||
              (c = c.featureFlagPayloads) == null
                ? void 0
                : c[e]) || null,
            $used_bootstrap_value: !this.xe,
          };
        We(w == null || (h = w.metadata) == null ? void 0 : h.version) ||
          (S.$feature_flag_version = w.metadata.version);
        var A,
          _ =
            (m =
              w == null || (p = w.reason) == null ? void 0 : p.description) !==
              null && m !== void 0
              ? m
              : w == null || (g = w.reason) == null
              ? void 0
              : g.code;
        _ && (S.$feature_flag_reason = _),
          w != null &&
            (y = w.metadata) != null &&
            y.id &&
            (S.$feature_flag_id = w.metadata.id),
          (We(w?.original_variant) && We(w?.original_enabled)) ||
            (S.$feature_flag_original_response = We(w.original_variant)
              ? w.original_enabled
              : w.original_variant),
          w != null &&
            (b = w.metadata) != null &&
            b.original_payload &&
            (S.$feature_flag_original_payload =
              w == null || (A = w.metadata) == null
                ? void 0
                : A.original_payload),
          this._instance.capture("$feature_flag_called", S);
      }
      return s;
    }
    eo.warn(
      'getFeatureFlag for key "' +
        e +
        `" failed. Feature flags didn't load in time.`
    );
  }
  getFeatureFlagDetails(e) {
    return this.getFlagsWithDetails()[e];
  }
  getFeatureFlagPayload(e) {
    return this.getFlagPayloads()[e];
  }
  getRemoteConfigPayload(e, t) {
    var s = this._instance.config.token;
    this._instance.Pe({
      method: "POST",
      url: this._instance.requestRouter.endpointFor(
        "api",
        "/flags/?v=2&config=true"
      ),
      data: { distinct_id: this._instance.get_distinct_id(), token: s },
      compression: this._instance.config.disable_compression
        ? void 0
        : xl.Base64,
      timeout: this._instance.config.feature_flag_request_timeout_ms,
      callback: (r) => {
        var i,
          a = (i = r.json) == null ? void 0 : i.featureFlagPayloads;
        t(a?.[e] || void 0);
      },
    });
  }
  isFeatureEnabled(e, t) {
    if (
      (t === void 0 && (t = {}),
      this.be || (this.getFlags() && this.getFlags().length > 0))
    )
      return !!this.getFeatureFlag(e, t);
    eo.warn(
      'isFeatureEnabled for key "' +
        e +
        `" failed. Feature flags didn't load in time.`
    );
  }
  addFeatureFlagsHandler(e) {
    this.featureFlagEventHandlers.push(e);
  }
  removeFeatureFlagsHandler(e) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter(
      (t) => t !== e
    );
  }
  receivedFeatureFlags(e, t) {
    if (this._instance.persistence) {
      this.be = !0;
      var s = this.getFlagVariants(),
        r = this.getFlagPayloads(),
        i = this.getFlagsWithDetails();
      (function (a, o, l, c, h) {
        l === void 0 && (l = {}),
          c === void 0 && (c = {}),
          h === void 0 && (h = {});
        var m = _oe(a),
          p = m.flags,
          g = m.featureFlags,
          y = m.featureFlagPayloads;
        if (g) {
          var b = a.requestId;
          if (zn(g)) {
            eo.warn(
              "v1 of the feature flags endpoint is deprecated. Please use the latest version."
            );
            var w = {};
            if (g) for (var S = 0; S < g.length; S++) w[g[S]] = !0;
            o && o.register({ [h1]: g, [Bh]: w });
          } else {
            var A = g,
              _ = y,
              R = p;
            a.errorsWhileComputingFlags &&
              ((A = nt({}, l, A)), (_ = nt({}, c, _)), (R = nt({}, h, R))),
              o &&
                o.register(
                  nt(
                    {
                      [h1]: Object.keys(pU(A)),
                      [Bh]: A || {},
                      [fU]: _ || {},
                      [LR]: R || {},
                    },
                    b ? { [mU]: b } : {}
                  )
                );
          }
        }
      })(e, this._instance.persistence, s, r, i),
        this.Te(t);
    }
  }
  override(e, t) {
    t === void 0 && (t = !1),
      eo.warn(
        "override is deprecated. Please use overrideFeatureFlags instead."
      ),
      this.overrideFeatureFlags({ flags: e, suppressWarning: t });
  }
  overrideFeatureFlags(e) {
    if (!this._instance.__loaded || !this._instance.persistence)
      return eo.uninitializedWarning(
        "posthog.featureFlags.overrideFeatureFlags"
      );
    if (e === !1)
      return (
        this._instance.persistence.unregister(ah),
        this._instance.persistence.unregister(rp),
        void this.Te()
      );
    if (e && typeof e == "object" && ("flags" in e || "payloads" in e)) {
      var t,
        s = e;
      if (
        ((this.me = !!((t = s.suppressWarning) !== null && t !== void 0 && t)),
        "flags" in s)
      ) {
        if (s.flags === !1) this._instance.persistence.unregister(ah);
        else if (s.flags)
          if (zn(s.flags)) {
            for (var r = {}, i = 0; i < s.flags.length; i++) r[s.flags[i]] = !0;
            this._instance.persistence.register({ [ah]: r });
          } else this._instance.persistence.register({ [ah]: s.flags });
      }
      return (
        "payloads" in s &&
          (s.payloads === !1
            ? this._instance.persistence.unregister(rp)
            : s.payloads &&
              this._instance.persistence.register({ [rp]: s.payloads })),
        void this.Te()
      );
    }
    this.Te();
  }
  onFeatureFlags(e) {
    if ((this.addFeatureFlagsHandler(e), this.be)) {
      var { flags: t, flagVariants: s } = this.Me();
      e(t, s);
    }
    return () => this.removeFeatureFlagsHandler(e);
  }
  updateEarlyAccessFeatureEnrollment(e, t, s) {
    var r,
      i = (this._instance.get_property(pb) || []).find((c) => c.flagKey === e),
      a = { ["$feature_enrollment/" + e]: t },
      o = { $feature_flag: e, $feature_enrollment: t, $set: a };
    i && (o.$early_access_feature_name = i.name),
      s && (o.$feature_enrollment_stage = s),
      this._instance.capture("$feature_enrollment_update", o),
      this.setPersonPropertiesForFlags(a, !1);
    var l = nt({}, this.getFlagVariants(), { [e]: t });
    (r = this._instance.persistence) == null ||
      r.register({ [h1]: Object.keys(pU(l)), [Bh]: l }),
      this.Te();
  }
  getEarlyAccessFeatures(e, t, s) {
    t === void 0 && (t = !1);
    var r = this._instance.get_property(pb),
      i = s ? "&" + s.map((a) => "stage=" + a).join("&") : "";
    if (r && !t) return e(r);
    this._instance.Pe({
      url: this._instance.requestRouter.endpointFor(
        "api",
        "/api/early_access_features/?token=" + this._instance.config.token + i
      ),
      method: "GET",
      callback: (a) => {
        var o;
        if (a.json) {
          var l = a.json.earlyAccessFeatures;
          return (
            (o = this._instance.persistence) == null || o.register({ [pb]: l }),
            e(l)
          );
        }
      },
    });
  }
  Me() {
    var e = this.getFlags(),
      t = this.getFlagVariants();
    return {
      flags: e.filter((s) => t[s]),
      flagVariants: Object.keys(t)
        .filter((s) => t[s])
        .reduce((s, r) => ((s[r] = t[r]), s), {}),
    };
  }
  Te(e) {
    var { flags: t, flagVariants: s } = this.Me();
    this.featureFlagEventHandlers.forEach((r) => r(t, s, { errorsLoading: e }));
  }
  setPersonPropertiesForFlags(e, t) {
    t === void 0 && (t = !0);
    var s = this._instance.get_property(Ep) || {};
    this._instance.register({ [Ep]: nt({}, s, e) }),
      t && this._instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this._instance.unregister(Ep);
  }
  setGroupPropertiesForFlags(e, t) {
    t === void 0 && (t = !0);
    var s = this._instance.get_property(_u) || {};
    Object.keys(s).length !== 0 &&
      Object.keys(s).forEach((r) => {
        (s[r] = nt({}, s[r], e[r])), delete e[r];
      }),
      this._instance.register({ [_u]: nt({}, s, e) }),
      t && this._instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(e) {
    if (e) {
      var t = this._instance.get_property(_u) || {};
      this._instance.register({ [_u]: nt({}, t, { [e]: {} }) });
    } else this._instance.unregister(_u);
  }
  reset() {
    (this.be = !1),
      (this.ye = !1),
      (this.we = !1),
      (this.Se = !1),
      (this.$e = !1),
      (this.xe = !1),
      (this.$anon_distinct_id = void 0),
      this.Ie(),
      (this.me = !1);
  }
}
var koe = [
  "cookie",
  "localstorage",
  "localstorage+cookie",
  "sessionstorage",
  "memory",
];
class f1 {
  constructor(e, t) {
    (this.S = e),
      (this.props = {}),
      (this.Ce = !1),
      (this.Fe = ((s) => {
        var r = "";
        return (
          s.token &&
            (r = s.token
              .replace(/\+/g, "PL")
              .replace(/\//g, "SL")
              .replace(/=/g, "EQ")),
          s.persistence_name
            ? "ph_" + s.persistence_name
            : "ph_" + r + "_posthog"
        );
      })(e)),
      (this.B = this.Oe(e)),
      this.load(),
      e.debug &&
        at.info("Persistence loaded", e.persistence, nt({}, this.props)),
      this.update_config(e, e, t),
      this.save();
  }
  isDisabled() {
    return !!this.Ae;
  }
  Oe(e) {
    koe.indexOf(e.persistence.toLowerCase()) === -1 &&
      (at.critical(
        "Unknown persistence type " +
          e.persistence +
          "; falling back to localStorage+cookie"
      ),
      (e.persistence = "localStorage+cookie"));
    var t = e.persistence.toLowerCase();
    return t === "localstorage" && Vs.O()
      ? Vs
      : t === "localstorage+cookie" && py.O()
      ? py
      : t === "sessionstorage" && vr.O()
      ? vr
      : t === "memory"
      ? oae
      : t === "cookie"
      ? Ao
      : py.O()
      ? py
      : Ao;
  }
  properties() {
    var e = {};
    return (
      Dn(this.props, function (t, s) {
        if (s === Bh && fs(t))
          for (var r = Object.keys(t), i = 0; i < r.length; i++)
            e["$feature/" + r[i]] = t[r[i]];
        else
          (o = s),
            (l = !1),
            (zc((a = Bie))
              ? l
              : xF && a.indexOf === xF
              ? a.indexOf(o) != -1
              : (Dn(a, function (c) {
                  if (l || (l = c === o)) return vx;
                }),
                l)) || (e[s] = t);
        var a, o, l;
      }),
      e
    );
  }
  load() {
    if (!this.Ae) {
      var e = this.B.L(this.Fe);
      e && (this.props = As({}, e));
    }
  }
  save() {
    this.Ae ||
      this.B.j(this.Fe, this.props, this.De, this.Le, this.je, this.S.debug);
  }
  remove() {
    this.B.N(this.Fe, !1), this.B.N(this.Fe, !0);
  }
  clear() {
    this.remove(), (this.props = {});
  }
  register_once(e, t, s) {
    if (fs(e)) {
      We(t) && (t = "None"), (this.De = We(s) ? this.Ne : s);
      var r = !1;
      if (
        (Dn(e, (i, a) => {
          (this.props.hasOwnProperty(a) && this.props[a] !== t) ||
            ((this.props[a] = i), (r = !0));
        }),
        r)
      )
        return this.save(), !0;
    }
    return !1;
  }
  register(e, t) {
    if (fs(e)) {
      this.De = We(t) ? this.Ne : t;
      var s = !1;
      if (
        (Dn(e, (r, i) => {
          e.hasOwnProperty(i) &&
            this.props[i] !== r &&
            ((this.props[i] = r), (s = !0));
        }),
        s)
      )
        return this.save(), !0;
    }
    return !1;
  }
  unregister(e) {
    e in this.props && (delete this.props[e], this.save());
  }
  update_campaign_params() {
    if (!this.Ce) {
      var e = pH(
        this.S.custom_campaign_params,
        this.S.mask_personal_data_properties,
        this.S.custom_personal_data_properties
      );
      $h(KI(e)) || this.register(e), (this.Ce = !0);
    }
  }
  update_search_keyword() {
    var e;
    this.register((e = rt?.referrer) ? vH(e) : {});
  }
  update_referrer_info() {
    var e;
    this.register_once(
      {
        $referrer: yH(),
        $referring_domain:
          (rt != null &&
            rt.referrer &&
            ((e = bf(rt.referrer)) == null ? void 0 : e.host)) ||
          "$direct",
      },
      void 0
    );
  }
  set_initial_person_info() {
    this.props[NR] ||
      this.props[OR] ||
      this.register_once(
        {
          [xx]: bH(
            this.S.mask_personal_data_properties,
            this.S.custom_personal_data_properties
          ),
        },
        void 0
      );
  }
  get_initial_props() {
    var e = {};
    Dn([OR, NR], (a) => {
      var o = this.props[a];
      o &&
        Dn(o, function (l, c) {
          e["$initial_" + TR(c)] = l;
        });
    });
    var t,
      s,
      r = this.props[xx];
    if (r) {
      var i =
        ((t = xH(r)),
        (s = {}),
        Dn(t, function (a, o) {
          s["$initial_" + TR(o)] = a;
        }),
        s);
      As(e, i);
    }
    return e;
  }
  safe_merge(e) {
    return (
      Dn(this.props, function (t, s) {
        s in e || (e[s] = t);
      }),
      e
    );
  }
  update_config(e, t, s) {
    if (
      ((this.Ne = this.De = e.cookie_expiration),
      this.set_disabled(e.disable_persistence || !!s),
      this.set_cross_subdomain(e.cross_subdomain_cookie),
      this.set_secure(e.secure_cookie),
      e.persistence !== t.persistence)
    ) {
      var r = this.Oe(e),
        i = this.props;
      this.clear(), (this.B = r), (this.props = i), this.save();
    }
  }
  set_disabled(e) {
    (this.Ae = e), this.Ae ? this.remove() : this.save();
  }
  set_cross_subdomain(e) {
    e !== this.Le && ((this.Le = e), this.remove(), this.save());
  }
  set_secure(e) {
    e !== this.je && ((this.je = e), this.remove(), this.save());
  }
  set_event_timer(e, t) {
    var s = this.props[xp] || {};
    (s[e] = t), (this.props[xp] = s), this.save();
  }
  remove_event_timer(e) {
    var t = (this.props[xp] || {})[e];
    return We(t) || (delete this.props[xp][e], this.save()), t;
  }
  get_property(e) {
    return this.props[e];
  }
  set_property(e, t) {
    (this.props[e] = t), this.save();
  }
}
(function (n) {
  return (n.Button = "button"), (n.Tab = "tab"), (n.Selector = "selector"), n;
})({});
(function (n) {
  return (
    (n.TopLeft = "top_left"),
    (n.TopRight = "top_right"),
    (n.TopCenter = "top_center"),
    (n.MiddleLeft = "middle_left"),
    (n.MiddleRight = "middle_right"),
    (n.MiddleCenter = "middle_center"),
    (n.Left = "left"),
    (n.Center = "center"),
    (n.Right = "right"),
    (n.NextToTrigger = "next_to_trigger"),
    n
  );
})({});
var vb = (function (n) {
  return (
    (n.Popover = "popover"),
    (n.API = "api"),
    (n.Widget = "widget"),
    (n.ExternalSurvey = "external_survey"),
    n
  );
})({});
(function (n) {
  return (
    (n.Open = "open"),
    (n.MultipleChoice = "multiple_choice"),
    (n.SingleChoice = "single_choice"),
    (n.Rating = "rating"),
    (n.Link = "link"),
    n
  );
})({});
(function (n) {
  return (
    (n.NextQuestion = "next_question"),
    (n.End = "end"),
    (n.ResponseBased = "response_based"),
    (n.SpecificQuestion = "specific_question"),
    n
  );
})({});
(function (n) {
  return (
    (n.Once = "once"), (n.Recurring = "recurring"), (n.Always = "always"), n
  );
})({});
var m1 = (function (n) {
    return (
      (n.SHOWN = "survey shown"),
      (n.DISMISSED = "survey dismissed"),
      (n.SENT = "survey sent"),
      n
    );
  })({}),
  gU = (function (n) {
    return (
      (n.SURVEY_ID = "$survey_id"),
      (n.SURVEY_NAME = "$survey_name"),
      (n.SURVEY_RESPONSE = "$survey_response"),
      (n.SURVEY_ITERATION = "$survey_iteration"),
      (n.SURVEY_ITERATION_START_DATE = "$survey_iteration_start_date"),
      (n.SURVEY_PARTIALLY_COMPLETED = "$survey_partially_completed"),
      (n.SURVEY_SUBMISSION_ID = "$survey_submission_id"),
      (n.SURVEY_QUESTIONS = "$survey_questions"),
      (n.SURVEY_COMPLETED = "$survey_completed"),
      n
    );
  })({});
class EH {
  constructor() {
    (this.ze = {}), (this.ze = {});
  }
  on(e, t) {
    return (
      this.ze[e] || (this.ze[e] = []),
      this.ze[e].push(t),
      () => {
        this.ze[e] = this.ze[e].filter((s) => s !== t);
      }
    );
  }
  emit(e, t) {
    for (var s of this.ze[e] || []) s(t);
    for (var r of this.ze["*"] || []) r(e, t);
  }
}
class Mu {
  constructor(e) {
    (this.Ue = new EH()),
      (this.qe = (t, s) => this.Be(t, s) && this.He(t, s) && this.We(t, s)),
      (this.Be = (t, s) => s == null || !s.event || t?.event === s?.event),
      (this._instance = e),
      (this.Ge = new Set()),
      (this.Je = new Set());
  }
  init() {
    var e;
    if (!We((e = this._instance) == null ? void 0 : e.Ve)) {
      var t;
      (t = this._instance) == null ||
        t.Ve((s, r) => {
          this.on(s, r);
        });
    }
  }
  register(e) {
    var t, s;
    if (
      !We((t = this._instance) == null ? void 0 : t.Ve) &&
      (e.forEach((a) => {
        var o, l;
        (o = this.Je) == null || o.add(a),
          (l = a.steps) == null ||
            l.forEach((c) => {
              var h;
              (h = this.Ge) == null || h.add(c?.event || "");
            });
      }),
      (s = this._instance) != null && s.autocapture)
    ) {
      var r,
        i = new Set();
      e.forEach((a) => {
        var o;
        (o = a.steps) == null ||
          o.forEach((l) => {
            l != null && l.selector && i.add(l?.selector);
          });
      }),
        (r = this._instance) == null || r.autocapture.setElementSelectors(i);
    }
  }
  on(e, t) {
    var s;
    t != null &&
      e.length != 0 &&
      (this.Ge.has(e) || this.Ge.has(t?.event)) &&
      this.Je &&
      ((s = this.Je) == null ? void 0 : s.size) > 0 &&
      this.Je.forEach((r) => {
        this.Ke(t, r) && this.Ue.emit("actionCaptured", r.name);
      });
  }
  Ye(e) {
    this.onAction("actionCaptured", (t) => e(t));
  }
  Ke(e, t) {
    if (t?.steps == null) return !1;
    for (var s of t.steps) if (this.qe(e, s)) return !0;
    return !1;
  }
  onAction(e, t) {
    return this.Ue.on(e, t);
  }
  He(e, t) {
    if (t != null && t.url) {
      var s,
        r = e == null || (s = e.properties) == null ? void 0 : s.$current_url;
      if (
        !r ||
        typeof r != "string" ||
        !Mu.Xe(r, t?.url, t?.url_matching || "contains")
      )
        return !1;
    }
    return !0;
  }
  static Xe(e, t, s) {
    switch (s) {
      case "regex":
        return !!Re && wf(e, t);
      case "exact":
        return t === e;
      case "contains":
        var r = Mu.Qe(t).replace(/_/g, ".").replace(/%/g, ".*");
        return wf(e, r);
      default:
        return !1;
    }
  }
  static Qe(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  We(e, t) {
    if (
      ((t != null && t.href) ||
        (t != null && t.tag_name) ||
        (t != null && t.text)) &&
      !this.Ze(e).some(
        (i) =>
          !(
            t != null &&
            t.href &&
            !Mu.Xe(i.href || "", t?.href, t?.href_matching || "exact")
          ) &&
          (t == null || !t.tag_name || i.tag_name === t?.tag_name) &&
          !(
            t != null &&
            t.text &&
            !Mu.Xe(i.text || "", t?.text, t?.text_matching || "exact") &&
            !Mu.Xe(i.$el_text || "", t?.text, t?.text_matching || "exact")
          )
      )
    )
      return !1;
    if (t != null && t.selector) {
      var s,
        r =
          e == null || (s = e.properties) == null
            ? void 0
            : s.$element_selectors;
      if (!r || !r.includes(t?.selector)) return !1;
    }
    return !0;
  }
  Ze(e) {
    return e?.properties.$elements == null ? [] : e?.properties.$elements;
  }
}
var Bs = cr("[Surveys]"),
  YR = "seenSurvey_",
  Coe = (n, e) => {
    var t = "$survey_" + e + "/" + n.id;
    return (
      n.current_iteration &&
        n.current_iteration > 0 &&
        (t = "$survey_" + e + "/" + n.id + "/" + n.current_iteration),
      t
    );
  },
  Ioe = [vb.Popover, vb.Widget, vb.API];
class Loe {
  constructor(e) {
    (this._instance = e), (this.tr = new Map()), (this.ir = new Map());
  }
  register(e) {
    var t;
    We((t = this._instance) == null ? void 0 : t.Ve) ||
      (this.er(e), this.rr(e));
  }
  rr(e) {
    var t = e.filter((s) => {
      var r, i;
      return (
        ((r = s.conditions) == null ? void 0 : r.actions) &&
        ((i = s.conditions) == null ||
        (i = i.actions) == null ||
        (i = i.values) == null
          ? void 0
          : i.length) > 0
      );
    });
    t.length !== 0 &&
      (this.sr == null &&
        ((this.sr = new Mu(this._instance)),
        this.sr.init(),
        this.sr.Ye((s) => {
          this.onAction(s);
        })),
      t.forEach((s) => {
        var r, i, a, o, l;
        s.conditions &&
          (r = s.conditions) != null &&
          r.actions &&
          (i = s.conditions) != null &&
          (i = i.actions) != null &&
          i.values &&
          ((a = s.conditions) == null ||
          (a = a.actions) == null ||
          (a = a.values) == null
            ? void 0
            : a.length) > 0 &&
          ((o = this.sr) == null || o.register(s.conditions.actions.values),
          (l = s.conditions) == null ||
            (l = l.actions) == null ||
            (l = l.values) == null ||
            l.forEach((c) => {
              if (c && c.name) {
                var h = this.ir.get(c.name);
                h && h.push(s.id), this.ir.set(c.name, h || [s.id]);
              }
            }));
      }));
  }
  er(e) {
    var t;
    e.filter((s) => {
      var r, i;
      return (
        ((r = s.conditions) == null ? void 0 : r.events) &&
        ((i = s.conditions) == null ||
        (i = i.events) == null ||
        (i = i.values) == null
          ? void 0
          : i.length) > 0
      );
    }).length !== 0 &&
      ((t = this._instance) == null ||
        t.Ve((s, r) => {
          this.onEvent(s, r);
        }),
      e.forEach((s) => {
        var r;
        (r = s.conditions) == null ||
          (r = r.events) == null ||
          (r = r.values) == null ||
          r.forEach((i) => {
            if (i && i.name) {
              var a = this.tr.get(i.name);
              a && a.push(s.id), this.tr.set(i.name, a || [s.id]);
            }
          });
      }));
  }
  onEvent(e, t) {
    var s,
      r =
        ((s = this._instance) == null || (s = s.persistence) == null
          ? void 0
          : s.props[fy]) || [];
    if (e === "survey shown" && t && r.length > 0) {
      var i;
      Bs.info("survey event matched, removing survey from activated surveys", {
        event: e,
        eventPayload: t,
        existingActivatedSurveys: r,
      });
      var a = t == null || (i = t.properties) == null ? void 0 : i.$survey_id;
      if (a) {
        var o = r.indexOf(a);
        o >= 0 && (r.splice(o, 1), this.nr(r));
      }
    } else
      this.tr.has(e) &&
        (Bs.info("survey event matched, updating activated surveys", {
          event: e,
          surveys: this.tr.get(e),
        }),
        this.nr(r.concat(this.tr.get(e) || [])));
  }
  onAction(e) {
    var t,
      s =
        ((t = this._instance) == null || (t = t.persistence) == null
          ? void 0
          : t.props[fy]) || [];
    this.ir.has(e) && this.nr(s.concat(this.ir.get(e) || []));
  }
  nr(e) {
    var t;
    (t = this._instance) == null ||
      (t = t.persistence) == null ||
      t.register({ [fy]: [...new Set(e)] });
  }
  getSurveys() {
    var e,
      t =
        (e = this._instance) == null || (e = e.persistence) == null
          ? void 0
          : e.props[fy];
    return t || [];
  }
  getEventToSurveys() {
    return this.tr;
  }
  ar() {
    return this.sr;
  }
}
class Doe {
  constructor(e) {
    (this.lr = void 0),
      (this.ur = null),
      (this.hr = !1),
      (this.dr = !1),
      (this.vr = []),
      (this._instance = e),
      (this._surveyEventReceiver = null);
  }
  onRemoteConfig(e) {
    var t = e.surveys;
    if (yn(t)) return Bs.warn("Flags not loaded yet. Not loading surveys.");
    var s = zn(t);
    (this.lr = s ? t.length > 0 : t),
      Bs.info("flags response received, isSurveysEnabled: " + this.lr),
      this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    for (var e = [], t = 0; t < localStorage.length; t++) {
      var s = localStorage.key(t);
      ((s != null && s.startsWith(YR)) ||
        (s != null && s.startsWith("inProgressSurvey_"))) &&
        e.push(s);
    }
    e.forEach((r) => localStorage.removeItem(r));
  }
  loadIfEnabled() {
    if (!this.ur)
      if (this.dr) Bs.info("Already initializing surveys, skipping...");
      else if (this._instance.config.disable_surveys)
        Bs.info("Disabled. Not loading surveys.");
      else {
        var e = Mt?.__PosthogExtensions__;
        if (e) {
          var t = this.lr;
          if (!We(t)) {
            this.dr = !0;
            try {
              var s = e.generateSurveys;
              if (s) return void this.cr(s, t);
              var r = e.loadExternalDependency;
              if (!r)
                return void this.pr(
                  "PostHog loadExternalDependency extension not found."
                );
              r(this._instance, "surveys", (i) => {
                i || !e.generateSurveys
                  ? this.pr("Could not load surveys script", i)
                  : this.cr(e.generateSurveys, t);
              });
            } catch (i) {
              throw (this.pr("Error initializing surveys", i), i);
            } finally {
              this.dr = !1;
            }
          }
        } else Bs.error("PostHog Extensions not found.");
      }
  }
  cr(e, t) {
    (this.ur = e(this._instance, t)),
      (this._surveyEventReceiver = new Loe(this._instance)),
      Bs.info("Surveys loaded successfully"),
      this._r({ isLoaded: !0 });
  }
  pr(e, t) {
    Bs.error(e, t), this._r({ isLoaded: !1, error: e });
  }
  onSurveysLoaded(e) {
    return (
      this.vr.push(e),
      this.ur && this._r({ isLoaded: !0 }),
      () => {
        this.vr = this.vr.filter((t) => t !== e);
      }
    );
  }
  getSurveys(e, t) {
    if ((t === void 0 && (t = !1), this._instance.config.disable_surveys))
      return Bs.info("Disabled. Not loading surveys."), e([]);
    var s = this._instance.get_property(DR);
    if (s && !t) return e(s, { isLoaded: !0 });
    if (this.hr)
      return e([], { isLoaded: !1, error: "Surveys are already being loaded" });
    try {
      (this.hr = !0),
        this._instance.Pe({
          url: this._instance.requestRouter.endpointFor(
            "api",
            "/api/surveys/?token=" + this._instance.config.token
          ),
          method: "GET",
          timeout: this._instance.config.surveys_request_timeout_ms,
          callback: (r) => {
            var i;
            this.hr = !1;
            var a = r.statusCode;
            if (a !== 200 || !r.json) {
              var o = "Surveys API could not be loaded, status: " + a;
              return Bs.error(o), e([], { isLoaded: !1, error: o });
            }
            var l,
              c = r.json.surveys || [],
              h = c.filter(
                (m) =>
                  (function (p) {
                    return !(!p.start_date || p.end_date);
                  })(m) &&
                  ((function (p) {
                    var g;
                    return !(
                      (g = p.conditions) == null ||
                      (g = g.events) == null ||
                      (g = g.values) == null ||
                      !g.length
                    );
                  })(m) ||
                    (function (p) {
                      var g;
                      return !(
                        (g = p.conditions) == null ||
                        (g = g.actions) == null ||
                        (g = g.values) == null ||
                        !g.length
                      );
                    })(m))
              );
            return (
              h.length > 0 &&
                ((l = this._surveyEventReceiver) == null || l.register(h)),
              (i = this._instance.persistence) == null ||
                i.register({ [DR]: c }),
              e(c, { isLoaded: !0 })
            );
          },
        });
    } catch (r) {
      throw ((this.hr = !1), r);
    }
  }
  _r(e) {
    for (var t of this.vr)
      try {
        e.isLoaded ? this.getSurveys(t) : t([], e);
      } catch (s) {
        Bs.error("Error in survey callback", s);
      }
  }
  getActiveMatchingSurveys(e, t) {
    if ((t === void 0 && (t = !1), !yn(this.ur)))
      return this.ur.getActiveMatchingSurveys(e, t);
    Bs.warn("init was not called");
  }
  gr(e) {
    var t = null;
    return (
      this.getSurveys((s) => {
        var r;
        t = (r = s.find((i) => i.id === e)) !== null && r !== void 0 ? r : null;
      }),
      t
    );
  }
  mr(e) {
    if (yn(this.ur))
      return {
        eligible: !1,
        reason: "SDK is not enabled or survey functionality is not yet loaded",
      };
    var t = typeof e == "string" ? this.gr(e) : e;
    return t
      ? this.ur.checkSurveyEligibility(t)
      : { eligible: !1, reason: "Survey not found" };
  }
  canRenderSurvey(e) {
    if (yn(this.ur))
      return (
        Bs.warn("init was not called"),
        {
          visible: !1,
          disabledReason:
            "SDK is not enabled or survey functionality is not yet loaded",
        }
      );
    var t = this.mr(e);
    return { visible: t.eligible, disabledReason: t.reason };
  }
  canRenderSurveyAsync(e, t) {
    return yn(this.ur)
      ? (Bs.warn("init was not called"),
        Promise.resolve({
          visible: !1,
          disabledReason:
            "SDK is not enabled or survey functionality is not yet loaded",
        }))
      : new Promise((s) => {
          this.getSurveys((r) => {
            var i,
              a =
                (i = r.find((l) => l.id === e)) !== null && i !== void 0
                  ? i
                  : null;
            if (a) {
              var o = this.mr(a);
              s({ visible: o.eligible, disabledReason: o.reason });
            } else s({ visible: !1, disabledReason: "Survey not found" });
          }, t);
        });
  }
  br(e, t, s) {
    if (yn(this.ur)) Bs.warn("init was not called");
    else {
      var r = this.gr(e);
      if (r)
        if (s.includes(r.type)) {
          var i = rt?.querySelector(t);
          i ? this.ur.renderSurvey(r, i) : Bs.warn("Survey element not found");
        } else
          Bs.warn(
            "Surveys of type " + r.type + " are cannot be rendered in the app"
          );
      else Bs.warn("Survey not found");
    }
  }
  renderSurvey(e, t) {
    this.br(e, t, Ioe);
  }
  _renderExternalSurvey(e, t) {
    this.br(e, t, [vb.ExternalSurvey]);
  }
}
var vU = cr("[RateLimiter]");
class Poe {
  constructor(e) {
    var t, s;
    (this.serverLimits = {}),
      (this.lastEventRateLimited = !1),
      (this.checkForLimiting = (r) => {
        var i = r.text;
        if (i && i.length)
          try {
            (JSON.parse(i).quota_limited || []).forEach((a) => {
              vU.info((a || "events") + " is quota limited."),
                (this.serverLimits[a] = new Date().getTime() + 6e4);
            });
          } catch (a) {
            return void vU.warn(
              'could not rate limit - continuing. Error: "' + a?.message + '"',
              { text: i }
            );
          }
      }),
      (this.instance = e),
      (this.captureEventsPerSecond =
        ((t = e.config.rate_limiting) == null ? void 0 : t.events_per_second) ||
        10),
      (this.captureEventsBurstLimit = Math.max(
        ((s = e.config.rate_limiting) == null
          ? void 0
          : s.events_burst_limit) || 10 * this.captureEventsPerSecond,
        this.captureEventsPerSecond
      )),
      (this.lastEventRateLimited = this.clientRateLimitContext(
        !0
      ).isRateLimited);
  }
  clientRateLimitContext(e) {
    var t, s, r;
    e === void 0 && (e = !1);
    var i = new Date().getTime(),
      a =
        (t =
          (s = this.instance.persistence) == null
            ? void 0
            : s.get_property(MR)) !== null && t !== void 0
          ? t
          : { tokens: this.captureEventsBurstLimit, last: i };
    (a.tokens += ((i - a.last) / 1e3) * this.captureEventsPerSecond),
      (a.last = i),
      a.tokens > this.captureEventsBurstLimit &&
        (a.tokens = this.captureEventsBurstLimit);
    var o = a.tokens < 1;
    return (
      o || e || (a.tokens = Math.max(0, a.tokens - 1)),
      !o ||
        this.lastEventRateLimited ||
        e ||
        this.instance.capture(
          "$$client_ingestion_warning",
          {
            $$client_ingestion_warning_message:
              "posthog-js client rate limited. Config is set to " +
              this.captureEventsPerSecond +
              " events per second and " +
              this.captureEventsBurstLimit +
              " events burst limit.",
          },
          { skip_client_rate_limiting: !0 }
        ),
      (this.lastEventRateLimited = o),
      (r = this.instance.persistence) == null || r.set_property(MR, a),
      { isRateLimited: o, remainingTokens: a.tokens }
    );
  }
  isServerRateLimited(e) {
    var t = this.serverLimits[e || "events"] || !1;
    return t !== !1 && new Date().getTime() < t;
  }
}
var xu = cr("[RemoteConfig]");
class Moe {
  constructor(e) {
    this._instance = e;
  }
  get remoteConfig() {
    var e;
    return (e = Mt._POSTHOG_REMOTE_CONFIG) == null ||
      (e = e[this._instance.config.token]) == null
      ? void 0
      : e.config;
  }
  yr(e) {
    var t, s;
    (t = Mt.__PosthogExtensions__) != null && t.loadExternalDependency
      ? (s = Mt.__PosthogExtensions__) == null ||
        s.loadExternalDependency == null ||
        s.loadExternalDependency(this._instance, "remote-config", () =>
          e(this.remoteConfig)
        )
      : (xu.error("PostHog Extensions not found. Cannot load remote config."),
        e());
  }
  wr(e) {
    this._instance.Pe({
      method: "GET",
      url: this._instance.requestRouter.endpointFor(
        "assets",
        "/array/" + this._instance.config.token + "/config"
      ),
      callback: (t) => {
        e(t.json);
      },
    });
  }
  load() {
    try {
      if (this.remoteConfig)
        return (
          xu.info("Using preloaded remote config", this.remoteConfig),
          void this.Re(this.remoteConfig)
        );
      if (this._instance.I())
        return void xu.warn(
          "Remote config is disabled. Falling back to local config."
        );
      this.yr((e) => {
        if (!e)
          return (
            xu.info(
              "No config found after loading remote JS config. Falling back to JSON."
            ),
            void this.wr((t) => {
              this.Re(t);
            })
          );
        this.Re(e);
      });
    } catch (e) {
      xu.error("Error loading remote config", e);
    }
  }
  Re(e) {
    e
      ? this._instance.config.__preview_remote_config
        ? (this._instance.Re(e),
          e.hasFeatureFlags !== !1 &&
            this._instance.featureFlags.ensureFlagsLoaded())
        : xu.info(
            "__preview_remote_config is disabled. Logging config instead",
            e
          )
      : xu.error("Failed to fetch remote config from PostHog.");
  }
}
var XR = 3e3;
class Noe {
  constructor(e, t) {
    (this.Sr = !0),
      (this.$r = []),
      (this.kr = Ai(
        t?.flush_interval_ms || XR,
        250,
        5e3,
        "flush interval",
        XR
      )),
      (this.Er = e);
  }
  enqueue(e) {
    this.$r.push(e), this.Ir || this.Pr();
  }
  unload() {
    this.Rr();
    var e = this.$r.length > 0 ? this.Tr() : {},
      t = Object.values(e);
    [
      ...t.filter((s) => s.url.indexOf("/e") === 0),
      ...t.filter((s) => s.url.indexOf("/e") !== 0),
    ].map((s) => {
      this.Er(nt({}, s, { transport: "sendBeacon" }));
    });
  }
  enable() {
    (this.Sr = !1), this.Pr();
  }
  Pr() {
    var e = this;
    this.Sr ||
      (this.Ir = setTimeout(() => {
        if ((this.Rr(), this.$r.length > 0)) {
          var t = this.Tr(),
            s = function () {
              var i = t[r],
                a = new Date().getTime();
              i.data &&
                zn(i.data) &&
                Dn(i.data, (o) => {
                  (o.offset = Math.abs(o.timestamp - a)), delete o.timestamp;
                }),
                e.Er(i);
            };
          for (var r in t) s();
        }
      }, this.kr));
  }
  Rr() {
    clearTimeout(this.Ir), (this.Ir = void 0);
  }
  Tr() {
    var e = {};
    return (
      Dn(this.$r, (t) => {
        var s,
          r = t,
          i = (r ? r.batchKey : null) || r.url;
        We(e[i]) && (e[i] = nt({}, r, { data: [] })),
          (s = e[i].data) == null || s.push(r.data);
      }),
      (this.$r = []),
      e
    );
  }
}
var Ooe = ["retriesPerformedSoFar"];
class joe {
  constructor(e) {
    (this.Mr = !1),
      (this.Cr = 3e3),
      (this.$r = []),
      (this._instance = e),
      (this.$r = []),
      (this.Fr = !0),
      !We(Re) &&
        "onLine" in Re.navigator &&
        ((this.Fr = Re.navigator.onLine),
        is(Re, "online", () => {
          (this.Fr = !0), this.se();
        }),
        is(Re, "offline", () => {
          this.Fr = !1;
        }));
  }
  get length() {
    return this.$r.length;
  }
  retriableRequest(e) {
    var { retriesPerformedSoFar: t } = e,
      s = b8(e, Ooe);
    Cr(t) && t > 0 && (s.url = Cx(s.url, { retry_count: t })),
      this._instance.Pe(
        nt({}, s, {
          callback: (r) => {
            r.statusCode !== 200 &&
            (r.statusCode < 400 || r.statusCode >= 500) &&
            (t ?? 0) < 10
              ? this.Or(nt({ retriesPerformedSoFar: t }, s))
              : s.callback == null || s.callback(r);
          },
        })
      );
  }
  Or(e) {
    var t = e.retriesPerformedSoFar || 0;
    e.retriesPerformedSoFar = t + 1;
    var s = (function (a) {
        var o = 3e3 * Math.pow(2, a),
          l = o / 2,
          c = Math.min(18e5, o),
          h = (Math.random() - 0.5) * (c - l);
        return Math.ceil(c + h);
      })(t),
      r = Date.now() + s;
    this.$r.push({ retryAt: r, requestOptions: e });
    var i = "Enqueued failed request for retry in " + s;
    navigator.onLine || (i += " (Browser is offline)"),
      at.warn(i),
      this.Mr || ((this.Mr = !0), this.Ar());
  }
  Ar() {
    this.Dr && clearTimeout(this.Dr),
      (this.Dr = setTimeout(() => {
        this.Fr && this.$r.length > 0 && this.se(), this.Ar();
      }, this.Cr));
  }
  se() {
    var e = Date.now(),
      t = [],
      s = this.$r.filter((i) => i.retryAt < e || (t.push(i), !1));
    if (((this.$r = t), s.length > 0))
      for (var { requestOptions: r } of s) this.retriableRequest(r);
  }
  unload() {
    for (var { requestOptions: e } of (this.Dr &&
      (clearTimeout(this.Dr), (this.Dr = void 0)),
    this.$r))
      try {
        this._instance.Pe(nt({}, e, { transport: "sendBeacon" }));
      } catch (t) {
        at.error(t);
      }
    this.$r = [];
  }
}
class Foe {
  constructor(e) {
    (this.Lr = () => {
      var t, s, r, i;
      this.jr || (this.jr = {});
      var a = this.scrollElement(),
        o = this.scrollY(),
        l = a ? Math.max(0, a.scrollHeight - a.clientHeight) : 0,
        c = o + (a?.clientHeight || 0),
        h = a?.scrollHeight || 0;
      (this.jr.lastScrollY = Math.ceil(o)),
        (this.jr.maxScrollY = Math.max(
          o,
          (t = this.jr.maxScrollY) !== null && t !== void 0 ? t : 0
        )),
        (this.jr.maxScrollHeight = Math.max(
          l,
          (s = this.jr.maxScrollHeight) !== null && s !== void 0 ? s : 0
        )),
        (this.jr.lastContentY = c),
        (this.jr.maxContentY = Math.max(
          c,
          (r = this.jr.maxContentY) !== null && r !== void 0 ? r : 0
        )),
        (this.jr.maxContentHeight = Math.max(
          h,
          (i = this.jr.maxContentHeight) !== null && i !== void 0 ? i : 0
        ));
    }),
      (this._instance = e);
  }
  getContext() {
    return this.jr;
  }
  resetContext() {
    var e = this.jr;
    return setTimeout(this.Lr, 0), e;
  }
  startMeasuringScrollPosition() {
    is(Re, "scroll", this.Lr, { capture: !0 }),
      is(Re, "scrollend", this.Lr, { capture: !0 }),
      is(Re, "resize", this.Lr);
  }
  scrollElement() {
    if (!this._instance.config.scroll_root_selector)
      return Re?.document.documentElement;
    var e = zn(this._instance.config.scroll_root_selector)
      ? this._instance.config.scroll_root_selector
      : [this._instance.config.scroll_root_selector];
    for (var t of e) {
      var s = Re?.document.querySelector(t);
      if (s) return s;
    }
  }
  scrollY() {
    if (this._instance.config.scroll_root_selector) {
      var e = this.scrollElement();
      return (e && e.scrollTop) || 0;
    }
    return (
      (Re &&
        (Re.scrollY ||
          Re.pageYOffset ||
          Re.document.documentElement.scrollTop)) ||
      0
    );
  }
  scrollX() {
    if (this._instance.config.scroll_root_selector) {
      var e = this.scrollElement();
      return (e && e.scrollLeft) || 0;
    }
    return (
      (Re &&
        (Re.scrollX ||
          Re.pageXOffset ||
          Re.document.documentElement.scrollLeft)) ||
      0
    );
  }
}
var Uoe = (n) =>
  bH(
    n?.config.mask_personal_data_properties,
    n?.config.custom_personal_data_properties
  );
class $oe {
  constructor(e, t, s, r) {
    (this.Nr = (i) => {
      var a = this.zr();
      if (!a || a.sessionId !== i) {
        var o = { sessionId: i, props: this.Ur(this._instance) };
        this.qr.register({ [PR]: o });
      }
    }),
      (this._instance = e),
      (this.Br = t),
      (this.qr = s),
      (this.Ur = r || Uoe),
      this.Br.onSessionId(this.Nr);
  }
  zr() {
    return this.qr.props[PR];
  }
  getSetOnceProps() {
    var e,
      t = (e = this.zr()) == null ? void 0 : e.props;
    return t
      ? "r" in t
        ? xH(t)
        : {
            $referring_domain: t.referringDomain,
            $pathname: t.initialPathName,
            utm_source: t.utm_source,
            utm_campaign: t.utm_campaign,
            utm_medium: t.utm_medium,
            utm_content: t.utm_content,
            utm_term: t.utm_term,
          }
      : {};
  }
  getSessionProps() {
    var e = {};
    return (
      Dn(KI(this.getSetOnceProps()), (t, s) => {
        s === "$current_url" && (s = "url"), (e["$session_entry_" + TR(s)] = t);
      }),
      e
    );
  }
}
var yU = cr("[SessionId]");
class Boe {
  constructor(e, t, s) {
    var r;
    if (
      ((this.Hr = []),
      (this.Wr = (h, m) => Math.abs(h - m) > this.sessionTimeoutMs),
      !e.persistence)
    )
      throw new Error(
        "SessionIdManager requires a PostHogPersistence instance"
      );
    if (e.config.__preview_experimental_cookieless_mode)
      throw new Error(
        "SessionIdManager cannot be used with __preview_experimental_cookieless_mode"
      );
    (this.S = e.config),
      (this.qr = e.persistence),
      (this.fi = void 0),
      (this.Ct = void 0),
      (this._sessionStartTimestamp = null),
      (this._sessionActivityTimestamp = null),
      (this.Gr = t || Rc),
      (this.Jr = s || Rc);
    var i = this.S.persistence_name || this.S.token,
      a = this.S.session_idle_timeout_seconds || 1800;
    if (
      ((this._sessionTimeoutMs =
        1e3 * Ai(a, 60, 36e3, "session_idle_timeout_seconds", 1800)),
      e.register({ $configured_session_timeout_ms: this._sessionTimeoutMs }),
      this.Vr(),
      (this.Kr = "ph_" + i + "_window_id"),
      (this.Yr = "ph_" + i + "_primary_window_exists"),
      this.Xr())
    ) {
      var o = vr.L(this.Kr),
        l = vr.L(this.Yr);
      o && !l ? (this.fi = o) : vr.N(this.Kr), vr.j(this.Yr, !0);
    }
    if ((r = this.S.bootstrap) != null && r.sessionID)
      try {
        var c = ((h) => {
          var m = h.replace(/-/g, "");
          if (m.length !== 32) throw new Error("Not a valid UUID");
          if (m[12] !== "7") throw new Error("Not a UUIDv7");
          return parseInt(m.substring(0, 12), 16);
        })(this.S.bootstrap.sessionID);
        this.Qr(this.S.bootstrap.sessionID, new Date().getTime(), c);
      } catch (h) {
        yU.error("Invalid sessionID in bootstrap", h);
      }
    this.Zr();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(e) {
    return (
      We(this.Hr) && (this.Hr = []),
      this.Hr.push(e),
      this.Ct && e(this.Ct, this.fi),
      () => {
        this.Hr = this.Hr.filter((t) => t !== e);
      }
    );
  }
  Xr() {
    return this.S.persistence !== "memory" && !this.qr.Ae && vr.O();
  }
  ts(e) {
    e !== this.fi && ((this.fi = e), this.Xr() && vr.j(this.Kr, e));
  }
  es() {
    return this.fi ? this.fi : this.Xr() ? vr.L(this.Kr) : null;
  }
  Qr(e, t, s) {
    (e === this.Ct &&
      t === this._sessionActivityTimestamp &&
      s === this._sessionStartTimestamp) ||
      ((this._sessionStartTimestamp = s),
      (this._sessionActivityTimestamp = t),
      (this.Ct = e),
      this.qr.register({ [yx]: [t, e, s] }));
  }
  rs() {
    if (
      this.Ct &&
      this._sessionActivityTimestamp &&
      this._sessionStartTimestamp
    )
      return [
        this._sessionActivityTimestamp,
        this.Ct,
        this._sessionStartTimestamp,
      ];
    var e = this.qr.props[yx];
    return zn(e) && e.length === 2 && e.push(e[0]), e || [0, null, 0];
  }
  resetSessionId() {
    this.Qr(null, null, null);
  }
  Zr() {
    is(
      Re,
      "beforeunload",
      () => {
        this.Xr() && vr.N(this.Yr);
      },
      { capture: !1 }
    );
  }
  checkAndGetSessionAndWindowId(e, t) {
    if (
      (e === void 0 && (e = !1),
      t === void 0 && (t = null),
      this.S.__preview_experimental_cookieless_mode)
    )
      throw new Error(
        "checkAndGetSessionAndWindowId should not be called in __preview_experimental_cookieless_mode"
      );
    var s = t || new Date().getTime(),
      [r, i, a] = this.rs(),
      o = this.es(),
      l = Cr(a) && a > 0 && Math.abs(s - a) > 864e5,
      c = !1,
      h = !i,
      m = !e && this.Wr(s, r);
    h || m || l
      ? ((i = this.Gr()),
        (o = this.Jr()),
        yU.info("new session ID generated", {
          sessionId: i,
          windowId: o,
          changeReason: {
            noSessionId: h,
            activityTimeout: m,
            sessionPastMaximumLength: l,
          },
        }),
        (a = s),
        (c = !0))
      : o || ((o = this.Jr()), (c = !0));
    var p = r === 0 || !e || l ? s : r,
      g = a === 0 ? new Date().getTime() : a;
    return (
      this.ts(o),
      this.Qr(i, p, g),
      e || this.Vr(),
      c &&
        this.Hr.forEach((y) =>
          y(
            i,
            o,
            c
              ? {
                  noSessionId: h,
                  activityTimeout: m,
                  sessionPastMaximumLength: l,
                }
              : void 0
          )
        ),
      {
        sessionId: i,
        windowId: o,
        sessionStartTimestamp: g,
        changeReason: c
          ? { noSessionId: h, activityTimeout: m, sessionPastMaximumLength: l }
          : void 0,
        lastActivityTimestamp: r,
      }
    );
  }
  Vr() {
    clearTimeout(this.ss),
      (this.ss = setTimeout(() => {
        var [e] = this.rs();
        this.Wr(new Date().getTime(), e) && this.resetSessionId();
      }, 1.1 * this.sessionTimeoutMs));
  }
}
var Hoe = ["$set_once", "$set"],
  tc = cr("[SiteApps]");
class Voe {
  constructor(e) {
    (this._instance = e), (this.ns = []), (this.apps = {});
  }
  get isEnabled() {
    return !!this._instance.config.opt_in_site_apps;
  }
  os(e, t) {
    if (t) {
      var s = this.globalsForEvent(t);
      this.ns.push(s), this.ns.length > 1e3 && (this.ns = this.ns.slice(10));
    }
  }
  get siteAppLoaders() {
    var e;
    return (e = Mt._POSTHOG_REMOTE_CONFIG) == null ||
      (e = e[this._instance.config.token]) == null
      ? void 0
      : e.siteApps;
  }
  init() {
    if (this.isEnabled) {
      var e = this._instance.Ve(this.os.bind(this));
      this.ls = () => {
        e(), (this.ns = []), (this.ls = void 0);
      };
    }
  }
  globalsForEvent(e) {
    var t, s, r, i, a, o, l;
    if (!e) throw new Error("Event payload is required");
    var c = {},
      h = this._instance.get_property("$groups") || [],
      m = this._instance.get_property("$stored_group_properties") || {};
    for (var [p, g] of Object.entries(m))
      c[p] = { id: h[p], type: p, properties: g };
    var { $set_once: y, $set: b } = e;
    return {
      event: nt({}, b8(e, Hoe), {
        properties: nt(
          {},
          e.properties,
          b
            ? {
                $set: nt(
                  {},
                  (t = (s = e.properties) == null ? void 0 : s.$set) !== null &&
                    t !== void 0
                    ? t
                    : {},
                  b
                ),
              }
            : {},
          y
            ? {
                $set_once: nt(
                  {},
                  (r = (i = e.properties) == null ? void 0 : i.$set_once) !==
                    null && r !== void 0
                    ? r
                    : {},
                  y
                ),
              }
            : {}
        ),
        elements_chain:
          (a = (o = e.properties) == null ? void 0 : o.$elements_chain) !==
            null && a !== void 0
            ? a
            : "",
        distinct_id: (l = e.properties) == null ? void 0 : l.distinct_id,
      }),
      person: {
        properties: this._instance.get_property("$stored_person_properties"),
      },
      groups: c,
    };
  }
  setupSiteApp(e) {
    var t = this.apps[e.id],
      s = () => {
        var o;
        !t.errored &&
          this.ns.length &&
          (tc.info(
            "Processing " +
              this.ns.length +
              " events for site app with id " +
              e.id
          ),
          this.ns.forEach((l) =>
            t.processEvent == null ? void 0 : t.processEvent(l)
          ),
          (t.processedBuffer = !0)),
          Object.values(this.apps).every(
            (l) => l.processedBuffer || l.errored
          ) &&
            ((o = this.ls) == null || o.call(this));
      },
      r = !1,
      i = (o) => {
        (t.errored = !o),
          (t.loaded = !0),
          tc.info(
            "Site app with id " + e.id + " " + (o ? "loaded" : "errored")
          ),
          r && s();
      };
    try {
      var { processEvent: a } = e.init({
        posthog: this._instance,
        callback: (o) => {
          i(o);
        },
      });
      a && (t.processEvent = a), (r = !0);
    } catch (o) {
      tc.error(
        "Error while initializing PostHog app with config id " + e.id,
        o
      ),
        i(!1);
    }
    if (r && t.loaded)
      try {
        s();
      } catch (o) {
        tc.error(
          "Error while processing buffered events PostHog app with config id " +
            e.id,
          o
        ),
          (t.errored = !0);
      }
  }
  us() {
    var e = this.siteAppLoaders || [];
    for (var t of e)
      this.apps[t.id] = {
        id: t.id,
        loaded: !1,
        errored: !1,
        processedBuffer: !1,
      };
    for (var s of e) this.setupSiteApp(s);
  }
  hs(e) {
    if (Object.keys(this.apps).length !== 0) {
      var t = this.globalsForEvent(e);
      for (var s of Object.values(this.apps))
        try {
          s.processEvent == null || s.processEvent(t);
        } catch (r) {
          tc.error(
            "Error while processing event " + e.event + " for site app " + s.id,
            r
          );
        }
    }
  }
  onRemoteConfig(e) {
    var t,
      s,
      r,
      i = this;
    if ((t = this.siteAppLoaders) != null && t.length)
      return this.isEnabled
        ? (this.us(),
          void this._instance.on("eventCaptured", (c) => this.hs(c)))
        : void tc.error(
            'PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.'
          );
    if (
      ((s = this.ls) == null || s.call(this),
      (r = e.siteApps) != null && r.length)
    )
      if (this.isEnabled) {
        var a = function (c) {
          var h;
          (Mt["__$$ph_site_app_" + c] = i._instance),
            (h = Mt.__PosthogExtensions__) == null ||
              h.loadSiteApp == null ||
              h.loadSiteApp(i._instance, l, (m) => {
                if (m)
                  return tc.error(
                    "Error while initializing PostHog app with config id " + c,
                    m
                  );
              });
        };
        for (var { id: o, url: l } of e.siteApps) a(o);
      } else
        tc.error(
          'PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.'
        );
  }
}
var zoe = [
    "amazonbot",
    "amazonproductbot",
    "app.hypefactors.com",
    "applebot",
    "archive.org_bot",
    "awariobot",
    "backlinksextendedbot",
    "baiduspider",
    "bingbot",
    "bingpreview",
    "chrome-lighthouse",
    "dataforseobot",
    "deepscan",
    "duckduckbot",
    "facebookexternal",
    "facebookcatalog",
    "http://yandex.com/bots",
    "hubspot",
    "ia_archiver",
    "leikibot",
    "linkedinbot",
    "meta-externalagent",
    "mj12bot",
    "msnbot",
    "nessus",
    "petalbot",
    "pinterest",
    "prerender",
    "rogerbot",
    "screaming frog",
    "sebot-wa",
    "sitebulb",
    "slackbot",
    "slurp",
    "trendictionbot",
    "turnitin",
    "twitterbot",
    "vercelbot",
    "yahoo! slurp",
    "yandexbot",
    "zoombot",
    "bot.htm",
    "bot.php",
    "(bot;",
    "bot/",
    "crawler",
    "ahrefsbot",
    "ahrefssiteaudit",
    "semrushbot",
    "siteauditbot",
    "splitsignalbot",
    "gptbot",
    "oai-searchbot",
    "chatgpt-user",
    "perplexitybot",
    "better uptime bot",
    "sentryuptimebot",
    "uptimerobot",
    "headlesschrome",
    "cypress",
    "google-hoteladsverifier",
    "adsbot-google",
    "apis-google",
    "duplexweb-google",
    "feedfetcher-google",
    "google favicon",
    "google web preview",
    "google-read-aloud",
    "googlebot",
    "googleother",
    "google-cloudvertexbot",
    "googleweblight",
    "mediapartners-google",
    "storebot-google",
    "google-inspectiontool",
    "bytespider",
  ],
  bU = function (n, e) {
    if (!n) return !1;
    var t = n.toLowerCase();
    return zoe.concat(e || []).some((s) => {
      var r = s.toLowerCase();
      return t.indexOf(r) !== -1;
    });
  },
  SH = function (n, e) {
    if (!n) return !1;
    var t = n.userAgent;
    if (t && bU(t, e)) return !0;
    try {
      var s = n?.userAgentData;
      if (s != null && s.brands && s.brands.some((r) => bU(r?.brand, e)))
        return !0;
    } catch {}
    return !!n.webdriver;
  },
  Ap = (function (n) {
    return (n.US = "us"), (n.EU = "eu"), (n.CUSTOM = "custom"), n;
  })({}),
  xU = "i.posthog.com";
let Goe = class {
  constructor(e) {
    (this.ds = {}), (this.instance = e);
  }
  get apiHost() {
    var e = this.instance.config.api_host.trim().replace(/\/$/, "");
    return e === "https://app.posthog.com" ? "https://us.i.posthog.com" : e;
  }
  get uiHost() {
    var e,
      t =
        (e = this.instance.config.ui_host) == null
          ? void 0
          : e.replace(/\/$/, "");
    return (
      t || (t = this.apiHost.replace("." + xU, ".posthog.com")),
      t === "https://app.posthog.com" ? "https://us.posthog.com" : t
    );
  }
  get region() {
    return (
      this.ds[this.apiHost] ||
        (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost)
          ? (this.ds[this.apiHost] = Ap.US)
          : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost)
          ? (this.ds[this.apiHost] = Ap.EU)
          : (this.ds[this.apiHost] = Ap.CUSTOM)),
      this.ds[this.apiHost]
    );
  }
  endpointFor(e, t) {
    if (
      (t === void 0 && (t = ""),
      t && (t = t[0] === "/" ? t : "/" + t),
      e === "ui")
    )
      return this.uiHost + t;
    if (this.region === Ap.CUSTOM) return this.apiHost + t;
    var s = xU + t;
    switch (e) {
      case "assets":
        return "https://" + this.region + "-assets." + s;
      case "api":
        return "https://" + this.region + "." + s;
    }
  }
};
var qoe = {
  icontains: (n, e) =>
    !!Re && e.href.toLowerCase().indexOf(n.toLowerCase()) > -1,
  not_icontains: (n, e) =>
    !!Re && e.href.toLowerCase().indexOf(n.toLowerCase()) === -1,
  regex: (n, e) => !!Re && wf(e.href, n),
  not_regex: (n, e) => !!Re && !wf(e.href, n),
  exact: (n, e) => e.href === n,
  is_not: (n, e) => e.href !== n,
};
class _r {
  constructor(e) {
    var t = this;
    (this.getWebExperimentsAndEvaluateDisplayLogic = function (s) {
      s === void 0 && (s = !1),
        t.getWebExperiments((r) => {
          _r.vs("retrieved web experiments from the server"),
            (t.cs = new Map()),
            r.forEach((i) => {
              if (i.feature_flag_key) {
                var a;
                t.cs &&
                  (_r.vs(
                    "setting flag key ",
                    i.feature_flag_key,
                    " to web experiment ",
                    i
                  ),
                  (a = t.cs) == null || a.set(i.feature_flag_key, i));
                var o = t._instance.getFeatureFlag(i.feature_flag_key);
                ms(o) &&
                  i.variants[o] &&
                  t.fs(i.name, o, i.variants[o].transforms);
              } else if (i.variants)
                for (var l in i.variants) {
                  var c = i.variants[l];
                  _r.ps(c) && t.fs(i.name, l, c.transforms);
                }
            });
        }, s);
    }),
      (this._instance = e),
      this._instance.onFeatureFlags((s) => {
        this.onFeatureFlags(s);
      });
  }
  onFeatureFlags(e) {
    if (this._is_bot())
      _r.vs(
        "Refusing to render web experiment since the viewer is a likely bot"
      );
    else if (!this._instance.config.disable_web_experiments) {
      if (yn(this.cs))
        return (
          (this.cs = new Map()),
          this.loadIfEnabled(),
          void this.previewWebExperiment()
        );
      _r.vs("applying feature flags", e),
        e.forEach((t) => {
          var s;
          if (this.cs && (s = this.cs) != null && s.has(t)) {
            var r,
              i = this._instance.getFeatureFlag(t),
              a = (r = this.cs) == null ? void 0 : r.get(t);
            i &&
              a != null &&
              a.variants[i] &&
              this.fs(a.name, i, a.variants[i].transforms);
          }
        });
    }
  }
  previewWebExperiment() {
    var e = _r.getWindowLocation();
    if (e != null && e.search) {
      var t = Sx(e?.search, "__experiment_id"),
        s = Sx(e?.search, "__experiment_variant");
      t &&
        s &&
        (_r.vs("previewing web experiments " + t + " && " + s),
        this.getWebExperiments(
          (r) => {
            this._s(parseInt(t), s, r);
          },
          !1,
          !0
        ));
    }
  }
  loadIfEnabled() {
    this._instance.config.disable_web_experiments ||
      this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(e, t, s) {
    if (this._instance.config.disable_web_experiments && !s) return e([]);
    var r = this._instance.get_property("$web_experiments");
    if (r && !t) return e(r);
    this._instance.Pe({
      url: this._instance.requestRouter.endpointFor(
        "api",
        "/api/web_experiments/?token=" + this._instance.config.token
      ),
      method: "GET",
      callback: (i) => {
        if (i.statusCode !== 200 || !i.json) return e([]);
        var a = i.json.experiments || [];
        return e(a);
      },
    });
  }
  _s(e, t, s) {
    var r = s.filter((i) => i.id === e);
    r &&
      r.length > 0 &&
      (_r.vs(
        "Previewing web experiment [" + r[0].name + "] with variant [" + t + "]"
      ),
      this.fs(r[0].name, t, r[0].variants[t].transforms));
  }
  static ps(e) {
    return !yn(e.conditions) && _r.gs(e) && _r.bs(e);
  }
  static gs(e) {
    var t;
    if (yn(e.conditions) || yn((t = e.conditions) == null ? void 0 : t.url))
      return !0;
    var s,
      r,
      i,
      a = _r.getWindowLocation();
    return (
      !!a &&
      ((s = e.conditions) == null ||
        !s.url ||
        qoe[
          (r = (i = e.conditions) == null ? void 0 : i.urlMatchType) !== null &&
          r !== void 0
            ? r
            : "icontains"
        ](e.conditions.url, a))
    );
  }
  static getWindowLocation() {
    return Re?.location;
  }
  static bs(e) {
    var t;
    if (yn(e.conditions) || yn((t = e.conditions) == null ? void 0 : t.utm))
      return !0;
    var s = pH();
    if (s.utm_source) {
      var r,
        i,
        a,
        o,
        l,
        c,
        h,
        m,
        p =
          (r = e.conditions) == null ||
          (r = r.utm) == null ||
          !r.utm_campaign ||
          ((i = e.conditions) == null || (i = i.utm) == null
            ? void 0
            : i.utm_campaign) == s.utm_campaign,
        g =
          (a = e.conditions) == null ||
          (a = a.utm) == null ||
          !a.utm_source ||
          ((o = e.conditions) == null || (o = o.utm) == null
            ? void 0
            : o.utm_source) == s.utm_source,
        y =
          (l = e.conditions) == null ||
          (l = l.utm) == null ||
          !l.utm_medium ||
          ((c = e.conditions) == null || (c = c.utm) == null
            ? void 0
            : c.utm_medium) == s.utm_medium,
        b =
          (h = e.conditions) == null ||
          (h = h.utm) == null ||
          !h.utm_term ||
          ((m = e.conditions) == null || (m = m.utm) == null
            ? void 0
            : m.utm_term) == s.utm_term;
      return p && y && b && g;
    }
    return !1;
  }
  static vs(e) {
    for (
      var t = arguments.length, s = new Array(t > 1 ? t - 1 : 0), r = 1;
      r < t;
      r++
    )
      s[r - 1] = arguments[r];
    at.info("[WebExperiments] " + e, s);
  }
  fs(e, t, s) {
    this._is_bot()
      ? _r.vs(
          "Refusing to render web experiment since the viewer is a likely bot"
        )
      : t !== "control"
      ? s.forEach((r) => {
          if (r.selector) {
            var i;
            _r.vs(
              "applying transform of variant " +
                t +
                " for experiment " +
                e +
                " ",
              r
            );
            var a =
              (i = document) == null ? void 0 : i.querySelectorAll(r.selector);
            a?.forEach((o) => {
              var l = o;
              r.html && (l.innerHTML = r.html),
                r.css && l.setAttribute("style", r.css);
            });
          }
        })
      : _r.vs("Control variants leave the page unmodified.");
  }
  _is_bot() {
    return _i && this._instance
      ? SH(_i, this._instance.config.custom_blocked_useragents)
      : void 0;
  }
}
var Woe = cr("[PostHog ExternalIntegrations]"),
  Koe = {
    intercom: "intercom-integration",
    crispChat: "crisp-chat-integration",
  };
class Yoe {
  constructor(e) {
    this._instance = e;
  }
  J(e, t) {
    var s;
    (s = Mt.__PosthogExtensions__) == null ||
      s.loadExternalDependency == null ||
      s.loadExternalDependency(this._instance, e, (r) => {
        if (r) return Woe.error("failed to load script", r);
        t();
      });
  }
  startIfEnabledOrStop() {
    var e = this,
      t = function (a) {
        var o, l, c;
        !r ||
          ((o = Mt.__PosthogExtensions__) != null &&
            (o = o.integrations) != null &&
            o[a]) ||
          e.J(Koe[a], () => {
            var h;
            (h = Mt.__PosthogExtensions__) == null ||
              (h = h.integrations) == null ||
              (h = h[a]) == null ||
              h.start(e._instance);
          }),
          !r &&
            (l = Mt.__PosthogExtensions__) != null &&
            (l = l.integrations) != null &&
            l[a] &&
            ((c = Mt.__PosthogExtensions__) == null ||
              (c = c.integrations) == null ||
              (c = c[a]) == null ||
              c.stop());
      };
    for (var [s, r] of Object.entries(
      (i = this._instance.config.integrations) !== null && i !== void 0 ? i : {}
    )) {
      var i;
      t(s);
    }
  }
}
var Wp = {},
  QR = () => {},
  Th = "posthog",
  TH = !loe && Zr?.indexOf("MSIE") === -1 && Zr?.indexOf("Mozilla") === -1,
  wU = (n) => {
    var e;
    return {
      api_host: "https://us.i.posthog.com",
      ui_host: null,
      token: "",
      autocapture: !0,
      rageclick: !0,
      cross_subdomain_cookie: $ie(rt?.location),
      persistence: "localStorage+cookie",
      persistence_name: "",
      loaded: QR,
      save_campaign_params: !0,
      custom_campaign_params: [],
      custom_blocked_useragents: [],
      save_referrer: !0,
      capture_pageview: n !== "2025-05-24" || "history_change",
      capture_pageleave: "if_capture_pageview",
      defaults: n ?? "unset",
      debug:
        (ti &&
          ms(ti?.search) &&
          ti.search.indexOf("__posthog_debug=true") !== -1) ||
        !1,
      cookie_expiration: 365,
      upgrade: !1,
      disable_session_recording: !1,
      disable_persistence: !1,
      disable_web_experiments: !0,
      disable_surveys: !1,
      disable_surveys_automatic_display: !1,
      disable_external_dependency_loading: !1,
      enable_recording_console_log: void 0,
      secure_cookie:
        (Re == null || (e = Re.location) == null ? void 0 : e.protocol) ===
        "https:",
      ip: !1,
      opt_out_capturing_by_default: !1,
      opt_out_persistence_by_default: !1,
      opt_out_useragent_filter: !1,
      opt_out_capturing_persistence_type: "localStorage",
      opt_out_capturing_cookie_prefix: null,
      opt_in_site_apps: !1,
      property_denylist: [],
      respect_dnt: !1,
      sanitize_properties: null,
      request_headers: {},
      request_batching: !0,
      properties_string_max_length: 65535,
      session_recording: {},
      mask_all_element_attributes: !1,
      mask_all_text: !1,
      mask_personal_data_properties: !1,
      custom_personal_data_properties: [],
      advanced_disable_flags: !1,
      advanced_disable_decide: !1,
      advanced_disable_feature_flags: !1,
      advanced_disable_feature_flags_on_first_load: !1,
      advanced_only_evaluate_survey_feature_flags: !1,
      advanced_disable_toolbar_metrics: !1,
      feature_flag_request_timeout_ms: 3e3,
      surveys_request_timeout_ms: 1e4,
      on_request_error: (t) => {
        var s = "Bad HTTP status: " + t.statusCode + " " + t.text;
        at.error(s);
      },
      get_device_id: (t) => t,
      capture_performance: void 0,
      name: "posthog",
      bootstrap: {},
      disable_compression: !1,
      session_idle_timeout_seconds: 1800,
      person_profiles: "identified_only",
      before_send: void 0,
      request_queue_config: { flush_interval_ms: XR },
      error_tracking: {},
      _onCapture: QR,
    };
  },
  EU = (n) => {
    var e = {};
    We(n.process_person) || (e.person_profiles = n.process_person),
      We(n.xhr_headers) || (e.request_headers = n.xhr_headers),
      We(n.cookie_name) || (e.persistence_name = n.cookie_name),
      We(n.disable_cookie) || (e.disable_persistence = n.disable_cookie),
      We(n.store_google) || (e.save_campaign_params = n.store_google),
      We(n.verbose) || (e.debug = n.verbose);
    var t = As({}, e, n);
    return (
      zn(n.property_blacklist) &&
        (We(n.property_denylist)
          ? (t.property_denylist = n.property_blacklist)
          : zn(n.property_denylist)
          ? (t.property_denylist = [
              ...n.property_blacklist,
              ...n.property_denylist,
            ])
          : at.error(
              "Invalid value for property_denylist config: " +
                n.property_denylist
            )),
      t
    );
  };
class Xoe {
  constructor() {
    this.__forceAllowLocalhost = !1;
  }
  get ys() {
    return this.__forceAllowLocalhost;
  }
  set ys(e) {
    at.error(
      "WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"
    ),
      (this.__forceAllowLocalhost = e);
  }
}
class vE {
  get decideEndpointWasHit() {
    var e, t;
    return (
      (e = (t = this.featureFlags) == null ? void 0 : t.hasLoadedFlags) !==
        null &&
      e !== void 0 &&
      e
    );
  }
  get flagsEndpointWasHit() {
    var e, t;
    return (
      (e = (t = this.featureFlags) == null ? void 0 : t.hasLoadedFlags) !==
        null &&
      e !== void 0 &&
      e
    );
  }
  constructor() {
    (this.webPerformance = new Xoe()),
      (this.ws = !1),
      (this.version = yl.LIB_VERSION),
      (this.Ss = new EH()),
      (this._calculate_event_properties =
        this.calculateEventProperties.bind(this)),
      (this.config = wU()),
      (this.SentryIntegration = Zae),
      (this.sentryIntegration = (e) =>
        (function (t, s) {
          var r = Z8(t, s);
          return { name: Q8, processEvent: (i) => r(i) };
        })(this, e)),
      (this.__request_queue = []),
      (this.__loaded = !1),
      (this.analyticsDefaultEndpoint = "/e/"),
      (this.$s = !1),
      (this.xs = null),
      (this.ks = null),
      (this.Es = null),
      (this.featureFlags = new Roe(this)),
      (this.toolbar = new eoe(this)),
      (this.scrollManager = new Foe(this)),
      (this.pageViewManager = new aoe(this)),
      (this.surveys = new Doe(this)),
      (this.experiments = new _r(this)),
      (this.exceptions = new uoe(this)),
      (this.rateLimiter = new Poe(this)),
      (this.requestRouter = new Goe(this)),
      (this.consent = new lae(this)),
      (this.externalIntegrations = new Yoe(this)),
      (this.people = {
        set: (e, t, s) => {
          var r = ms(e) ? { [e]: t } : e;
          this.setPersonProperties(r), s?.({});
        },
        set_once: (e, t, s) => {
          var r = ms(e) ? { [e]: t } : e;
          this.setPersonProperties(void 0, r), s?.({});
        },
      }),
      this.on("eventCaptured", (e) => at.info('send "' + e?.event + '"', e));
  }
  init(e, t, s) {
    if (s && s !== Th) {
      var r,
        i = (r = Wp[s]) !== null && r !== void 0 ? r : new vE();
      return i._init(e, t, s), (Wp[s] = i), (Wp[Th][s] = i), i;
    }
    return this._init(e, t, s);
  }
  _init(e, t, s) {
    var r, i;
    if ((t === void 0 && (t = {}), We(e) || _R(e)))
      return (
        at.critical(
          "PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"
        ),
        this
      );
    if (this.__loaded)
      return (
        at.warn(
          "You have already initialized PostHog! Re-initializing is a no-op"
        ),
        this
      );
    (this.__loaded = !0),
      (this.config = {}),
      (this.Is = t),
      (this.Ps = []),
      t.person_profiles && (this.ks = t.person_profiles),
      this.set_config(As({}, wU(t.defaults), EU(t), { name: s, token: e })),
      this.config.on_xhr_error &&
        at.error("on_xhr_error is deprecated. Use on_request_error instead"),
      (this.compression = t.disable_compression ? void 0 : xl.GZipJS);
    var a = this.Rs();
    (this.persistence = new f1(this.config, a)),
      (this.sessionPersistence =
        this.config.persistence === "sessionStorage" ||
        this.config.persistence === "memory"
          ? this.persistence
          : new f1(nt({}, this.config, { persistence: "sessionStorage" }), a));
    var o = nt({}, this.persistence.props),
      l = nt({}, this.sessionPersistence.props);
    if (
      (this.register({ $initialization_time: new Date().toISOString() }),
      (this.Ts = new Noe((A) => this.Ms(A), this.config.request_queue_config)),
      (this.Cs = new joe(this)),
      (this.__request_queue = []),
      this.config.__preview_experimental_cookieless_mode ||
        ((this.sessionManager = new Boe(this)),
        (this.sessionPropsManager = new $oe(
          this,
          this.sessionManager,
          this.persistence
        ))),
      new noe(this).startIfEnabledOrStop(),
      (this.siteApps = new Voe(this)),
      (r = this.siteApps) == null || r.init(),
      this.config.__preview_experimental_cookieless_mode ||
        ((this.sessionRecording = new Xae(this)),
        this.sessionRecording.startIfEnabledOrStop()),
      this.config.disable_scroll_properties ||
        this.scrollManager.startMeasuringScrollPosition(),
      (this.autocapture = new eae(this)),
      this.autocapture.startIfEnabled(),
      this.surveys.loadIfEnabled(),
      (this.heatmaps = new ioe(this)),
      this.heatmaps.startIfEnabled(),
      (this.webVitalsAutocapture = new soe(this)),
      (this.exceptionObserver = new dae(this)),
      this.exceptionObserver.startIfEnabled(),
      (this.deadClicksAutocapture = new O8(this, uae)),
      this.deadClicksAutocapture.startIfEnabled(),
      (this.historyAutocapture = new _ae(this)),
      this.historyAutocapture.startIfEnabled(),
      (yl.DEBUG = yl.DEBUG || this.config.debug),
      yl.DEBUG &&
        at.info("Starting in debug mode", {
          this: this,
          config: t,
          thisC: nt({}, this.config),
          p: o,
          s: l,
        }),
      ((i = t.bootstrap) == null ? void 0 : i.distinctID) !== void 0)
    ) {
      var c,
        h,
        m = this.config.get_device_id(Rc()),
        p =
          (c = t.bootstrap) != null && c.isIdentifiedID
            ? m
            : t.bootstrap.distinctID;
      this.persistence.set_property(
        dl,
        (h = t.bootstrap) != null && h.isIdentifiedID
          ? "identified"
          : "anonymous"
      ),
        this.register({ distinct_id: t.bootstrap.distinctID, $device_id: p });
    }
    if (this.Fs()) {
      var g,
        y,
        b = Object.keys(
          ((g = t.bootstrap) == null ? void 0 : g.featureFlags) || {}
        )
          .filter((A) => {
            var _;
            return !(
              (_ = t.bootstrap) == null ||
              (_ = _.featureFlags) == null ||
              !_[A]
            );
          })
          .reduce((A, _) => {
            var R;
            return (
              (A[_] =
                ((R = t.bootstrap) == null || (R = R.featureFlags) == null
                  ? void 0
                  : R[_]) || !1),
              A
            );
          }, {}),
        w = Object.keys(
          ((y = t.bootstrap) == null ? void 0 : y.featureFlagPayloads) || {}
        )
          .filter((A) => b[A])
          .reduce((A, _) => {
            var R, C;
            return (
              (R = t.bootstrap) != null &&
                (R = R.featureFlagPayloads) != null &&
                R[_] &&
                (A[_] =
                  (C = t.bootstrap) == null ||
                  (C = C.featureFlagPayloads) == null
                    ? void 0
                    : C[_]),
              A
            );
          }, {});
      this.featureFlags.receivedFeatureFlags({
        featureFlags: b,
        featureFlagPayloads: w,
      });
    }
    if (this.config.__preview_experimental_cookieless_mode)
      this.register_once({ distinct_id: my, $device_id: null }, "");
    else if (!this.get_distinct_id()) {
      var S = this.config.get_device_id(Rc());
      this.register_once({ distinct_id: S, $device_id: S }, ""),
        this.persistence.set_property(dl, "anonymous");
    }
    return (
      is(
        Re,
        "onpagehide" in self ? "pagehide" : "unload",
        this._handle_unload.bind(this),
        { passive: !1 }
      ),
      this.toolbar.maybeLoadToolbar(),
      t.segment ? Qae(this, () => this.Os()) : this.Os(),
      sa(this.config._onCapture) &&
        this.config._onCapture !== QR &&
        (at.warn("onCapture is deprecated. Please use `before_send` instead"),
        this.on("eventCaptured", (A) => this.config._onCapture(A.event, A))),
      this.config.ip &&
        at.warn(
          'The `ip` config option has NO EFFECT AT ALL and has been deprecated. Use a custom transformation or "Discard IP data" project setting instead. See https://posthog.com/tutorials/web-redact-properties#hiding-customer-ip-address for more information.'
        ),
      this
    );
  }
  Re(e) {
    var t, s, r, i, a, o, l, c;
    if (!rt || !rt.body)
      return (
        at.info("document not ready yet, trying again in 500 milliseconds..."),
        void setTimeout(() => {
          this.Re(e);
        }, 500)
      );
    (this.compression = void 0),
      e.supportedCompression &&
        !this.config.disable_compression &&
        (this.compression = rn(e.supportedCompression, xl.GZipJS)
          ? xl.GZipJS
          : rn(e.supportedCompression, xl.Base64)
          ? xl.Base64
          : void 0),
      (t = e.analytics) != null &&
        t.endpoint &&
        (this.analyticsDefaultEndpoint = e.analytics.endpoint),
      this.set_config({
        person_profiles: this.ks ? this.ks : "identified_only",
      }),
      (s = this.siteApps) == null || s.onRemoteConfig(e),
      (r = this.sessionRecording) == null || r.onRemoteConfig(e),
      (i = this.autocapture) == null || i.onRemoteConfig(e),
      (a = this.heatmaps) == null || a.onRemoteConfig(e),
      this.surveys.onRemoteConfig(e),
      (o = this.webVitalsAutocapture) == null || o.onRemoteConfig(e),
      (l = this.exceptionObserver) == null || l.onRemoteConfig(e),
      this.exceptions.onRemoteConfig(e),
      (c = this.deadClicksAutocapture) == null || c.onRemoteConfig(e);
  }
  Os() {
    try {
      this.config.loaded(this);
    } catch (e) {
      at.critical("`loaded` function failed", e);
    }
    this.As(),
      this.config.capture_pageview &&
        setTimeout(() => {
          this.consent.isOptedIn() && this.Ds();
        }, 1),
      new Moe(this).load(),
      this.featureFlags.flags();
  }
  As() {
    var e;
    this.has_opted_out_capturing() ||
      (this.config.request_batching && ((e = this.Ts) == null || e.enable()));
  }
  _dom_loaded() {
    this.has_opted_out_capturing() ||
      Cc(this.__request_queue, (e) => this.Ms(e)),
      (this.__request_queue = []),
      this.As();
  }
  _handle_unload() {
    var e, t;
    this.config.request_batching
      ? (this.Ls() && this.capture("$pageleave"),
        (e = this.Ts) == null || e.unload(),
        (t = this.Cs) == null || t.unload())
      : this.Ls() &&
        this.capture("$pageleave", null, { transport: "sendBeacon" });
  }
  Pe(e) {
    this.__loaded &&
      (TH
        ? this.__request_queue.push(e)
        : this.rateLimiter.isServerRateLimited(e.batchKey) ||
          ((e.transport = e.transport || this.config.api_transport),
          (e.url = Cx(e.url, { ip: this.config.ip ? 1 : 0 })),
          (e.headers = nt({}, this.config.request_headers)),
          (e.compression =
            e.compression === "best-available"
              ? this.compression
              : e.compression),
          (e.fetchOptions = e.fetchOptions || this.config.fetch_options),
          ((t) => {
            var s,
              r,
              i,
              a = nt({}, t);
            (a.timeout = a.timeout || 6e4),
              (a.url = Cx(a.url, {
                _: new Date().getTime().toString(),
                ver: yl.LIB_VERSION,
                compression: a.compression,
              }));
            var o = (s = a.transport) !== null && s !== void 0 ? s : "fetch",
              l =
                (r =
                  (i = x8(qp, (c) => c.transport === o)) == null
                    ? void 0
                    : i.method) !== null && r !== void 0
                  ? r
                  : qp[0].method;
            if (!l) throw new Error("No available transport method");
            l(a);
          })(
            nt({}, e, {
              callback: (t) => {
                var s, r;
                this.rateLimiter.checkForLimiting(t),
                  t.statusCode >= 400 &&
                    ((s = (r = this.config).on_request_error) == null ||
                      s.call(r, t)),
                  e.callback == null || e.callback(t);
              },
            })
          )));
  }
  Ms(e) {
    this.Cs ? this.Cs.retriableRequest(e) : this.Pe(e);
  }
  _execute_array(e) {
    var t,
      s = [],
      r = [],
      i = [];
    Cc(e, (o) => {
      o &&
        ((t = o[0]),
        zn(t)
          ? i.push(o)
          : sa(o)
          ? o.call(this)
          : zn(o) && t === "alias"
          ? s.push(o)
          : zn(o) && t.indexOf("capture") !== -1 && sa(this[t])
          ? i.push(o)
          : r.push(o));
    });
    var a = function (o, l) {
      Cc(
        o,
        function (c) {
          if (zn(c[0])) {
            var h = l;
            Dn(c, function (m) {
              h = h[m[0]].apply(h, m.slice(1));
            });
          } else this[c[0]].apply(this, c.slice(1));
        },
        l
      );
    };
    a(s, this), a(r, this), a(i, this);
  }
  Fs() {
    var e, t;
    return (
      (((e = this.config.bootstrap) == null ? void 0 : e.featureFlags) &&
        Object.keys(
          (t = this.config.bootstrap) == null ? void 0 : t.featureFlags
        ).length > 0) ||
      !1
    );
  }
  push(e) {
    this._execute_array([e]);
  }
  capture(e, t, s) {
    var r;
    if (
      this.__loaded &&
      this.persistence &&
      this.sessionPersistence &&
      this.Ts
    ) {
      if (!this.consent.isOptedOut())
        if (!We(e) && ms(e)) {
          if (this.config.opt_out_useragent_filter || !this._is_bot()) {
            var i =
              s != null && s.skip_client_rate_limiting
                ? void 0
                : this.rateLimiter.clientRateLimitContext();
            if (i == null || !i.isRateLimited) {
              t != null &&
                t.$current_url &&
                !ms(t?.$current_url) &&
                (at.error(
                  "Invalid `$current_url` property provided to `posthog.capture`. Input must be a string. Ignoring provided value."
                ),
                t == null || delete t.$current_url),
                this.sessionPersistence.update_search_keyword(),
                this.config.save_campaign_params &&
                  this.sessionPersistence.update_campaign_params(),
                this.config.save_referrer &&
                  this.sessionPersistence.update_referrer_info(),
                (this.config.save_campaign_params ||
                  this.config.save_referrer) &&
                  this.persistence.set_initial_person_info();
              var a = new Date(),
                o = s?.timestamp || a,
                l = Rc(),
                c = {
                  uuid: l,
                  event: e,
                  properties: this.calculateEventProperties(e, t || {}, o, l),
                };
              i &&
                (c.properties.$lib_rate_limit_remaining_tokens =
                  i.remainingTokens),
                s?.$set && (c.$set = s?.$set);
              var h,
                m,
                p = this.js(s?.$set_once);
              if (
                (p && (c.$set_once = p),
                ((c = Fie(
                  c,
                  s != null && s._noTruncate
                    ? null
                    : this.config.properties_string_max_length
                )).timestamp = o),
                We(s?.timestamp) ||
                  ((c.properties.$event_time_override_provided = !0),
                  (c.properties.$event_time_override_system_time = a)),
                e === m1.DISMISSED || e === m1.SENT)
              ) {
                var g = t?.[gU.SURVEY_ID],
                  y = t?.[gU.SURVEY_ITERATION];
                localStorage.setItem(
                  ((m = "" + YR + (h = { id: g, current_iteration: y }).id),
                  h.current_iteration &&
                    h.current_iteration > 0 &&
                    (m = "" + YR + h.id + "_" + h.current_iteration),
                  m),
                  "true"
                ),
                  (c.$set = nt({}, c.$set, {
                    [Coe(
                      { id: g, current_iteration: y },
                      e === m1.SENT ? "responded" : "dismissed"
                    )]: !0,
                  }));
              }
              var b = nt({}, c.properties.$set, c.$set);
              if (
                ($h(b) || this.setPersonPropertiesForFlags(b),
                !yn(this.config.before_send))
              ) {
                var w = this.Ns(c);
                if (!w) return;
                c = w;
              }
              this.Ss.emit("eventCaptured", c);
              var S = {
                method: "POST",
                url:
                  (r = s?._url) !== null && r !== void 0
                    ? r
                    : this.requestRouter.endpointFor(
                        "api",
                        this.analyticsDefaultEndpoint
                      ),
                data: c,
                compression: "best-available",
                batchKey: s?._batchKey,
              };
              return (
                !this.config.request_batching ||
                (s && (s == null || !s._batchKey)) ||
                (s != null && s.send_instantly)
                  ? this.Ms(S)
                  : this.Ts.enqueue(S),
                c
              );
            }
            at.critical(
              "This capture call is ignored due to client rate limiting."
            );
          }
        } else at.error("No event name provided to posthog.capture");
    } else at.uninitializedWarning("posthog.capture");
  }
  Ve(e) {
    return this.on("eventCaptured", (t) => e(t.event, t));
  }
  calculateEventProperties(e, t, s, r, i) {
    if (((s = s || new Date()), !this.persistence || !this.sessionPersistence))
      return t;
    var a = i ? void 0 : this.persistence.remove_event_timer(e),
      o = nt({}, t);
    if (
      ((o.token = this.config.token),
      (o.$config_defaults = this.config.defaults),
      this.config.__preview_experimental_cookieless_mode &&
        (o.$cookieless_mode = !0),
      e === "$snapshot")
    ) {
      var l = nt(
        {},
        this.persistence.properties(),
        this.sessionPersistence.properties()
      );
      return (
        (o.distinct_id = l.distinct_id),
        ((!ms(o.distinct_id) && !Cr(o.distinct_id)) || _R(o.distinct_id)) &&
          at.error(
            "Invalid distinct_id for replay event. This indicates a bug in your implementation"
          ),
        o
      );
    }
    var c,
      h = Toe(
        this.config.mask_personal_data_properties,
        this.config.custom_personal_data_properties
      );
    if (this.sessionManager) {
      var { sessionId: m, windowId: p } =
        this.sessionManager.checkAndGetSessionAndWindowId(i, s.getTime());
      (o.$session_id = m), (o.$window_id = p);
    }
    this.sessionPropsManager &&
      As(o, this.sessionPropsManager.getSessionProps());
    try {
      var g;
      this.sessionRecording && As(o, this.sessionRecording.sdkDebugProperties),
        (o.$sdk_debug_retry_queue_size =
          (g = this.Cs) == null ? void 0 : g.length);
    } catch (S) {
      o.$sdk_debug_error_capturing_properties = String(S);
    }
    if (
      (this.requestRouter.region === Ap.CUSTOM &&
        (o.$lib_custom_api_host = this.config.api_host),
      (c =
        e !== "$pageview" || i
          ? e !== "$pageleave" || i
            ? this.pageViewManager.doEvent()
            : this.pageViewManager.doPageLeave(s)
          : this.pageViewManager.doPageView(s, r)),
      (o = As(o, c)),
      e === "$pageview" && rt && (o.title = rt.title),
      !We(a))
    ) {
      var y = s.getTime() - a;
      o.$duration = parseFloat((y / 1e3).toFixed(3));
    }
    Zr &&
      this.config.opt_out_useragent_filter &&
      (o.$browser_type = this._is_bot() ? "bot" : "browser"),
      ((o = As(
        {},
        h,
        this.persistence.properties(),
        this.sessionPersistence.properties(),
        o
      )).$is_identified = this._isIdentified()),
      zn(this.config.property_denylist)
        ? Dn(this.config.property_denylist, function (S) {
            delete o[S];
          })
        : at.error(
            "Invalid value for property_denylist config: " +
              this.config.property_denylist +
              " or property_blacklist config: " +
              this.config.property_blacklist
          );
    var b = this.config.sanitize_properties;
    b &&
      (at.error("sanitize_properties is deprecated. Use before_send instead"),
      (o = b(o, e)));
    var w = this.zs();
    return (
      (o.$process_person_profile = w),
      w && !i && this.Us("_calculate_event_properties"),
      o
    );
  }
  js(e) {
    var t;
    if (!this.persistence || !this.zs() || this.ws) return e;
    var s = this.persistence.get_initial_props(),
      r = (t = this.sessionPropsManager) == null ? void 0 : t.getSetOnceProps(),
      i = As({}, s, r || {}, e || {}),
      a = this.config.sanitize_properties;
    return (
      a &&
        (at.error("sanitize_properties is deprecated. Use before_send instead"),
        (i = a(i, "$set_once"))),
      (this.ws = !0),
      $h(i) ? void 0 : i
    );
  }
  register(e, t) {
    var s;
    (s = this.persistence) == null || s.register(e, t);
  }
  register_once(e, t, s) {
    var r;
    (r = this.persistence) == null || r.register_once(e, t, s);
  }
  register_for_session(e) {
    var t;
    (t = this.sessionPersistence) == null || t.register(e);
  }
  unregister(e) {
    var t;
    (t = this.persistence) == null || t.unregister(e);
  }
  unregister_for_session(e) {
    var t;
    (t = this.sessionPersistence) == null || t.unregister(e);
  }
  qs(e, t) {
    this.register({ [e]: t });
  }
  getFeatureFlag(e, t) {
    return this.featureFlags.getFeatureFlag(e, t);
  }
  getFeatureFlagPayload(e) {
    var t = this.featureFlags.getFeatureFlagPayload(e);
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  }
  isFeatureEnabled(e, t) {
    return this.featureFlags.isFeatureEnabled(e, t);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(e, t, s) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(e, t, s);
  }
  getEarlyAccessFeatures(e, t, s) {
    return (
      t === void 0 && (t = !1),
      this.featureFlags.getEarlyAccessFeatures(e, t, s)
    );
  }
  on(e, t) {
    return this.Ss.on(e, t);
  }
  onFeatureFlags(e) {
    return this.featureFlags.onFeatureFlags(e);
  }
  onSurveysLoaded(e) {
    return this.surveys.onSurveysLoaded(e);
  }
  onSessionId(e) {
    var t, s;
    return (t =
      (s = this.sessionManager) == null ? void 0 : s.onSessionId(e)) !== null &&
      t !== void 0
      ? t
      : () => {};
  }
  getSurveys(e, t) {
    t === void 0 && (t = !1), this.surveys.getSurveys(e, t);
  }
  getActiveMatchingSurveys(e, t) {
    t === void 0 && (t = !1), this.surveys.getActiveMatchingSurveys(e, t);
  }
  renderSurvey(e, t) {
    this.surveys.renderSurvey(e, t);
  }
  canRenderSurvey(e) {
    return this.surveys.canRenderSurvey(e);
  }
  canRenderSurveyAsync(e, t) {
    return t === void 0 && (t = !1), this.surveys.canRenderSurveyAsync(e, t);
  }
  identify(e, t, s) {
    if (!this.__loaded || !this.persistence)
      return at.uninitializedWarning("posthog.identify");
    if (
      (Cr(e) &&
        ((e = e.toString()),
        at.warn(
          "The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string."
        )),
      e)
    )
      if (["distinct_id", "distinctid"].includes(e.toLowerCase()))
        at.critical(
          'The string "' +
            e +
            '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'
        );
      else if (e !== my) {
        if (this.Us("posthog.identify")) {
          var r = this.get_distinct_id();
          if (
            (this.register({ $user_id: e }), !this.get_property("$device_id"))
          ) {
            var i = r;
            this.register_once(
              { $had_persisted_distinct_id: !0, $device_id: i },
              ""
            );
          }
          e !== r &&
            e !== this.get_property(bp) &&
            (this.unregister(bp), this.register({ distinct_id: e }));
          var a =
            (this.persistence.get_property(dl) || "anonymous") === "anonymous";
          e !== r && a
            ? (this.persistence.set_property(dl, "identified"),
              this.setPersonPropertiesForFlags(nt({}, s || {}, t || {}), !1),
              this.capture(
                "$identify",
                { distinct_id: e, $anon_distinct_id: r },
                { $set: t || {}, $set_once: s || {} }
              ),
              (this.Es = oU(e, t, s)),
              this.featureFlags.setAnonymousDistinctId(r))
            : (t || s) && this.setPersonProperties(t, s),
            e !== r && (this.reloadFeatureFlags(), this.unregister(bx));
        }
      } else
        at.critical(
          'The string "' +
            my +
            '" was set in posthog.identify which indicates an error. This ID is only used as a sentinel value.'
        );
    else at.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(e, t) {
    if ((e || t) && this.Us("posthog.setPersonProperties")) {
      var s = oU(this.get_distinct_id(), e, t);
      this.Es !== s
        ? (this.setPersonPropertiesForFlags(nt({}, t || {}, e || {})),
          this.capture("$set", { $set: e || {}, $set_once: t || {} }),
          (this.Es = s))
        : at.info(
            "A duplicate setPersonProperties call was made with the same properties. It has been ignored."
          );
    }
  }
  group(e, t, s) {
    if (e && t) {
      if (this.Us("posthog.group")) {
        var r = this.getGroups();
        r[e] !== t && this.resetGroupPropertiesForFlags(e),
          this.register({ $groups: nt({}, r, { [e]: t }) }),
          s &&
            (this.capture("$groupidentify", {
              $group_type: e,
              $group_key: t,
              $group_set: s,
            }),
            this.setGroupPropertiesForFlags({ [e]: s })),
          r[e] === t || s || this.reloadFeatureFlags();
      }
    } else at.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({ $groups: {} }),
      this.resetGroupPropertiesForFlags(),
      this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(e, t) {
    t === void 0 && (t = !0),
      this.featureFlags.setPersonPropertiesForFlags(e, t);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(e, t) {
    t === void 0 && (t = !0),
      this.Us("posthog.setGroupPropertiesForFlags") &&
        this.featureFlags.setGroupPropertiesForFlags(e, t);
  }
  resetGroupPropertiesForFlags(e) {
    this.featureFlags.resetGroupPropertiesForFlags(e);
  }
  reset(e) {
    var t, s, r, i;
    if ((at.info("reset"), !this.__loaded))
      return at.uninitializedWarning("posthog.reset");
    var a = this.get_property("$device_id");
    if (
      (this.consent.reset(),
      (t = this.persistence) == null || t.clear(),
      (s = this.sessionPersistence) == null || s.clear(),
      this.surveys.reset(),
      this.featureFlags.reset(),
      (r = this.persistence) == null || r.set_property(dl, "anonymous"),
      (i = this.sessionManager) == null || i.resetSessionId(),
      (this.Es = null),
      this.config.__preview_experimental_cookieless_mode)
    )
      this.register_once({ distinct_id: my, $device_id: null }, "");
    else {
      var o = this.config.get_device_id(Rc());
      this.register_once({ distinct_id: o, $device_id: e ? o : a }, "");
    }
    this.register({ $last_posthog_reset: new Date().toISOString() }, 1);
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var e, t;
    return (e =
      (t = this.sessionManager) == null
        ? void 0
        : t.checkAndGetSessionAndWindowId(!0).sessionId) !== null &&
      e !== void 0
      ? e
      : "";
  }
  get_session_replay_url(e) {
    if (!this.sessionManager) return "";
    var { sessionId: t, sessionStartTimestamp: s } =
        this.sessionManager.checkAndGetSessionAndWindowId(!0),
      r = this.requestRouter.endpointFor(
        "ui",
        "/project/" + this.config.token + "/replay/" + t
      );
    if (e != null && e.withTimestamp && s) {
      var i,
        a = (i = e.timestampLookBack) !== null && i !== void 0 ? i : 10;
      if (!s) return r;
      r +=
        "?t=" + Math.max(Math.floor((new Date().getTime() - s) / 1e3) - a, 0);
    }
    return r;
  }
  alias(e, t) {
    return e === this.get_property(w8)
      ? (at.critical(
          "Attempting to create alias for existing People user - aborting."
        ),
        -2)
      : this.Us("posthog.alias")
      ? (We(t) && (t = this.get_distinct_id()),
        e !== t
          ? (this.qs(bp, e),
            this.capture("$create_alias", { alias: e, distinct_id: t }))
          : (at.warn("alias matches current distinct_id - skipping api call."),
            this.identify(e),
            -1))
      : void 0;
  }
  set_config(e) {
    var t = nt({}, this.config);
    if (fs(e)) {
      var s, r, i, a, o;
      As(this.config, EU(e));
      var l = this.Rs();
      (s = this.persistence) == null || s.update_config(this.config, t, l),
        (this.sessionPersistence =
          this.config.persistence === "sessionStorage" ||
          this.config.persistence === "memory"
            ? this.persistence
            : new f1(
                nt({}, this.config, { persistence: "sessionStorage" }),
                l
              )),
        Vs.O() && Vs.D("ph_debug") === "true" && (this.config.debug = !0),
        this.config.debug &&
          ((yl.DEBUG = !0),
          at.info("set_config", {
            config: e,
            oldConfig: t,
            newConfig: nt({}, this.config),
          })),
        (r = this.sessionRecording) == null || r.startIfEnabledOrStop(),
        (i = this.autocapture) == null || i.startIfEnabled(),
        (a = this.heatmaps) == null || a.startIfEnabled(),
        this.surveys.loadIfEnabled(),
        this.Bs(),
        (o = this.externalIntegrations) == null || o.startIfEnabledOrStop();
    }
  }
  startSessionRecording(e) {
    var t = e === !0,
      s = {
        sampling: t || !(e == null || !e.sampling),
        linked_flag: t || !(e == null || !e.linked_flag),
        url_trigger: t || !(e == null || !e.url_trigger),
        event_trigger: t || !(e == null || !e.event_trigger),
      };
    if (Object.values(s).some(Boolean)) {
      var r, i, a, o, l;
      (r = this.sessionManager) == null || r.checkAndGetSessionAndWindowId(),
        s.sampling &&
          ((i = this.sessionRecording) == null || i.overrideSampling()),
        s.linked_flag &&
          ((a = this.sessionRecording) == null || a.overrideLinkedFlag()),
        s.url_trigger &&
          ((o = this.sessionRecording) == null || o.overrideTrigger("url")),
        s.event_trigger &&
          ((l = this.sessionRecording) == null || l.overrideTrigger("event"));
    }
    this.set_config({ disable_session_recording: !1 });
  }
  stopSessionRecording() {
    this.set_config({ disable_session_recording: !0 });
  }
  sessionRecordingStarted() {
    var e;
    return !((e = this.sessionRecording) == null || !e.started);
  }
  captureException(e, t) {
    var s = new Error("PostHog syntheticException");
    return this.exceptions.sendExceptionEvent(
      nt(
        {},
        Tae(
          ((r) => r instanceof Error)(e)
            ? { error: e, event: e.message }
            : { event: e },
          { syntheticException: s }
        ),
        t
      )
    );
  }
  loadToolbar(e) {
    return this.toolbar.loadToolbar(e);
  }
  get_property(e) {
    var t;
    return (t = this.persistence) == null ? void 0 : t.props[e];
  }
  getSessionProperty(e) {
    var t;
    return (t = this.sessionPersistence) == null ? void 0 : t.props[e];
  }
  toString() {
    var e,
      t = (e = this.config.name) !== null && e !== void 0 ? e : Th;
    return t !== Th && (t = Th + "." + t), t;
  }
  _isIdentified() {
    var e, t;
    return (
      ((e = this.persistence) == null ? void 0 : e.get_property(dl)) ===
        "identified" ||
      ((t = this.sessionPersistence) == null ? void 0 : t.get_property(dl)) ===
        "identified"
    );
  }
  zs() {
    var e, t;
    return !(
      this.config.person_profiles === "never" ||
      (this.config.person_profiles === "identified_only" &&
        !this._isIdentified() &&
        $h(this.getGroups()) &&
        ((e = this.persistence) == null || (e = e.props) == null || !e[bp]) &&
        ((t = this.persistence) == null || (t = t.props) == null || !t[wx]))
    );
  }
  Ls() {
    return (
      this.config.capture_pageleave === !0 ||
      (this.config.capture_pageleave === "if_capture_pageview" &&
        (this.config.capture_pageview === !0 ||
          this.config.capture_pageview === "history_change"))
    );
  }
  createPersonProfile() {
    this.zs() ||
      (this.Us("posthog.createPersonProfile") &&
        this.setPersonProperties({}, {}));
  }
  Us(e) {
    return this.config.person_profiles === "never"
      ? (at.error(
          e +
            ' was called, but process_person is set to "never". This call will be ignored.'
        ),
        !1)
      : (this.qs(wx, !0), !0);
  }
  Rs() {
    var e = this.consent.isOptedOut(),
      t = this.config.opt_out_persistence_by_default;
    return this.config.disable_persistence || (e && !!t);
  }
  Bs() {
    var e,
      t,
      s,
      r,
      i = this.Rs();
    return (
      ((e = this.persistence) == null ? void 0 : e.Ae) !== i &&
        ((s = this.persistence) == null || s.set_disabled(i)),
      ((t = this.sessionPersistence) == null ? void 0 : t.Ae) !== i &&
        ((r = this.sessionPersistence) == null || r.set_disabled(i)),
      i
    );
  }
  opt_in_capturing(e) {
    var t;
    this.consent.optInOut(!0),
      this.Bs(),
      (We(e?.captureEventName) || (e != null && e.captureEventName)) &&
        this.capture(
          (t = e?.captureEventName) !== null && t !== void 0 ? t : "$opt_in",
          e?.captureProperties,
          { send_instantly: !0 }
        ),
      this.config.capture_pageview && this.Ds();
  }
  opt_out_capturing() {
    this.consent.optInOut(!1), this.Bs();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this.Bs();
  }
  _is_bot() {
    return _i ? SH(_i, this.config.custom_blocked_useragents) : void 0;
  }
  Ds() {
    rt &&
      (rt.visibilityState === "visible"
        ? this.$s ||
          ((this.$s = !0),
          this.capture(
            "$pageview",
            { title: rt.title },
            { send_instantly: !0 }
          ),
          this.xs &&
            (rt.removeEventListener("visibilitychange", this.xs),
            (this.xs = null)))
        : this.xs ||
          ((this.xs = this.Ds.bind(this)),
          is(rt, "visibilitychange", this.xs)));
  }
  debug(e) {
    e === !1
      ? (Re?.console.log("You've disabled debug mode."),
        localStorage && localStorage.removeItem("ph_debug"),
        this.set_config({ debug: !1 }))
      : (Re?.console.log(
          "You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."
        ),
        localStorage && localStorage.setItem("ph_debug", "true"),
        this.set_config({ debug: !0 }));
  }
  I() {
    var e,
      t,
      s,
      r,
      i,
      a,
      o,
      l = this.Is || {};
    return "advanced_disable_flags" in l
      ? !!l.advanced_disable_flags
      : this.config.advanced_disable_flags !== !1
      ? !!this.config.advanced_disable_flags
      : this.config.advanced_disable_decide === !0
      ? (at.warn(
          "Config field 'advanced_disable_decide' is deprecated. Please use 'advanced_disable_flags' instead. The old field will be removed in a future major version."
        ),
        !0)
      : ((s = "advanced_disable_decide"),
        (r = !1),
        (i = at),
        (a = (t = "advanced_disable_flags") in (e = l) && !We(e[t])),
        (o = s in e && !We(e[s])),
        a
          ? e[t]
          : o
          ? (i &&
              i.warn(
                "Config field '" +
                  s +
                  "' is deprecated. Please use '" +
                  t +
                  "' instead. The old field will be removed in a future major version."
              ),
            e[s])
          : r);
  }
  Ns(e) {
    if (yn(this.config.before_send)) return e;
    var t = zn(this.config.before_send)
        ? this.config.before_send
        : [this.config.before_send],
      s = e;
    for (var r of t) {
      if (((s = r(s)), yn(s))) {
        var i = "Event '" + e.event + "' was rejected in beforeSend function";
        return (
          Nie(e.event)
            ? at.warn(i + ". This can cause unexpected behavior.")
            : at.info(i),
          null
        );
      }
      (s.properties && !$h(s.properties)) ||
        at.warn(
          "Event '" +
            e.event +
            "' has no properties after beforeSend function, this is likely an error."
        );
    }
    return s;
  }
  getPageViewId() {
    var e;
    return (e = this.pageViewManager.ce) == null ? void 0 : e.pageViewId;
  }
  captureTraceFeedback(e, t) {
    this.capture("$ai_feedback", {
      $ai_trace_id: String(e),
      $ai_feedback_text: t,
    });
  }
  captureTraceMetric(e, t, s) {
    this.capture("$ai_metric", {
      $ai_trace_id: String(e),
      $ai_metric_name: t,
      $ai_metric_value: String(s),
    });
  }
}
(function (n, e) {
  for (var t = 0; t < e.length; t++) n.prototype[e[t]] = jie(n.prototype[e[t]]);
})(vE, ["identify"]);
var SU,
  Sc =
    ((SU = Wp[Th] = new vE()),
    (function () {
      function n() {
        n.done ||
          ((n.done = !0),
          (TH = !1),
          Dn(Wp, function (e) {
            e._dom_loaded();
          }));
      }
      rt != null && rt.addEventListener
        ? rt.readyState === "complete"
          ? n()
          : is(rt, "DOMContentLoaded", n, { capture: !1 })
        : Re &&
          at.error(
            "Browser doesn't support `document.addEventListener` so PostHog couldn't be initialized"
          );
    })(),
    SU);
typeof window < "u" &&
  Sc.init("phc_h90tBZBiBJHr8fRNcGKpBmr4zz0iuBxfh7H0EXqP8wq", {
    api_host: "https://us.i.posthog.com",
    person_profiles: "identified_only",
    capture_pageview: !0,
    capture_pageleave: !0,
    autocapture: !0,
    disable_session_recording: !0,
    loaded: (n) => {},
    on_request_error: (n) => {},
  });
class Qoe {
  identifyUser(e) {
    if (this.isAvailable()) {
      if (!e?.email) {
        console.warn("[PostHog] Cannot identify user without email");
        return;
      }
      try {
        Sc.identify(e.email, {
          email: e.email,
          user_id: e.id,
          ...(e.user_metadata?.full_name && {
            name: e.user_metadata.full_name,
          }),
          ...(e.user_metadata?.avatar_url && {
            avatar: e.user_metadata.avatar_url,
          }),
        }),
          e.email;
      } catch (t) {
        console.error("[PostHog] Error identifying user:", t);
      }
    }
  }
  resetUser() {
    if (this.isAvailable())
      try {
        Sc.reset();
      } catch (e) {
        console.error("[PostHog] Error resetting user:", e);
      }
  }
  capture(e, t) {
    if (this.isAvailable())
      try {
        Sc.capture(e, t);
      } catch (s) {
        console.error("[PostHog] Error capturing event:", s);
      }
  }
  setPersonProperties(e) {
    if (this.isAvailable())
      try {
        Sc.setPersonProperties(e);
      } catch (t) {
        console.error("[PostHog] Error setting person properties:", t);
      }
  }
  isAvailable() {
    return typeof window < "u" && !!Sc;
  }
}
const Bt = new Qoe(),
  hn = Di()(
    $a(
      ha((n, e) => ({
        user: null,
        profile: null,
        session: null,
        isLoading: !1,
        isInitialized: !1,
        isInitializing: !1,
        userProfiles: {},
        setUser: (t) =>
          n((s) => {
            s.user = t;
          }),
        setProfile: (t) =>
          n((s) => {
            s.profile = t;
          }),
        setSession: (t) =>
          n((s) => {
            s.session = t;
          }),
        setIsLoading: (t) =>
          n((s) => {
            s.isLoading = t;
          }),
        setIsInitialized: (t) =>
          n((s) => {
            s.isInitialized = t;
          }),
        setIsInitializing: (t) =>
          n((s) => {
            s.isInitializing = t;
          }),
        signInWithGoogle: async (t) => {
          try {
            Bt.isAvailable() &&
              Bt.capture("auth_signin_attempted", {
                provider: "google",
                redirect_path: t,
              });
            const s = await Ut("/api/auth/signin", {
              method: "POST",
              body: JSON.stringify({ redirectPath: t }),
            });
            if (!s.ok) throw new Error("Failed to sign in");
            const { url: r } = await s.json();
            r && (window.location.href = r);
          } catch (s) {
            throw (
              (Bt.isAvailable() &&
                Bt.capture("auth_signin_error", {
                  provider: "google",
                  error: s instanceof Error ? s.message : "Unknown error",
                }),
              console.error("Error signing in with Google:", s),
              s)
            );
          }
        },
        signOut: async () => {
          try {
            if (
              (Bt.isAvailable() && Bt.capture("auth_signout_attempted"),
              !(await Ut("/api/auth/signout", { method: "POST" })).ok)
            )
              throw new Error("Failed to sign out");
            Bt.isAvailable() && Bt.capture("auth_signout_success"),
              Bt.isAvailable() && Bt.resetUser(),
              await ka().auth.signOut(),
              e().reset();
          } catch (t) {
            throw (
              (Bt.isAvailable() &&
                Bt.capture("auth_signout_error", {
                  error: t instanceof Error ? t.message : "Unknown error",
                }),
              console.error("Error signing out:", t),
              t)
            );
          }
        },
        fetchProfile: async (t) => {
          const s = e();
          if (s.profile && s.profile.user_id === t) return s.profile;
          const r = `profile_fetch_${t}`;
          return (
            window[r] ||
              (window[r] = (async () => {
                try {
                  const i = await Ut("/api/auth/me", { method: "GET" });
                  if (!i.ok)
                    return (
                      i.status === 401
                        ? n((o) => {
                            (o.profile = null),
                              (o.user = null),
                              (o.session = null);
                          })
                        : i.status >= 500 &&
                          console.error(
                            "[AuthStore] Server error fetching profile:",
                            i.status
                          ),
                      null
                    );
                  const a = await i.json();
                  return a.profile
                    ? (n((o) => {
                        o.profile = a.profile;
                      }),
                      Bt.isAvailable() &&
                        a.profile &&
                        Bt.setPersonProperties({
                          full_name: a.profile.full_name,
                          subscription_status: a.profile.subscription_status,
                          subscription_type: a.profile.subscription_type,
                          created_at: a.profile.created_at,
                        }),
                      a.profile)
                    : null;
                } catch (i) {
                  return i instanceof Error &&
                    i.message.includes("ERR_TOO_MANY_REDIRECTS")
                    ? (console.error(
                        "[AuthStore] Redirect loop detected, skipping profile fetch"
                      ),
                      null)
                    : (console.error("[AuthStore] Error fetching profile:", i),
                      null);
                } finally {
                  delete window[r];
                }
              })()),
            window[r]
          );
        },
        createProfile: async (t) => {
          const s = e();
          return s.profile?.user_id === t.id
            ? s.profile
            : await e().fetchProfile(t.id);
        },
        updateProfile: async (t) => {
          const { profile: s } = e();
          if (!s) return null;
          try {
            const r = ka(),
              { id: i, ...a } = t,
              { data: o, error: l } = await r
                .from("profiles")
                .update(a)
                .eq("user_id", s.user_id)
                .select()
                .single();
            if (l) throw l;
            const c = o;
            return (
              n((h) => {
                h.profile = c;
              }),
              c
            );
          } catch (r) {
            return console.error("Error updating profile:", r), null;
          }
        },
        fetchUserProfiles: async (t) => {
          if (t.length)
            try {
              const s = await u8(t);
              n((r) => ({ userProfiles: { ...r.userProfiles, ...s } }));
            } catch (s) {
              console.error("Error fetching user profiles:", s);
            }
        },
        addUserProfile: (t, s) =>
          n((r) => {
            r.userProfiles[t] = s;
          }),
        getUserProfiles: () => e().userProfiles,
        initialize: async () => {
          const t = e();
          if (!(t.isInitialized || t.isInitializing))
            try {
              n((h) => {
                (h.isLoading = !0), (h.isInitializing = !0);
              });
              const s = ka(),
                r = new URLSearchParams(window.location.search),
                i = r.has("code") || r.has("access_token") || r.has("session"),
                a = i ? 1e4 : 5e3;
              let o = null;
              try {
                const h = s.auth.getSession(),
                  m = new Promise((g, y) =>
                    setTimeout(() => y(new Error("Session check timeout")), a)
                  );
                o = (await Promise.race([h, m])).data?.session;
              } catch (h) {
                o = null;
              }
              if (o) {
                n((h) => {
                  (h.session = o), (h.user = o.user);
                }),
                  Bt.isAvailable() && o.user && Bt.identifyUser(o.user);
                try {
                  const h = await Ut("/api/auth/me", {
                    method: "GET",
                    cache: "no-cache",
                  });
                  if (h.ok) {
                    const m = await h.json();
                    m.profile &&
                      n((p) => {
                        p.profile = m.profile;
                      });
                  } else
                    h.status === 401
                      ? (await s.auth.signOut(),
                        n((m) => {
                          (m.session = null),
                            (m.user = null),
                            (m.profile = null);
                        }))
                      : h.status;
                } catch (h) {}
              }
              const l = window.__authSubscription;
              l && (l.unsubscribe(), delete window.__authSubscription);
              const {
                data: { subscription: c },
              } = s.auth.onAuthStateChange(async (h, m) => {
                if (m) {
                  if (
                    (n((p) => {
                      (p.session = m), (p.user = m.user);
                    }),
                    Bt.isAvailable() &&
                      m.user &&
                      (Bt.identifyUser(m.user),
                      h === "SIGNED_IN" &&
                        Bt.capture("auth_signin_success", {
                          provider: "google",
                          user_id: m.user.id,
                        })),
                    h === "SIGNED_IN")
                  ) {
                    const p = e().profile;
                    (!p || p.user_id !== m.user.id) &&
                      e()
                        .fetchProfile(m.user.id)
                        .catch((g) => {
                          console.warn("[AuthStore] Profile fetch failed:", g);
                        });
                  }
                } else
                  Bt.isAvailable() && Bt.resetUser(),
                    n((p) => {
                      (p.session = null), (p.user = null), (p.profile = null);
                    });
              });
              window.__authSubscription = c;
            } catch (s) {
              console.error("[AuthStore] Error initializing auth:", s);
            } finally {
              n((s) => {
                (s.isLoading = !1),
                  (s.isInitialized = !0),
                  (s.isInitializing = !1);
              });
            }
        },
        reset: () => {
          const t = window.__authSubscription;
          t && (t.unsubscribe(), delete window.__authSubscription),
            Bt.isAvailable() && Bt.resetUser(),
            n((s) => {
              (s.user = null),
                (s.profile = null),
                (s.session = null),
                (s.userProfiles = {}),
                (s.isInitialized = !1),
                (s.isInitializing = !1),
                (s.isLoading = !1);
            });
        },
      }))
    )
  ),
  ks = () => {
    const n = hn((o) => o.user),
      e = hn((o) => o.profile),
      t = hn((o) => o.session),
      s = hn((o) => o.isLoading),
      r = hn((o) => o.isInitialized),
      i = hn((o) => o.signInWithGoogle),
      a = hn((o) => o.signOut);
    return {
      user: n,
      profile: e,
      session: t,
      isLoading: s,
      isInitialized: r,
      signInWithGoogle: i,
      signOut: a,
    };
  },
  _H = () => hn((n) => n.user),
  AH = () => hn((n) => n.profile),
  Zoe = () => hn((n) => n.isLoading),
  RH = () => hn((n) => n.signInWithGoogle),
  Joe = () => hn((n) => n.signOut),
  Ig = ({ className: n = "", size: e = "large", isOpen: t = !1 }) =>
    e === "small"
      ? u.jsxs("div", {
          className: `flex items-center  group ${n}`,
          children: [
            u.jsx("img", {
              src: "/images/flasklogo.png",
              alt: "Flask Logo",
              className: `h-10 object-contain absolute left-0.5 mb-1 opacity-80 transition-all duration-200 cursor-pointer ${
                t
                  ? "rotate-6 opacity-100 scale-105"
                  : "group-hover:rotate-6 group-hover:opacity-100 group-hover:scale-105"
              }`,
            }),
            u.jsx("p", {
              className: `text-text-primary/85 text-2xl text-bold tracking-[-0.075em] font-bold transition-all duration-200 ${
                t ? "text-text-primary" : "group-hover:text-text-primary"
              }`,
              children: "Flask",
            }),
          ],
        })
      : u.jsxs("div", {
          className: `flex h-full items-center mb-1 group ${n}`,
          children: [
            u.jsx("p", {
              className: `text-text-primary/85 text-bold tracking-[-0.075em] text-[32px] font-bold transition-all duration-200 cursor-pointer ${
                t ? "text-text-primary" : "group-hover:text-text-primary"
              }`,
              children: "Flask",
            }),
            u.jsx("img", {
              src: "/images/flasklogo.png",
              alt: "Flask Logo",
              className: `h-[78px] object-contain absolute left-10 mb-0 opacity-80 transition-all duration-200 cursor-pointer ${
                t
                  ? "rotate-6 opacity-100 scale-105"
                  : "group-hover:rotate-6 group-hover:opacity-100 group-hover:scale-105"
              }`,
            }),
          ],
        });
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ele = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  kH = (...n) =>
    n
      .filter((e, t, s) => !!e && e.trim() !== "" && s.indexOf(e) === t)
      .join(" ")
      .trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var tle = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const nle = E.forwardRef(
  (
    {
      color: n = "currentColor",
      size: e = 24,
      strokeWidth: t = 2,
      absoluteStrokeWidth: s,
      className: r = "",
      children: i,
      iconNode: a,
      ...o
    },
    l
  ) =>
    E.createElement(
      "svg",
      {
        ref: l,
        ...tle,
        width: e,
        height: e,
        stroke: n,
        strokeWidth: s ? (Number(t) * 24) / Number(e) : t,
        className: kH("lucide", r),
        ...o,
      },
      [
        ...a.map(([c, h]) => E.createElement(c, h)),
        ...(Array.isArray(i) ? i : [i]),
      ]
    )
);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yt = (n, e) => {
  const t = E.forwardRef(({ className: s, ...r }, i) =>
    E.createElement(nle, {
      ref: i,
      iconNode: e,
      className: kH(`lucide-${ele(n)}`, s),
      ...r,
    })
  );
  return (t.displayName = `${n}`), t;
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const sle = yt("ArrowDown", [
  ["path", { d: "M12 5v14", key: "s699le" }],
  ["path", { d: "m19 12-7 7-7-7", key: "1idqje" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const rle = yt("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yE = yt("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ZR = yt("Bell", [
  ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
  ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const CH = yt("Camera", [
  [
    "path",
    {
      d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",
      key: "1tc9qg",
    },
  ],
  ["circle", { cx: "12", cy: "13", r: "3", key: "1vg3eu" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zs = yt("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cd = yt("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ile = yt("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lL = yt("ChevronUp", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const IH = yt("ChevronsUpDown", [
  ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
  ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Lx = yt("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ip = yt("CircleCheck", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const TU = yt("CircleX", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Lg = yt("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const LH = yt("Copy", [
  [
    "rect",
    {
      width: "14",
      height: "14",
      x: "8",
      y: "8",
      rx: "2",
      ry: "2",
      key: "17jyea",
    },
  ],
  [
    "path",
    {
      d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
      key: "zix9uf",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ale = yt("CreditCard", [
  [
    "rect",
    { width: "20", height: "14", x: "2", y: "5", rx: "2", key: "ynyp8z" },
  ],
  ["line", { x1: "2", x2: "22", y1: "10", y2: "10", key: "1b3vmo" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ole = yt("Crown", [
  [
    "path",
    {
      d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",
      key: "1vdc57",
    },
  ],
  ["path", { d: "M5 21h14", key: "11awu3" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const JR = yt("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _U = yt("EllipsisVertical", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cL = yt("Ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const DH = yt("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  [
    "path",
    {
      d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
      key: "a6xqqp",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const lle = yt("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0",
    },
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cle = yt("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  [
    "path",
    { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" },
  ],
  ["path", { d: "M2 12h20", key: "9i4pu4" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ule = yt("Keyboard", [
  ["path", { d: "M10 8h.01", key: "1r9ogq" }],
  ["path", { d: "M12 12h.01", key: "1mp3jc" }],
  ["path", { d: "M14 8h.01", key: "1primd" }],
  ["path", { d: "M16 12h.01", key: "1l6xoz" }],
  ["path", { d: "M18 8h.01", key: "emo2bl" }],
  ["path", { d: "M6 8h.01", key: "x9i8wu" }],
  ["path", { d: "M7 16h10", key: "wp8him" }],
  ["path", { d: "M8 12h.01", key: "czm47f" }],
  [
    "rect",
    { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const dle = yt("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const PH = yt("Link", [
  [
    "path",
    {
      d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
      key: "1cjeqo",
    },
  ],
  [
    "path",
    {
      d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
      key: "19qd67",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const AU = yt("ListFilter", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M7 12h10", key: "b7w52i" }],
  ["path", { d: "M10 18h4", key: "1ulq68" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const wo = yt("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const hle = yt("Lock", [
  [
    "rect",
    {
      width: "18",
      height: "11",
      x: "3",
      y: "11",
      rx: "2",
      ry: "2",
      key: "1w4ew1",
    },
  ],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const fle = yt("LogOut", [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const MH = yt("Mail", [
  [
    "rect",
    { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" },
  ],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const mle = yt("Maximize", [
  ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3", key: "1dcmit" }],
  ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3", key: "1e4gt3" }],
  ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3", key: "wsl5sc" }],
  ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3", key: "18trek" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ple = yt("MessageCircleQuestion", [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }],
  ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3", key: "1u773s" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const gle = yt("MessageSquareQuote", [
  [
    "path",
    {
      d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z",
      key: "1lielz",
    },
  ],
  ["path", { d: "M8 12a2 2 0 0 0 2-2V8H8", key: "1jfesj" }],
  ["path", { d: "M14 12a2 2 0 0 0 2-2V8h-2", key: "1dq9mh" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const vle = yt("MessageSquare", [
  [
    "path",
    {
      d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z",
      key: "1lielz",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const yle = yt("Mic", [
  [
    "path",
    {
      d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z",
      key: "131961",
    },
  ],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ble = yt("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const xle = yt("Monitor", [
  [
    "rect",
    { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" },
  ],
  ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
  ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const NH = yt("Palette", [
  [
    "circle",
    { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" },
  ],
  [
    "circle",
    { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" },
  ],
  [
    "circle",
    { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" },
  ],
  [
    "circle",
    { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" },
  ],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uL = yt("Pause", [
  [
    "rect",
    { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" },
  ],
  [
    "rect",
    { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Dg = yt("Pen", [
  [
    "path",
    {
      d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",
      key: "1a8usu",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Pg = yt("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Zu = yt("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const wle = yt("Reply", [
  ["polyline", { points: "9 17 4 12 9 7", key: "hvgpf2" }],
  ["path", { d: "M20 18v-2a4 4 0 0 0-4-4H4", key: "5vmcpk" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Ele = yt("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const OH = yt("Send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3",
    },
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const RU = yt("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f",
    },
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Sle = yt("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const ek = yt("Tag", [
  [
    "path",
    {
      d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
      key: "vktsd0",
    },
  ],
  [
    "circle",
    { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor", key: "kqv944" },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Mg = yt("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Tle = yt("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq",
    },
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const _le = yt("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Ale = yt("UserMinus", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const tk = yt("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Rle = yt("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const kle = yt("Volume2", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw",
    },
  ],
  ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
  ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Cle = yt("VolumeX", [
  [
    "path",
    {
      d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
      key: "uqj9uw",
    },
  ],
  ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }],
  ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Pa = yt("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Ile = yt("Zap", [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db",
    },
  ],
]);
function Lle(n, e) {
  const t = E.createContext(e),
    s = (i) => {
      const { children: a, ...o } = i,
        l = E.useMemo(() => o, Object.values(o));
      return u.jsx(t.Provider, { value: l, children: a });
    };
  s.displayName = n + "Provider";
  function r(i) {
    const a = E.useContext(t);
    if (a) return a;
    if (e !== void 0) return e;
    throw new Error(`\`${i}\` must be used within \`${n}\``);
  }
  return [s, r];
}
function Pr(n, e = []) {
  let t = [];
  function s(i, a) {
    const o = E.createContext(a),
      l = t.length;
    t = [...t, a];
    const c = (m) => {
      const { scope: p, children: g, ...y } = m,
        b = p?.[n]?.[l] || o,
        w = E.useMemo(() => y, Object.values(y));
      return u.jsx(b.Provider, { value: w, children: g });
    };
    c.displayName = i + "Provider";
    function h(m, p) {
      const g = p?.[n]?.[l] || o,
        y = E.useContext(g);
      if (y) return y;
      if (a !== void 0) return a;
      throw new Error(`\`${m}\` must be used within \`${i}\``);
    }
    return [c, h];
  }
  const r = () => {
    const i = t.map((a) => E.createContext(a));
    return function (o) {
      const l = o?.[n] || i;
      return E.useMemo(() => ({ [`__scope${n}`]: { ...o, [n]: l } }), [o, l]);
    };
  };
  return (r.scopeName = n), [s, Dle(r, ...e)];
}
function Dle(...n) {
  const e = n[0];
  if (n.length === 1) return e;
  const t = () => {
    const s = n.map((r) => ({ useScope: r(), scopeName: r.scopeName }));
    return function (i) {
      const a = s.reduce((o, { useScope: l, scopeName: c }) => {
        const m = l(i)[`__scope${c}`];
        return { ...o, ...m };
      }, {});
      return E.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return (t.scopeName = e.scopeName), t;
}
function ua(n) {
  const e = E.useRef(n);
  return (
    E.useEffect(() => {
      e.current = n;
    }),
    E.useMemo(
      () =>
        (...t) =>
          e.current?.(...t),
      []
    )
  );
}
var ys = globalThis?.document ? E.useLayoutEffect : () => {};
function kU(n, e) {
  if (typeof n == "function") return n(e);
  n != null && (n.current = e);
}
function bE(...n) {
  return (e) => {
    let t = !1;
    const s = n.map((r) => {
      const i = kU(r, e);
      return !t && typeof i == "function" && (t = !0), i;
    });
    if (t)
      return () => {
        for (let r = 0; r < s.length; r++) {
          const i = s[r];
          typeof i == "function" ? i() : kU(n[r], null);
        }
      };
  };
}
function Nt(...n) {
  return E.useCallback(bE(...n), n);
}
function Mc(n) {
  const e = Mle(n),
    t = E.forwardRef((s, r) => {
      const { children: i, ...a } = s,
        o = E.Children.toArray(i),
        l = o.find(Nle);
      if (l) {
        const c = l.props.children,
          h = o.map((m) =>
            m === l
              ? E.Children.count(c) > 1
                ? E.Children.only(null)
                : E.isValidElement(c)
                ? c.props.children
                : null
              : m
          );
        return u.jsx(e, {
          ...a,
          ref: r,
          children: E.isValidElement(c) ? E.cloneElement(c, void 0, h) : null,
        });
      }
      return u.jsx(e, { ...a, ref: r, children: i });
    });
  return (t.displayName = `${n}.Slot`), t;
}
var Ple = Mc("Slot");
function Mle(n) {
  const e = E.forwardRef((t, s) => {
    const { children: r, ...i } = t;
    if (E.isValidElement(r)) {
      const a = jle(r),
        o = Ole(i, r.props);
      return (
        r.type !== E.Fragment && (o.ref = s ? bE(s, a) : a),
        E.cloneElement(r, o)
      );
    }
    return E.Children.count(r) > 1 ? E.Children.only(null) : null;
  });
  return (e.displayName = `${n}.SlotClone`), e;
}
var jH = Symbol("radix.slottable");
function FH(n) {
  const e = ({ children: t }) => u.jsx(u.Fragment, { children: t });
  return (e.displayName = `${n}.Slottable`), (e.__radixId = jH), e;
}
function Nle(n) {
  return (
    E.isValidElement(n) &&
    typeof n.type == "function" &&
    "__radixId" in n.type &&
    n.type.__radixId === jH
  );
}
function Ole(n, e) {
  const t = { ...e };
  for (const s in e) {
    const r = n[s],
      i = e[s];
    /^on[A-Z]/.test(s)
      ? r && i
        ? (t[s] = (...o) => {
            const l = i(...o);
            return r(...o), l;
          })
        : r && (t[s] = r)
      : s === "style"
      ? (t[s] = { ...r, ...i })
      : s === "className" && (t[s] = [r, i].filter(Boolean).join(" "));
  }
  return { ...n, ...t };
}
function jle(n) {
  let e = Object.getOwnPropertyDescriptor(n.props, "ref")?.get,
    t = e && "isReactWarning" in e && e.isReactWarning;
  return t
    ? n.ref
    : ((e = Object.getOwnPropertyDescriptor(n, "ref")?.get),
      (t = e && "isReactWarning" in e && e.isReactWarning),
      t ? n.props.ref : n.props.ref || n.ref);
}
var Fle = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  Et = Fle.reduce((n, e) => {
    const t = Mc(`Primitive.${e}`),
      s = E.forwardRef((r, i) => {
        const { asChild: a, ...o } = r,
          l = a ? t : e;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          u.jsx(l, { ...o, ref: i })
        );
      });
    return (s.displayName = `Primitive.${e}`), { ...n, [e]: s };
  }, {});
function UH(n, e) {
  n && ri.flushSync(() => n.dispatchEvent(e));
}
var p1 = { exports: {} },
  g1 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var CU;
function Ule() {
  if (CU) return g1;
  CU = 1;
  var n = sE();
  function e(m, p) {
    return (m === p && (m !== 0 || 1 / m === 1 / p)) || (m !== m && p !== p);
  }
  var t = typeof Object.is == "function" ? Object.is : e,
    s = n.useState,
    r = n.useEffect,
    i = n.useLayoutEffect,
    a = n.useDebugValue;
  function o(m, p) {
    var g = p(),
      y = s({ inst: { value: g, getSnapshot: p } }),
      b = y[0].inst,
      w = y[1];
    return (
      i(
        function () {
          (b.value = g), (b.getSnapshot = p), l(b) && w({ inst: b });
        },
        [m, g, p]
      ),
      r(
        function () {
          return (
            l(b) && w({ inst: b }),
            m(function () {
              l(b) && w({ inst: b });
            })
          );
        },
        [m]
      ),
      a(g),
      g
    );
  }
  function l(m) {
    var p = m.getSnapshot;
    m = m.value;
    try {
      var g = p();
      return !t(m, g);
    } catch {
      return !0;
    }
  }
  function c(m, p) {
    return p();
  }
  var h =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? c
      : o;
  return (
    (g1.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h),
    g1
  );
}
var IU;
function $le() {
  return IU || ((IU = 1), (p1.exports = Ule())), p1.exports;
}
var Ble = $le();
function Hle() {
  return Ble.useSyncExternalStore(
    Vle,
    () => !0,
    () => !1
  );
}
function Vle() {
  return () => {};
}
var dL = "Avatar",
  [zle, YMe] = Pr(dL),
  [Gle, $H] = zle(dL),
  BH = E.forwardRef((n, e) => {
    const { __scopeAvatar: t, ...s } = n,
      [r, i] = E.useState("idle");
    return u.jsx(Gle, {
      scope: t,
      imageLoadingStatus: r,
      onImageLoadingStatusChange: i,
      children: u.jsx(Et.span, { ...s, ref: e }),
    });
  });
BH.displayName = dL;
var HH = "AvatarImage",
  VH = E.forwardRef((n, e) => {
    const {
        __scopeAvatar: t,
        src: s,
        onLoadingStatusChange: r = () => {},
        ...i
      } = n,
      a = $H(HH, t),
      o = qle(s, i),
      l = ua((c) => {
        r(c), a.onImageLoadingStatusChange(c);
      });
    return (
      ys(() => {
        o !== "idle" && l(o);
      }, [o, l]),
      o === "loaded" ? u.jsx(Et.img, { ...i, ref: e, src: s }) : null
    );
  });
VH.displayName = HH;
var zH = "AvatarFallback",
  GH = E.forwardRef((n, e) => {
    const { __scopeAvatar: t, delayMs: s, ...r } = n,
      i = $H(zH, t),
      [a, o] = E.useState(s === void 0);
    return (
      E.useEffect(() => {
        if (s !== void 0) {
          const l = window.setTimeout(() => o(!0), s);
          return () => window.clearTimeout(l);
        }
      }, [s]),
      a && i.imageLoadingStatus !== "loaded"
        ? u.jsx(Et.span, { ...r, ref: e })
        : null
    );
  });
GH.displayName = zH;
function LU(n, e) {
  return n
    ? e
      ? (n.src !== e && (n.src = e),
        n.complete && n.naturalWidth > 0 ? "loaded" : "loading")
      : "error"
    : "idle";
}
function qle(n, { referrerPolicy: e, crossOrigin: t }) {
  const s = Hle(),
    r = E.useRef(null),
    i = s ? (r.current || (r.current = new window.Image()), r.current) : null,
    [a, o] = E.useState(() => LU(i, n));
  return (
    ys(() => {
      o(LU(i, n));
    }, [i, n]),
    ys(() => {
      const l = (m) => () => {
        o(m);
      };
      if (!i) return;
      const c = l("loaded"),
        h = l("error");
      return (
        i.addEventListener("load", c),
        i.addEventListener("error", h),
        e && (i.referrerPolicy = e),
        typeof t == "string" && (i.crossOrigin = t),
        () => {
          i.removeEventListener("load", c), i.removeEventListener("error", h);
        }
      );
    }, [i, t, e]),
    a
  );
}
var qH = BH,
  WH = VH,
  KH = GH;
function YH(n) {
  var e,
    t,
    s = "";
  if (typeof n == "string" || typeof n == "number") s += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var r = n.length;
      for (e = 0; e < r; e++)
        n[e] && (t = YH(n[e])) && (s && (s += " "), (s += t));
    } else for (t in n) n[t] && (s && (s += " "), (s += t));
  return s;
}
function XH() {
  for (var n, e, t = 0, s = "", r = arguments.length; t < r; t++)
    (n = arguments[t]) && (e = YH(n)) && (s && (s += " "), (s += e));
  return s;
}
const hL = "-",
  Wle = (n) => {
    const e = Yle(n),
      { conflictingClassGroups: t, conflictingClassGroupModifiers: s } = n;
    return {
      getClassGroupId: (a) => {
        const o = a.split(hL);
        return o[0] === "" && o.length !== 1 && o.shift(), QH(o, e) || Kle(a);
      },
      getConflictingClassGroupIds: (a, o) => {
        const l = t[a] || [];
        return o && s[a] ? [...l, ...s[a]] : l;
      },
    };
  },
  QH = (n, e) => {
    if (n.length === 0) return e.classGroupId;
    const t = n[0],
      s = e.nextPart.get(t),
      r = s ? QH(n.slice(1), s) : void 0;
    if (r) return r;
    if (e.validators.length === 0) return;
    const i = n.join(hL);
    return e.validators.find(({ validator: a }) => a(i))?.classGroupId;
  },
  DU = /^\[(.+)\]$/,
  Kle = (n) => {
    if (DU.test(n)) {
      const e = DU.exec(n)[1],
        t = e?.substring(0, e.indexOf(":"));
      if (t) return "arbitrary.." + t;
    }
  },
  Yle = (n) => {
    const { theme: e, prefix: t } = n,
      s = { nextPart: new Map(), validators: [] };
    return (
      Qle(Object.entries(n.classGroups), t).forEach(([i, a]) => {
        nk(a, s, i, e);
      }),
      s
    );
  },
  nk = (n, e, t, s) => {
    n.forEach((r) => {
      if (typeof r == "string") {
        const i = r === "" ? e : PU(e, r);
        i.classGroupId = t;
        return;
      }
      if (typeof r == "function") {
        if (Xle(r)) {
          nk(r(s), e, t, s);
          return;
        }
        e.validators.push({ validator: r, classGroupId: t });
        return;
      }
      Object.entries(r).forEach(([i, a]) => {
        nk(a, PU(e, i), t, s);
      });
    });
  },
  PU = (n, e) => {
    let t = n;
    return (
      e.split(hL).forEach((s) => {
        t.nextPart.has(s) ||
          t.nextPart.set(s, { nextPart: new Map(), validators: [] }),
          (t = t.nextPart.get(s));
      }),
      t
    );
  },
  Xle = (n) => n.isThemeGetter,
  Qle = (n, e) =>
    e
      ? n.map(([t, s]) => {
          const r = s.map((i) =>
            typeof i == "string"
              ? e + i
              : typeof i == "object"
              ? Object.fromEntries(
                  Object.entries(i).map(([a, o]) => [e + a, o])
                )
              : i
          );
          return [t, r];
        })
      : n,
  Zle = (n) => {
    if (n < 1) return { get: () => {}, set: () => {} };
    let e = 0,
      t = new Map(),
      s = new Map();
    const r = (i, a) => {
      t.set(i, a), e++, e > n && ((e = 0), (s = t), (t = new Map()));
    };
    return {
      get(i) {
        let a = t.get(i);
        if (a !== void 0) return a;
        if ((a = s.get(i)) !== void 0) return r(i, a), a;
      },
      set(i, a) {
        t.has(i) ? t.set(i, a) : r(i, a);
      },
    };
  },
  ZH = "!",
  Jle = (n) => {
    const { separator: e, experimentalParseClassName: t } = n,
      s = e.length === 1,
      r = e[0],
      i = e.length,
      a = (o) => {
        const l = [];
        let c = 0,
          h = 0,
          m;
        for (let w = 0; w < o.length; w++) {
          let S = o[w];
          if (c === 0) {
            if (S === r && (s || o.slice(w, w + i) === e)) {
              l.push(o.slice(h, w)), (h = w + i);
              continue;
            }
            if (S === "/") {
              m = w;
              continue;
            }
          }
          S === "[" ? c++ : S === "]" && c--;
        }
        const p = l.length === 0 ? o : o.substring(h),
          g = p.startsWith(ZH),
          y = g ? p.substring(1) : p,
          b = m && m > h ? m - h : void 0;
        return {
          modifiers: l,
          hasImportantModifier: g,
          baseClassName: y,
          maybePostfixModifierPosition: b,
        };
      };
    return t ? (o) => t({ className: o, parseClassName: a }) : a;
  },
  ece = (n) => {
    if (n.length <= 1) return n;
    const e = [];
    let t = [];
    return (
      n.forEach((s) => {
        s[0] === "[" ? (e.push(...t.sort(), s), (t = [])) : t.push(s);
      }),
      e.push(...t.sort()),
      e
    );
  },
  tce = (n) => ({ cache: Zle(n.cacheSize), parseClassName: Jle(n), ...Wle(n) }),
  nce = /\s+/,
  sce = (n, e) => {
    const {
        parseClassName: t,
        getClassGroupId: s,
        getConflictingClassGroupIds: r,
      } = e,
      i = [],
      a = n.trim().split(nce);
    let o = "";
    for (let l = a.length - 1; l >= 0; l -= 1) {
      const c = a[l],
        {
          modifiers: h,
          hasImportantModifier: m,
          baseClassName: p,
          maybePostfixModifierPosition: g,
        } = t(c);
      let y = !!g,
        b = s(y ? p.substring(0, g) : p);
      if (!b) {
        if (!y) {
          o = c + (o.length > 0 ? " " + o : o);
          continue;
        }
        if (((b = s(p)), !b)) {
          o = c + (o.length > 0 ? " " + o : o);
          continue;
        }
        y = !1;
      }
      const w = ece(h).join(":"),
        S = m ? w + ZH : w,
        A = S + b;
      if (i.includes(A)) continue;
      i.push(A);
      const _ = r(b, y);
      for (let R = 0; R < _.length; ++R) {
        const C = _[R];
        i.push(S + C);
      }
      o = c + (o.length > 0 ? " " + o : o);
    }
    return o;
  };
function rce() {
  let n = 0,
    e,
    t,
    s = "";
  for (; n < arguments.length; )
    (e = arguments[n++]) && (t = JH(e)) && (s && (s += " "), (s += t));
  return s;
}
const JH = (n) => {
  if (typeof n == "string") return n;
  let e,
    t = "";
  for (let s = 0; s < n.length; s++)
    n[s] && (e = JH(n[s])) && (t && (t += " "), (t += e));
  return t;
};
function ice(n, ...e) {
  let t,
    s,
    r,
    i = a;
  function a(l) {
    const c = e.reduce((h, m) => m(h), n());
    return (t = tce(c)), (s = t.cache.get), (r = t.cache.set), (i = o), o(l);
  }
  function o(l) {
    const c = s(l);
    if (c) return c;
    const h = sce(l, t);
    return r(l, h), h;
  }
  return function () {
    return i(rce.apply(null, arguments));
  };
}
const Hn = (n) => {
    const e = (t) => t[n] || [];
    return (e.isThemeGetter = !0), e;
  },
  eV = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  ace = /^\d+\/\d+$/,
  oce = new Set(["px", "full", "screen"]),
  lce = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  cce =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  uce = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  dce = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  hce =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Jo = (n) => nf(n) || oce.has(n) || ace.test(n),
  nc = (n) => $f(n, "length", xce),
  nf = (n) => !!n && !Number.isNaN(Number(n)),
  v1 = (n) => $f(n, "number", nf),
  ap = (n) => !!n && Number.isInteger(Number(n)),
  fce = (n) => n.endsWith("%") && nf(n.slice(0, -1)),
  qt = (n) => eV.test(n),
  sc = (n) => lce.test(n),
  mce = new Set(["length", "size", "percentage"]),
  pce = (n) => $f(n, mce, tV),
  gce = (n) => $f(n, "position", tV),
  vce = new Set(["image", "url"]),
  yce = (n) => $f(n, vce, Ece),
  bce = (n) => $f(n, "", wce),
  op = () => !0,
  $f = (n, e, t) => {
    const s = eV.exec(n);
    return s
      ? s[1]
        ? typeof e == "string"
          ? s[1] === e
          : e.has(s[1])
        : t(s[2])
      : !1;
  },
  xce = (n) => cce.test(n) && !uce.test(n),
  tV = () => !1,
  wce = (n) => dce.test(n),
  Ece = (n) => hce.test(n),
  Sce = () => {
    const n = Hn("colors"),
      e = Hn("spacing"),
      t = Hn("blur"),
      s = Hn("brightness"),
      r = Hn("borderColor"),
      i = Hn("borderRadius"),
      a = Hn("borderSpacing"),
      o = Hn("borderWidth"),
      l = Hn("contrast"),
      c = Hn("grayscale"),
      h = Hn("hueRotate"),
      m = Hn("invert"),
      p = Hn("gap"),
      g = Hn("gradientColorStops"),
      y = Hn("gradientColorStopPositions"),
      b = Hn("inset"),
      w = Hn("margin"),
      S = Hn("opacity"),
      A = Hn("padding"),
      _ = Hn("saturate"),
      R = Hn("scale"),
      C = Hn("sepia"),
      D = Hn("skew"),
      L = Hn("space"),
      P = Hn("translate"),
      V = () => ["auto", "contain", "none"],
      N = () => ["auto", "hidden", "clip", "visible", "scroll"],
      W = () => ["auto", qt, e],
      H = () => [qt, e],
      z = () => ["", Jo, nc],
      B = () => ["auto", nf, qt],
      q = () => [
        "bottom",
        "center",
        "left",
        "left-bottom",
        "left-top",
        "right",
        "right-bottom",
        "right-top",
        "top",
      ],
      O = () => ["solid", "dashed", "dotted", "double", "none"],
      U = () => [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
      ],
      j = () => [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
      ],
      Q = () => ["", "0", qt],
      M = () => [
        "auto",
        "avoid",
        "all",
        "avoid-page",
        "page",
        "left",
        "right",
        "column",
      ],
      I = () => [nf, qt];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [op],
        spacing: [Jo, nc],
        blur: ["none", "", sc, qt],
        brightness: I(),
        borderColor: [n],
        borderRadius: ["none", "", "full", sc, qt],
        borderSpacing: H(),
        borderWidth: z(),
        contrast: I(),
        grayscale: Q(),
        hueRotate: I(),
        invert: Q(),
        gap: H(),
        gradientColorStops: [n],
        gradientColorStopPositions: [fce, nc],
        inset: W(),
        margin: W(),
        opacity: I(),
        padding: H(),
        saturate: I(),
        scale: I(),
        sepia: Q(),
        skew: I(),
        space: H(),
        translate: H(),
      },
      classGroups: {
        aspect: [{ aspect: ["auto", "square", "video", qt] }],
        container: ["container"],
        columns: [{ columns: [sc] }],
        "break-after": [{ "break-after": M() }],
        "break-before": [{ "break-before": M() }],
        "break-inside": [
          { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
        ],
        "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
        box: [{ box: ["border", "content"] }],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden",
        ],
        float: [{ float: ["right", "left", "none", "start", "end"] }],
        clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [
          { object: ["contain", "cover", "fill", "none", "scale-down"] },
        ],
        "object-position": [{ object: [...q(), qt] }],
        overflow: [{ overflow: N() }],
        "overflow-x": [{ "overflow-x": N() }],
        "overflow-y": [{ "overflow-y": N() }],
        overscroll: [{ overscroll: V() }],
        "overscroll-x": [{ "overscroll-x": V() }],
        "overscroll-y": [{ "overscroll-y": V() }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{ inset: [b] }],
        "inset-x": [{ "inset-x": [b] }],
        "inset-y": [{ "inset-y": [b] }],
        start: [{ start: [b] }],
        end: [{ end: [b] }],
        top: [{ top: [b] }],
        right: [{ right: [b] }],
        bottom: [{ bottom: [b] }],
        left: [{ left: [b] }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{ z: ["auto", ap, qt] }],
        basis: [{ basis: W() }],
        "flex-direction": [
          { flex: ["row", "row-reverse", "col", "col-reverse"] },
        ],
        "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
        flex: [{ flex: ["1", "auto", "initial", "none", qt] }],
        grow: [{ grow: Q() }],
        shrink: [{ shrink: Q() }],
        order: [{ order: ["first", "last", "none", ap, qt] }],
        "grid-cols": [{ "grid-cols": [op] }],
        "col-start-end": [{ col: ["auto", { span: ["full", ap, qt] }, qt] }],
        "col-start": [{ "col-start": B() }],
        "col-end": [{ "col-end": B() }],
        "grid-rows": [{ "grid-rows": [op] }],
        "row-start-end": [{ row: ["auto", { span: [ap, qt] }, qt] }],
        "row-start": [{ "row-start": B() }],
        "row-end": [{ "row-end": B() }],
        "grid-flow": [
          { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
        ],
        "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", qt] }],
        "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", qt] }],
        gap: [{ gap: [p] }],
        "gap-x": [{ "gap-x": [p] }],
        "gap-y": [{ "gap-y": [p] }],
        "justify-content": [{ justify: ["normal", ...j()] }],
        "justify-items": [
          { "justify-items": ["start", "end", "center", "stretch"] },
        ],
        "justify-self": [
          { "justify-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        "align-content": [{ content: ["normal", ...j(), "baseline"] }],
        "align-items": [
          { items: ["start", "end", "center", "baseline", "stretch"] },
        ],
        "align-self": [
          { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
        ],
        "place-content": [{ "place-content": [...j(), "baseline"] }],
        "place-items": [
          { "place-items": ["start", "end", "center", "baseline", "stretch"] },
        ],
        "place-self": [
          { "place-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        p: [{ p: [A] }],
        px: [{ px: [A] }],
        py: [{ py: [A] }],
        ps: [{ ps: [A] }],
        pe: [{ pe: [A] }],
        pt: [{ pt: [A] }],
        pr: [{ pr: [A] }],
        pb: [{ pb: [A] }],
        pl: [{ pl: [A] }],
        m: [{ m: [w] }],
        mx: [{ mx: [w] }],
        my: [{ my: [w] }],
        ms: [{ ms: [w] }],
        me: [{ me: [w] }],
        mt: [{ mt: [w] }],
        mr: [{ mr: [w] }],
        mb: [{ mb: [w] }],
        ml: [{ ml: [w] }],
        "space-x": [{ "space-x": [L] }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{ "space-y": [L] }],
        "space-y-reverse": ["space-y-reverse"],
        w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", qt, e] }],
        "min-w": [{ "min-w": [qt, e, "min", "max", "fit"] }],
        "max-w": [
          {
            "max-w": [
              qt,
              e,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              { screen: [sc] },
              sc,
            ],
          },
        ],
        h: [{ h: [qt, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
        "min-h": [
          { "min-h": [qt, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        "max-h": [
          { "max-h": [qt, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        size: [{ size: [qt, e, "auto", "min", "max", "fit"] }],
        "font-size": [{ text: ["base", sc, nc] }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              v1,
            ],
          },
        ],
        "font-family": [{ font: [op] }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              qt,
            ],
          },
        ],
        "line-clamp": [{ "line-clamp": ["none", nf, v1] }],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              Jo,
              qt,
            ],
          },
        ],
        "list-image": [{ "list-image": ["none", qt] }],
        "list-style-type": [{ list: ["none", "disc", "decimal", qt] }],
        "list-style-position": [{ list: ["inside", "outside"] }],
        "placeholder-color": [{ placeholder: [n] }],
        "placeholder-opacity": [{ "placeholder-opacity": [S] }],
        "text-alignment": [
          { text: ["left", "center", "right", "justify", "start", "end"] },
        ],
        "text-color": [{ text: [n] }],
        "text-opacity": [{ "text-opacity": [S] }],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline",
        ],
        "text-decoration-style": [{ decoration: [...O(), "wavy"] }],
        "text-decoration-thickness": [
          { decoration: ["auto", "from-font", Jo, nc] },
        ],
        "underline-offset": [{ "underline-offset": ["auto", Jo, qt] }],
        "text-decoration-color": [{ decoration: [n] }],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case",
        ],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
        indent: [{ indent: H() }],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              qt,
            ],
          },
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces",
            ],
          },
        ],
        break: [{ break: ["normal", "words", "all", "keep"] }],
        hyphens: [{ hyphens: ["none", "manual", "auto"] }],
        content: [{ content: ["none", qt] }],
        "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
        "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
        "bg-opacity": [{ "bg-opacity": [S] }],
        "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
        "bg-position": [{ bg: [...q(), gce] }],
        "bg-repeat": [
          { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
        ],
        "bg-size": [{ bg: ["auto", "cover", "contain", pce] }],
        "bg-image": [
          {
            bg: [
              "none",
              { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
              yce,
            ],
          },
        ],
        "bg-color": [{ bg: [n] }],
        "gradient-from-pos": [{ from: [y] }],
        "gradient-via-pos": [{ via: [y] }],
        "gradient-to-pos": [{ to: [y] }],
        "gradient-from": [{ from: [g] }],
        "gradient-via": [{ via: [g] }],
        "gradient-to": [{ to: [g] }],
        rounded: [{ rounded: [i] }],
        "rounded-s": [{ "rounded-s": [i] }],
        "rounded-e": [{ "rounded-e": [i] }],
        "rounded-t": [{ "rounded-t": [i] }],
        "rounded-r": [{ "rounded-r": [i] }],
        "rounded-b": [{ "rounded-b": [i] }],
        "rounded-l": [{ "rounded-l": [i] }],
        "rounded-ss": [{ "rounded-ss": [i] }],
        "rounded-se": [{ "rounded-se": [i] }],
        "rounded-ee": [{ "rounded-ee": [i] }],
        "rounded-es": [{ "rounded-es": [i] }],
        "rounded-tl": [{ "rounded-tl": [i] }],
        "rounded-tr": [{ "rounded-tr": [i] }],
        "rounded-br": [{ "rounded-br": [i] }],
        "rounded-bl": [{ "rounded-bl": [i] }],
        "border-w": [{ border: [o] }],
        "border-w-x": [{ "border-x": [o] }],
        "border-w-y": [{ "border-y": [o] }],
        "border-w-s": [{ "border-s": [o] }],
        "border-w-e": [{ "border-e": [o] }],
        "border-w-t": [{ "border-t": [o] }],
        "border-w-r": [{ "border-r": [o] }],
        "border-w-b": [{ "border-b": [o] }],
        "border-w-l": [{ "border-l": [o] }],
        "border-opacity": [{ "border-opacity": [S] }],
        "border-style": [{ border: [...O(), "hidden"] }],
        "divide-x": [{ "divide-x": [o] }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{ "divide-y": [o] }],
        "divide-y-reverse": ["divide-y-reverse"],
        "divide-opacity": [{ "divide-opacity": [S] }],
        "divide-style": [{ divide: O() }],
        "border-color": [{ border: [r] }],
        "border-color-x": [{ "border-x": [r] }],
        "border-color-y": [{ "border-y": [r] }],
        "border-color-s": [{ "border-s": [r] }],
        "border-color-e": [{ "border-e": [r] }],
        "border-color-t": [{ "border-t": [r] }],
        "border-color-r": [{ "border-r": [r] }],
        "border-color-b": [{ "border-b": [r] }],
        "border-color-l": [{ "border-l": [r] }],
        "divide-color": [{ divide: [r] }],
        "outline-style": [{ outline: ["", ...O()] }],
        "outline-offset": [{ "outline-offset": [Jo, qt] }],
        "outline-w": [{ outline: [Jo, nc] }],
        "outline-color": [{ outline: [n] }],
        "ring-w": [{ ring: z() }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{ ring: [n] }],
        "ring-opacity": [{ "ring-opacity": [S] }],
        "ring-offset-w": [{ "ring-offset": [Jo, nc] }],
        "ring-offset-color": [{ "ring-offset": [n] }],
        shadow: [{ shadow: ["", "inner", "none", sc, bce] }],
        "shadow-color": [{ shadow: [op] }],
        opacity: [{ opacity: [S] }],
        "mix-blend": [{ "mix-blend": [...U(), "plus-lighter", "plus-darker"] }],
        "bg-blend": [{ "bg-blend": U() }],
        filter: [{ filter: ["", "none"] }],
        blur: [{ blur: [t] }],
        brightness: [{ brightness: [s] }],
        contrast: [{ contrast: [l] }],
        "drop-shadow": [{ "drop-shadow": ["", "none", sc, qt] }],
        grayscale: [{ grayscale: [c] }],
        "hue-rotate": [{ "hue-rotate": [h] }],
        invert: [{ invert: [m] }],
        saturate: [{ saturate: [_] }],
        sepia: [{ sepia: [C] }],
        "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
        "backdrop-blur": [{ "backdrop-blur": [t] }],
        "backdrop-brightness": [{ "backdrop-brightness": [s] }],
        "backdrop-contrast": [{ "backdrop-contrast": [l] }],
        "backdrop-grayscale": [{ "backdrop-grayscale": [c] }],
        "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [h] }],
        "backdrop-invert": [{ "backdrop-invert": [m] }],
        "backdrop-opacity": [{ "backdrop-opacity": [S] }],
        "backdrop-saturate": [{ "backdrop-saturate": [_] }],
        "backdrop-sepia": [{ "backdrop-sepia": [C] }],
        "border-collapse": [{ border: ["collapse", "separate"] }],
        "border-spacing": [{ "border-spacing": [a] }],
        "border-spacing-x": [{ "border-spacing-x": [a] }],
        "border-spacing-y": [{ "border-spacing-y": [a] }],
        "table-layout": [{ table: ["auto", "fixed"] }],
        caption: [{ caption: ["top", "bottom"] }],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              qt,
            ],
          },
        ],
        duration: [{ duration: I() }],
        ease: [{ ease: ["linear", "in", "out", "in-out", qt] }],
        delay: [{ delay: I() }],
        animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", qt] }],
        transform: [{ transform: ["", "gpu", "none"] }],
        scale: [{ scale: [R] }],
        "scale-x": [{ "scale-x": [R] }],
        "scale-y": [{ "scale-y": [R] }],
        rotate: [{ rotate: [ap, qt] }],
        "translate-x": [{ "translate-x": [P] }],
        "translate-y": [{ "translate-y": [P] }],
        "skew-x": [{ "skew-x": [D] }],
        "skew-y": [{ "skew-y": [D] }],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              qt,
            ],
          },
        ],
        accent: [{ accent: ["auto", n] }],
        appearance: [{ appearance: ["none", "auto"] }],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              qt,
            ],
          },
        ],
        "caret-color": [{ caret: [n] }],
        "pointer-events": [{ "pointer-events": ["none", "auto"] }],
        resize: [{ resize: ["none", "y", "x", ""] }],
        "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
        "scroll-m": [{ "scroll-m": H() }],
        "scroll-mx": [{ "scroll-mx": H() }],
        "scroll-my": [{ "scroll-my": H() }],
        "scroll-ms": [{ "scroll-ms": H() }],
        "scroll-me": [{ "scroll-me": H() }],
        "scroll-mt": [{ "scroll-mt": H() }],
        "scroll-mr": [{ "scroll-mr": H() }],
        "scroll-mb": [{ "scroll-mb": H() }],
        "scroll-ml": [{ "scroll-ml": H() }],
        "scroll-p": [{ "scroll-p": H() }],
        "scroll-px": [{ "scroll-px": H() }],
        "scroll-py": [{ "scroll-py": H() }],
        "scroll-ps": [{ "scroll-ps": H() }],
        "scroll-pe": [{ "scroll-pe": H() }],
        "scroll-pt": [{ "scroll-pt": H() }],
        "scroll-pr": [{ "scroll-pr": H() }],
        "scroll-pb": [{ "scroll-pb": H() }],
        "scroll-pl": [{ "scroll-pl": H() }],
        "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
        "snap-stop": [{ snap: ["normal", "always"] }],
        "snap-type": [{ snap: ["none", "x", "y", "both"] }],
        "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
        touch: [{ touch: ["auto", "none", "manipulation"] }],
        "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
        "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{ select: ["none", "text", "all", "auto"] }],
        "will-change": [
          { "will-change": ["auto", "scroll", "contents", "transform", qt] },
        ],
        fill: [{ fill: [n, "none"] }],
        "stroke-w": [{ stroke: [Jo, nc, v1] }],
        stroke: [{ stroke: [n, "none"] }],
        sr: ["sr-only", "not-sr-only"],
        "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left",
        ],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction",
        ],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl",
        ],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l",
        ],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l",
        ],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml",
        ],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl",
        ],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"],
      },
      conflictingClassGroupModifiers: { "font-size": ["leading"] },
    };
  },
  Tce = ice(Sce);
(console.log = () => {}), (console.warn = () => {}), (console.error = () => {});
function Le(...n) {
  return Tce(XH(n));
}
const fL = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(qH, {
    ref: t,
    className: Le(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      n
    ),
    ...e,
  })
);
fL.displayName = qH.displayName;
const mL = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(WH, { ref: t, className: Le("aspect-square h-full w-full", n), ...e })
);
mL.displayName = WH.displayName;
const pL = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(KH, {
    ref: t,
    className: Le(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      n
    ),
    ...e,
  })
);
pL.displayName = KH.displayName;
const _ce = {
    xs: "h-4 w-4",
    sm: "h-5 w-5",
    md: "h-8 w-8",
    lg: "h-10 w-10",
    xl: "h-12 w-12",
    full: "!h-full !w-auto aspect-square",
  },
  Ng = ({
    src: n,
    userId: e,
    user: t,
    name: s,
    size: r = "md",
    className: i,
    alt: a = "Profile picture",
  }) => {
    const o = hn((S) => S.userProfiles) || {},
      [l, c] = E.useState(!1),
      h = () => {
        let S = null,
          A = null;
        if (n) (S = n), (A = s || null);
        else if (t)
          (S = t.avatar_url || null), (A = t.full_name || t.email || t.id);
        else if (e && o[e]) {
          const _ = o[e];
          (S = _.avatar_url || null), (A = _.full_name || _.email || e);
        } else s && (A = s);
        return { avatarUrl: S, displayName: A };
      },
      { avatarUrl: m, displayName: p } = h();
    E.useEffect(() => {
      c(!1);
    }, [m]);
    const g = [
        { bg: "bg-accent-purple", text: "text-white" },
        { bg: "bg-accent-blue", text: "text-white" },
        { bg: "bg-accent-teal", text: "text-white" },
        { bg: "bg-accent-green", text: "text-black" },
        { bg: "bg-accent-lime", text: "text-black" },
        { bg: "bg-accent-orange", text: "text-black" },
        { bg: "bg-accent-red", text: "text-white" },
      ],
      y = (S) => {
        if (!S) return g[0];
        let A = 0;
        for (let R = 0; R < S.length; R++) {
          const C = S.charCodeAt(R);
          (A = (A << 5) - A + C), (A = A & A);
        }
        const _ = Math.abs(A) % g.length;
        return g[_];
      },
      b = (S) =>
        S.split(" ")
          .map((A) => A.charAt(0))
          .join("")
          .toUpperCase()
          .slice(0, 2),
      w = y(t?.id || e || p || "");
    return u.jsxs(fL, {
      className: Le(_ce[r], i),
      children: [
        m && !l && u.jsx(mL, { src: m, alt: a, onError: () => c(!0) }),
        u.jsx(pL, {
          className: Le(w.bg, "font-bold text-xs text-card-background/50"),
          children: p ? b(p) : u.jsx(tk, { className: "h-4 w-4" }),
        }),
      ],
    });
  },
  Ace = () => {
    Pt((c) => c.currentTeam);
    const { user: n, profile: e, isInitialized: t } = ks(),
      s = Joe(),
      r = Dr(),
      i = es(),
      a = r.pathname === "/",
      o =
        n && e
          ? {
              id: n.id,
              full_name: e.full_name,
              avatar_url: e.avatar_url,
              email: n.email,
            }
          : null,
      l = () => {
        i("/"), window.scrollTo({ top: 0, behavior: "smooth" });
      };
    return u.jsx("div", {
      className:
        "shared-nav md:fixed top-0 left-0 w-full z-20  transition-colors overflow-visible duration-200 pointer-events-none",
      children: u.jsx("div", {
        className: "max-w-screen-2xl mx-auto px-4 md:px-16 ",
        children: u.jsx("div", {
          className: "py-2 mt-4",
          children: u.jsxs("div", {
            className:
              "relative overflow-visible pointer-events-auto w-full flex items-center justify-between gap-4",
            children: [
              u.jsx("div", {
                className:
                  "h-[52px] rounded-full md:bg-element-background/90 md:backdrop-blur-md md:border-t md:border-text-primary/30 md:shadow-2xl flex items-center md:p-3",
                children: u.jsxs("div", {
                  className: "flex items-center",
                  children: [
                    u.jsx("div", {
                      onClick: l,
                      className: "cursor-pointer",
                      children: u.jsx(Ig, { className: "mr-6 z-10 ml-6" }),
                    }),
                    u.jsx("div", {
                      className: "hidden md:flex items-center gap-3 ",
                      children: m8.map((c) =>
                        c.isExternal
                          ? u.jsx(
                              "a",
                              {
                                href: c.href,
                                className:
                                  "text-text-primary text-sm hover:opacity-80 rounded-full px-3 py-1 transition-all duration-200",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                children: c.label,
                              },
                              c.label
                            )
                          : u.jsx(
                              br,
                              {
                                to: c.href,
                                className:
                                  "text-text-primary text-sm hover:opacity-80 rounded-full px-3 py-1 transition-all duration-200",
                                children: c.label,
                              },
                              c.label
                            )
                      ),
                    }),
                  ],
                }),
              }),
              u.jsx("div", {
                className: "flex h-[48px] items-center gap-4",
                children: t
                  ? u.jsxs(u.Fragment, {
                      children: [
                        n &&
                          a &&
                          o &&
                          u.jsx("button", {
                            onClick: async () => {
                              await s(), i("/");
                            },
                            className:
                              "text-text-primary text-sm  hover:opacity-80 transition-all duration-200",
                            children: "Logout",
                          }),
                        u.jsx(br, {
                          to: n && a ? "/dash" : "/login",
                          className: "h-full",
                          children: u.jsx("div", {
                            className:
                              "button-secondary h-full flex items-center gap-2 px-4 cursor-pointer",
                            children:
                              n && a && o
                                ? u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx(Ng, {
                                        user: o,
                                        src: o.avatar_url,
                                        size: "sm",
                                      }),
                                      u.jsx("span", {
                                        className: "text-sm font-medium",
                                        children: "Dashboard",
                                      }),
                                    ],
                                  })
                                : u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx("span", {
                                        className:
                                          "text-sm !font-normal !text-text-primary ",
                                        children: "Get Started",
                                      }),
                                      u.jsx(yE, {
                                        className:
                                          "w-5 h-5 !text-text-primary ",
                                      }),
                                    ],
                                  }),
                          }),
                        }),
                      ],
                    })
                  : u.jsx("div", {
                      className: "h-full",
                      children: u.jsx("div", {
                        className:
                          "button-secondary h-full flex items-center gap-2 px-4",
                        children: u.jsx("div", {
                          className:
                            "w-20 h-4 bg-text-primary/20 rounded animate-pulse",
                        }),
                      }),
                    }),
              }),
            ],
          }),
        }),
      }),
    });
  },
  gL = ({ className: n = "" }) =>
    u.jsxs("div", {
      className: `flex items-center relative ${n}`,
      children: [
        u.jsx("img", {
          src: "/images/flasklogo.png",
          alt: "Flask Logo",
          className: "h-[78px] object-contain absolute left-6 opacity-80",
        }),
        u.jsx("p", {
          className:
            "text-text-primary/85 tracking-[-0.075em] text-[46px] font-bold ",
          children: "Flask",
        }),
      ],
    }),
  nV = () =>
    u.jsx("footer", {
      className:
        "bg-card-background border-t border-border mt-8 md:mt-16 relative w-full",
      children: u.jsxs("div", {
        className:
          "w-full px-6 md:max-w-screen-2xl md:mx-auto md:px-12 py-8 md:py-12",
        children: [
          u.jsxs("div", {
            className: "flex flex-col md:flex-row md:justify-between gap-8",
            children: [
              u.jsxs("div", {
                className: "flex-shrink-0",
                children: [
                  u.jsx("div", {
                    className: "flex items-center mb-4",
                    children: u.jsx(br, { to: "/", children: u.jsx(gL, {}) }),
                  }),
                  u.jsxs("p", {
                    className: "text-text-secondary text-sm",
                    children: [
                      " ",
                      new Date().getFullYear(),
                      " Flask. All rights reserved.",
                    ],
                  }),
                ],
              }),
              u.jsxs("div", {
                className: "flex flex-col gap-4 md:items-end",
                children: [
                  m8.map((n) =>
                    n.isExternal
                      ? u.jsx(
                          "a",
                          {
                            href: n.href,
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className:
                              "text-sm text-text-primary hover:text-text-primary/80 transition-colors",
                            children: n.label,
                          },
                          n.label
                        )
                      : u.jsx(
                          br,
                          {
                            to: n.href,
                            className:
                              "text-sm text-text-primary hover:text-text-primary/80 transition-colors",
                            children: n.label,
                          },
                          n.label
                        )
                  ),
                  u.jsx(br, {
                    to: "/manifesto",
                    className:
                      "text-sm text-text-primary hover:text-text-primary/80 transition-colors",
                    children: "Manifesto",
                  }),
                  u.jsx(br, {
                    to: "/privacy-policy",
                    className:
                      "text-sm text-text-secondary hover:text-text-primary transition-colors",
                    children: "Privacy Policy",
                  }),
                  u.jsx(br, {
                    to: "/terms-of-service",
                    className:
                      "text-sm text-text-secondary hover:text-text-primary transition-colors",
                    children: "Terms of Service",
                  }),
                ],
              }),
            ],
          }),
          u.jsx("div", {
            className: "mt-8 md:mt-12",
            children: u.jsxs("div", {
              className: "flex justify-between items-center",
              children: [
                u.jsx("div", {
                  className: "text-xs text-text-secondary/60",
                  children: "Built with blood, sweat and redbulls.",
                }),
                u.jsx("a", {
                  href: "https://www.youtube.com/watch?v=c-wT7sijLIs",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className:
                    "text-xs text-text-secondary/20 hover:text-text-secondary transition-colors",
                  children: "I have a bad feeling about this",
                }),
              ],
            }),
          }),
        ],
      }),
    }),
  MU = (n) => (typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n),
  NU = XH,
  vL = (n, e) => (t) => {
    var s;
    if (e?.variants == null) return NU(n, t?.class, t?.className);
    const { variants: r, defaultVariants: i } = e,
      a = Object.keys(r).map((c) => {
        const h = t?.[c],
          m = i?.[c];
        if (h === null) return null;
        const p = MU(h) || MU(m);
        return r[c][p];
      }),
      o =
        t &&
        Object.entries(t).reduce((c, h) => {
          let [m, p] = h;
          return p === void 0 || (c[m] = p), c;
        }, {}),
      l =
        e == null || (s = e.compoundVariants) === null || s === void 0
          ? void 0
          : s.reduce((c, h) => {
              let { class: m, className: p, ...g } = h;
              return Object.entries(g).every((y) => {
                let [b, w] = y;
                return Array.isArray(w)
                  ? w.includes({ ...i, ...o }[b])
                  : { ...i, ...o }[b] === w;
              })
                ? [...c, m, p]
                : c;
            }, []);
    return NU(n, a, l, t?.class, t?.className);
  },
  yL = vL(
    "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline",
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  et = E.forwardRef(
    ({ className: n, variant: e, size: t, asChild: s = !1, ...r }, i) => {
      const a = s ? Ple : "button";
      return u.jsx(a, {
        className: Le(yL({ variant: e, size: t, className: n })),
        ref: i,
        ...r,
      });
    }
  );
et.displayName = "Button";
const Rce = 1,
  kce = 1e6;
let y1 = 0;
function Cce() {
  return (y1 = (y1 + 1) % Number.MAX_SAFE_INTEGER), y1.toString();
}
const b1 = new Map(),
  OU = (n) => {
    if (b1.has(n)) return;
    const e = setTimeout(() => {
      b1.delete(n), Kp({ type: "REMOVE_TOAST", toastId: n });
    }, kce);
    b1.set(n, e);
  },
  Ice = (n, e) => {
    switch (e.type) {
      case "ADD_TOAST":
        return { ...n, toasts: [e.toast, ...n.toasts].slice(0, Rce) };
      case "UPDATE_TOAST":
        return {
          ...n,
          toasts: n.toasts.map((t) =>
            t.id === e.toast.id ? { ...t, ...e.toast } : t
          ),
        };
      case "DISMISS_TOAST": {
        const { toastId: t } = e;
        return (
          t
            ? OU(t)
            : n.toasts.forEach((s) => {
                OU(s.id);
              }),
          {
            ...n,
            toasts: n.toasts.map((s) =>
              s.id === t || t === void 0 ? { ...s, open: !1 } : s
            ),
          }
        );
      }
      case "REMOVE_TOAST":
        return e.toastId === void 0
          ? { ...n, toasts: [] }
          : { ...n, toasts: n.toasts.filter((t) => t.id !== e.toastId) };
    }
  },
  yb = [];
let bb = { toasts: [] };
function Kp(n) {
  (bb = Ice(bb, n)),
    yb.forEach((e) => {
      e(bb);
    });
}
function Ms({ ...n }) {
  const e = Cce(),
    t = (r) => Kp({ type: "UPDATE_TOAST", toast: { ...r, id: e } }),
    s = () => Kp({ type: "DISMISS_TOAST", toastId: e });
  return (
    Kp({
      type: "ADD_TOAST",
      toast: {
        ...n,
        id: e,
        open: !0,
        onOpenChange: (r) => {
          r || s();
        },
      },
    }),
    { id: e, dismiss: s, update: t }
  );
}
function Lce() {
  const [n, e] = E.useState(bb);
  return (
    E.useEffect(
      () => (
        yb.push(e),
        () => {
          const t = yb.indexOf(e);
          t > -1 && yb.splice(t, 1);
        }
      ),
      [n]
    ),
    {
      ...n,
      toast: Ms,
      dismiss: (t) => Kp({ type: "DISMISS_TOAST", toastId: t }),
    }
  );
}
const Dce = () => {
    const [n, e] = E.useState(!1),
      { user: t } = ks(),
      { toast: s } = Lce(),
      r = es(),
      i = async () => {
        if (!t) {
          const o = encodeURIComponent("/#pricing");
          r(`/login?redirect=${o}`);
          return;
        }
        e(!0);
        try {
          const o = await Ut("/api/teams/subscribe", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              billing_period: "yearly",
              success_url: `${window.location.origin}/?settings=team&from_checkout=true`,
              cancel_url: `${window.location.origin}/#pricing`,
              team_name: "New Team",
            }),
          });
          if (!o.ok) throw new Error("Failed to create checkout session");
          const { url: l } = await o.json();
          window.location.href = l;
        } catch (o) {
          console.error("Error starting checkout:", o),
            s({
              title: "Error",
              description: "Failed to start checkout. Please try again.",
              variant: "destructive",
            }),
            e(!1);
        }
      };
    return u.jsx("div", {
      className: "w-full max-w-6xl mx-auto relative z-10",
      children: u.jsxs("div", {
        className:
          "flex flex-col md:flex-row justify-center items-start gap-12 md:gap-6 relative",
        children: [
          u.jsx("div", {
            className: "flex-1 flex flex-col max-w-xs mx-auto md:mx-0",
            children: u.jsxs("div", {
              className:
                "bg-card-background border border-border rounded-3xl  p-6 flex flex-col flex-1",
              children: [
                u.jsx("div", {
                  className: "mb-1",
                  children: u.jsx("h3", {
                    className: "text-2xl font-bold text-white",
                    children: "Free",
                  }),
                }),
                u.jsx("div", {
                  className: "h-10",
                  children: u.jsx("p", {
                    className: "text-text-secondary text-sm md:text-xs",
                    children: "Free, unlimited video collaboration",
                  }),
                }),
                u.jsx("div", {
                  className: "mb-4 h-14 flex flex-col justify-center",
                  children: u.jsx("div", {
                    className: "flex items-baseline gap-2",
                    children: u.jsx("span", {
                      className: "text-3xl font-mono text-text-primary/90",
                      children: "$0",
                    }),
                  }),
                }),
                u.jsx("div", {
                  className: "mb-3",
                  children: u.jsx("p", {
                    className:
                      "text-text-secondary text-xs uppercase tracking-wider",
                    children: "Includes",
                  }),
                }),
                u.jsxs("ul", {
                  className: "space-y-2 flex-grow mb-6",
                  children: [
                    u.jsxs("li", {
                      className: "flex items-start gap-2",
                      children: [
                        u.jsx(zs, {
                          className:
                            "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                        }),
                        u.jsx("span", {
                          className: "text-text-primary text-xs",
                          children: "Unlimited, free video collaboration",
                        }),
                      ],
                    }),
                    u.jsxs("li", {
                      className: "flex items-start gap-2",
                      children: [
                        u.jsx(zs, {
                          className:
                            "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                        }),
                        u.jsx("span", {
                          className: "text-text-primary text-xs",
                          children:
                            "Unlimited comments, recordings, AI insights",
                        }),
                      ],
                    }),
                    u.jsxs("li", {
                      className: "flex items-start gap-2",
                      children: [
                        u.jsx(zs, {
                          className:
                            "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                        }),
                        u.jsx("span", {
                          className: "text-text-primary text-xs",
                          children:
                            "Use YouTube as storage (Unlisted or Public videos)",
                        }),
                      ],
                    }),
                  ],
                }),
                u.jsx("div", {
                  children: u.jsx(et, {
                    className:
                      "w-full rounded-full h-12 button-secondary shadow-lg mt-2",
                    onClick: () => r("/dash"),
                    children: "Get Started",
                  }),
                }),
              ],
            }),
          }),
          u.jsxs("div", {
            className: "flex-1 flex flex-col max-w-xs mx-auto md:mx-0 relative",
            children: [
              u.jsx("div", {
                className: "absolute -top-5 left-1/2 -translate-x-1/2 z-10 ",
                children: u.jsx("div", {
                  className:
                    "bg-green-500/50 backdrop-blur-md border border-green-200 rounded-full px-3 py-1",
                  children: u.jsx("span", {
                    className: "text-green-200 text-xs whitespace-nowrap",
                    children: "For Creative Teams",
                  }),
                }),
              }),
              u.jsxs("div", {
                className:
                  "bg-element-background border-t border-text-primary/30 rounded-3xl shadow-3xl p-6 flex flex-col flex-1 relative",
                children: [
                  u.jsx("img", {
                    src: "/images/thumbsup.png",
                    alt: "",
                    className:
                      "absolute -top-10 -right-8 w-24 h-24 pointer-events-none",
                  }),
                  u.jsx("div", {
                    className: "mb-1",
                    children: u.jsx("h3", {
                      className: "text-2xl font-bold text-white",
                      children: "Pro",
                    }),
                  }),
                  u.jsx("div", {
                    className: "h-10",
                    children: u.jsx("p", {
                      className: "text-text-secondary text-sm md:text-xs",
                      children: "Creative collaboration for teams",
                    }),
                  }),
                  u.jsxs("div", {
                    className: "mb-4 flex items-center gap-2",
                    children: [
                      u.jsxs("span", {
                        className: "text-3xl font-mono text-text-primary ",
                        children: ["$", 13],
                      }),
                      u.jsxs("span", {
                        className: "text-text-secondary pl-2 text-xs",
                        children: [
                          "per member / month ",
                          u.jsx("br", {}),
                          " (billed annually)",
                        ],
                      }),
                    ],
                  }),
                  u.jsx("div", {
                    className: "mb-3",
                    children: u.jsx("p", {
                      className:
                        "text-text-secondary text-xs uppercase tracking-wider mt-5",
                      children: "Everything in Free, plus",
                    }),
                  }),
                  u.jsxs("ul", {
                    className: "space-y-2 flex-grow mb-6",
                    children: [
                      u.jsxs("li", {
                        className: "flex items-start gap-2",
                        children: [
                          u.jsx(zs, {
                            className:
                              "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                          }),
                          u.jsx("span", {
                            className: "text-text-primary text-xs",
                            children: "Upload videos from device",
                          }),
                        ],
                      }),
                      u.jsxs("li", {
                        className: "flex items-start gap-2",
                        children: [
                          u.jsx(zs, {
                            className:
                              "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                          }),
                          u.jsx("span", {
                            className: "text-text-primary text-xs",
                            children: "Shared workspace with team members",
                          }),
                        ],
                      }),
                      u.jsxs("li", {
                        className: "flex items-start gap-2",
                        children: [
                          u.jsx(zs, {
                            className:
                              "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                          }),
                          u.jsx("span", {
                            className: "text-text-primary text-xs",
                            children: "Multiple assets/versions per Flask",
                          }),
                        ],
                      }),
                      u.jsxs("li", {
                        className: "flex items-start gap-2",
                        children: [
                          u.jsx(zs, {
                            className:
                              "w-3.5 h-3.5 text-text-primary mt-0.5 flex-shrink-0",
                          }),
                          u.jsx("span", {
                            className: "text-text-primary text-xs",
                            children: "Remove Flask branding",
                          }),
                        ],
                      }),
                    ],
                  }),
                  u.jsx("div", {
                    children: u.jsx(et, {
                      className:
                        "w-full button-primary font-bold rounded-full h-12 shadow-lg",
                      onClick: i,
                      disabled: n,
                      children: n
                        ? u.jsxs(u.Fragment, {
                            children: [
                              u.jsx(wo, {
                                className: "w-4 h-4 mr-2 animate-spin",
                              }),
                              "Loading...",
                            ],
                          })
                        : "Get Started",
                    }),
                  }),
                  u.jsx("div", {
                    className: "text-center mt-2",
                    children: u.jsx("span", {
                      className: "text-text-secondary text-xs",
                      children: "30-day guarantee",
                    }),
                  }),
                ],
              }),
            ],
          }),
          u.jsx("div", {
            className:
              "hidden md:flex flex-1 flex-col max-w-xs mx-auto md:mx-0",
            children: u.jsxs("div", {
              className:
                "bg-card-background border border-border rounded-3xl shadow-3xl p-6 flex flex-col flex-1",
              children: [
                u.jsx("div", {
                  className: "mb-1",
                  children: u.jsx("h3", {
                    className: "text-2xl font-bold text-text-secondary",
                    children: "Top 1%",
                  }),
                }),
                u.jsx("div", {
                  className: "h-10 flex items-center",
                  children: u.jsxs("p", {
                    className: "text-text-secondary text-xs",
                    children: [
                      "The top 1% most active teams get Flask Pro for free",
                      " ",
                      u.jsx("a", {
                        href: "#faq-1-6",
                        className: "text-text-secondary underline ml-1",
                        onClick: (o) => {
                          o.preventDefault();
                          const l = document.getElementById("faq-1-6");
                          l &&
                            (l.scrollIntoView({
                              behavior: "smooth",
                              block: "center",
                            }),
                            (window.location.hash = "faq-1-6"));
                        },
                        children: "Learn more",
                      }),
                    ],
                  }),
                }),
                u.jsx("div", {
                  className: "mb-4 h-14 flex flex-col justify-center",
                  children: u.jsx("div", {
                    className: "flex items-baseline gap-2",
                    children: u.jsx("span", {
                      className: "text-3xl font-mono text-text-primary",
                      children: "$0",
                    }),
                  }),
                }),
                u.jsx("div", {
                  className: "mb-3",
                  children: u.jsx("p", {
                    className:
                      "text-text-secondary text-xs uppercase h-36 tracking-wider opacity-0",
                    children: "Placeholder",
                  }),
                }),
                u.jsx("div", { className: "flex-grow" }),
                u.jsx("div", {
                  children: u.jsx(et, {
                    className:
                      "w-full rounded-full h-12 bg-transparent border border-border text-text-secondary",
                    disabled: !0,
                    children: "Keep using Flask!",
                  }),
                }),
              ],
            }),
          }),
        ],
      }),
    });
  },
  Pce = 80,
  Mce = () => {
    const n = Dr(),
      e = E.useRef("");
    return (
      E.useEffect(() => {
        n.hash && (e.current = n.hash.slice(1)),
          e.current &&
            document.getElementById(e.current) &&
            setTimeout(() => {
              const t = document.getElementById(e.current);
              if (t) {
                const s = t.getBoundingClientRect().top + window.scrollY;
                window.scrollTo({ top: s - Pce, behavior: "smooth" }),
                  (e.current = "");
              }
            }, 100);
      }, [n]),
      null
    );
  },
  Nce = () => ({
    "@context": "https://schema.org",
    "@type": "Organization",
    name: "Flask",
    url: "https://flask.do",
    logo: "https://flask.do/images/flasklogo.png",
    sameAs: ["https://twitter.com/flaskapp"],
    description:
      "Next-gen video collaboration tool for creative teams. Record in-depth feedback, add any reference on your screen, and let AI extract what matters.",
    foundingDate: "2024",
    founders: [{ "@type": "Person", name: "Enrico", jobTitle: "Founder" }],
    contactPoint: {
      "@type": "ContactPoint",
      contactType: "customer service",
      url: "https://flask.do#talk-to-us",
    },
  }),
  Oce = () => ({
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    name: "Flask",
    description:
      "Next-gen video collaboration tool for creative teams. Record in-depth feedback, add any reference on your screen, and let AI extract what matters. Tag, filter, and organize comments on a visual canvas.",
    url: "https://flask.do",
    applicationCategory: "BusinessApplication",
    operatingSystem: "Web Browser",
    featureList: [
      "Screen recording with AI feedback extraction",
      "Visual canvas for comment organization",
      "Custom tagging and filtering",
      "Team collaboration workspaces",
      "YouTube integration",
      "Video annotation tools",
    ],
    screenshot: "https://flask.do/images/screen-preview.png",
  }),
  jce = () => ({
    "@context": "https://schema.org",
    "@type": "WebSite",
    name: "Flask",
    url: "https://flask.do",
    description:
      "Video collaboration platform built for how creatives actually work. Annotate videos visually, record in-depth feedback, add any reference on your screen.",
    potentialAction: {
      "@type": "SearchAction",
      target: "https://flask.do/search?q={search_term_string}",
      "query-input": "required name=search_term_string",
    },
    publisher: {
      "@type": "Organization",
      name: "Flask",
      logo: "https://flask.do/images/flasklogo.png",
    },
  }),
  Fce = () => ({
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: [
      {
        "@type": "Question",
        name: "Is Flask really free?",
        acceptedAnswer: {
          "@type": "Answer",
          text: "Yes! Flask is free for unlimited videos and feedback when you upload to YouTube. For creative teams who want shared workspaces and direct uploads, Flask Pro is available.",
        },
      },
      {
        "@type": "Question",
        name: "How does Flask work with YouTube?",
        acceptedAnswer: {
          "@type": "Answer",
          text: "Upload your video to YouTube as Public or Unlisted, then paste the link into Flask. You can use all Flask features for free with YouTube videos.",
        },
      },
      {
        "@type": "Question",
        name: "What makes Flask different from other video collaboration tools?",
        acceptedAnswer: {
          "@type": "Answer",
          text: "Flask focuses on visual feedback for creatives. Record complex feedback with screen sharing, let AI extract key points, and organize comments on a visual canvas with custom tagging.",
        },
      },
    ],
  }),
  Uce = () => ({
    "@context": "https://schema.org",
    "@type": "SiteNavigationElement",
    name: "Flask Navigation",
    url: "https://flask.do",
    hasPart: [
      {
        "@type": "WebPageElement",
        name: "Features",
        url: "https://flask.do/#features",
        description:
          "Learn about Flask's video collaboration features including screen recording, AI feedback extraction, and visual canvas organization.",
      },
      {
        "@type": "WebPageElement",
        name: "Pricing",
        url: "https://flask.do/#pricing",
        description:
          "View Flask's pricing plans - free unlimited collaboration with YouTube integration and Pro plans for creative teams.",
      },
      {
        "@type": "WebPageElement",
        name: "FAQ",
        url: "https://flask.do/#faq",
        description:
          "Frequently asked questions about Flask video collaboration platform and how it works.",
      },
      {
        "@type": "WebPageElement",
        name: "Contact",
        url: "https://flask.do/#talk-to-us",
        description:
          "Get in touch with the Flask team for support or questions about video collaboration.",
      },
    ],
  }),
  fo = {
    siteName: "Flask",
    domain: "https://flask.do",
    twitterHandle: "@flaskapp",
    author: "Flask Team",
    themeColor: "#09090B",
    locale: "en_US",
  },
  oh = {
    title: "Flask - Video Collaboration for Creative Teams",
    description:
      "The best video collaboration tool you've ever used. Type and record creative feedback. Show any reference on your screen. All in a visual canvas linked to your video.",
    keywords:
      "flask do, flask . do, flask video, flask enrico, video collaboration, creative feedback, video review, team collaboration, creative tools, video annotation, screen recording, AI feedback, visual feedback, creative workflow, design feedback, video comments, creative teams, frame, frame io, frame video tool, visual canvas, tagging system",
    ogImage: "/images/OpenGraphImage.png",
    ogType: "website",
    twitterCard: "summary_large_image",
  },
  $ce = (n, e) => ({
    title: `${n} - Flask`,
    description: `Collaborate on ${n} with Flask. Add feedback, record comments, and organize thoughts on a visual canvas.`,
    canonical: `/flask/${e}`,
    ogImage: "/images/OpenGraphImage.png",
    noindex: !1,
  }),
  Bce = (n) => (n.includes("Flask") ? n : `${n} | Flask`),
  Hce = (n) => (n ? `${fo.domain}${n}` : fo.domain),
  Vce = (n) => (n.startsWith("http") ? n : `${fo.domain}${n}`),
  sV = ({
    title: n = oh.title,
    description: e = oh.description,
    canonical: t,
    ogImage: s = oh.ogImage,
    ogType: r = oh.ogType,
    twitterCard: i = oh.twitterCard,
    keywords: a = oh.keywords,
    author: o = fo.author,
    structuredData: l,
    noindex: c = !1,
  }) => {
    const h = Bce(n),
      m = Hce(t),
      p = Vce(s);
    return u.jsxs(eee, {
      children: [
        u.jsx("title", { children: h }),
        u.jsx("meta", { name: "description", content: e }),
        u.jsx("meta", { name: "keywords", content: a }),
        u.jsx("meta", { name: "author", content: o }),
        u.jsx("link", { rel: "canonical", href: m }),
        c && u.jsx("meta", { name: "robots", content: "noindex, nofollow" }),
        u.jsx("meta", { property: "og:title", content: h }),
        u.jsx("meta", { property: "og:description", content: e }),
        u.jsx("meta", { property: "og:image", content: p }),
        u.jsx("meta", { property: "og:url", content: m }),
        u.jsx("meta", { property: "og:type", content: r }),
        u.jsx("meta", { property: "og:site_name", content: fo.siteName }),
        u.jsx("meta", { property: "og:locale", content: fo.locale }),
        u.jsx("meta", { name: "twitter:card", content: i }),
        u.jsx("meta", { name: "twitter:title", content: h }),
        u.jsx("meta", { name: "twitter:description", content: e }),
        u.jsx("meta", { name: "twitter:image", content: p }),
        u.jsx("meta", { name: "twitter:site", content: fo.twitterHandle }),
        u.jsx("meta", { name: "twitter:creator", content: fo.twitterHandle }),
        u.jsx("meta", { name: "theme-color", content: fo.themeColor }),
        u.jsx("meta", {
          name: "msapplication-TileColor",
          content: fo.themeColor,
        }),
        l &&
          u.jsx("script", {
            type: "application/ld+json",
            children: JSON.stringify(l),
          }),
      ],
    });
  };
function Tv(n) {
  const e = n + "CollectionProvider",
    [t, s] = Pr(e),
    [r, i] = t(e, { collectionRef: { current: null }, itemMap: new Map() }),
    a = (b) => {
      const { scope: w, children: S } = b,
        A = de.useRef(null),
        _ = de.useRef(new Map()).current;
      return u.jsx(r, { scope: w, itemMap: _, collectionRef: A, children: S });
    };
  a.displayName = e;
  const o = n + "CollectionSlot",
    l = Mc(o),
    c = de.forwardRef((b, w) => {
      const { scope: S, children: A } = b,
        _ = i(o, S),
        R = Nt(w, _.collectionRef);
      return u.jsx(l, { ref: R, children: A });
    });
  c.displayName = o;
  const h = n + "CollectionItemSlot",
    m = "data-radix-collection-item",
    p = Mc(h),
    g = de.forwardRef((b, w) => {
      const { scope: S, children: A, ..._ } = b,
        R = de.useRef(null),
        C = Nt(w, R),
        D = i(h, S);
      return (
        de.useEffect(
          () => (
            D.itemMap.set(R, { ref: R, ..._ }), () => void D.itemMap.delete(R)
          )
        ),
        u.jsx(p, { [m]: "", ref: C, children: A })
      );
    });
  g.displayName = h;
  function y(b) {
    const w = i(n + "CollectionConsumer", b);
    return de.useCallback(() => {
      const A = w.collectionRef.current;
      if (!A) return [];
      const _ = Array.from(A.querySelectorAll(`[${m}]`));
      return Array.from(w.itemMap.values()).sort(
        (D, L) => _.indexOf(D.ref.current) - _.indexOf(L.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [{ Provider: a, Slot: c, ItemSlot: g }, y, s];
}
function qe(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function (r) {
    if ((n?.(r), t === !1 || !r.defaultPrevented)) return e?.(r);
  };
}
var zce = J5[" useInsertionEffect ".trim().toString()] || ys;
function ci({ prop: n, defaultProp: e, onChange: t = () => {}, caller: s }) {
  const [r, i, a] = Gce({ defaultProp: e, onChange: t }),
    o = n !== void 0,
    l = o ? n : r;
  {
    const h = E.useRef(n !== void 0);
    E.useEffect(() => {
      const m = h.current;
      m !== o &&
        console.warn(
          `${s} is changing from ${m ? "controlled" : "uncontrolled"} to ${
            o ? "controlled" : "uncontrolled"
          }. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ),
        (h.current = o);
    }, [o, s]);
  }
  const c = E.useCallback(
    (h) => {
      if (o) {
        const m = qce(h) ? h(n) : h;
        m !== n && a.current?.(m);
      } else i(h);
    },
    [o, n, i, a]
  );
  return [l, c];
}
function Gce({ defaultProp: n, onChange: e }) {
  const [t, s] = E.useState(n),
    r = E.useRef(t),
    i = E.useRef(e);
  return (
    zce(() => {
      i.current = e;
    }, [e]),
    E.useEffect(() => {
      r.current !== t && (i.current?.(t), (r.current = t));
    }, [t, r]),
    [t, s, i]
  );
}
function qce(n) {
  return typeof n == "function";
}
function Wce(n, e) {
  return E.useReducer((t, s) => e[t][s] ?? t, n);
}
var Pi = (n) => {
  const { present: e, children: t } = n,
    s = Kce(e),
    r =
      typeof t == "function" ? t({ present: s.isPresent }) : E.Children.only(t),
    i = Nt(s.ref, Yce(r));
  return typeof t == "function" || s.isPresent
    ? E.cloneElement(r, { ref: i })
    : null;
};
Pi.displayName = "Presence";
function Kce(n) {
  const [e, t] = E.useState(),
    s = E.useRef(null),
    r = E.useRef(n),
    i = E.useRef("none"),
    a = n ? "mounted" : "unmounted",
    [o, l] = Wce(a, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    E.useEffect(() => {
      const c = Ty(s.current);
      i.current = o === "mounted" ? c : "none";
    }, [o]),
    ys(() => {
      const c = s.current,
        h = r.current;
      if (h !== n) {
        const p = i.current,
          g = Ty(c);
        n
          ? l("MOUNT")
          : g === "none" || c?.display === "none"
          ? l("UNMOUNT")
          : l(h && p !== g ? "ANIMATION_OUT" : "UNMOUNT"),
          (r.current = n);
      }
    }, [n, l]),
    ys(() => {
      if (e) {
        let c;
        const h = e.ownerDocument.defaultView ?? window,
          m = (g) => {
            const b = Ty(s.current).includes(g.animationName);
            if (g.target === e && b && (l("ANIMATION_END"), !r.current)) {
              const w = e.style.animationFillMode;
              (e.style.animationFillMode = "forwards"),
                (c = h.setTimeout(() => {
                  e.style.animationFillMode === "forwards" &&
                    (e.style.animationFillMode = w);
                }));
            }
          },
          p = (g) => {
            g.target === e && (i.current = Ty(s.current));
          };
        return (
          e.addEventListener("animationstart", p),
          e.addEventListener("animationcancel", m),
          e.addEventListener("animationend", m),
          () => {
            h.clearTimeout(c),
              e.removeEventListener("animationstart", p),
              e.removeEventListener("animationcancel", m),
              e.removeEventListener("animationend", m);
          }
        );
      } else l("ANIMATION_END");
    }, [e, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(o),
      ref: E.useCallback((c) => {
        (s.current = c ? getComputedStyle(c) : null), t(c);
      }, []),
    }
  );
}
function Ty(n) {
  return n?.animationName || "none";
}
function Yce(n) {
  let e = Object.getOwnPropertyDescriptor(n.props, "ref")?.get,
    t = e && "isReactWarning" in e && e.isReactWarning;
  return t
    ? n.ref
    : ((e = Object.getOwnPropertyDescriptor(n, "ref")?.get),
      (t = e && "isReactWarning" in e && e.isReactWarning),
      t ? n.props.ref : n.props.ref || n.ref);
}
var Xce = J5[" useId ".trim().toString()] || (() => {}),
  Qce = 0;
function $r(n) {
  const [e, t] = E.useState(Xce());
  return (
    ys(() => {
      t((s) => s ?? String(Qce++));
    }, [n]),
    e ? `radix-${e}` : ""
  );
}
var xE = "Collapsible",
  [Zce, rV] = Pr(xE),
  [Jce, bL] = Zce(xE),
  iV = E.forwardRef((n, e) => {
    const {
        __scopeCollapsible: t,
        open: s,
        defaultOpen: r,
        disabled: i,
        onOpenChange: a,
        ...o
      } = n,
      [l, c] = ci({ prop: s, defaultProp: r ?? !1, onChange: a, caller: xE });
    return u.jsx(Jce, {
      scope: t,
      disabled: i,
      contentId: $r(),
      open: l,
      onOpenToggle: E.useCallback(() => c((h) => !h), [c]),
      children: u.jsx(Et.div, {
        "data-state": wL(l),
        "data-disabled": i ? "" : void 0,
        ...o,
        ref: e,
      }),
    });
  });
iV.displayName = xE;
var aV = "CollapsibleTrigger",
  oV = E.forwardRef((n, e) => {
    const { __scopeCollapsible: t, ...s } = n,
      r = bL(aV, t);
    return u.jsx(Et.button, {
      type: "button",
      "aria-controls": r.contentId,
      "aria-expanded": r.open || !1,
      "data-state": wL(r.open),
      "data-disabled": r.disabled ? "" : void 0,
      disabled: r.disabled,
      ...s,
      ref: e,
      onClick: qe(n.onClick, r.onOpenToggle),
    });
  });
oV.displayName = aV;
var xL = "CollapsibleContent",
  lV = E.forwardRef((n, e) => {
    const { forceMount: t, ...s } = n,
      r = bL(xL, n.__scopeCollapsible);
    return u.jsx(Pi, {
      present: t || r.open,
      children: ({ present: i }) => u.jsx(eue, { ...s, ref: e, present: i }),
    });
  });
lV.displayName = xL;
var eue = E.forwardRef((n, e) => {
  const { __scopeCollapsible: t, present: s, children: r, ...i } = n,
    a = bL(xL, t),
    [o, l] = E.useState(s),
    c = E.useRef(null),
    h = Nt(e, c),
    m = E.useRef(0),
    p = m.current,
    g = E.useRef(0),
    y = g.current,
    b = a.open || o,
    w = E.useRef(b),
    S = E.useRef(void 0);
  return (
    E.useEffect(() => {
      const A = requestAnimationFrame(() => (w.current = !1));
      return () => cancelAnimationFrame(A);
    }, []),
    ys(() => {
      const A = c.current;
      if (A) {
        (S.current = S.current || {
          transitionDuration: A.style.transitionDuration,
          animationName: A.style.animationName,
        }),
          (A.style.transitionDuration = "0s"),
          (A.style.animationName = "none");
        const _ = A.getBoundingClientRect();
        (m.current = _.height),
          (g.current = _.width),
          w.current ||
            ((A.style.transitionDuration = S.current.transitionDuration),
            (A.style.animationName = S.current.animationName)),
          l(s);
      }
    }, [a.open, s]),
    u.jsx(Et.div, {
      "data-state": wL(a.open),
      "data-disabled": a.disabled ? "" : void 0,
      id: a.contentId,
      hidden: !b,
      ...i,
      ref: h,
      style: {
        "--radix-collapsible-content-height": p ? `${p}px` : void 0,
        "--radix-collapsible-content-width": y ? `${y}px` : void 0,
        ...n.style,
      },
      children: b && r,
    })
  );
});
function wL(n) {
  return n ? "open" : "closed";
}
var tue = iV,
  nue = oV,
  sue = lV,
  rue = E.createContext(void 0);
function _v(n) {
  const e = E.useContext(rue);
  return n || e || "ltr";
}
var Ba = "Accordion",
  iue = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"],
  [EL, aue, oue] = Tv(Ba),
  [wE, XMe] = Pr(Ba, [oue, rV]),
  SL = rV(),
  cV = de.forwardRef((n, e) => {
    const { type: t, ...s } = n,
      r = s,
      i = s;
    return u.jsx(EL.Provider, {
      scope: n.__scopeAccordion,
      children:
        t === "multiple"
          ? u.jsx(due, { ...i, ref: e })
          : u.jsx(uue, { ...r, ref: e }),
    });
  });
cV.displayName = Ba;
var [uV, lue] = wE(Ba),
  [dV, cue] = wE(Ba, { collapsible: !1 }),
  uue = de.forwardRef((n, e) => {
    const {
        value: t,
        defaultValue: s,
        onValueChange: r = () => {},
        collapsible: i = !1,
        ...a
      } = n,
      [o, l] = ci({ prop: t, defaultProp: s ?? "", onChange: r, caller: Ba });
    return u.jsx(uV, {
      scope: n.__scopeAccordion,
      value: de.useMemo(() => (o ? [o] : []), [o]),
      onItemOpen: l,
      onItemClose: de.useCallback(() => i && l(""), [i, l]),
      children: u.jsx(dV, {
        scope: n.__scopeAccordion,
        collapsible: i,
        children: u.jsx(hV, { ...a, ref: e }),
      }),
    });
  }),
  due = de.forwardRef((n, e) => {
    const { value: t, defaultValue: s, onValueChange: r = () => {}, ...i } = n,
      [a, o] = ci({ prop: t, defaultProp: s ?? [], onChange: r, caller: Ba }),
      l = de.useCallback((h) => o((m = []) => [...m, h]), [o]),
      c = de.useCallback((h) => o((m = []) => m.filter((p) => p !== h)), [o]);
    return u.jsx(uV, {
      scope: n.__scopeAccordion,
      value: a,
      onItemOpen: l,
      onItemClose: c,
      children: u.jsx(dV, {
        scope: n.__scopeAccordion,
        collapsible: !0,
        children: u.jsx(hV, { ...i, ref: e }),
      }),
    });
  }),
  [hue, EE] = wE(Ba),
  hV = de.forwardRef((n, e) => {
    const {
        __scopeAccordion: t,
        disabled: s,
        dir: r,
        orientation: i = "vertical",
        ...a
      } = n,
      o = de.useRef(null),
      l = Nt(o, e),
      c = aue(t),
      m = _v(r) === "ltr",
      p = qe(n.onKeyDown, (g) => {
        if (!iue.includes(g.key)) return;
        const y = g.target,
          b = c().filter((P) => !P.ref.current?.disabled),
          w = b.findIndex((P) => P.ref.current === y),
          S = b.length;
        if (w === -1) return;
        g.preventDefault();
        let A = w;
        const _ = 0,
          R = S - 1,
          C = () => {
            (A = w + 1), A > R && (A = _);
          },
          D = () => {
            (A = w - 1), A < _ && (A = R);
          };
        switch (g.key) {
          case "Home":
            A = _;
            break;
          case "End":
            A = R;
            break;
          case "ArrowRight":
            i === "horizontal" && (m ? C() : D());
            break;
          case "ArrowDown":
            i === "vertical" && C();
            break;
          case "ArrowLeft":
            i === "horizontal" && (m ? D() : C());
            break;
          case "ArrowUp":
            i === "vertical" && D();
            break;
        }
        const L = A % S;
        b[L].ref.current?.focus();
      });
    return u.jsx(hue, {
      scope: t,
      disabled: s,
      direction: r,
      orientation: i,
      children: u.jsx(EL.Slot, {
        scope: t,
        children: u.jsx(Et.div, {
          ...a,
          "data-orientation": i,
          ref: l,
          onKeyDown: s ? void 0 : p,
        }),
      }),
    });
  }),
  Dx = "AccordionItem",
  [fue, TL] = wE(Dx),
  fV = de.forwardRef((n, e) => {
    const { __scopeAccordion: t, value: s, ...r } = n,
      i = EE(Dx, t),
      a = lue(Dx, t),
      o = SL(t),
      l = $r(),
      c = (s && a.value.includes(s)) || !1,
      h = i.disabled || n.disabled;
    return u.jsx(fue, {
      scope: t,
      open: c,
      disabled: h,
      triggerId: l,
      children: u.jsx(tue, {
        "data-orientation": i.orientation,
        "data-state": bV(c),
        ...o,
        ...r,
        ref: e,
        disabled: h,
        open: c,
        onOpenChange: (m) => {
          m ? a.onItemOpen(s) : a.onItemClose(s);
        },
      }),
    });
  });
fV.displayName = Dx;
var mV = "AccordionHeader",
  pV = de.forwardRef((n, e) => {
    const { __scopeAccordion: t, ...s } = n,
      r = EE(Ba, t),
      i = TL(mV, t);
    return u.jsx(Et.h3, {
      "data-orientation": r.orientation,
      "data-state": bV(i.open),
      "data-disabled": i.disabled ? "" : void 0,
      ...s,
      ref: e,
    });
  });
pV.displayName = mV;
var sk = "AccordionTrigger",
  gV = de.forwardRef((n, e) => {
    const { __scopeAccordion: t, ...s } = n,
      r = EE(Ba, t),
      i = TL(sk, t),
      a = cue(sk, t),
      o = SL(t);
    return u.jsx(EL.ItemSlot, {
      scope: t,
      children: u.jsx(nue, {
        "aria-disabled": (i.open && !a.collapsible) || void 0,
        "data-orientation": r.orientation,
        id: i.triggerId,
        ...o,
        ...s,
        ref: e,
      }),
    });
  });
gV.displayName = sk;
var vV = "AccordionContent",
  yV = de.forwardRef((n, e) => {
    const { __scopeAccordion: t, ...s } = n,
      r = EE(Ba, t),
      i = TL(vV, t),
      a = SL(t);
    return u.jsx(sue, {
      role: "region",
      "aria-labelledby": i.triggerId,
      "data-orientation": r.orientation,
      ...a,
      ...s,
      ref: e,
      style: {
        "--radix-accordion-content-height":
          "var(--radix-collapsible-content-height)",
        "--radix-accordion-content-width":
          "var(--radix-collapsible-content-width)",
        ...n.style,
      },
    });
  });
yV.displayName = vV;
function bV(n) {
  return n ? "open" : "closed";
}
var mue = cV,
  pue = fV,
  gue = pV,
  xV = gV,
  wV = yV;
const vue = mue,
  EV = E.forwardRef(({ className: n, ...e }, t) =>
    u.jsx(pue, { ref: t, className: Le("border-b border-border", n), ...e })
  );
EV.displayName = "AccordionItem";
const SV = E.forwardRef(({ className: n, children: e, ...t }, s) =>
  u.jsx(gue, {
    className: "flex",
    children: u.jsxs(xV, {
      ref: s,
      className: Le(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        n
      ),
      ...t,
      children: [
        e,
        u.jsx(cd, {
          className: "h-4 w-4 shrink-0 transition-transform duration-200",
        }),
      ],
    }),
  })
);
SV.displayName = xV.displayName;
const TV = E.forwardRef(({ className: n, children: e, ...t }, s) =>
  u.jsx(wV, {
    ref: s,
    className:
      "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...t,
    children: u.jsx("div", { className: Le("pb-4 pt-0", n), children: e }),
  })
);
TV.displayName = wV.displayName;
const yue = {
    Product: [
      {
        question: "Is the free plan truly unlimited?",
        answer:
          "Yes, on the free plan you can use Flask, including all the recording features, tagging and AI summarization. Just upload your videos to YouTube either as public or unlisted and drop the link in Flask.",
      },
      {
        question: "How does the YouTube video support work?",
        answer:
          "Flask supports both YouTube videos (both with visibility 'Public' and 'Unlisted') and uploading videos from your device (for Pro users). The product and all the commenting features work in the exact same way for both. You can not only annotate public videos (e.g. for breakdowns or references), but also private ones, without any limitations on storage space.",
      },
      {
        question: "Can anyone add comments and recordings in a Flask?",
        answer:
          "Yes. When you create a Flask, if it's set to 'Anyone with link can edit' (default option) anyone can just quickly sign in with Google and add comments and recordings to the Flask. No subscription required and no limit on number of people collaborating.",
      },
      {
        question:
          "Can I have a shared space with my team where we share and organize Flasks?",
        answer:
          "Yes. When you activate a Pro subscription a Pro team is created. You can invite others in that team with an invite link: you will then have a shared space with all your team's Flasks in one place and every user will be able to upload videos from device as well as from YouTube.",
      },
      {
        question: "Is Flask's AI processing my video?",
        answer:
          "No. Only recordings (Thoughts recordings or Screen recordings) on the canvas are analyzed by AI to extract insights.",
      },
    ],
    "Billing & Pricing": [
      {
        question: "Is there a monthly payment option?",
        answer:
          "No. We offer a yearly plan with a 30 day satisfaction guarantee, meaning you get a full refund if you are not happy with the product for any reason.",
      },
      {
        question: "How does per-seat pricing work?",
        answer:
          "When you create a Pro team, you get added to that team (1 seat). Once team members join the team via invite link, a seat is added to your subscription. We prorate the charge for these seats for the remainder of your billing period.",
      },
      {
        question: "Can I change my billing period?",
        answer:
          "Yes! You can switch between monthly and yearly billing anytime. When switching to yearly, you'll be charged the prorated amount immediately. When switching to monthly, the change takes effect at the end of your current period.",
      },
      {
        question: "What happens if I remove team members?",
        answer:
          "When you remove team members, you'll receive a prorated credit on your next invoice for the unused time.",
      },
      {
        question: "Can I cancel anytime?",
        answer:
          "Yes, you can cancel your Flask Pro subscription at any time. Just click on 'Manage Subscription' in your Pro team settings. Your team will continue to have Pro features until the end of your current billing period.",
      },
      {
        question:
          "If I am not happy, can I ask for a refund on my Pro subscription?",
        answer:
          "Yes. If you are not happy for any reason with Flask Pro you can ask for a refund within 30 days of purchase. You will be refunded the full amount paid and Pro team will be deleted.",
      },
      {
        question: "How does the Top 1% deal work?",
        answer:
          "The Top 1% of teams whose Flasks have been viewed by the most unique people (legitimately), at the end of the year will get their next year on Flask Pro completely for free",
      },
    ],
    Team: [
      {
        question: "How do team invites work?",
        answer:
          "As a team owner, you can invite unlimited members to your Pro team. Each member will have their own account and can create and share flasks within the team workspace. You can also remove team members at any time.",
      },
    ],
  },
  bue = () => {
    const [n, e] = E.useState(void 0);
    return (
      E.useEffect(() => {
        const t = () => {
          const s = window.location.hash.slice(1);
          s.startsWith("faq-") &&
            (e(s),
            setTimeout(() => {
              const r = document.getElementById(s);
              r && r.scrollIntoView({ behavior: "smooth", block: "center" });
            }, 100));
        };
        return (
          t(),
          window.addEventListener("hashchange", t),
          () => window.removeEventListener("hashchange", t)
        );
      }, []),
      u.jsxs("div", {
        className: "w-full",
        children: [
          u.jsx("h2", {
            className:
              "text-3xl font-semibold text-white text-center pb-12 tracking-tight",
            children: "FAQ",
          }),
          u.jsx(vue, {
            type: "single",
            collapsible: !0,
            className: "w-full",
            value: n,
            onValueChange: e,
            children: Object.entries(yue).map(([t, s], r) =>
              u.jsxs(
                de.Fragment,
                {
                  children: [
                    u.jsx("div", {
                      className: "mb-4 mt-8 first:mt-0",
                      children: u.jsx("p", {
                        className:
                          "text-text-secondary text-xs uppercase tracking-wider",
                        children: t,
                      }),
                    }),
                    s.map((i, a) =>
                      u.jsxs(
                        EV,
                        {
                          value: `faq-${r}-${a}`,
                          id: `faq-${r}-${a}`,
                          className: "border-border/50",
                          children: [
                            u.jsx(SV, {
                              className:
                                "text-white hover:text-white/90 text-left",
                              children: i.question,
                            }),
                            u.jsx(TV, {
                              className: "text-text-secondary",
                              children: i.answer,
                            }),
                          ],
                        },
                        `${r}-${a}`
                      )
                    ),
                  ],
                },
                t
              )
            ),
          }),
        ],
      })
    );
  },
  xue = () =>
    u.jsxs("div", {
      id: "contact",
      className: "w-full  py-12 pt-24",
      children: [
        u.jsx("h2", {
          className:
            "text-3xl font-semibold text-white text-center pb-16 tracking-tight",
          children: "Talk to Humans",
        }),
        u.jsxs("div", {
          className: "flex flex-col items-center gap-4",
          children: [
            u.jsxs("p", {
              className: "text-sm text-text-primary mb-8 text-center px-4",
              children: [
                "For questions, bugs, support or feedback",
                " ",
                u.jsx("span", {
                  className: "text-text-secondary",
                  children: "(or to send us memes)",
                }),
                ", get in touch with us:",
              ],
            }),
            u.jsxs("div", {
              className:
                "flex flex-col md:flex-row justify-center gap-4 md:gap-6 w-full md:w-auto px-4 md:px-0",
              children: [
                u.jsx(et, {
                  size: "lg",
                  className:
                    "button-secondary rounded-full flex items-center justify-center gap-3 px-6 md:px-8 py-3 md:py-4 h-auto w-full md:w-auto",
                  asChild: !0,
                  children: u.jsxs("a", {
                    href: "mailto:hello@flask.to",
                    children: [
                      u.jsx(MH, { className: "w-5 h-5" }),
                      "hello@flask.to",
                    ],
                  }),
                }),
                u.jsx(et, {
                  size: "lg",
                  className:
                    "flex items-center button-secondary rounded-full justify-center gap-3 px-6 md:px-8 py-3 md:py-4 h-auto w-full md:w-auto",
                  asChild: !0,
                  children: u.jsxs("a", {
                    href: "https://discord.gg/Qpq3ySHkKQ",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: [
                      u.jsx("img", {
                        src: "/svgs/discord.svg",
                        alt: "Discord",
                        className: "w-5 h-5 opacity-70",
                      }),
                      "Community",
                    ],
                  }),
                }),
                u.jsx(et, {
                  size: "lg",
                  className:
                    "flex items-center button-secondary rounded-full justify-center gap-3 px-6 md:px-8 py-3 md:py-4 h-auto w-full md:w-auto",
                  asChild: !0,
                  children: u.jsxs("a", {
                    href: "https://enritarta.notion.site/286abb4f34b78017ade3caa106f9ca9f?pvs=105",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    children: [u.jsx(vle, { className: "w-5 h-5" }), "Support"],
                  }),
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  lh = [
    {
      id: "tommy",
      quote: "It's Notion meets Loom, but for video collaboration",
      name: "Tommy Geoco",
      title: "Product Designer, Content Creator",
      personalUrl: "https://www.youtube.com/@designertom",
      image: "/images/testimonials/tommy.jpg",
      imageAlt: "Tommy Geoco",
    },
    {
      id: "fabrizio",
      quote:
        "We work on dozens of complex creative projects with all sorts of clients, Flask has been a lifesaver",
      name: "Fabrizio San Biagio",
      title: "CEO",
      company: "Seequence Studio",
      companyUrl: "https://www.seequencestudio.com/",
      image: "/images/testimonials/seequence.png",
      imageAlt: "Fabrizio San Biagio",
    },
    {
      id: "simone",
      quote:
        "We used Frame.io with my team, now I cannot even fathom going back. Flask is crazy.",
      name: "@sferro21",
      title: "Content Creator, 570k followers",
      personalUrl: "https://instagram.com/simone.ferretti",
      image: "/images/testimonials/simo.jpg",
      imageAlt: "Simone Ferretti",
    },
    {
      id: "eric",
      quote:
        "Flask completely changes how I collaborate with our team. It adds a new layer to creative communication I didn't know existed",
      name: "Eric Villa",
      title: "Producer",
      company: "MKBHD & The Studio",
      companyUrl: "https://www.youtube.com/@mkbhd",
      image: "/images/testimonials/mkbhd.png",
      imageAlt: "Eric Villa",
    },
    {
      id: "pedro",
      quote: "Flask is modernising video collaboration and I'm here for it!",
      name: "Pedro Duarte",
      title: "Head of Hype",
      company: "Raycast",
      companyUrl: "https://raycast.com",
      image: "/images/testimonials/raycast.png",
      imageAlt: "Pedro Duarte",
    },
  ],
  lp = ({ testimonial: n, className: e = "", isCompact: t = !1 }) => {
    const s = n.personalUrl || n.companyUrl;
    return u.jsxs("div", {
      className: Le(
        "relative bg-element-background border-t border-text-primary/30 rounded-3xl flex flex-col overflow-hidden h-full",
        e
      ),
      children: [
        u.jsx("div", {
          className: "absolute inset-0 bg-element-background z-0",
        }),
        u.jsxs("div", {
          className: "absolute inset-0 flex z-10",
          children: [
            u.jsx("div", { className: "flex-1" }),
            u.jsxs("div", {
              className: "relative opacity-70 transition-all duration-200",
              children: [
                u.jsx("img", {
                  src: n.image,
                  alt: n.imageAlt,
                  className: "h-full w-auto object-cover",
                }),
                u.jsx("div", {
                  className:
                    "absolute inset-0 bg-gradient-to-r from-element-background to-transparent",
                }),
              ],
            }),
          ],
        }),
        !t &&
          u.jsx("div", {
            className:
              "absolute top-0 left-0 right-0 h-[20%] bg-gradient-to-b from-element-background to-transparent z-20",
          }),
        u.jsxs("div", {
          className: "relative z-30 p-6 flex flex-col h-full",
          children: [
            u.jsxs("blockquote", {
              className:
                "text-sm text-foreground mb-4 flex-1 pr-[40%] leading-relaxed",
              children: ['"', n.quote, '"'],
            }),
            u.jsxs("div", {
              className: "mt-auto",
              children: [
                u.jsx("div", {
                  className: "text-sm font-medium text-foreground",
                  children:
                    (n.id === "simone" || n.id === "tommy") && s
                      ? u.jsx("a", {
                          href: s,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className: "underline",
                          children: n.name,
                        })
                      : n.name,
                }),
                u.jsxs("div", {
                  className: "text-xs text-text-primary/80 mt-1",
                  children: [
                    n.title,
                    n.company &&
                      u.jsxs(u.Fragment, {
                        children: [
                          n.title && ", ",
                          s
                            ? u.jsx("a", {
                                href: s,
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "underline",
                                children: n.company,
                              })
                            : n.company,
                        ],
                      }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    });
  },
  wue = ({ compact: n = !1, className: e }) => {
    const [t, s] = E.useState(0),
      [r, i] = E.useState(!0);
    return (
      E.useEffect(() => {
        if (!n || !r) return;
        const a = setInterval(() => {
          s((o) => (o + 1) % lh.length);
        }, 4e3);
        return () => clearInterval(a);
      }, [n, r]),
      u.jsx("div", {
        className: Le(
          "relative w-full items-center justify-center max-w-4xl mx-auto flex flex-col min-h-[900px]",
          e
        ),
        children: u.jsxs("div", {
          className:
            "relative flex flex-col md:grid md:grid-cols-2 gap-8 w-full h-full md:-mt-10 md:py-16 px-4 md:px-16",
          children: [
            u.jsxs("div", {
              className: "flex flex-col gap-8 items-stretch md:items-start",
              children: [
                u.jsx("div", {
                  className: "w-full md:w-80",
                  children: u.jsx(lp, {
                    testimonial: lh.find((a) => a.id === "eric"),
                    className: "w-full",
                  }),
                }),
                u.jsx("div", {
                  className: "w-full md:w-80 md:mt-8",
                  children: u.jsx(lp, {
                    testimonial: lh.find((a) => a.id === "tommy"),
                    className: "w-full",
                  }),
                }),
                u.jsx("div", {
                  className: "w-full md:w-80 md:mt-8",
                  children: u.jsx(lp, {
                    testimonial: lh.find((a) => a.id === "simone"),
                    className: "w-full",
                  }),
                }),
              ],
            }),
            u.jsxs("div", {
              className: "flex flex-col gap-8 items-stretch md:items-end",
              children: [
                u.jsx("div", {
                  className: "w-full md:w-80 md:mt-16",
                  children: u.jsx(lp, {
                    testimonial: lh.find((a) => a.id === "pedro"),
                    className: "w-full",
                  }),
                }),
                u.jsx("div", {
                  className: "w-full md:w-80 md:mt-8",
                  children: u.jsx(lp, {
                    testimonial: lh.find((a) => a.id === "fabrizio"),
                    className: "w-full",
                  }),
                }),
              ],
            }),
          ],
        }),
      })
    );
  },
  Eue = E.lazy(() =>
    Lt(() => Promise.resolve().then(() => hMe), void 0).then(
      (n) =>
        new Promise((e) => {
          requestAnimationFrame(() => e(n));
        })
    )
  ),
  Sue = ({ onLoad: n, children: e }) => (
    E.useEffect(() => {
      n();
    }, [n]),
    u.jsx(u.Fragment, { children: e })
  ),
  Tue = de.memo(function () {
    const e = es(),
      [t, s] = E.useState(1),
      [r, i] = E.useState(2),
      [a, o] = E.useState(0.3),
      [l, c] = E.useState(-20),
      [h, m] = E.useState(!1);
    E.useEffect(() => {
      const g = () => {
        const y = window.scrollY,
          b = window.innerHeight,
          w = 0,
          S = b * 0.5;
        if (y <= w) s(1);
        else if (y >= S) s(0);
        else {
          const R = (y - w) / (S - w);
          s(1 - R);
        }
        const A = b * 0.5,
          _ = b * 0.75;
        if (y <= A) i(2), o(0.3), c(-20);
        else if (y < _) {
          const R = (y - A) / (_ - A);
          i(2 * (1 - R)), o(0.3 * (1 - R)), c(-20);
        } else {
          i(0), o(0);
          const R = b;
          if (y >= R) c(0);
          else {
            const C = (y - _) / (R - _);
            c(-20 * (1 - C));
          }
        }
      };
      return (
        window.addEventListener("scroll", g),
        () => window.removeEventListener("scroll", g)
      );
    }, []);
    const p = {
      "@context": "https://schema.org",
      "@graph": [Nce(), Oce(), jce(), Fce(), Uce()],
    };
    return u.jsxs("div", {
      className: "min-h-screen text-foreground",
      children: [
        u.jsx(sV, {
          title: "Flask - Video Collaboration for Creative Teams",
          description:
            "Next-gen video collaboration tool for creative teams. Record in-depth feedback, add any reference on your screen, and let AI extract what matters. Tag, filter, and organize comments on a visual canvas.",
          canonical: "/",
          ogImage: "/images/OpenGraphImage.png",
          structuredData: p,
          keywords:
            "video collaboration, creative feedback, flask do, do flask, flask . do, video review, team collaboration, creative tools, video annotation, screen recording, AI feedback, visual feedback, creative workflow, design feedback, video comments, creative teams, visual canvas, tagging system",
        }),
        u.jsx("div", {
          style: { opacity: t, transition: "opacity 0.1s ease-out " },
        }),
        u.jsx(Ace, {}),
        u.jsx(Mce, {}),
        u.jsxs("main", {
          className: "relative flex flex-col items-center",
          style: { zIndex: 1 },
          children: [
            u.jsxs("div", {
              className:
                "flex flex-col w-full max-w-7xl md:pt-24 px-4 md:px-12 relative justify-between",
              style: { minHeight: "calc(100vh - 96px)" },
              children: [
                u.jsx("div", {
                  className: "flex-1 md:flex-1",
                  style: { maxHeight: "150px", minHeight: "20px" },
                }),
                u.jsxs("div", {
                  className:
                    "flex flex-col items-center space-y-6 md:space-y-8 text-center w-full",
                  children: [
                    u.jsx("div", {
                      className:
                        "w-full 2xl:max-w-6xl lg:max-w-4xl shadow-2xl shadow-black/50 border-t border-text-primary/30 rounded-[32px] p-2 bg-element-background z-10 relative",
                      children: u.jsx("div", {
                        className: "relative w-full",
                        style: { paddingBottom: "56.25%" },
                        children: u.jsx("video", {
                          className:
                            "absolute top-0 left-0 w-full h-full rounded-3xl",
                          src: "https://github.com/ibxprofiletest/flask.to/raw/refs/heads/master/assets/Introducing%20Flask%20(Notion%20+%20Loom%20for%20video).mp4",
                          title: "Flask Demo Video",
                          frameBorder: "0",
                          controls: true,
                          autoplay : false,
                        }),
                      }),
                    }),
                    u.jsxs("div", {
                      className:
                        "space-y-2 flex flex-col items-center relative z-20",
                      children: [
                        u.jsx("h1", {
                          className:
                            "text-3xl leading-tight tracking-tight md:leading-none ",
                          style: {
                            color: "#FFFFFF",
                            textShadow: "0 4px 8px rgba(0, 0, 0, 0.4)",
                          },
                          children:
                            "Video collaboration, built for how creatives actually work",
                        }),
                        u.jsx("h3", {
                          className:
                            "text-lg md:text-md  tracking-tight leading-7 text-text-primary/90 md:leading-10",
                          style: {
                            textShadow:
                              "0 4px 8px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.6)",
                          },
                          children: "Notion + Loom, but for videos",
                        }),
                      ],
                    }),
                  ],
                }),
                u.jsxs("div", {
                  className:
                    "flex-1 flex flex-col items-center justify-center relative z-10 mb-6 md:mt-0",
                  style: { minHeight: "20px" },
                  children: [
                    u.jsxs(et, {
                      onClick: () => e("/dash"),
                      className:
                        "group rounded-full flex items-center gap-3 px-12 py-6 w-auto button-primary font-semibold text-md cursor-pointer shadow-xl hover:shadow-xl transition-all duration-200",
                      children: [
                        u.jsx("span", { children: "Get Started " }),
                        u.jsx(yE, {
                          className:
                            "group-hover:translate-x-2 transition-transform duration-200",
                        }),
                      ],
                    }),
                    u.jsx(et, {
                      onClick: () =>
                        window.open(
                          "https://cal.com/enricotartarotti/flask-20?overlayCalendar=true",
                          "_blank"
                        ),
                      className:
                        "group rounded-full flex items-center gap-3 px-6 py-3 w-auto button-secondary mt-3 text-sm cursor-pointer shadow-xl hover:shadow-xl transition-all duration-200",
                      children: u.jsx("span", { children: "Book a Demo " }),
                    }),
                  ],
                }),
              ],
            }),
            u.jsx("div", {
              className: "w-full flex justify-center mt-24",
              style: { overflow: "visible", position: "relative", zIndex: 0 },
              children: u.jsxs("div", {
                className: "relative",
                children: [
                  " ",
                  u.jsx("div", {
                    style: {
                      position: "absolute",
                      bottom: "100%",
                      left: "50%",
                      transform: "translateX(-50%)",
                      width: "100vw",
                      height: "200vh",
                      pointerEvents: "none",
                      zIndex: 1,
                      isolation: "isolate",
                      opacity: h ? 1 : 0,
                      transition: "opacity 1.5s ease-in",
                    },
                    children: u.jsx(E.Suspense, {
                      fallback: null,
                      children: u.jsx(Sue, {
                        onLoad: () => m(!0),
                        children: u.jsx(Eue, {
                          raysOrigin: "bottom-center",
                          raysSpeed: 0.25,
                          lightSpread: 7,
                          opacity: 1,
                          saturation: 2,
                          rayLength: r,
                          followMouse: !1,
                          mouseInfluence: 0,
                          distortion: 0.1,
                          distortionPhase: a,
                          className: "custom-rays",
                          gradientColors: [
                            "#D15DFF",
                            "#F78264",
                            "#EFD7A4",
                            "#CFDEF6",
                          ],
                          gradientStops: [0, 0.25, 0.5, 1],
                          gradientScale: 0.1,
                          noiseAmount: 0.2,
                          gradientOpacity: 1,
                        }),
                      }),
                    }),
                  }),
                  u.jsx("div", {
                    style: {
                      position: "absolute",
                      top: "50px",
                      left: "50%",
                      transform: "translateX(-50%)",
                      width: "100vw",
                      zIndex: 0,
                      pointerEvents: "none",
                    },
                  }),
                  u.jsx("img", {
                    src: "/images/flasklogo.png",
                    alt: "Flask",
                    className: "w-40 h-40 object-contain -mt-4",
                    style: {
                      transform: `rotate(${l}deg)`,
                      zIndex: 0,
                      position: "relative",
                      transition: "transform 0.1s ease-out",
                    },
                  }),
                ],
              }),
            }),
            u.jsxs("div", {
              className:
                "w-full flex flex-col items-center justify-center mt-16 mb-8 px-4",
              children: [
                u.jsx("div", {
                  className: "mb-10",
                  children: u.jsx("a", {
                    href: "https://www.producthunt.com/products/flask-6/launches/flask-4",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "block",
                    children: u.jsx("img", {
                      src: "/svgs/award.svg",
                      alt: "Flask - Product of the Month",
                      className:
                        "w-full px-8 md:w-[400px] h-auto  transition-opacity duration-200 hover:opacity-80",
                    }),
                  }),
                }),
                u.jsxs("div", {
                  className:
                    "flex flex-col md:flex-row gap-4 md:gap-6 items-center justify-center",
                  children: [
                    u.jsx("a", {
                      href: "https://www.producthunt.com/products/flask-6/launches/flask-4",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      className: "block",
                      children: u.jsx("img", {
                        src: "/svgs/award2.svg",
                        alt: "Flask - Product of the Month #1 Artificial Intelligence",
                        className:
                          "w-full px-12 md:w-[320px] h-auto transition-opacity duration-200 hover:opacity-80",
                      }),
                    }),
                    u.jsx("a", {
                      href: "https://www.producthunt.com/products/flask-6/launches/flask-4",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      className: "block",
                      children: u.jsx("img", {
                        src: "/svgs/award3.svg",
                        alt: "Flask - Product of the Month #1 Design Tools",
                        className:
                          "w-full px-12 md:w-[320px] h-auto transition-opacity duration-200 hover:opacity-80",
                      }),
                    }),
                  ],
                }),
              ],
            }),
            u.jsx("div", {
              className: "w-full px-4  relative",
              style: { zIndex: 1 },
              children: u.jsx(wue, {}),
            }),
            u.jsx("div", {
              id: "features",
              className: "w-full max-w-6xl mb-24 px-4 md:px-8 ",
              children: u.jsxs("div", {
                className: " p-8 md:p-12 space-y-8 ",
                children: [
                  u.jsxs("div", {
                    className: "flex flex-col md:flex-row gap-8 items-center",
                    children: [
                      u.jsxs("div", {
                        className: "flex-1 space-y-4",
                        children: [
                          u.jsx("h2", {
                            className:
                              "text-2xl font-semibold text-white tracking-tight",
                            children: u.jsx("div", {
                              className: "flex",
                              children: "Show, don't type.",
                            }),
                          }),
                          u.jsx("ul", {
                            className: "space-y-3 text-md",
                            children: u.jsx("li", {
                              className: "text-text-secondary",
                              children:
                                "Record your feedback and share any reference on your screen. Watch Flask turn your 5-minute ramble into 3 clear tasks",
                            }),
                          }),
                        ],
                      }),
                      u.jsx("div", {
                        className: "flex-1",
                        children: u.jsx("img", {
                          src: "/images/showdonttell.png",
                          alt: "Show don't tell - Flask video feedback",
                          className: "w-full h-auto rounded-xl",
                        }),
                      }),
                    ],
                  }),
                  u.jsxs("div", {
                    className:
                      "flex flex-col md:flex-row-reverse gap-8 items-center",
                    children: [
                      u.jsxs("div", {
                        className: "flex-1 space-y-4",
                        children: [
                          u.jsx("h2", {
                            className:
                              "text-2xl font-semibold text-white tracking-tight",
                            children: "Free, unlimited video collaboration .",
                          }),
                          u.jsxs("ul", {
                            className: "space-y-3 text-md",
                            children: [
                              u.jsx("li", {
                                className: "text-text-secondary",
                                children:
                                  "Unlimited videos, unlimited feedback,for free using YouTube.",
                              }),
                              u.jsx("li", {
                                className: "text-text-secondary",
                                children:
                                  "For creative teams, Flask Pro gives you shared workspaces and uploads directly to Flask.",
                              }),
                            ],
                          }),
                        ],
                      }),
                      u.jsx("div", {
                        className: "flex-1 flex justify-end items-center",
                        children: u.jsx("div", {
                          className: " bg-zinc-700 rounded-xl  overflow-hidden",
                          children: u.jsx("img", {
                            src: "/images/freepro.jpg",
                            alt: "Free unlimited collaboration",
                            className: "w-full h-full object-cover",
                          }),
                        }),
                      }),
                    ],
                  }),
                  u.jsxs("div", {
                    className: "flex flex-col md:flex-row gap-8 items-center",
                    children: [
                      u.jsxs("div", {
                        className: "flex-1 space-y-4",
                        children: [
                          u.jsx("h2", {
                            className:
                              "text-2xl font-semibold text-white tracking-tight",
                            children: "Tag, filter, and organize.",
                          }),
                          u.jsx("ul", {
                            className: "space-y-3 text-md",
                            children: u.jsx("li", {
                              className: "text-text-secondary",
                              children:
                                "Create custom tags, filter what's shown, build the system that works for you.",
                            }),
                          }),
                        ],
                      }),
                      u.jsx("div", {
                        className: "flex-1",
                        children: u.jsx("img", {
                          src: "/images/Tag-preview.png",
                          alt: "Tag, filter, and organize - Flask tagging system",
                          className: "w-full h-auto rounded-xl",
                        }),
                      }),
                    ],
                  }),
                ],
              }),
            }),
            u.jsx("div", {
              id: "pricing",
              className: "w-full max-w-5xl px-4 md:px-8 ",
              children: u.jsxs("div", {
                className: "bg-card-background  rounded-3xl p-8 ",
                children: [
                  u.jsx("h2", {
                    className:
                      "text-3xl font-semibold text-white text-center pb-16 tracking-tight",
                    children: "Pricing",
                  }),
                  u.jsx(Dce, {}),
                ],
              }),
            }),
            u.jsx("div", {
              id: "faq",
              className: "w-full max-w-3xl mx-auto mt-16 px-4 md:px-0",
              children: u.jsx(bue, {}),
            }),
            u.jsx("div", {
              id: "talk-to-us",
              className:
                "w-full max-w-5xl mx-auto  px-4 md:px-0 mb-24 md:mb-24",
              children: u.jsx(xue, {}),
            }),
            u.jsxs("div", {
              className: "w-full max-w-4xl mx-auto mb-24 px-4 md:px-8",
              children: [
                u.jsx("div", {
                  className: "flex flex-col items-center text-left",
                  children: u.jsxs("p", {
                    className: "text-text-primary text-2xl",
                    style: { fontFamily: "'Reenie Beanie'" },
                    children: [
                      "I built Flask because as a video creative, I hated working with my team. ",
                      u.jsx("br", {}),
                      " ",
                      u.jsx("br", {}),
                      "Not because they weren't good, but because the tools to do it sucked.  ",
                      u.jsx("br", {}),
                      " ",
                      u.jsx("br", {}),
                      "Creativity and taste cannot be typed: they are complex and nuanced, and no tool on the market seems to realize this. ",
                      u.jsx("br", {}),
                      u.jsx("br", {}),
                      "Flask is the best creative collaboration tool I've ever used",
                      u.jsx("br", {}),
                      u.jsx("br", {}),
                      "My job is for it to become yours as well.",
                      u.jsx("br", {}),
                      u.jsx("br", {}),
                      "- Enrico, Founder",
                    ],
                  }),
                }),
                u.jsx("div", {
                  className: "flex justify-center mt-12",
                  children: u.jsx(et, {
                    size: "lg",
                    className:
                      "button-secondary rounded-full flex items-start gap-3 px-8 py-4 h-auto",
                    asChild: !0,
                    children: u.jsx("a", {
                      href: "/manifesto",
                      children: "Manifesto ",
                    }),
                  }),
                }),
              ],
            }),
          ],
        }),
        u.jsx(nV, {}),
      ],
    });
  }),
  _ue = de.memo(function () {
    return u.jsx(E.Suspense, {
      fallback: u.jsx("div", { className: "min-h-screen" }),
      children: u.jsx(Tue, {}),
    });
  });
function Sf(n) {
  if (!n) return null;
  const e = [
    /(?:youtube\.com\/watch\?v=|youtube\.com\/embed\/|youtube\.com\/v\/|youtu\.be\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/,
  ];
  for (const t of e) {
    const s = n.match(t);
    if (s && s[1]) return s[1];
  }
  return null;
}
const Aue = async (n) => {
  if (!Sf(n))
    return (
      Xe.error("Invalid YouTube URL"),
      { valid: !1, error: "Invalid YouTube URL" }
    );
  try {
    const t = await Ut("/api/youtube/validate", {
        method: "POST",
        body: JSON.stringify({ url: n }),
      }),
      s = await t.json();
    return !t.ok || !s.valid
      ? (Xe.error(s.error || "Video not found or unavailable"),
        { valid: !1, error: s.error || "Video not found or unavailable" })
      : {
          valid: !0,
          title: s.title,
          videoId: s.videoId,
          duration: s.duration,
          channelTitle: s.channelTitle,
          thumbnail: s.thumbnail,
        };
  } catch (t) {
    return (
      console.error("Error validating YouTube URL:", t),
      Xe.error("Failed to validate YouTube URL"),
      { valid: !1, error: "Failed to validate YouTube URL" }
    );
  }
};
function Rue(n, e = globalThis?.document) {
  const t = ua(n);
  E.useEffect(() => {
    const s = (r) => {
      r.key === "Escape" && t(r);
    };
    return (
      e.addEventListener("keydown", s, { capture: !0 }),
      () => e.removeEventListener("keydown", s, { capture: !0 })
    );
  }, [t, e]);
}
var kue = "DismissableLayer",
  rk = "dismissableLayer.update",
  Cue = "dismissableLayer.pointerDownOutside",
  Iue = "dismissableLayer.focusOutside",
  jU,
  _V = E.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  Bf = E.forwardRef((n, e) => {
    const {
        disableOutsidePointerEvents: t = !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: r,
        onFocusOutside: i,
        onInteractOutside: a,
        onDismiss: o,
        ...l
      } = n,
      c = E.useContext(_V),
      [h, m] = E.useState(null),
      p = h?.ownerDocument ?? globalThis?.document,
      [, g] = E.useState({}),
      y = Nt(e, (L) => m(L)),
      b = Array.from(c.layers),
      [w] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      S = b.indexOf(w),
      A = h ? b.indexOf(h) : -1,
      _ = c.layersWithOutsidePointerEventsDisabled.size > 0,
      R = A >= S,
      C = Pue((L) => {
        const P = L.target,
          V = [...c.branches].some((N) => N.contains(P));
        !R || V || (r?.(L), a?.(L), L.defaultPrevented || o?.());
      }, p),
      D = Mue((L) => {
        const P = L.target;
        [...c.branches].some((N) => N.contains(P)) ||
          (i?.(L), a?.(L), L.defaultPrevented || o?.());
      }, p);
    return (
      Rue((L) => {
        A === c.layers.size - 1 &&
          (s?.(L), !L.defaultPrevented && o && (L.preventDefault(), o()));
      }, p),
      E.useEffect(() => {
        if (h)
          return (
            t &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((jU = p.body.style.pointerEvents),
                (p.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(h)),
            c.layers.add(h),
            FU(),
            () => {
              t &&
                c.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = jU);
            }
          );
      }, [h, p, t, c]),
      E.useEffect(
        () => () => {
          h &&
            (c.layers.delete(h),
            c.layersWithOutsidePointerEventsDisabled.delete(h),
            FU());
        },
        [h, c]
      ),
      E.useEffect(() => {
        const L = () => g({});
        return (
          document.addEventListener(rk, L),
          () => document.removeEventListener(rk, L)
        );
      }, []),
      u.jsx(Et.div, {
        ...l,
        ref: y,
        style: {
          pointerEvents: _ ? (R ? "auto" : "none") : void 0,
          ...n.style,
        },
        onFocusCapture: qe(n.onFocusCapture, D.onFocusCapture),
        onBlurCapture: qe(n.onBlurCapture, D.onBlurCapture),
        onPointerDownCapture: qe(
          n.onPointerDownCapture,
          C.onPointerDownCapture
        ),
      })
    );
  });
Bf.displayName = kue;
var Lue = "DismissableLayerBranch",
  Due = E.forwardRef((n, e) => {
    const t = E.useContext(_V),
      s = E.useRef(null),
      r = Nt(e, s);
    return (
      E.useEffect(() => {
        const i = s.current;
        if (i)
          return (
            t.branches.add(i),
            () => {
              t.branches.delete(i);
            }
          );
      }, [t.branches]),
      u.jsx(Et.div, { ...n, ref: r })
    );
  });
Due.displayName = Lue;
function Pue(n, e = globalThis?.document) {
  const t = ua(n),
    s = E.useRef(!1),
    r = E.useRef(() => {});
  return (
    E.useEffect(() => {
      const i = (o) => {
          if (o.target && !s.current) {
            let l = function () {
              AV(Cue, t, c, { discrete: !0 });
            };
            const c = { originalEvent: o };
            o.pointerType === "touch"
              ? (e.removeEventListener("click", r.current),
                (r.current = l),
                e.addEventListener("click", r.current, { once: !0 }))
              : l();
          } else e.removeEventListener("click", r.current);
          s.current = !1;
        },
        a = window.setTimeout(() => {
          e.addEventListener("pointerdown", i);
        }, 0);
      return () => {
        window.clearTimeout(a),
          e.removeEventListener("pointerdown", i),
          e.removeEventListener("click", r.current);
      };
    }, [e, t]),
    { onPointerDownCapture: () => (s.current = !0) }
  );
}
function Mue(n, e = globalThis?.document) {
  const t = ua(n),
    s = E.useRef(!1);
  return (
    E.useEffect(() => {
      const r = (i) => {
        i.target &&
          !s.current &&
          AV(Iue, t, { originalEvent: i }, { discrete: !1 });
      };
      return (
        e.addEventListener("focusin", r),
        () => e.removeEventListener("focusin", r)
      );
    }, [e, t]),
    {
      onFocusCapture: () => (s.current = !0),
      onBlurCapture: () => (s.current = !1),
    }
  );
}
function FU() {
  const n = new CustomEvent(rk);
  document.dispatchEvent(n);
}
function AV(n, e, t, { discrete: s }) {
  const r = t.originalEvent.target,
    i = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t });
  e && r.addEventListener(n, e, { once: !0 }),
    s ? UH(r, i) : r.dispatchEvent(i);
}
var x1 = "focusScope.autoFocusOnMount",
  w1 = "focusScope.autoFocusOnUnmount",
  UU = { bubbles: !1, cancelable: !0 },
  Nue = "FocusScope",
  Av = E.forwardRef((n, e) => {
    const {
        loop: t = !1,
        trapped: s = !1,
        onMountAutoFocus: r,
        onUnmountAutoFocus: i,
        ...a
      } = n,
      [o, l] = E.useState(null),
      c = ua(r),
      h = ua(i),
      m = E.useRef(null),
      p = Nt(e, (b) => l(b)),
      g = E.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    E.useEffect(() => {
      if (s) {
        let b = function (_) {
            if (g.paused || !o) return;
            const R = _.target;
            o.contains(R) ? (m.current = R) : fc(m.current, { select: !0 });
          },
          w = function (_) {
            if (g.paused || !o) return;
            const R = _.relatedTarget;
            R !== null && (o.contains(R) || fc(m.current, { select: !0 }));
          },
          S = function (_) {
            if (document.activeElement === document.body)
              for (const C of _) C.removedNodes.length > 0 && fc(o);
          };
        document.addEventListener("focusin", b),
          document.addEventListener("focusout", w);
        const A = new MutationObserver(S);
        return (
          o && A.observe(o, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", b),
              document.removeEventListener("focusout", w),
              A.disconnect();
          }
        );
      }
    }, [s, o, g.paused]),
      E.useEffect(() => {
        if (o) {
          BU.add(g);
          const b = document.activeElement;
          if (!o.contains(b)) {
            const S = new CustomEvent(x1, UU);
            o.addEventListener(x1, c),
              o.dispatchEvent(S),
              S.defaultPrevented ||
                (Oue(Bue(RV(o)), { select: !0 }),
                document.activeElement === b && fc(o));
          }
          return () => {
            o.removeEventListener(x1, c),
              setTimeout(() => {
                const S = new CustomEvent(w1, UU);
                o.addEventListener(w1, h),
                  o.dispatchEvent(S),
                  S.defaultPrevented || fc(b ?? document.body, { select: !0 }),
                  o.removeEventListener(w1, h),
                  BU.remove(g);
              }, 0);
          };
        }
      }, [o, c, h, g]);
    const y = E.useCallback(
      (b) => {
        if ((!t && !s) || g.paused) return;
        const w = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey,
          S = document.activeElement;
        if (w && S) {
          const A = b.currentTarget,
            [_, R] = jue(A);
          _ && R
            ? !b.shiftKey && S === R
              ? (b.preventDefault(), t && fc(_, { select: !0 }))
              : b.shiftKey &&
                S === _ &&
                (b.preventDefault(), t && fc(R, { select: !0 }))
            : S === A && b.preventDefault();
        }
      },
      [t, s, g.paused]
    );
    return u.jsx(Et.div, { tabIndex: -1, ...a, ref: p, onKeyDown: y });
  });
Av.displayName = Nue;
function Oue(n, { select: e = !1 } = {}) {
  const t = document.activeElement;
  for (const s of n)
    if ((fc(s, { select: e }), document.activeElement !== t)) return;
}
function jue(n) {
  const e = RV(n),
    t = $U(e, n),
    s = $U(e.reverse(), n);
  return [t, s];
}
function RV(n) {
  const e = [],
    t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (s) => {
        const r = s.tagName === "INPUT" && s.type === "hidden";
        return s.disabled || s.hidden || r
          ? NodeFilter.FILTER_SKIP
          : s.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function $U(n, e) {
  for (const t of n) if (!Fue(t, { upTo: e })) return t;
}
function Fue(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function Uue(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function fc(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== t && Uue(n) && e && n.select();
  }
}
var BU = $ue();
function $ue() {
  let n = [];
  return {
    add(e) {
      const t = n[0];
      e !== t && t?.pause(), (n = HU(n, e)), n.unshift(e);
    },
    remove(e) {
      (n = HU(n, e)), n[0]?.resume();
    },
  };
}
function HU(n, e) {
  const t = [...n],
    s = t.indexOf(e);
  return s !== -1 && t.splice(s, 1), t;
}
function Bue(n) {
  return n.filter((e) => e.tagName !== "A");
}
var Hue = "Portal",
  Hf = E.forwardRef((n, e) => {
    const { container: t, ...s } = n,
      [r, i] = E.useState(!1);
    ys(() => i(!0), []);
    const a = t || (r && globalThis?.document?.body);
    return a ? S6.createPortal(u.jsx(Et.div, { ...s, ref: e }), a) : null;
  });
Hf.displayName = Hue;
var E1 = 0;
function SE() {
  E.useEffect(() => {
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", n[0] ?? VU()),
      document.body.insertAdjacentElement("beforeend", n[1] ?? VU()),
      E1++,
      () => {
        E1 === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((e) => e.remove()),
          E1--;
      }
    );
  }, []);
}
function VU() {
  const n = document.createElement("span");
  return (
    n.setAttribute("data-radix-focus-guard", ""),
    (n.tabIndex = 0),
    (n.style.outline = "none"),
    (n.style.opacity = "0"),
    (n.style.position = "fixed"),
    (n.style.pointerEvents = "none"),
    n
  );
}
var po = function () {
  return (
    (po =
      Object.assign ||
      function (e) {
        for (var t, s = 1, r = arguments.length; s < r; s++) {
          t = arguments[s];
          for (var i in t)
            Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }),
    po.apply(this, arguments)
  );
};
function kV(n, e) {
  var t = {};
  for (var s in n)
    Object.prototype.hasOwnProperty.call(n, s) &&
      e.indexOf(s) < 0 &&
      (t[s] = n[s]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, s = Object.getOwnPropertySymbols(n); r < s.length; r++)
      e.indexOf(s[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, s[r]) &&
        (t[s[r]] = n[s[r]]);
  return t;
}
function Vue(n, e, t) {
  if (t || arguments.length === 2)
    for (var s = 0, r = e.length, i; s < r; s++)
      (i || !(s in e)) &&
        (i || (i = Array.prototype.slice.call(e, 0, s)), (i[s] = e[s]));
  return n.concat(i || Array.prototype.slice.call(e));
}
var xb = "right-scroll-bar-position",
  wb = "width-before-scroll-bar",
  zue = "with-scroll-bars-hidden",
  Gue = "--removed-body-scroll-bar-size";
function S1(n, e) {
  return typeof n == "function" ? n(e) : n && (n.current = e), n;
}
function que(n, e) {
  var t = E.useState(function () {
    return {
      value: n,
      callback: e,
      facade: {
        get current() {
          return t.value;
        },
        set current(s) {
          var r = t.value;
          r !== s && ((t.value = s), t.callback(s, r));
        },
      },
    };
  })[0];
  return (t.callback = e), t.facade;
}
var Wue = typeof window < "u" ? E.useLayoutEffect : E.useEffect,
  zU = new WeakMap();
function Kue(n, e) {
  var t = que(null, function (s) {
    return n.forEach(function (r) {
      return S1(r, s);
    });
  });
  return (
    Wue(
      function () {
        var s = zU.get(t);
        if (s) {
          var r = new Set(s),
            i = new Set(n),
            a = t.current;
          r.forEach(function (o) {
            i.has(o) || S1(o, null);
          }),
            i.forEach(function (o) {
              r.has(o) || S1(o, a);
            });
        }
        zU.set(t, n);
      },
      [n]
    ),
    t
  );
}
function Yue(n) {
  return n;
}
function Xue(n, e) {
  e === void 0 && (e = Yue);
  var t = [],
    s = !1,
    r = {
      read: function () {
        if (s)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
          );
        return t.length ? t[t.length - 1] : n;
      },
      useMedium: function (i) {
        var a = e(i, s);
        return (
          t.push(a),
          function () {
            t = t.filter(function (o) {
              return o !== a;
            });
          }
        );
      },
      assignSyncMedium: function (i) {
        for (s = !0; t.length; ) {
          var a = t;
          (t = []), a.forEach(i);
        }
        t = {
          push: function (o) {
            return i(o);
          },
          filter: function () {
            return t;
          },
        };
      },
      assignMedium: function (i) {
        s = !0;
        var a = [];
        if (t.length) {
          var o = t;
          (t = []), o.forEach(i), (a = t);
        }
        var l = function () {
            var h = a;
            (a = []), h.forEach(i);
          },
          c = function () {
            return Promise.resolve().then(l);
          };
        c(),
          (t = {
            push: function (h) {
              a.push(h), c();
            },
            filter: function (h) {
              return (a = a.filter(h)), t;
            },
          });
      },
    };
  return r;
}
function Que(n) {
  n === void 0 && (n = {});
  var e = Xue(null);
  return (e.options = po({ async: !0, ssr: !1 }, n)), e;
}
var CV = function (n) {
  var e = n.sideCar,
    t = kV(n, ["sideCar"]);
  if (!e)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    );
  var s = e.read();
  if (!s) throw new Error("Sidecar medium not found");
  return E.createElement(s, po({}, t));
};
CV.isSideCarExport = !0;
function Zue(n, e) {
  return n.useMedium(e), CV;
}
var IV = Que(),
  T1 = function () {},
  TE = E.forwardRef(function (n, e) {
    var t = E.useRef(null),
      s = E.useState({
        onScrollCapture: T1,
        onWheelCapture: T1,
        onTouchMoveCapture: T1,
      }),
      r = s[0],
      i = s[1],
      a = n.forwardProps,
      o = n.children,
      l = n.className,
      c = n.removeScrollBar,
      h = n.enabled,
      m = n.shards,
      p = n.sideCar,
      g = n.noRelative,
      y = n.noIsolation,
      b = n.inert,
      w = n.allowPinchZoom,
      S = n.as,
      A = S === void 0 ? "div" : S,
      _ = n.gapMode,
      R = kV(n, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noRelative",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      C = p,
      D = Kue([t, e]),
      L = po(po({}, R), r);
    return E.createElement(
      E.Fragment,
      null,
      h &&
        E.createElement(C, {
          sideCar: IV,
          removeScrollBar: c,
          shards: m,
          noRelative: g,
          noIsolation: y,
          inert: b,
          setCallbacks: i,
          allowPinchZoom: !!w,
          lockRef: t,
          gapMode: _,
        }),
      a
        ? E.cloneElement(E.Children.only(o), po(po({}, L), { ref: D }))
        : E.createElement(A, po({}, L, { className: l, ref: D }), o)
    );
  });
TE.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
TE.classNames = { fullWidth: wb, zeroRight: xb };
var Jue = function () {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function ede() {
  if (!document) return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var e = Jue();
  return e && n.setAttribute("nonce", e), n;
}
function tde(n, e) {
  n.styleSheet
    ? (n.styleSheet.cssText = e)
    : n.appendChild(document.createTextNode(e));
}
function nde(n) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(n);
}
var sde = function () {
    var n = 0,
      e = null;
    return {
      add: function (t) {
        n == 0 && (e = ede()) && (tde(e, t), nde(e)), n++;
      },
      remove: function () {
        n--,
          !n && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  rde = function () {
    var n = sde();
    return function (e, t) {
      E.useEffect(
        function () {
          return (
            n.add(e),
            function () {
              n.remove();
            }
          );
        },
        [e && t]
      );
    };
  },
  LV = function () {
    var n = rde(),
      e = function (t) {
        var s = t.styles,
          r = t.dynamic;
        return n(s, r), null;
      };
    return e;
  },
  ide = { left: 0, top: 0, right: 0, gap: 0 },
  _1 = function (n) {
    return parseInt(n || "", 10) || 0;
  },
  ade = function (n) {
    var e = window.getComputedStyle(document.body),
      t = e[n === "padding" ? "paddingLeft" : "marginLeft"],
      s = e[n === "padding" ? "paddingTop" : "marginTop"],
      r = e[n === "padding" ? "paddingRight" : "marginRight"];
    return [_1(t), _1(s), _1(r)];
  },
  ode = function (n) {
    if ((n === void 0 && (n = "margin"), typeof window > "u")) return ide;
    var e = ade(n),
      t = document.documentElement.clientWidth,
      s = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, s - t + e[2] - e[0]),
    };
  },
  lde = LV(),
  sf = "data-scroll-locked",
  cde = function (n, e, t, s) {
    var r = n.left,
      i = n.top,
      a = n.right,
      o = n.gap;
    return (
      t === void 0 && (t = "margin"),
      `
  .`
        .concat(
          zue,
          ` {
   overflow: hidden `
        )
        .concat(
          s,
          `;
   padding-right: `
        )
        .concat(o, "px ")
        .concat(
          s,
          `;
  }
  body[`
        )
        .concat(
          sf,
          `] {
    overflow: hidden `
        )
        .concat(
          s,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            e && "position: relative ".concat(s, ";"),
            t === "margin" &&
              `
    padding-left: `
                .concat(
                  r,
                  `px;
    padding-top: `
                )
                .concat(
                  i,
                  `px;
    padding-right: `
                )
                .concat(
                  a,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(o, "px ")
                .concat(
                  s,
                  `;
    `
                ),
            t === "padding" &&
              "padding-right: ".concat(o, "px ").concat(s, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          xb,
          ` {
    right: `
        )
        .concat(o, "px ")
        .concat(
          s,
          `;
  }
  
  .`
        )
        .concat(
          wb,
          ` {
    margin-right: `
        )
        .concat(o, "px ")
        .concat(
          s,
          `;
  }
  
  .`
        )
        .concat(xb, " .")
        .concat(
          xb,
          ` {
    right: 0 `
        )
        .concat(
          s,
          `;
  }
  
  .`
        )
        .concat(wb, " .")
        .concat(
          wb,
          ` {
    margin-right: 0 `
        )
        .concat(
          s,
          `;
  }
  
  body[`
        )
        .concat(
          sf,
          `] {
    `
        )
        .concat(Gue, ": ")
        .concat(
          o,
          `px;
  }
`
        )
    );
  },
  GU = function () {
    var n = parseInt(document.body.getAttribute(sf) || "0", 10);
    return isFinite(n) ? n : 0;
  },
  ude = function () {
    E.useEffect(function () {
      return (
        document.body.setAttribute(sf, (GU() + 1).toString()),
        function () {
          var n = GU() - 1;
          n <= 0
            ? document.body.removeAttribute(sf)
            : document.body.setAttribute(sf, n.toString());
        }
      );
    }, []);
  },
  dde = function (n) {
    var e = n.noRelative,
      t = n.noImportant,
      s = n.gapMode,
      r = s === void 0 ? "margin" : s;
    ude();
    var i = E.useMemo(
      function () {
        return ode(r);
      },
      [r]
    );
    return E.createElement(lde, {
      styles: cde(i, !e, r, t ? "" : "!important"),
    });
  },
  ik = !1;
if (typeof window < "u")
  try {
    var _y = Object.defineProperty({}, "passive", {
      get: function () {
        return (ik = !0), !0;
      },
    });
    window.addEventListener("test", _y, _y),
      window.removeEventListener("test", _y, _y);
  } catch {
    ik = !1;
  }
var ch = ik ? { passive: !1 } : !1,
  hde = function (n) {
    return n.tagName === "TEXTAREA";
  },
  DV = function (n, e) {
    if (!(n instanceof Element)) return !1;
    var t = window.getComputedStyle(n);
    return (
      t[e] !== "hidden" &&
      !(t.overflowY === t.overflowX && !hde(n) && t[e] === "visible")
    );
  },
  fde = function (n) {
    return DV(n, "overflowY");
  },
  mde = function (n) {
    return DV(n, "overflowX");
  },
  qU = function (n, e) {
    var t = e.ownerDocument,
      s = e;
    do {
      typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host);
      var r = PV(n, s);
      if (r) {
        var i = MV(n, s),
          a = i[1],
          o = i[2];
        if (a > o) return !0;
      }
      s = s.parentNode;
    } while (s && s !== t.body);
    return !1;
  },
  pde = function (n) {
    var e = n.scrollTop,
      t = n.scrollHeight,
      s = n.clientHeight;
    return [e, t, s];
  },
  gde = function (n) {
    var e = n.scrollLeft,
      t = n.scrollWidth,
      s = n.clientWidth;
    return [e, t, s];
  },
  PV = function (n, e) {
    return n === "v" ? fde(e) : mde(e);
  },
  MV = function (n, e) {
    return n === "v" ? pde(e) : gde(e);
  },
  vde = function (n, e) {
    return n === "h" && e === "rtl" ? -1 : 1;
  },
  yde = function (n, e, t, s, r) {
    var i = vde(n, window.getComputedStyle(e).direction),
      a = i * s,
      o = t.target,
      l = e.contains(o),
      c = !1,
      h = a > 0,
      m = 0,
      p = 0;
    do {
      if (!o) break;
      var g = MV(n, o),
        y = g[0],
        b = g[1],
        w = g[2],
        S = b - w - i * y;
      (y || S) && PV(n, o) && ((m += S), (p += y));
      var A = o.parentNode;
      o = A && A.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? A.host : A;
    } while ((!l && o !== document.body) || (l && (e.contains(o) || e === o)));
    return ((h && Math.abs(m) < 1) || (!h && Math.abs(p) < 1)) && (c = !0), c;
  },
  Ay = function (n) {
    return "changedTouches" in n
      ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY]
      : [0, 0];
  },
  WU = function (n) {
    return [n.deltaX, n.deltaY];
  },
  KU = function (n) {
    return n && "current" in n ? n.current : n;
  },
  bde = function (n, e) {
    return n[0] === e[0] && n[1] === e[1];
  },
  xde = function (n) {
    return `
  .block-interactivity-`
      .concat(
        n,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        n,
        ` {pointer-events: all;}
`
      );
  },
  wde = 0,
  uh = [];
function Ede(n) {
  var e = E.useRef([]),
    t = E.useRef([0, 0]),
    s = E.useRef(),
    r = E.useState(wde++)[0],
    i = E.useState(LV)[0],
    a = E.useRef(n);
  E.useEffect(
    function () {
      a.current = n;
    },
    [n]
  ),
    E.useEffect(
      function () {
        if (n.inert) {
          document.body.classList.add("block-interactivity-".concat(r));
          var b = Vue([n.lockRef.current], (n.shards || []).map(KU), !0).filter(
            Boolean
          );
          return (
            b.forEach(function (w) {
              return w.classList.add("allow-interactivity-".concat(r));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(r)),
                b.forEach(function (w) {
                  return w.classList.remove("allow-interactivity-".concat(r));
                });
            }
          );
        }
      },
      [n.inert, n.lockRef.current, n.shards]
    );
  var o = E.useCallback(function (b, w) {
      if (
        ("touches" in b && b.touches.length === 2) ||
        (b.type === "wheel" && b.ctrlKey)
      )
        return !a.current.allowPinchZoom;
      var S = Ay(b),
        A = t.current,
        _ = "deltaX" in b ? b.deltaX : A[0] - S[0],
        R = "deltaY" in b ? b.deltaY : A[1] - S[1],
        C,
        D = b.target,
        L = Math.abs(_) > Math.abs(R) ? "h" : "v";
      if ("touches" in b && L === "h" && D.type === "range") return !1;
      var P = qU(L, D);
      if (!P) return !0;
      if ((P ? (C = L) : ((C = L === "v" ? "h" : "v"), (P = qU(L, D))), !P))
        return !1;
      if (
        (!s.current && "changedTouches" in b && (_ || R) && (s.current = C), !C)
      )
        return !0;
      var V = s.current || C;
      return yde(V, w, b, V === "h" ? _ : R);
    }, []),
    l = E.useCallback(function (b) {
      var w = b;
      if (!(!uh.length || uh[uh.length - 1] !== i)) {
        var S = "deltaY" in w ? WU(w) : Ay(w),
          A = e.current.filter(function (C) {
            return (
              C.name === w.type &&
              (C.target === w.target || w.target === C.shadowParent) &&
              bde(C.delta, S)
            );
          })[0];
        if (A && A.should) {
          w.cancelable && w.preventDefault();
          return;
        }
        if (!A) {
          var _ = (a.current.shards || [])
              .map(KU)
              .filter(Boolean)
              .filter(function (C) {
                return C.contains(w.target);
              }),
            R = _.length > 0 ? o(w, _[0]) : !a.current.noIsolation;
          R && w.cancelable && w.preventDefault();
        }
      }
    }, []),
    c = E.useCallback(function (b, w, S, A) {
      var _ = { name: b, delta: w, target: S, should: A, shadowParent: Sde(S) };
      e.current.push(_),
        setTimeout(function () {
          e.current = e.current.filter(function (R) {
            return R !== _;
          });
        }, 1);
    }, []),
    h = E.useCallback(function (b) {
      (t.current = Ay(b)), (s.current = void 0);
    }, []),
    m = E.useCallback(function (b) {
      c(b.type, WU(b), b.target, o(b, n.lockRef.current));
    }, []),
    p = E.useCallback(function (b) {
      c(b.type, Ay(b), b.target, o(b, n.lockRef.current));
    }, []);
  E.useEffect(function () {
    return (
      uh.push(i),
      n.setCallbacks({
        onScrollCapture: m,
        onWheelCapture: m,
        onTouchMoveCapture: p,
      }),
      document.addEventListener("wheel", l, ch),
      document.addEventListener("touchmove", l, ch),
      document.addEventListener("touchstart", h, ch),
      function () {
        (uh = uh.filter(function (b) {
          return b !== i;
        })),
          document.removeEventListener("wheel", l, ch),
          document.removeEventListener("touchmove", l, ch),
          document.removeEventListener("touchstart", h, ch);
      }
    );
  }, []);
  var g = n.removeScrollBar,
    y = n.inert;
  return E.createElement(
    E.Fragment,
    null,
    y ? E.createElement(i, { styles: xde(r) }) : null,
    g
      ? E.createElement(dde, { noRelative: n.noRelative, gapMode: n.gapMode })
      : null
  );
}
function Sde(n) {
  for (var e = null; n !== null; )
    n instanceof ShadowRoot && ((e = n.host), (n = n.host)), (n = n.parentNode);
  return e;
}
const Tde = Zue(IV, Ede);
var Rv = E.forwardRef(function (n, e) {
  return E.createElement(TE, po({}, n, { ref: e, sideCar: Tde }));
});
Rv.classNames = TE.classNames;
var _de = function (n) {
    if (typeof document > "u") return null;
    var e = Array.isArray(n) ? n[0] : n;
    return e.ownerDocument.body;
  },
  dh = new WeakMap(),
  Ry = new WeakMap(),
  ky = {},
  A1 = 0,
  NV = function (n) {
    return n && (n.host || NV(n.parentNode));
  },
  Ade = function (n, e) {
    return e
      .map(function (t) {
        if (n.contains(t)) return t;
        var s = NV(t);
        return s && n.contains(s)
          ? s
          : (console.error(
              "aria-hidden",
              t,
              "in not contained inside",
              n,
              ". Doing nothing"
            ),
            null);
      })
      .filter(function (t) {
        return !!t;
      });
  },
  Rde = function (n, e, t, s) {
    var r = Ade(e, Array.isArray(n) ? n : [n]);
    ky[t] || (ky[t] = new WeakMap());
    var i = ky[t],
      a = [],
      o = new Set(),
      l = new Set(r),
      c = function (m) {
        !m || o.has(m) || (o.add(m), c(m.parentNode));
      };
    r.forEach(c);
    var h = function (m) {
      !m ||
        l.has(m) ||
        Array.prototype.forEach.call(m.children, function (p) {
          if (o.has(p)) h(p);
          else
            try {
              var g = p.getAttribute(s),
                y = g !== null && g !== "false",
                b = (dh.get(p) || 0) + 1,
                w = (i.get(p) || 0) + 1;
              dh.set(p, b),
                i.set(p, w),
                a.push(p),
                b === 1 && y && Ry.set(p, !0),
                w === 1 && p.setAttribute(t, "true"),
                y || p.setAttribute(s, "true");
            } catch (S) {
              console.error("aria-hidden: cannot operate on ", p, S);
            }
        });
    };
    return (
      h(e),
      o.clear(),
      A1++,
      function () {
        a.forEach(function (m) {
          var p = dh.get(m) - 1,
            g = i.get(m) - 1;
          dh.set(m, p),
            i.set(m, g),
            p || (Ry.has(m) || m.removeAttribute(s), Ry.delete(m)),
            g || m.removeAttribute(t);
        }),
          A1--,
          A1 ||
            ((dh = new WeakMap()),
            (dh = new WeakMap()),
            (Ry = new WeakMap()),
            (ky = {}));
      }
    );
  },
  _E = function (n, e, t) {
    t === void 0 && (t = "data-aria-hidden");
    var s = Array.from(Array.isArray(n) ? n : [n]),
      r = _de(n);
    return r
      ? (s.push.apply(s, Array.from(r.querySelectorAll("[aria-live], script"))),
        Rde(s, r, t, "aria-hidden"))
      : function () {
          return null;
        };
  },
  AE = "Dialog",
  [OV, jV] = Pr(AE),
  [kde, Ha] = OV(AE),
  FV = (n) => {
    const {
        __scopeDialog: e,
        children: t,
        open: s,
        defaultOpen: r,
        onOpenChange: i,
        modal: a = !0,
      } = n,
      o = E.useRef(null),
      l = E.useRef(null),
      [c, h] = ci({ prop: s, defaultProp: r ?? !1, onChange: i, caller: AE });
    return u.jsx(kde, {
      scope: e,
      triggerRef: o,
      contentRef: l,
      contentId: $r(),
      titleId: $r(),
      descriptionId: $r(),
      open: c,
      onOpenChange: h,
      onOpenToggle: E.useCallback(() => h((m) => !m), [h]),
      modal: a,
      children: t,
    });
  };
FV.displayName = AE;
var UV = "DialogTrigger",
  $V = E.forwardRef((n, e) => {
    const { __scopeDialog: t, ...s } = n,
      r = Ha(UV, t),
      i = Nt(e, r.triggerRef);
    return u.jsx(Et.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": r.open,
      "aria-controls": r.contentId,
      "data-state": RL(r.open),
      ...s,
      ref: i,
      onClick: qe(n.onClick, r.onOpenToggle),
    });
  });
$V.displayName = UV;
var _L = "DialogPortal",
  [Cde, BV] = OV(_L, { forceMount: void 0 }),
  HV = (n) => {
    const { __scopeDialog: e, forceMount: t, children: s, container: r } = n,
      i = Ha(_L, e);
    return u.jsx(Cde, {
      scope: e,
      forceMount: t,
      children: E.Children.map(s, (a) =>
        u.jsx(Pi, {
          present: t || i.open,
          children: u.jsx(Hf, { asChild: !0, container: r, children: a }),
        })
      ),
    });
  };
HV.displayName = _L;
var Px = "DialogOverlay",
  VV = E.forwardRef((n, e) => {
    const t = BV(Px, n.__scopeDialog),
      { forceMount: s = t.forceMount, ...r } = n,
      i = Ha(Px, n.__scopeDialog);
    return i.modal
      ? u.jsx(Pi, {
          present: s || i.open,
          children: u.jsx(Lde, { ...r, ref: e }),
        })
      : null;
  });
VV.displayName = Px;
var Ide = Mc("DialogOverlay.RemoveScroll"),
  Lde = E.forwardRef((n, e) => {
    const { __scopeDialog: t, ...s } = n,
      r = Ha(Px, t);
    return u.jsx(Rv, {
      as: Ide,
      allowPinchZoom: !0,
      shards: [r.contentRef],
      children: u.jsx(Et.div, {
        "data-state": RL(r.open),
        ...s,
        ref: e,
        style: { pointerEvents: "auto", ...s.style },
      }),
    });
  }),
  Ju = "DialogContent",
  zV = E.forwardRef((n, e) => {
    const t = BV(Ju, n.__scopeDialog),
      { forceMount: s = t.forceMount, ...r } = n,
      i = Ha(Ju, n.__scopeDialog);
    return u.jsx(Pi, {
      present: s || i.open,
      children: i.modal
        ? u.jsx(Dde, { ...r, ref: e })
        : u.jsx(Pde, { ...r, ref: e }),
    });
  });
zV.displayName = Ju;
var Dde = E.forwardRef((n, e) => {
    const t = Ha(Ju, n.__scopeDialog),
      s = E.useRef(null),
      r = Nt(e, t.contentRef, s);
    return (
      E.useEffect(() => {
        const i = s.current;
        if (i) return _E(i);
      }, []),
      u.jsx(GV, {
        ...n,
        ref: r,
        trapFocus: t.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: qe(n.onCloseAutoFocus, (i) => {
          i.preventDefault(), t.triggerRef.current?.focus();
        }),
        onPointerDownOutside: qe(n.onPointerDownOutside, (i) => {
          const a = i.detail.originalEvent,
            o = a.button === 0 && a.ctrlKey === !0;
          (a.button === 2 || o) && i.preventDefault();
        }),
        onFocusOutside: qe(n.onFocusOutside, (i) => i.preventDefault()),
      })
    );
  }),
  Pde = E.forwardRef((n, e) => {
    const t = Ha(Ju, n.__scopeDialog),
      s = E.useRef(!1),
      r = E.useRef(!1);
    return u.jsx(GV, {
      ...n,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        n.onCloseAutoFocus?.(i),
          i.defaultPrevented ||
            (s.current || t.triggerRef.current?.focus(), i.preventDefault()),
          (s.current = !1),
          (r.current = !1);
      },
      onInteractOutside: (i) => {
        n.onInteractOutside?.(i),
          i.defaultPrevented ||
            ((s.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (r.current = !0));
        const a = i.target;
        t.triggerRef.current?.contains(a) && i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            r.current &&
            i.preventDefault();
      },
    });
  }),
  GV = E.forwardRef((n, e) => {
    const {
        __scopeDialog: t,
        trapFocus: s,
        onOpenAutoFocus: r,
        onCloseAutoFocus: i,
        ...a
      } = n,
      o = Ha(Ju, t),
      l = E.useRef(null),
      c = Nt(e, l);
    return (
      SE(),
      u.jsxs(u.Fragment, {
        children: [
          u.jsx(Av, {
            asChild: !0,
            loop: !0,
            trapped: s,
            onMountAutoFocus: r,
            onUnmountAutoFocus: i,
            children: u.jsx(Bf, {
              role: "dialog",
              id: o.contentId,
              "aria-describedby": o.descriptionId,
              "aria-labelledby": o.titleId,
              "data-state": RL(o.open),
              ...a,
              ref: c,
              onDismiss: () => o.onOpenChange(!1),
            }),
          }),
          u.jsxs(u.Fragment, {
            children: [
              u.jsx(Nde, { titleId: o.titleId }),
              u.jsx(jde, { contentRef: l, descriptionId: o.descriptionId }),
            ],
          }),
        ],
      })
    );
  }),
  AL = "DialogTitle",
  qV = E.forwardRef((n, e) => {
    const { __scopeDialog: t, ...s } = n,
      r = Ha(AL, t);
    return u.jsx(Et.h2, { id: r.titleId, ...s, ref: e });
  });
qV.displayName = AL;
var WV = "DialogDescription",
  KV = E.forwardRef((n, e) => {
    const { __scopeDialog: t, ...s } = n,
      r = Ha(WV, t);
    return u.jsx(Et.p, { id: r.descriptionId, ...s, ref: e });
  });
KV.displayName = WV;
var YV = "DialogClose",
  XV = E.forwardRef((n, e) => {
    const { __scopeDialog: t, ...s } = n,
      r = Ha(YV, t);
    return u.jsx(Et.button, {
      type: "button",
      ...s,
      ref: e,
      onClick: qe(n.onClick, () => r.onOpenChange(!1)),
    });
  });
XV.displayName = YV;
function RL(n) {
  return n ? "open" : "closed";
}
var QV = "DialogTitleWarning",
  [Mde, ZV] = Lle(QV, { contentName: Ju, titleName: AL, docsSlug: "dialog" }),
  Nde = ({ titleId: n }) => {
    const e = ZV(QV),
      t = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return (
      E.useEffect(() => {
        n && (document.getElementById(n) || console.error(t));
      }, [t, n]),
      null
    );
  },
  Ode = "DialogDescriptionWarning",
  jde = ({ contentRef: n, descriptionId: e }) => {
    const s = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${
      ZV(Ode).contentName
    }}.`;
    return (
      E.useEffect(() => {
        const r = n.current?.getAttribute("aria-describedby");
        e && r && (document.getElementById(e) || console.warn(s));
      }, [s, n, e]),
      null
    );
  },
  JV = FV,
  ez = $V,
  tz = HV,
  kL = VV,
  CL = zV,
  IL = qV,
  LL = KV,
  nz = XV;
const os = JV,
  Fde = ez,
  Ude = tz,
  sz = E.forwardRef(({ className: n, ...e }, t) =>
    u.jsx(kL, {
      ref: t,
      className: Le(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        n
      ),
      ...e,
    })
  );
sz.displayName = kL.displayName;
const Jn = E.forwardRef(
  ({ className: n, children: e, overlayClassName: t, ...s }, r) =>
    u.jsxs(Ude, {
      children: [
        u.jsx(sz, { className: t }),
        u.jsx(CL, {
          ref: r,
          className: Le(
            "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 element-border bg-element-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-3xl",
            n
          ),
          ...s,
          children: e,
        }),
      ],
    })
);
Jn.displayName = CL.displayName;
const bs = ({ className: n, ...e }) =>
  u.jsx("div", {
    className: Le("flex flex-col space-y-1.5 text-center sm:text-left ", n),
    ...e,
  });
bs.displayName = "DialogHeader";
const xr = ({ className: n, ...e }) =>
  u.jsx("div", {
    className: Le(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      n
    ),
    ...e,
  });
xr.displayName = "DialogFooter";
const xs = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(IL, {
    ref: t,
    className: Le("text-lg font-semibold leading-none tracking-tight ", n),
    ...e,
  })
);
xs.displayName = IL.displayName;
const Cl = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(LL, { ref: t, className: Le("text-sm text-muted-foreground", n), ...e })
);
Cl.displayName = LL.displayName;
const $de = ({ open: n, onOpenChange: e }) => {
    const { signInWithGoogle: t } = ks(),
      s = async () => {
        try {
          const r = window.location.pathname + window.location.search;
          await t(r);
        } catch (r) {
          console.error("Error signing in with Google:", r);
        }
      };
    return u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsx(Jn, {
        className:
          "max-w-sm bg-card-background/50 backdrop-blur-lg py-8 rounded-3xl border-border text-white",
        children: u.jsxs("div", {
          className: "flex flex-col items-center space-y-4",
          children: [
            u.jsxs("div", {
              className: "text-center space-y-2",
              children: [
                u.jsx("h2", {
                  className: "text-2xl font-bold",
                  children: "Almost there",
                }),
                u.jsx("p", {
                  className: "text-sm text-text-secondary",
                  children: "Continue with Google to add elements",
                }),
              ],
            }),
            u.jsxs(et, {
              onClick: s,
              className:
                "w-full max-w-xs bg-white text-black hover:bg-white/90",
              children: [
                u.jsxs("svg", {
                  className: "w-5 h-5 mr-2",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [
                    u.jsx("path", {
                      d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z",
                      fill: "#4285F4",
                    }),
                    u.jsx("path", {
                      d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z",
                      fill: "#34A853",
                    }),
                    u.jsx("path", {
                      d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z",
                      fill: "#FBBC05",
                    }),
                    u.jsx("path", {
                      d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z",
                      fill: "#EA4335",
                    }),
                  ],
                }),
                "Continue with Google",
              ],
            }),
            u.jsxs("p", {
              className: "text-xs text-text-secondary text-center px-4",
              children: [
                "By continuing, you agree to the",
                " ",
                u.jsx("a", {
                  href: "/terms-of-service",
                  className: "text-text-primary hover:underline",
                  children: "Terms of Service",
                }),
                " ",
                "and",
                " ",
                u.jsx("a", {
                  href: "/privacy-policy",
                  className: "text-text-primary hover:underline",
                  children: "Privacy Policy",
                }),
                ".",
              ],
            }),
          ],
        }),
      }),
    });
  },
  Bde = ({ open: n, onOpenChange: e, title: t = "Flask Pro" }) => {
    const s = es(),
      r = () => {
        e(!1), s("/#pricing");
      };
    return u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-md",
        onClick: (i) => i.stopPropagation(),
        children: [
          u.jsx(bs, { children: u.jsx(xs, { children: t }) }),
          u.jsxs("p", {
            className: "text-sm text-text-secondary mt-2",
            children: [
              "Flask gives you free, unlimited video collaboration using YouTube as storage. ",
              u.jsx("br", {}),
              u.jsx("br", {}),
              "Upload your video to YouTube (unlisted or public) and drop the link in Flask.",
              u.jsx("p", {
                className: "text-sm text-text-primary mt-4",
                children:
                  "To upload videos directly from your device, upgrade to Flask Pro",
              }),
            ],
          }),
          u.jsxs("div", {
            className: "mt-2 flex items-center gap-3",
            children: [
              u.jsx(et, {
                onClick: r,
                variant: "ghost",
                className:
                  "text-text-secondary button-secondary px-6 py-3 h-full hover:text-text-primary text-sm flex-1",
                children: "Upgrade to Flask Pro",
              }),
              u.jsx("div", {
                onClick: () => e(!1),
                className:
                  "button-primary flex items-center font-semibold rounded-xl justify-center px-6 h-full cursor-pointer text-sm flex-1",
                children: u.jsx("span", { children: "Got it" }),
              }),
            ],
          }),
        ],
      }),
    });
  },
  Hde = ["top", "right", "bottom", "left"],
  Nc = Math.min,
  wi = Math.max,
  Mx = Math.round,
  Cy = Math.floor,
  ko = (n) => ({ x: n, y: n }),
  Vde = { left: "right", right: "left", bottom: "top", top: "bottom" },
  zde = { start: "end", end: "start" };
function ak(n, e, t) {
  return wi(n, Nc(e, t));
}
function Tl(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function _l(n) {
  return n.split("-")[0];
}
function Vf(n) {
  return n.split("-")[1];
}
function DL(n) {
  return n === "x" ? "y" : "x";
}
function PL(n) {
  return n === "y" ? "height" : "width";
}
const Gde = new Set(["top", "bottom"]);
function Eo(n) {
  return Gde.has(_l(n)) ? "y" : "x";
}
function ML(n) {
  return DL(Eo(n));
}
function qde(n, e, t) {
  t === void 0 && (t = !1);
  const s = Vf(n),
    r = ML(n),
    i = PL(r);
  let a =
    r === "x"
      ? s === (t ? "end" : "start")
        ? "right"
        : "left"
      : s === "start"
      ? "bottom"
      : "top";
  return e.reference[i] > e.floating[i] && (a = Nx(a)), [a, Nx(a)];
}
function Wde(n) {
  const e = Nx(n);
  return [ok(n), e, ok(e)];
}
function ok(n) {
  return n.replace(/start|end/g, (e) => zde[e]);
}
const YU = ["left", "right"],
  XU = ["right", "left"],
  Kde = ["top", "bottom"],
  Yde = ["bottom", "top"];
function Xde(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? (e ? XU : YU) : e ? YU : XU;
    case "left":
    case "right":
      return e ? Kde : Yde;
    default:
      return [];
  }
}
function Qde(n, e, t, s) {
  const r = Vf(n);
  let i = Xde(_l(n), t === "start", s);
  return (
    r && ((i = i.map((a) => a + "-" + r)), e && (i = i.concat(i.map(ok)))), i
  );
}
function Nx(n) {
  return n.replace(/left|right|bottom|top/g, (e) => Vde[e]);
}
function Zde(n) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...n };
}
function rz(n) {
  return typeof n != "number"
    ? Zde(n)
    : { top: n, right: n, bottom: n, left: n };
}
function Ox(n) {
  const { x: e, y: t, width: s, height: r } = n;
  return {
    width: s,
    height: r,
    top: t,
    left: e,
    right: e + s,
    bottom: t + r,
    x: e,
    y: t,
  };
}
function QU(n, e, t) {
  let { reference: s, floating: r } = n;
  const i = Eo(e),
    a = ML(e),
    o = PL(a),
    l = _l(e),
    c = i === "y",
    h = s.x + s.width / 2 - r.width / 2,
    m = s.y + s.height / 2 - r.height / 2,
    p = s[o] / 2 - r[o] / 2;
  let g;
  switch (l) {
    case "top":
      g = { x: h, y: s.y - r.height };
      break;
    case "bottom":
      g = { x: h, y: s.y + s.height };
      break;
    case "right":
      g = { x: s.x + s.width, y: m };
      break;
    case "left":
      g = { x: s.x - r.width, y: m };
      break;
    default:
      g = { x: s.x, y: s.y };
  }
  switch (Vf(e)) {
    case "start":
      g[a] -= p * (t && c ? -1 : 1);
      break;
    case "end":
      g[a] += p * (t && c ? -1 : 1);
      break;
  }
  return g;
}
const Jde = async (n, e, t) => {
  const {
      placement: s = "bottom",
      strategy: r = "absolute",
      middleware: i = [],
      platform: a,
    } = t,
    o = i.filter(Boolean),
    l = await (a.isRTL == null ? void 0 : a.isRTL(e));
  let c = await a.getElementRects({ reference: n, floating: e, strategy: r }),
    { x: h, y: m } = QU(c, s, l),
    p = s,
    g = {},
    y = 0;
  for (let b = 0; b < o.length; b++) {
    const { name: w, fn: S } = o[b],
      {
        x: A,
        y: _,
        data: R,
        reset: C,
      } = await S({
        x: h,
        y: m,
        initialPlacement: s,
        placement: p,
        strategy: r,
        middlewareData: g,
        rects: c,
        platform: a,
        elements: { reference: n, floating: e },
      });
    (h = A ?? h),
      (m = _ ?? m),
      (g = { ...g, [w]: { ...g[w], ...R } }),
      C &&
        y <= 50 &&
        (y++,
        typeof C == "object" &&
          (C.placement && (p = C.placement),
          C.rects &&
            (c =
              C.rects === !0
                ? await a.getElementRects({
                    reference: n,
                    floating: e,
                    strategy: r,
                  })
                : C.rects),
          ({ x: h, y: m } = QU(c, p, l))),
        (b = -1));
  }
  return { x: h, y: m, placement: p, strategy: r, middlewareData: g };
};
async function Og(n, e) {
  var t;
  e === void 0 && (e = {});
  const { x: s, y: r, platform: i, rects: a, elements: o, strategy: l } = n,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: h = "viewport",
      elementContext: m = "floating",
      altBoundary: p = !1,
      padding: g = 0,
    } = Tl(e, n),
    y = rz(g),
    w = o[p ? (m === "floating" ? "reference" : "floating") : m],
    S = Ox(
      await i.getClippingRect({
        element:
          (t = await (i.isElement == null ? void 0 : i.isElement(w))) == null ||
          t
            ? w
            : w.contextElement ||
              (await (i.getDocumentElement == null
                ? void 0
                : i.getDocumentElement(o.floating))),
        boundary: c,
        rootBoundary: h,
        strategy: l,
      })
    ),
    A =
      m === "floating"
        ? { x: s, y: r, width: a.floating.width, height: a.floating.height }
        : a.reference,
    _ = await (i.getOffsetParent == null
      ? void 0
      : i.getOffsetParent(o.floating)),
    R = (await (i.isElement == null ? void 0 : i.isElement(_)))
      ? (await (i.getScale == null ? void 0 : i.getScale(_))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    C = Ox(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: o,
            rect: A,
            offsetParent: _,
            strategy: l,
          })
        : A
    );
  return {
    top: (S.top - C.top + y.top) / R.y,
    bottom: (C.bottom - S.bottom + y.bottom) / R.y,
    left: (S.left - C.left + y.left) / R.x,
    right: (C.right - S.right + y.right) / R.x,
  };
}
const ehe = (n) => ({
    name: "arrow",
    options: n,
    async fn(e) {
      const {
          x: t,
          y: s,
          placement: r,
          rects: i,
          platform: a,
          elements: o,
          middlewareData: l,
        } = e,
        { element: c, padding: h = 0 } = Tl(n, e) || {};
      if (c == null) return {};
      const m = rz(h),
        p = { x: t, y: s },
        g = ML(r),
        y = PL(g),
        b = await a.getDimensions(c),
        w = g === "y",
        S = w ? "top" : "left",
        A = w ? "bottom" : "right",
        _ = w ? "clientHeight" : "clientWidth",
        R = i.reference[y] + i.reference[g] - p[g] - i.floating[y],
        C = p[g] - i.reference[g],
        D = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(c));
      let L = D ? D[_] : 0;
      (!L || !(await (a.isElement == null ? void 0 : a.isElement(D)))) &&
        (L = o.floating[_] || i.floating[y]);
      const P = R / 2 - C / 2,
        V = L / 2 - b[y] / 2 - 1,
        N = Nc(m[S], V),
        W = Nc(m[A], V),
        H = N,
        z = L - b[y] - W,
        B = L / 2 - b[y] / 2 + P,
        q = ak(H, B, z),
        O =
          !l.arrow &&
          Vf(r) != null &&
          B !== q &&
          i.reference[y] / 2 - (B < H ? N : W) - b[y] / 2 < 0,
        U = O ? (B < H ? B - H : B - z) : 0;
      return {
        [g]: p[g] + U,
        data: {
          [g]: q,
          centerOffset: B - q - U,
          ...(O && { alignmentOffset: U }),
        },
        reset: O,
      };
    },
  }),
  the = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "flip",
        options: n,
        async fn(e) {
          var t, s;
          const {
              placement: r,
              middlewareData: i,
              rects: a,
              initialPlacement: o,
              platform: l,
              elements: c,
            } = e,
            {
              mainAxis: h = !0,
              crossAxis: m = !0,
              fallbackPlacements: p,
              fallbackStrategy: g = "bestFit",
              fallbackAxisSideDirection: y = "none",
              flipAlignment: b = !0,
              ...w
            } = Tl(n, e);
          if ((t = i.arrow) != null && t.alignmentOffset) return {};
          const S = _l(r),
            A = Eo(o),
            _ = _l(o) === o,
            R = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            C = p || (_ || !b ? [Nx(o)] : Wde(o)),
            D = y !== "none";
          !p && D && C.push(...Qde(o, b, y, R));
          const L = [o, ...C],
            P = await Og(e, w),
            V = [];
          let N = ((s = i.flip) == null ? void 0 : s.overflows) || [];
          if ((h && V.push(P[S]), m)) {
            const B = qde(r, a, R);
            V.push(P[B[0]], P[B[1]]);
          }
          if (
            ((N = [...N, { placement: r, overflows: V }]),
            !V.every((B) => B <= 0))
          ) {
            var W, H;
            const B = (((W = i.flip) == null ? void 0 : W.index) || 0) + 1,
              q = L[B];
            if (
              q &&
              (!(m === "alignment" ? A !== Eo(q) : !1) ||
                N.every((j) => j.overflows[0] > 0 && Eo(j.placement) === A))
            )
              return {
                data: { index: B, overflows: N },
                reset: { placement: q },
              };
            let O =
              (H = N.filter((U) => U.overflows[0] <= 0).sort(
                (U, j) => U.overflows[1] - j.overflows[1]
              )[0]) == null
                ? void 0
                : H.placement;
            if (!O)
              switch (g) {
                case "bestFit": {
                  var z;
                  const U =
                    (z = N.filter((j) => {
                      if (D) {
                        const Q = Eo(j.placement);
                        return Q === A || Q === "y";
                      }
                      return !0;
                    })
                      .map((j) => [
                        j.placement,
                        j.overflows
                          .filter((Q) => Q > 0)
                          .reduce((Q, M) => Q + M, 0),
                      ])
                      .sort((j, Q) => j[1] - Q[1])[0]) == null
                      ? void 0
                      : z[0];
                  U && (O = U);
                  break;
                }
                case "initialPlacement":
                  O = o;
                  break;
              }
            if (r !== O) return { reset: { placement: O } };
          }
          return {};
        },
      }
    );
  };
function ZU(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width,
  };
}
function JU(n) {
  return Hde.some((e) => n[e] >= 0);
}
const nhe = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "hide",
        options: n,
        async fn(e) {
          const { rects: t } = e,
            { strategy: s = "referenceHidden", ...r } = Tl(n, e);
          switch (s) {
            case "referenceHidden": {
              const i = await Og(e, { ...r, elementContext: "reference" }),
                a = ZU(i, t.reference);
              return {
                data: { referenceHiddenOffsets: a, referenceHidden: JU(a) },
              };
            }
            case "escaped": {
              const i = await Og(e, { ...r, altBoundary: !0 }),
                a = ZU(i, t.floating);
              return { data: { escapedOffsets: a, escaped: JU(a) } };
            }
            default:
              return {};
          }
        },
      }
    );
  },
  iz = new Set(["left", "top"]);
async function she(n, e) {
  const { placement: t, platform: s, elements: r } = n,
    i = await (s.isRTL == null ? void 0 : s.isRTL(r.floating)),
    a = _l(t),
    o = Vf(t),
    l = Eo(t) === "y",
    c = iz.has(a) ? -1 : 1,
    h = i && l ? -1 : 1,
    m = Tl(e, n);
  let {
    mainAxis: p,
    crossAxis: g,
    alignmentAxis: y,
  } = typeof m == "number"
    ? { mainAxis: m, crossAxis: 0, alignmentAxis: null }
    : {
        mainAxis: m.mainAxis || 0,
        crossAxis: m.crossAxis || 0,
        alignmentAxis: m.alignmentAxis,
      };
  return (
    o && typeof y == "number" && (g = o === "end" ? y * -1 : y),
    l ? { x: g * h, y: p * c } : { x: p * c, y: g * h }
  );
}
const rhe = function (n) {
    return (
      n === void 0 && (n = 0),
      {
        name: "offset",
        options: n,
        async fn(e) {
          var t, s;
          const { x: r, y: i, placement: a, middlewareData: o } = e,
            l = await she(e, n);
          return a === ((t = o.offset) == null ? void 0 : t.placement) &&
            (s = o.arrow) != null &&
            s.alignmentOffset
            ? {}
            : { x: r + l.x, y: i + l.y, data: { ...l, placement: a } };
        },
      }
    );
  },
  ihe = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "shift",
        options: n,
        async fn(e) {
          const { x: t, y: s, placement: r } = e,
            {
              mainAxis: i = !0,
              crossAxis: a = !1,
              limiter: o = {
                fn: (w) => {
                  let { x: S, y: A } = w;
                  return { x: S, y: A };
                },
              },
              ...l
            } = Tl(n, e),
            c = { x: t, y: s },
            h = await Og(e, l),
            m = Eo(_l(r)),
            p = DL(m);
          let g = c[p],
            y = c[m];
          if (i) {
            const w = p === "y" ? "top" : "left",
              S = p === "y" ? "bottom" : "right",
              A = g + h[w],
              _ = g - h[S];
            g = ak(A, g, _);
          }
          if (a) {
            const w = m === "y" ? "top" : "left",
              S = m === "y" ? "bottom" : "right",
              A = y + h[w],
              _ = y - h[S];
            y = ak(A, y, _);
          }
          const b = o.fn({ ...e, [p]: g, [m]: y });
          return {
            ...b,
            data: { x: b.x - t, y: b.y - s, enabled: { [p]: i, [m]: a } },
          };
        },
      }
    );
  },
  ahe = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        options: n,
        fn(e) {
          const { x: t, y: s, placement: r, rects: i, middlewareData: a } = e,
            { offset: o = 0, mainAxis: l = !0, crossAxis: c = !0 } = Tl(n, e),
            h = { x: t, y: s },
            m = Eo(r),
            p = DL(m);
          let g = h[p],
            y = h[m];
          const b = Tl(o, e),
            w =
              typeof b == "number"
                ? { mainAxis: b, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...b };
          if (l) {
            const _ = p === "y" ? "height" : "width",
              R = i.reference[p] - i.floating[_] + w.mainAxis,
              C = i.reference[p] + i.reference[_] - w.mainAxis;
            g < R ? (g = R) : g > C && (g = C);
          }
          if (c) {
            var S, A;
            const _ = p === "y" ? "width" : "height",
              R = iz.has(_l(r)),
              C =
                i.reference[m] -
                i.floating[_] +
                ((R && ((S = a.offset) == null ? void 0 : S[m])) || 0) +
                (R ? 0 : w.crossAxis),
              D =
                i.reference[m] +
                i.reference[_] +
                (R ? 0 : ((A = a.offset) == null ? void 0 : A[m]) || 0) -
                (R ? w.crossAxis : 0);
            y < C ? (y = C) : y > D && (y = D);
          }
          return { [p]: g, [m]: y };
        },
      }
    );
  },
  ohe = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "size",
        options: n,
        async fn(e) {
          var t, s;
          const { placement: r, rects: i, platform: a, elements: o } = e,
            { apply: l = () => {}, ...c } = Tl(n, e),
            h = await Og(e, c),
            m = _l(r),
            p = Vf(r),
            g = Eo(r) === "y",
            { width: y, height: b } = i.floating;
          let w, S;
          m === "top" || m === "bottom"
            ? ((w = m),
              (S =
                p ===
                ((await (a.isRTL == null ? void 0 : a.isRTL(o.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((S = m), (w = p === "end" ? "top" : "bottom"));
          const A = b - h.top - h.bottom,
            _ = y - h.left - h.right,
            R = Nc(b - h[w], A),
            C = Nc(y - h[S], _),
            D = !e.middlewareData.shift;
          let L = R,
            P = C;
          if (
            ((t = e.middlewareData.shift) != null && t.enabled.x && (P = _),
            (s = e.middlewareData.shift) != null && s.enabled.y && (L = A),
            D && !p)
          ) {
            const N = wi(h.left, 0),
              W = wi(h.right, 0),
              H = wi(h.top, 0),
              z = wi(h.bottom, 0);
            g
              ? (P = y - 2 * (N !== 0 || W !== 0 ? N + W : wi(h.left, h.right)))
              : (L =
                  b - 2 * (H !== 0 || z !== 0 ? H + z : wi(h.top, h.bottom)));
          }
          await l({ ...e, availableWidth: P, availableHeight: L });
          const V = await a.getDimensions(o.floating);
          return y !== V.width || b !== V.height
            ? { reset: { rects: !0 } }
            : {};
        },
      }
    );
  };
function RE() {
  return typeof window < "u";
}
function zf(n) {
  return az(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Ri(n) {
  var e;
  return (
    (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) ||
    window
  );
}
function Oo(n) {
  var e;
  return (e = (az(n) ? n.ownerDocument : n.document) || window.document) == null
    ? void 0
    : e.documentElement;
}
function az(n) {
  return RE() ? n instanceof Node || n instanceof Ri(n).Node : !1;
}
function Na(n) {
  return RE() ? n instanceof Element || n instanceof Ri(n).Element : !1;
}
function Mo(n) {
  return RE() ? n instanceof HTMLElement || n instanceof Ri(n).HTMLElement : !1;
}
function e3(n) {
  return !RE() || typeof ShadowRoot > "u"
    ? !1
    : n instanceof ShadowRoot || n instanceof Ri(n).ShadowRoot;
}
const lhe = new Set(["inline", "contents"]);
function kv(n) {
  const { overflow: e, overflowX: t, overflowY: s, display: r } = Oa(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + s + t) && !lhe.has(r);
}
const che = new Set(["table", "td", "th"]);
function uhe(n) {
  return che.has(zf(n));
}
const dhe = [":popover-open", ":modal"];
function kE(n) {
  return dhe.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const hhe = ["transform", "translate", "scale", "rotate", "perspective"],
  fhe = ["transform", "translate", "scale", "rotate", "perspective", "filter"],
  mhe = ["paint", "layout", "strict", "content"];
function NL(n) {
  const e = OL(),
    t = Na(n) ? Oa(n) : n;
  return (
    hhe.some((s) => (t[s] ? t[s] !== "none" : !1)) ||
    (t.containerType ? t.containerType !== "normal" : !1) ||
    (!e && (t.backdropFilter ? t.backdropFilter !== "none" : !1)) ||
    (!e && (t.filter ? t.filter !== "none" : !1)) ||
    fhe.some((s) => (t.willChange || "").includes(s)) ||
    mhe.some((s) => (t.contain || "").includes(s))
  );
}
function phe(n) {
  let e = Oc(n);
  for (; Mo(e) && !Tf(e); ) {
    if (NL(e)) return e;
    if (kE(e)) return null;
    e = Oc(e);
  }
  return null;
}
function OL() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
const ghe = new Set(["html", "body", "#document"]);
function Tf(n) {
  return ghe.has(zf(n));
}
function Oa(n) {
  return Ri(n).getComputedStyle(n);
}
function CE(n) {
  return Na(n)
    ? { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop }
    : { scrollLeft: n.scrollX, scrollTop: n.scrollY };
}
function Oc(n) {
  if (zf(n) === "html") return n;
  const e = n.assignedSlot || n.parentNode || (e3(n) && n.host) || Oo(n);
  return e3(e) ? e.host : e;
}
function oz(n) {
  const e = Oc(n);
  return Tf(e)
    ? n.ownerDocument
      ? n.ownerDocument.body
      : n.body
    : Mo(e) && kv(e)
    ? e
    : oz(e);
}
function jg(n, e, t) {
  var s;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const r = oz(n),
    i = r === ((s = n.ownerDocument) == null ? void 0 : s.body),
    a = Ri(r);
  if (i) {
    const o = lk(a);
    return e.concat(
      a,
      a.visualViewport || [],
      kv(r) ? r : [],
      o && t ? jg(o) : []
    );
  }
  return e.concat(r, jg(r, [], t));
}
function lk(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function lz(n) {
  const e = Oa(n);
  let t = parseFloat(e.width) || 0,
    s = parseFloat(e.height) || 0;
  const r = Mo(n),
    i = r ? n.offsetWidth : t,
    a = r ? n.offsetHeight : s,
    o = Mx(t) !== i || Mx(s) !== a;
  return o && ((t = i), (s = a)), { width: t, height: s, $: o };
}
function jL(n) {
  return Na(n) ? n : n.contextElement;
}
function rf(n) {
  const e = jL(n);
  if (!Mo(e)) return ko(1);
  const t = e.getBoundingClientRect(),
    { width: s, height: r, $: i } = lz(e);
  let a = (i ? Mx(t.width) : t.width) / s,
    o = (i ? Mx(t.height) : t.height) / r;
  return (
    (!a || !Number.isFinite(a)) && (a = 1),
    (!o || !Number.isFinite(o)) && (o = 1),
    { x: a, y: o }
  );
}
const vhe = ko(0);
function cz(n) {
  const e = Ri(n);
  return !OL() || !e.visualViewport
    ? vhe
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function yhe(n, e, t) {
  return e === void 0 && (e = !1), !t || (e && t !== Ri(n)) ? !1 : e;
}
function ed(n, e, t, s) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const r = n.getBoundingClientRect(),
    i = jL(n);
  let a = ko(1);
  e && (s ? Na(s) && (a = rf(s)) : (a = rf(n)));
  const o = yhe(i, t, s) ? cz(i) : ko(0);
  let l = (r.left + o.x) / a.x,
    c = (r.top + o.y) / a.y,
    h = r.width / a.x,
    m = r.height / a.y;
  if (i) {
    const p = Ri(i),
      g = s && Na(s) ? Ri(s) : s;
    let y = p,
      b = lk(y);
    for (; b && s && g !== y; ) {
      const w = rf(b),
        S = b.getBoundingClientRect(),
        A = Oa(b),
        _ = S.left + (b.clientLeft + parseFloat(A.paddingLeft)) * w.x,
        R = S.top + (b.clientTop + parseFloat(A.paddingTop)) * w.y;
      (l *= w.x),
        (c *= w.y),
        (h *= w.x),
        (m *= w.y),
        (l += _),
        (c += R),
        (y = Ri(b)),
        (b = lk(y));
    }
  }
  return Ox({ width: h, height: m, x: l, y: c });
}
function FL(n, e) {
  const t = CE(n).scrollLeft;
  return e ? e.left + t : ed(Oo(n)).left + t;
}
function uz(n, e, t) {
  t === void 0 && (t = !1);
  const s = n.getBoundingClientRect(),
    r = s.left + e.scrollLeft - (t ? 0 : FL(n, s)),
    i = s.top + e.scrollTop;
  return { x: r, y: i };
}
function bhe(n) {
  let { elements: e, rect: t, offsetParent: s, strategy: r } = n;
  const i = r === "fixed",
    a = Oo(s),
    o = e ? kE(e.floating) : !1;
  if (s === a || (o && i)) return t;
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = ko(1);
  const h = ko(0),
    m = Mo(s);
  if (
    (m || (!m && !i)) &&
    ((zf(s) !== "body" || kv(a)) && (l = CE(s)), Mo(s))
  ) {
    const g = ed(s);
    (c = rf(s)), (h.x = g.x + s.clientLeft), (h.y = g.y + s.clientTop);
  }
  const p = a && !m && !i ? uz(a, l, !0) : ko(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - l.scrollLeft * c.x + h.x + p.x,
    y: t.y * c.y - l.scrollTop * c.y + h.y + p.y,
  };
}
function xhe(n) {
  return Array.from(n.getClientRects());
}
function whe(n) {
  const e = Oo(n),
    t = CE(n),
    s = n.ownerDocument.body,
    r = wi(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth),
    i = wi(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);
  let a = -t.scrollLeft + FL(n);
  const o = -t.scrollTop;
  return (
    Oa(s).direction === "rtl" && (a += wi(e.clientWidth, s.clientWidth) - r),
    { width: r, height: i, x: a, y: o }
  );
}
function Ehe(n, e) {
  const t = Ri(n),
    s = Oo(n),
    r = t.visualViewport;
  let i = s.clientWidth,
    a = s.clientHeight,
    o = 0,
    l = 0;
  if (r) {
    (i = r.width), (a = r.height);
    const c = OL();
    (!c || (c && e === "fixed")) && ((o = r.offsetLeft), (l = r.offsetTop));
  }
  return { width: i, height: a, x: o, y: l };
}
const She = new Set(["absolute", "fixed"]);
function The(n, e) {
  const t = ed(n, !0, e === "fixed"),
    s = t.top + n.clientTop,
    r = t.left + n.clientLeft,
    i = Mo(n) ? rf(n) : ko(1),
    a = n.clientWidth * i.x,
    o = n.clientHeight * i.y,
    l = r * i.x,
    c = s * i.y;
  return { width: a, height: o, x: l, y: c };
}
function t3(n, e, t) {
  let s;
  if (e === "viewport") s = Ehe(n, t);
  else if (e === "document") s = whe(Oo(n));
  else if (Na(e)) s = The(e, t);
  else {
    const r = cz(n);
    s = { x: e.x - r.x, y: e.y - r.y, width: e.width, height: e.height };
  }
  return Ox(s);
}
function dz(n, e) {
  const t = Oc(n);
  return t === e || !Na(t) || Tf(t)
    ? !1
    : Oa(t).position === "fixed" || dz(t, e);
}
function _he(n, e) {
  const t = e.get(n);
  if (t) return t;
  let s = jg(n, [], !1).filter((o) => Na(o) && zf(o) !== "body"),
    r = null;
  const i = Oa(n).position === "fixed";
  let a = i ? Oc(n) : n;
  for (; Na(a) && !Tf(a); ) {
    const o = Oa(a),
      l = NL(a);
    !l && o.position === "fixed" && (r = null),
      (
        i
          ? !l && !r
          : (!l && o.position === "static" && !!r && She.has(r.position)) ||
            (kv(a) && !l && dz(n, a))
      )
        ? (s = s.filter((h) => h !== a))
        : (r = o),
      (a = Oc(a));
  }
  return e.set(n, s), s;
}
function Ahe(n) {
  let { element: e, boundary: t, rootBoundary: s, strategy: r } = n;
  const a = [
      ...(t === "clippingAncestors"
        ? kE(e)
          ? []
          : _he(e, this._c)
        : [].concat(t)),
      s,
    ],
    o = a[0],
    l = a.reduce((c, h) => {
      const m = t3(e, h, r);
      return (
        (c.top = wi(m.top, c.top)),
        (c.right = Nc(m.right, c.right)),
        (c.bottom = Nc(m.bottom, c.bottom)),
        (c.left = wi(m.left, c.left)),
        c
      );
    }, t3(e, o, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top,
  };
}
function Rhe(n) {
  const { width: e, height: t } = lz(n);
  return { width: e, height: t };
}
function khe(n, e, t) {
  const s = Mo(e),
    r = Oo(e),
    i = t === "fixed",
    a = ed(n, !0, i, e);
  let o = { scrollLeft: 0, scrollTop: 0 };
  const l = ko(0);
  function c() {
    l.x = FL(r);
  }
  if (s || (!s && !i))
    if (((zf(e) !== "body" || kv(r)) && (o = CE(e)), s)) {
      const g = ed(e, !0, i, e);
      (l.x = g.x + e.clientLeft), (l.y = g.y + e.clientTop);
    } else r && c();
  i && !s && r && c();
  const h = r && !s && !i ? uz(r, o) : ko(0),
    m = a.left + o.scrollLeft - l.x - h.x,
    p = a.top + o.scrollTop - l.y - h.y;
  return { x: m, y: p, width: a.width, height: a.height };
}
function R1(n) {
  return Oa(n).position === "static";
}
function n3(n, e) {
  if (!Mo(n) || Oa(n).position === "fixed") return null;
  if (e) return e(n);
  let t = n.offsetParent;
  return Oo(n) === t && (t = t.ownerDocument.body), t;
}
function hz(n, e) {
  const t = Ri(n);
  if (kE(n)) return t;
  if (!Mo(n)) {
    let r = Oc(n);
    for (; r && !Tf(r); ) {
      if (Na(r) && !R1(r)) return r;
      r = Oc(r);
    }
    return t;
  }
  let s = n3(n, e);
  for (; s && uhe(s) && R1(s); ) s = n3(s, e);
  return s && Tf(s) && R1(s) && !NL(s) ? t : s || phe(n) || t;
}
const Che = async function (n) {
  const e = this.getOffsetParent || hz,
    t = this.getDimensions,
    s = await t(n.floating);
  return {
    reference: khe(n.reference, await e(n.floating), n.strategy),
    floating: { x: 0, y: 0, width: s.width, height: s.height },
  };
};
function Ihe(n) {
  return Oa(n).direction === "rtl";
}
const Lhe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: bhe,
  getDocumentElement: Oo,
  getClippingRect: Ahe,
  getOffsetParent: hz,
  getElementRects: Che,
  getClientRects: xhe,
  getDimensions: Rhe,
  getScale: rf,
  isElement: Na,
  isRTL: Ihe,
};
function fz(n, e) {
  return (
    n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height
  );
}
function Dhe(n, e) {
  let t = null,
    s;
  const r = Oo(n);
  function i() {
    var o;
    clearTimeout(s), (o = t) == null || o.disconnect(), (t = null);
  }
  function a(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), i();
    const c = n.getBoundingClientRect(),
      { left: h, top: m, width: p, height: g } = c;
    if ((o || e(), !p || !g)) return;
    const y = Cy(m),
      b = Cy(r.clientWidth - (h + p)),
      w = Cy(r.clientHeight - (m + g)),
      S = Cy(h),
      _ = {
        rootMargin: -y + "px " + -b + "px " + -w + "px " + -S + "px",
        threshold: wi(0, Nc(1, l)) || 1,
      };
    let R = !0;
    function C(D) {
      const L = D[0].intersectionRatio;
      if (L !== l) {
        if (!R) return a();
        L
          ? a(!1, L)
          : (s = setTimeout(() => {
              a(!1, 1e-7);
            }, 1e3));
      }
      L === 1 && !fz(c, n.getBoundingClientRect()) && a(), (R = !1);
    }
    try {
      t = new IntersectionObserver(C, { ..._, root: r.ownerDocument });
    } catch {
      t = new IntersectionObserver(C, _);
    }
    t.observe(n);
  }
  return a(!0), i;
}
function Phe(n, e, t, s) {
  s === void 0 && (s = {});
  const {
      ancestorScroll: r = !0,
      ancestorResize: i = !0,
      elementResize: a = typeof ResizeObserver == "function",
      layoutShift: o = typeof IntersectionObserver == "function",
      animationFrame: l = !1,
    } = s,
    c = jL(n),
    h = r || i ? [...(c ? jg(c) : []), ...jg(e)] : [];
  h.forEach((S) => {
    r && S.addEventListener("scroll", t, { passive: !0 }),
      i && S.addEventListener("resize", t);
  });
  const m = c && o ? Dhe(c, t) : null;
  let p = -1,
    g = null;
  a &&
    ((g = new ResizeObserver((S) => {
      let [A] = S;
      A &&
        A.target === c &&
        g &&
        (g.unobserve(e),
        cancelAnimationFrame(p),
        (p = requestAnimationFrame(() => {
          var _;
          (_ = g) == null || _.observe(e);
        }))),
        t();
    })),
    c && !l && g.observe(c),
    g.observe(e));
  let y,
    b = l ? ed(n) : null;
  l && w();
  function w() {
    const S = ed(n);
    b && !fz(b, S) && t(), (b = S), (y = requestAnimationFrame(w));
  }
  return (
    t(),
    () => {
      var S;
      h.forEach((A) => {
        r && A.removeEventListener("scroll", t),
          i && A.removeEventListener("resize", t);
      }),
        m?.(),
        (S = g) == null || S.disconnect(),
        (g = null),
        l && cancelAnimationFrame(y);
    }
  );
}
const Mhe = rhe,
  Nhe = ihe,
  Ohe = the,
  jhe = ohe,
  Fhe = nhe,
  s3 = ehe,
  Uhe = ahe,
  $he = (n, e, t) => {
    const s = new Map(),
      r = { platform: Lhe, ...t },
      i = { ...r.platform, _c: s };
    return Jde(n, e, { ...r, platform: i });
  };
var Bhe = typeof document < "u",
  Hhe = function () {},
  Eb = Bhe ? E.useLayoutEffect : Hhe;
function jx(n, e) {
  if (n === e) return !0;
  if (typeof n != typeof e) return !1;
  if (typeof n == "function" && n.toString() === e.toString()) return !0;
  let t, s, r;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (((t = n.length), t !== e.length)) return !1;
      for (s = t; s-- !== 0; ) if (!jx(n[s], e[s])) return !1;
      return !0;
    }
    if (((r = Object.keys(n)), (t = r.length), t !== Object.keys(e).length))
      return !1;
    for (s = t; s-- !== 0; ) if (!{}.hasOwnProperty.call(e, r[s])) return !1;
    for (s = t; s-- !== 0; ) {
      const i = r[s];
      if (!(i === "_owner" && n.$$typeof) && !jx(n[i], e[i])) return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function mz(n) {
  return typeof window > "u"
    ? 1
    : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function r3(n, e) {
  const t = mz(n);
  return Math.round(e * t) / t;
}
function k1(n) {
  const e = E.useRef(n);
  return (
    Eb(() => {
      e.current = n;
    }),
    e
  );
}
function Vhe(n) {
  n === void 0 && (n = {});
  const {
      placement: e = "bottom",
      strategy: t = "absolute",
      middleware: s = [],
      platform: r,
      elements: { reference: i, floating: a } = {},
      transform: o = !0,
      whileElementsMounted: l,
      open: c,
    } = n,
    [h, m] = E.useState({
      x: 0,
      y: 0,
      strategy: t,
      placement: e,
      middlewareData: {},
      isPositioned: !1,
    }),
    [p, g] = E.useState(s);
  jx(p, s) || g(s);
  const [y, b] = E.useState(null),
    [w, S] = E.useState(null),
    A = E.useCallback((j) => {
      j !== D.current && ((D.current = j), b(j));
    }, []),
    _ = E.useCallback((j) => {
      j !== L.current && ((L.current = j), S(j));
    }, []),
    R = i || y,
    C = a || w,
    D = E.useRef(null),
    L = E.useRef(null),
    P = E.useRef(h),
    V = l != null,
    N = k1(l),
    W = k1(r),
    H = k1(c),
    z = E.useCallback(() => {
      if (!D.current || !L.current) return;
      const j = { placement: e, strategy: t, middleware: p };
      W.current && (j.platform = W.current),
        $he(D.current, L.current, j).then((Q) => {
          const M = { ...Q, isPositioned: H.current !== !1 };
          B.current &&
            !jx(P.current, M) &&
            ((P.current = M),
            ri.flushSync(() => {
              m(M);
            }));
        });
    }, [p, e, t, W, H]);
  Eb(() => {
    c === !1 &&
      P.current.isPositioned &&
      ((P.current.isPositioned = !1), m((j) => ({ ...j, isPositioned: !1 })));
  }, [c]);
  const B = E.useRef(!1);
  Eb(
    () => (
      (B.current = !0),
      () => {
        B.current = !1;
      }
    ),
    []
  ),
    Eb(() => {
      if ((R && (D.current = R), C && (L.current = C), R && C)) {
        if (N.current) return N.current(R, C, z);
        z();
      }
    }, [R, C, z, N, V]);
  const q = E.useMemo(
      () => ({ reference: D, floating: L, setReference: A, setFloating: _ }),
      [A, _]
    ),
    O = E.useMemo(() => ({ reference: R, floating: C }), [R, C]),
    U = E.useMemo(() => {
      const j = { position: t, left: 0, top: 0 };
      if (!O.floating) return j;
      const Q = r3(O.floating, h.x),
        M = r3(O.floating, h.y);
      return o
        ? {
            ...j,
            transform: "translate(" + Q + "px, " + M + "px)",
            ...(mz(O.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: t, left: Q, top: M };
    }, [t, o, O.floating, h.x, h.y]);
  return E.useMemo(
    () => ({ ...h, update: z, refs: q, elements: O, floatingStyles: U }),
    [h, z, q, O, U]
  );
}
const zhe = (n) => {
    function e(t) {
      return {}.hasOwnProperty.call(t, "current");
    }
    return {
      name: "arrow",
      options: n,
      fn(t) {
        const { element: s, padding: r } = typeof n == "function" ? n(t) : n;
        return s && e(s)
          ? s.current != null
            ? s3({ element: s.current, padding: r }).fn(t)
            : {}
          : s
          ? s3({ element: s, padding: r }).fn(t)
          : {};
      },
    };
  },
  Ghe = (n, e) => ({ ...Mhe(n), options: [n, e] }),
  qhe = (n, e) => ({ ...Nhe(n), options: [n, e] }),
  Whe = (n, e) => ({ ...Uhe(n), options: [n, e] }),
  Khe = (n, e) => ({ ...Ohe(n), options: [n, e] }),
  Yhe = (n, e) => ({ ...jhe(n), options: [n, e] }),
  Xhe = (n, e) => ({ ...Fhe(n), options: [n, e] }),
  Qhe = (n, e) => ({ ...zhe(n), options: [n, e] });
var Zhe = "Arrow",
  pz = E.forwardRef((n, e) => {
    const { children: t, width: s = 10, height: r = 5, ...i } = n;
    return u.jsx(Et.svg, {
      ...i,
      ref: e,
      width: s,
      height: r,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? t : u.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
pz.displayName = Zhe;
var Jhe = pz;
function IE(n) {
  const [e, t] = E.useState(void 0);
  return (
    ys(() => {
      if (n) {
        t({ width: n.offsetWidth, height: n.offsetHeight });
        const s = new ResizeObserver((r) => {
          if (!Array.isArray(r) || !r.length) return;
          const i = r[0];
          let a, o;
          if ("borderBoxSize" in i) {
            const l = i.borderBoxSize,
              c = Array.isArray(l) ? l[0] : l;
            (a = c.inlineSize), (o = c.blockSize);
          } else (a = n.offsetWidth), (o = n.offsetHeight);
          t({ width: a, height: o });
        });
        return s.observe(n, { box: "border-box" }), () => s.unobserve(n);
      } else t(void 0);
    }, [n]),
    e
  );
}
var UL = "Popper",
  [gz, Gc] = Pr(UL),
  [efe, vz] = gz(UL),
  yz = (n) => {
    const { __scopePopper: e, children: t } = n,
      [s, r] = E.useState(null);
    return u.jsx(efe, { scope: e, anchor: s, onAnchorChange: r, children: t });
  };
yz.displayName = UL;
var bz = "PopperAnchor",
  xz = E.forwardRef((n, e) => {
    const { __scopePopper: t, virtualRef: s, ...r } = n,
      i = vz(bz, t),
      a = E.useRef(null),
      o = Nt(e, a);
    return (
      E.useEffect(() => {
        i.onAnchorChange(s?.current || a.current);
      }),
      s ? null : u.jsx(Et.div, { ...r, ref: o })
    );
  });
xz.displayName = bz;
var $L = "PopperContent",
  [tfe, nfe] = gz($L),
  wz = E.forwardRef((n, e) => {
    const {
        __scopePopper: t,
        side: s = "bottom",
        sideOffset: r = 0,
        align: i = "center",
        alignOffset: a = 0,
        arrowPadding: o = 0,
        avoidCollisions: l = !0,
        collisionBoundary: c = [],
        collisionPadding: h = 0,
        sticky: m = "partial",
        hideWhenDetached: p = !1,
        updatePositionStrategy: g = "optimized",
        onPlaced: y,
        ...b
      } = n,
      w = vz($L, t),
      [S, A] = E.useState(null),
      _ = Nt(e, (te) => A(te)),
      [R, C] = E.useState(null),
      D = IE(R),
      L = D?.width ?? 0,
      P = D?.height ?? 0,
      V = s + (i !== "center" ? "-" + i : ""),
      N =
        typeof h == "number"
          ? h
          : { top: 0, right: 0, bottom: 0, left: 0, ...h },
      W = Array.isArray(c) ? c : [c],
      H = W.length > 0,
      z = { padding: N, boundary: W.filter(rfe), altBoundary: H },
      {
        refs: B,
        floatingStyles: q,
        placement: O,
        isPositioned: U,
        middlewareData: j,
      } = Vhe({
        strategy: "fixed",
        placement: V,
        whileElementsMounted: (...te) =>
          Phe(...te, { animationFrame: g === "always" }),
        elements: { reference: w.anchor },
        middleware: [
          Ghe({ mainAxis: r + P, alignmentAxis: a }),
          l &&
            qhe({
              mainAxis: !0,
              crossAxis: !1,
              limiter: m === "partial" ? Whe() : void 0,
              ...z,
            }),
          l && Khe({ ...z }),
          Yhe({
            ...z,
            apply: ({
              elements: te,
              rects: ce,
              availableWidth: pe,
              availableHeight: se,
            }) => {
              const { width: be, height: K } = ce.reference,
                ve = te.floating.style;
              ve.setProperty("--radix-popper-available-width", `${pe}px`),
                ve.setProperty("--radix-popper-available-height", `${se}px`),
                ve.setProperty("--radix-popper-anchor-width", `${be}px`),
                ve.setProperty("--radix-popper-anchor-height", `${K}px`);
            },
          }),
          R && Qhe({ element: R, padding: o }),
          ife({ arrowWidth: L, arrowHeight: P }),
          p && Xhe({ strategy: "referenceHidden", ...z }),
        ],
      }),
      [Q, M] = Tz(O),
      I = ua(y);
    ys(() => {
      U && I?.();
    }, [U, I]);
    const F = j.arrow?.x,
      Y = j.arrow?.y,
      J = j.arrow?.centerOffset !== 0,
      [X, Z] = E.useState();
    return (
      ys(() => {
        S && Z(window.getComputedStyle(S).zIndex);
      }, [S]),
      u.jsx("div", {
        ref: B.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...q,
          transform: U ? q.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: X,
          "--radix-popper-transform-origin": [
            j.transformOrigin?.x,
            j.transformOrigin?.y,
          ].join(" "),
          ...(j.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none",
          }),
        },
        dir: n.dir,
        children: u.jsx(tfe, {
          scope: t,
          placedSide: Q,
          onArrowChange: C,
          arrowX: F,
          arrowY: Y,
          shouldHideArrow: J,
          children: u.jsx(Et.div, {
            "data-side": Q,
            "data-align": M,
            ...b,
            ref: _,
            style: { ...b.style, animation: U ? void 0 : "none" },
          }),
        }),
      })
    );
  });
wz.displayName = $L;
var Ez = "PopperArrow",
  sfe = { top: "bottom", right: "left", bottom: "top", left: "right" },
  Sz = E.forwardRef(function (e, t) {
    const { __scopePopper: s, ...r } = e,
      i = nfe(Ez, s),
      a = sfe[i.placedSide];
    return u.jsx("span", {
      ref: i.onArrowChange,
      style: {
        position: "absolute",
        left: i.arrowX,
        top: i.arrowY,
        [a]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0",
        }[i.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[i.placedSide],
        visibility: i.shouldHideArrow ? "hidden" : void 0,
      },
      children: u.jsx(Jhe, {
        ...r,
        ref: t,
        style: { ...r.style, display: "block" },
      }),
    });
  });
Sz.displayName = Ez;
function rfe(n) {
  return n !== null;
}
var ife = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    const { placement: t, rects: s, middlewareData: r } = e,
      a = r.arrow?.centerOffset !== 0,
      o = a ? 0 : n.arrowWidth,
      l = a ? 0 : n.arrowHeight,
      [c, h] = Tz(t),
      m = { start: "0%", center: "50%", end: "100%" }[h],
      p = (r.arrow?.x ?? 0) + o / 2,
      g = (r.arrow?.y ?? 0) + l / 2;
    let y = "",
      b = "";
    return (
      c === "bottom"
        ? ((y = a ? m : `${p}px`), (b = `${-l}px`))
        : c === "top"
        ? ((y = a ? m : `${p}px`), (b = `${s.floating.height + l}px`))
        : c === "right"
        ? ((y = `${-l}px`), (b = a ? m : `${g}px`))
        : c === "left" &&
          ((y = `${s.floating.width + l}px`), (b = a ? m : `${g}px`)),
      { data: { x: y, y: b } }
    );
  },
});
function Tz(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
var Cv = yz,
  Iv = xz,
  LE = wz,
  DE = Sz,
  _z = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
  }),
  afe = "VisuallyHidden",
  Az = E.forwardRef((n, e) =>
    u.jsx(Et.span, { ...n, ref: e, style: { ..._z, ...n.style } })
  );
Az.displayName = afe;
var ofe = Az,
  [PE, QMe] = Pr("Tooltip", [Gc]),
  ME = Gc(),
  Rz = "TooltipProvider",
  lfe = 700,
  ck = "tooltip.open",
  [cfe, BL] = PE(Rz),
  HL = (n) => {
    const {
        __scopeTooltip: e,
        delayDuration: t = lfe,
        skipDelayDuration: s = 300,
        disableHoverableContent: r = !1,
        children: i,
      } = n,
      a = E.useRef(!0),
      o = E.useRef(!1),
      l = E.useRef(0);
    return (
      E.useEffect(() => {
        const c = l.current;
        return () => window.clearTimeout(c);
      }, []),
      u.jsx(cfe, {
        scope: e,
        isOpenDelayedRef: a,
        delayDuration: t,
        onOpen: E.useCallback(() => {
          window.clearTimeout(l.current), (a.current = !1);
        }, []),
        onClose: E.useCallback(() => {
          window.clearTimeout(l.current),
            (l.current = window.setTimeout(() => (a.current = !0), s));
        }, [s]),
        isPointerInTransitRef: o,
        onPointerInTransitChange: E.useCallback((c) => {
          o.current = c;
        }, []),
        disableHoverableContent: r,
        children: i,
      })
    );
  };
HL.displayName = Rz;
var Fg = "Tooltip",
  [ufe, Lv] = PE(Fg),
  kz = (n) => {
    const {
        __scopeTooltip: e,
        children: t,
        open: s,
        defaultOpen: r,
        onOpenChange: i,
        disableHoverableContent: a,
        delayDuration: o,
      } = n,
      l = BL(Fg, n.__scopeTooltip),
      c = ME(e),
      [h, m] = E.useState(null),
      p = $r(),
      g = E.useRef(0),
      y = a ?? l.disableHoverableContent,
      b = o ?? l.delayDuration,
      w = E.useRef(!1),
      [S, A] = ci({
        prop: s,
        defaultProp: r ?? !1,
        onChange: (L) => {
          L
            ? (l.onOpen(), document.dispatchEvent(new CustomEvent(ck)))
            : l.onClose(),
            i?.(L);
        },
        caller: Fg,
      }),
      _ = E.useMemo(
        () => (S ? (w.current ? "delayed-open" : "instant-open") : "closed"),
        [S]
      ),
      R = E.useCallback(() => {
        window.clearTimeout(g.current),
          (g.current = 0),
          (w.current = !1),
          A(!0);
      }, [A]),
      C = E.useCallback(() => {
        window.clearTimeout(g.current), (g.current = 0), A(!1);
      }, [A]),
      D = E.useCallback(() => {
        window.clearTimeout(g.current),
          (g.current = window.setTimeout(() => {
            (w.current = !0), A(!0), (g.current = 0);
          }, b));
      }, [b, A]);
    return (
      E.useEffect(
        () => () => {
          g.current && (window.clearTimeout(g.current), (g.current = 0));
        },
        []
      ),
      u.jsx(Cv, {
        ...c,
        children: u.jsx(ufe, {
          scope: e,
          contentId: p,
          open: S,
          stateAttribute: _,
          trigger: h,
          onTriggerChange: m,
          onTriggerEnter: E.useCallback(() => {
            l.isOpenDelayedRef.current ? D() : R();
          }, [l.isOpenDelayedRef, D, R]),
          onTriggerLeave: E.useCallback(() => {
            y ? C() : (window.clearTimeout(g.current), (g.current = 0));
          }, [C, y]),
          onOpen: R,
          onClose: C,
          disableHoverableContent: y,
          children: t,
        }),
      })
    );
  };
kz.displayName = Fg;
var uk = "TooltipTrigger",
  Cz = E.forwardRef((n, e) => {
    const { __scopeTooltip: t, ...s } = n,
      r = Lv(uk, t),
      i = BL(uk, t),
      a = ME(t),
      o = E.useRef(null),
      l = Nt(e, o, r.onTriggerChange),
      c = E.useRef(!1),
      h = E.useRef(!1),
      m = E.useCallback(() => (c.current = !1), []);
    return (
      E.useEffect(
        () => () => document.removeEventListener("pointerup", m),
        [m]
      ),
      u.jsx(Iv, {
        asChild: !0,
        ...a,
        children: u.jsx(Et.button, {
          "aria-describedby": r.open ? r.contentId : void 0,
          "data-state": r.stateAttribute,
          ...s,
          ref: l,
          onPointerMove: qe(n.onPointerMove, (p) => {
            p.pointerType !== "touch" &&
              !h.current &&
              !i.isPointerInTransitRef.current &&
              (r.onTriggerEnter(), (h.current = !0));
          }),
          onPointerLeave: qe(n.onPointerLeave, () => {
            r.onTriggerLeave(), (h.current = !1);
          }),
          onPointerDown: qe(n.onPointerDown, () => {
            r.open && r.onClose(),
              (c.current = !0),
              document.addEventListener("pointerup", m, { once: !0 });
          }),
          onFocus: qe(n.onFocus, () => {
            c.current || r.onOpen();
          }),
          onBlur: qe(n.onBlur, r.onClose),
          onClick: qe(n.onClick, r.onClose),
        }),
      })
    );
  });
Cz.displayName = uk;
var VL = "TooltipPortal",
  [dfe, hfe] = PE(VL, { forceMount: void 0 }),
  Iz = (n) => {
    const { __scopeTooltip: e, forceMount: t, children: s, container: r } = n,
      i = Lv(VL, e);
    return u.jsx(dfe, {
      scope: e,
      forceMount: t,
      children: u.jsx(Pi, {
        present: t || i.open,
        children: u.jsx(Hf, { asChild: !0, container: r, children: s }),
      }),
    });
  };
Iz.displayName = VL;
var _f = "TooltipContent",
  Lz = E.forwardRef((n, e) => {
    const t = hfe(_f, n.__scopeTooltip),
      { forceMount: s = t.forceMount, side: r = "top", ...i } = n,
      a = Lv(_f, n.__scopeTooltip);
    return u.jsx(Pi, {
      present: s || a.open,
      children: a.disableHoverableContent
        ? u.jsx(Dz, { side: r, ...i, ref: e })
        : u.jsx(ffe, { side: r, ...i, ref: e }),
    });
  }),
  ffe = E.forwardRef((n, e) => {
    const t = Lv(_f, n.__scopeTooltip),
      s = BL(_f, n.__scopeTooltip),
      r = E.useRef(null),
      i = Nt(e, r),
      [a, o] = E.useState(null),
      { trigger: l, onClose: c } = t,
      h = r.current,
      { onPointerInTransitChange: m } = s,
      p = E.useCallback(() => {
        o(null), m(!1);
      }, [m]),
      g = E.useCallback(
        (y, b) => {
          const w = y.currentTarget,
            S = { x: y.clientX, y: y.clientY },
            A = yfe(S, w.getBoundingClientRect()),
            _ = bfe(S, A),
            R = xfe(b.getBoundingClientRect()),
            C = Efe([..._, ...R]);
          o(C), m(!0);
        },
        [m]
      );
    return (
      E.useEffect(() => () => p(), [p]),
      E.useEffect(() => {
        if (l && h) {
          const y = (w) => g(w, h),
            b = (w) => g(w, l);
          return (
            l.addEventListener("pointerleave", y),
            h.addEventListener("pointerleave", b),
            () => {
              l.removeEventListener("pointerleave", y),
                h.removeEventListener("pointerleave", b);
            }
          );
        }
      }, [l, h, g, p]),
      E.useEffect(() => {
        if (a) {
          const y = (b) => {
            const w = b.target,
              S = { x: b.clientX, y: b.clientY },
              A = l?.contains(w) || h?.contains(w),
              _ = !wfe(S, a);
            A ? p() : _ && (p(), c());
          };
          return (
            document.addEventListener("pointermove", y),
            () => document.removeEventListener("pointermove", y)
          );
        }
      }, [l, h, a, c, p]),
      u.jsx(Dz, { ...n, ref: i })
    );
  }),
  [mfe, pfe] = PE(Fg, { isInside: !1 }),
  gfe = FH("TooltipContent"),
  Dz = E.forwardRef((n, e) => {
    const {
        __scopeTooltip: t,
        children: s,
        "aria-label": r,
        onEscapeKeyDown: i,
        onPointerDownOutside: a,
        ...o
      } = n,
      l = Lv(_f, t),
      c = ME(t),
      { onClose: h } = l;
    return (
      E.useEffect(
        () => (
          document.addEventListener(ck, h),
          () => document.removeEventListener(ck, h)
        ),
        [h]
      ),
      E.useEffect(() => {
        if (l.trigger) {
          const m = (p) => {
            p.target?.contains(l.trigger) && h();
          };
          return (
            window.addEventListener("scroll", m, { capture: !0 }),
            () => window.removeEventListener("scroll", m, { capture: !0 })
          );
        }
      }, [l.trigger, h]),
      u.jsx(Bf, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: a,
        onFocusOutside: (m) => m.preventDefault(),
        onDismiss: h,
        children: u.jsxs(LE, {
          "data-state": l.stateAttribute,
          ...c,
          ...o,
          ref: e,
          style: {
            ...o.style,
            "--radix-tooltip-content-transform-origin":
              "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width":
              "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height":
              "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height":
              "var(--radix-popper-anchor-height)",
          },
          children: [
            u.jsx(gfe, { children: s }),
            u.jsx(mfe, {
              scope: t,
              isInside: !0,
              children: u.jsx(ofe, {
                id: l.contentId,
                role: "tooltip",
                children: r || s,
              }),
            }),
          ],
        }),
      })
    );
  });
Lz.displayName = _f;
var Pz = "TooltipArrow",
  vfe = E.forwardRef((n, e) => {
    const { __scopeTooltip: t, ...s } = n,
      r = ME(t);
    return pfe(Pz, t).isInside ? null : u.jsx(DE, { ...r, ...s, ref: e });
  });
vfe.displayName = Pz;
function yfe(n, e) {
  const t = Math.abs(e.top - n.y),
    s = Math.abs(e.bottom - n.y),
    r = Math.abs(e.right - n.x),
    i = Math.abs(e.left - n.x);
  switch (Math.min(t, s, r, i)) {
    case i:
      return "left";
    case r:
      return "right";
    case t:
      return "top";
    case s:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function bfe(n, e, t = 5) {
  const s = [];
  switch (e) {
    case "top":
      s.push({ x: n.x - t, y: n.y + t }, { x: n.x + t, y: n.y + t });
      break;
    case "bottom":
      s.push({ x: n.x - t, y: n.y - t }, { x: n.x + t, y: n.y - t });
      break;
    case "left":
      s.push({ x: n.x + t, y: n.y - t }, { x: n.x + t, y: n.y + t });
      break;
    case "right":
      s.push({ x: n.x - t, y: n.y - t }, { x: n.x - t, y: n.y + t });
      break;
  }
  return s;
}
function xfe(n) {
  const { top: e, right: t, bottom: s, left: r } = n;
  return [
    { x: r, y: e },
    { x: t, y: e },
    { x: t, y: s },
    { x: r, y: s },
  ];
}
function wfe(n, e) {
  const { x: t, y: s } = n;
  let r = !1;
  for (let i = 0, a = e.length - 1; i < e.length; a = i++) {
    const o = e[i],
      l = e[a],
      c = o.x,
      h = o.y,
      m = l.x,
      p = l.y;
    h > s != p > s && t < ((m - c) * (s - h)) / (p - h) + c && (r = !r);
  }
  return r;
}
function Efe(n) {
  const e = n.slice();
  return (
    e.sort((t, s) =>
      t.x < s.x ? -1 : t.x > s.x ? 1 : t.y < s.y ? -1 : t.y > s.y ? 1 : 0
    ),
    Sfe(e)
  );
}
function Sfe(n) {
  if (n.length <= 1) return n.slice();
  const e = [];
  for (let s = 0; s < n.length; s++) {
    const r = n[s];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1],
        a = e[e.length - 2];
      if ((i.x - a.x) * (r.y - a.y) >= (i.y - a.y) * (r.x - a.x)) e.pop();
      else break;
    }
    e.push(r);
  }
  e.pop();
  const t = [];
  for (let s = n.length - 1; s >= 0; s--) {
    const r = n[s];
    for (; t.length >= 2; ) {
      const i = t[t.length - 1],
        a = t[t.length - 2];
      if ((i.x - a.x) * (r.y - a.y) >= (i.y - a.y) * (r.x - a.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  return (
    t.pop(),
    e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y
      ? e
      : e.concat(t)
  );
}
var Tfe = HL,
  _fe = kz,
  Afe = Cz,
  Rfe = Iz,
  Mz = Lz;
const Br = Tfe,
  Xn = _fe,
  Qn = Afe,
  Pn = E.forwardRef(({ className: n, sideOffset: e = 4, ...t }, s) =>
    u.jsx(Rfe, {
      children: u.jsx(Mz, {
        ref: s,
        sideOffset: e,
        className: Le(
          "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          n
        ),
        ...t,
      }),
    })
  );
Pn.displayName = Mz.displayName;
var C1 = "rovingFocusGroup.onEntryFocus",
  kfe = { bubbles: !1, cancelable: !0 },
  Dv = "RovingFocusGroup",
  [dk, Nz, Cfe] = Tv(Dv),
  [Ife, Oz] = Pr(Dv, [Cfe]),
  [Lfe, Dfe] = Ife(Dv),
  jz = E.forwardRef((n, e) =>
    u.jsx(dk.Provider, {
      scope: n.__scopeRovingFocusGroup,
      children: u.jsx(dk.Slot, {
        scope: n.__scopeRovingFocusGroup,
        children: u.jsx(Pfe, { ...n, ref: e }),
      }),
    })
  );
jz.displayName = Dv;
var Pfe = E.forwardRef((n, e) => {
    const {
        __scopeRovingFocusGroup: t,
        orientation: s,
        loop: r = !1,
        dir: i,
        currentTabStopId: a,
        defaultCurrentTabStopId: o,
        onCurrentTabStopIdChange: l,
        onEntryFocus: c,
        preventScrollOnEntryFocus: h = !1,
        ...m
      } = n,
      p = E.useRef(null),
      g = Nt(e, p),
      y = _v(i),
      [b, w] = ci({ prop: a, defaultProp: o ?? null, onChange: l, caller: Dv }),
      [S, A] = E.useState(!1),
      _ = ua(c),
      R = Nz(t),
      C = E.useRef(!1),
      [D, L] = E.useState(0);
    return (
      E.useEffect(() => {
        const P = p.current;
        if (P)
          return P.addEventListener(C1, _), () => P.removeEventListener(C1, _);
      }, [_]),
      u.jsx(Lfe, {
        scope: t,
        orientation: s,
        dir: y,
        loop: r,
        currentTabStopId: b,
        onItemFocus: E.useCallback((P) => w(P), [w]),
        onItemShiftTab: E.useCallback(() => A(!0), []),
        onFocusableItemAdd: E.useCallback(() => L((P) => P + 1), []),
        onFocusableItemRemove: E.useCallback(() => L((P) => P - 1), []),
        children: u.jsx(Et.div, {
          tabIndex: S || D === 0 ? -1 : 0,
          "data-orientation": s,
          ...m,
          ref: g,
          style: { outline: "none", ...n.style },
          onMouseDown: qe(n.onMouseDown, () => {
            C.current = !0;
          }),
          onFocus: qe(n.onFocus, (P) => {
            const V = !C.current;
            if (P.target === P.currentTarget && V && !S) {
              const N = new CustomEvent(C1, kfe);
              if ((P.currentTarget.dispatchEvent(N), !N.defaultPrevented)) {
                const W = R().filter((O) => O.focusable),
                  H = W.find((O) => O.active),
                  z = W.find((O) => O.id === b),
                  q = [H, z, ...W].filter(Boolean).map((O) => O.ref.current);
                $z(q, h);
              }
            }
            C.current = !1;
          }),
          onBlur: qe(n.onBlur, () => A(!1)),
        }),
      })
    );
  }),
  Fz = "RovingFocusGroupItem",
  Uz = E.forwardRef((n, e) => {
    const {
        __scopeRovingFocusGroup: t,
        focusable: s = !0,
        active: r = !1,
        tabStopId: i,
        children: a,
        ...o
      } = n,
      l = $r(),
      c = i || l,
      h = Dfe(Fz, t),
      m = h.currentTabStopId === c,
      p = Nz(t),
      {
        onFocusableItemAdd: g,
        onFocusableItemRemove: y,
        currentTabStopId: b,
      } = h;
    return (
      E.useEffect(() => {
        if (s) return g(), () => y();
      }, [s, g, y]),
      u.jsx(dk.ItemSlot, {
        scope: t,
        id: c,
        focusable: s,
        active: r,
        children: u.jsx(Et.span, {
          tabIndex: m ? 0 : -1,
          "data-orientation": h.orientation,
          ...o,
          ref: e,
          onMouseDown: qe(n.onMouseDown, (w) => {
            s ? h.onItemFocus(c) : w.preventDefault();
          }),
          onFocus: qe(n.onFocus, () => h.onItemFocus(c)),
          onKeyDown: qe(n.onKeyDown, (w) => {
            if (w.key === "Tab" && w.shiftKey) {
              h.onItemShiftTab();
              return;
            }
            if (w.target !== w.currentTarget) return;
            const S = Ofe(w, h.orientation, h.dir);
            if (S !== void 0) {
              if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
              w.preventDefault();
              let _ = p()
                .filter((R) => R.focusable)
                .map((R) => R.ref.current);
              if (S === "last") _.reverse();
              else if (S === "prev" || S === "next") {
                S === "prev" && _.reverse();
                const R = _.indexOf(w.currentTarget);
                _ = h.loop ? jfe(_, R + 1) : _.slice(R + 1);
              }
              setTimeout(() => $z(_));
            }
          }),
          children:
            typeof a == "function"
              ? a({ isCurrentTabStop: m, hasTabStop: b != null })
              : a,
        }),
      })
    );
  });
Uz.displayName = Fz;
var Mfe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last",
};
function Nfe(n, e) {
  return e !== "rtl"
    ? n
    : n === "ArrowLeft"
    ? "ArrowRight"
    : n === "ArrowRight"
    ? "ArrowLeft"
    : n;
}
function Ofe(n, e, t) {
  const s = Nfe(n.key, t);
  if (
    !(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(s)) &&
    !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(s))
  )
    return Mfe[s];
}
function $z(n, e = !1) {
  const t = document.activeElement;
  for (const s of n)
    if (
      s === t ||
      (s.focus({ preventScroll: e }), document.activeElement !== t)
    )
      return;
}
function jfe(n, e) {
  return n.map((t, s) => n[(e + s) % n.length]);
}
var Ffe = jz,
  Ufe = Uz,
  hk = ["Enter", " "],
  $fe = ["ArrowDown", "PageUp", "Home"],
  Bz = ["ArrowUp", "PageDown", "End"],
  Bfe = [...$fe, ...Bz],
  Hfe = { ltr: [...hk, "ArrowRight"], rtl: [...hk, "ArrowLeft"] },
  Vfe = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] },
  Pv = "Menu",
  [Ug, zfe, Gfe] = Tv(Pv),
  [ud, Hz] = Pr(Pv, [Gfe, Gc, Oz]),
  Mv = Gc(),
  Vz = Oz(),
  [zz, qc] = ud(Pv),
  [qfe, Nv] = ud(Pv),
  Gz = (n) => {
    const {
        __scopeMenu: e,
        open: t = !1,
        children: s,
        dir: r,
        onOpenChange: i,
        modal: a = !0,
      } = n,
      o = Mv(e),
      [l, c] = E.useState(null),
      h = E.useRef(!1),
      m = ua(i),
      p = _v(r);
    return (
      E.useEffect(() => {
        const g = () => {
            (h.current = !0),
              document.addEventListener("pointerdown", y, {
                capture: !0,
                once: !0,
              }),
              document.addEventListener("pointermove", y, {
                capture: !0,
                once: !0,
              });
          },
          y = () => (h.current = !1);
        return (
          document.addEventListener("keydown", g, { capture: !0 }),
          () => {
            document.removeEventListener("keydown", g, { capture: !0 }),
              document.removeEventListener("pointerdown", y, { capture: !0 }),
              document.removeEventListener("pointermove", y, { capture: !0 });
          }
        );
      }, []),
      u.jsx(Cv, {
        ...o,
        children: u.jsx(zz, {
          scope: e,
          open: t,
          onOpenChange: m,
          content: l,
          onContentChange: c,
          children: u.jsx(qfe, {
            scope: e,
            onClose: E.useCallback(() => m(!1), [m]),
            isUsingKeyboardRef: h,
            dir: p,
            modal: a,
            children: s,
          }),
        }),
      })
    );
  };
Gz.displayName = Pv;
var Wfe = "MenuAnchor",
  zL = E.forwardRef((n, e) => {
    const { __scopeMenu: t, ...s } = n,
      r = Mv(t);
    return u.jsx(Iv, { ...r, ...s, ref: e });
  });
zL.displayName = Wfe;
var GL = "MenuPortal",
  [Kfe, qz] = ud(GL, { forceMount: void 0 }),
  Wz = (n) => {
    const { __scopeMenu: e, forceMount: t, children: s, container: r } = n,
      i = qc(GL, e);
    return u.jsx(Kfe, {
      scope: e,
      forceMount: t,
      children: u.jsx(Pi, {
        present: t || i.open,
        children: u.jsx(Hf, { asChild: !0, container: r, children: s }),
      }),
    });
  };
Wz.displayName = GL;
var aa = "MenuContent",
  [Yfe, qL] = ud(aa),
  Kz = E.forwardRef((n, e) => {
    const t = qz(aa, n.__scopeMenu),
      { forceMount: s = t.forceMount, ...r } = n,
      i = qc(aa, n.__scopeMenu),
      a = Nv(aa, n.__scopeMenu);
    return u.jsx(Ug.Provider, {
      scope: n.__scopeMenu,
      children: u.jsx(Pi, {
        present: s || i.open,
        children: u.jsx(Ug.Slot, {
          scope: n.__scopeMenu,
          children: a.modal
            ? u.jsx(Xfe, { ...r, ref: e })
            : u.jsx(Qfe, { ...r, ref: e }),
        }),
      }),
    });
  }),
  Xfe = E.forwardRef((n, e) => {
    const t = qc(aa, n.__scopeMenu),
      s = E.useRef(null),
      r = Nt(e, s);
    return (
      E.useEffect(() => {
        const i = s.current;
        if (i) return _E(i);
      }, []),
      u.jsx(WL, {
        ...n,
        ref: r,
        trapFocus: t.open,
        disableOutsidePointerEvents: t.open,
        disableOutsideScroll: !0,
        onFocusOutside: qe(n.onFocusOutside, (i) => i.preventDefault(), {
          checkForDefaultPrevented: !1,
        }),
        onDismiss: () => t.onOpenChange(!1),
      })
    );
  }),
  Qfe = E.forwardRef((n, e) => {
    const t = qc(aa, n.__scopeMenu);
    return u.jsx(WL, {
      ...n,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => t.onOpenChange(!1),
    });
  }),
  Zfe = Mc("MenuContent.ScrollLock"),
  WL = E.forwardRef((n, e) => {
    const {
        __scopeMenu: t,
        loop: s = !1,
        trapFocus: r,
        onOpenAutoFocus: i,
        onCloseAutoFocus: a,
        disableOutsidePointerEvents: o,
        onEntryFocus: l,
        onEscapeKeyDown: c,
        onPointerDownOutside: h,
        onFocusOutside: m,
        onInteractOutside: p,
        onDismiss: g,
        disableOutsideScroll: y,
        ...b
      } = n,
      w = qc(aa, t),
      S = Nv(aa, t),
      A = Mv(t),
      _ = Vz(t),
      R = zfe(t),
      [C, D] = E.useState(null),
      L = E.useRef(null),
      P = Nt(e, L, w.onContentChange),
      V = E.useRef(0),
      N = E.useRef(""),
      W = E.useRef(0),
      H = E.useRef(null),
      z = E.useRef("right"),
      B = E.useRef(0),
      q = y ? Rv : E.Fragment,
      O = y ? { as: Zfe, allowPinchZoom: !0 } : void 0,
      U = (Q) => {
        const M = N.current + Q,
          I = R().filter((te) => !te.disabled),
          F = document.activeElement,
          Y = I.find((te) => te.ref.current === F)?.textValue,
          J = I.map((te) => te.textValue),
          X = ume(J, M, Y),
          Z = I.find((te) => te.textValue === X)?.ref.current;
        (function te(ce) {
          (N.current = ce),
            window.clearTimeout(V.current),
            ce !== "" && (V.current = window.setTimeout(() => te(""), 1e3));
        })(M),
          Z && setTimeout(() => Z.focus());
      };
    E.useEffect(() => () => window.clearTimeout(V.current), []), SE();
    const j = E.useCallback(
      (Q) => z.current === H.current?.side && hme(Q, H.current?.area),
      []
    );
    return u.jsx(Yfe, {
      scope: t,
      searchRef: N,
      onItemEnter: E.useCallback(
        (Q) => {
          j(Q) && Q.preventDefault();
        },
        [j]
      ),
      onItemLeave: E.useCallback(
        (Q) => {
          j(Q) || (L.current?.focus(), D(null));
        },
        [j]
      ),
      onTriggerLeave: E.useCallback(
        (Q) => {
          j(Q) && Q.preventDefault();
        },
        [j]
      ),
      pointerGraceTimerRef: W,
      onPointerGraceIntentChange: E.useCallback((Q) => {
        H.current = Q;
      }, []),
      children: u.jsx(q, {
        ...O,
        children: u.jsx(Av, {
          asChild: !0,
          trapped: r,
          onMountAutoFocus: qe(i, (Q) => {
            Q.preventDefault(), L.current?.focus({ preventScroll: !0 });
          }),
          onUnmountAutoFocus: a,
          children: u.jsx(Bf, {
            asChild: !0,
            disableOutsidePointerEvents: o,
            onEscapeKeyDown: c,
            onPointerDownOutside: h,
            onFocusOutside: m,
            onInteractOutside: p,
            onDismiss: g,
            children: u.jsx(Ffe, {
              asChild: !0,
              ..._,
              dir: S.dir,
              orientation: "vertical",
              loop: s,
              currentTabStopId: C,
              onCurrentTabStopIdChange: D,
              onEntryFocus: qe(l, (Q) => {
                S.isUsingKeyboardRef.current || Q.preventDefault();
              }),
              preventScrollOnEntryFocus: !0,
              children: u.jsx(LE, {
                role: "menu",
                "aria-orientation": "vertical",
                "data-state": dG(w.open),
                "data-radix-menu-content": "",
                dir: S.dir,
                ...A,
                ...b,
                ref: P,
                style: { outline: "none", ...b.style },
                onKeyDown: qe(b.onKeyDown, (Q) => {
                  const I =
                      Q.target.closest("[data-radix-menu-content]") ===
                      Q.currentTarget,
                    F = Q.ctrlKey || Q.altKey || Q.metaKey,
                    Y = Q.key.length === 1;
                  I &&
                    (Q.key === "Tab" && Q.preventDefault(),
                    !F && Y && U(Q.key));
                  const J = L.current;
                  if (Q.target !== J || !Bfe.includes(Q.key)) return;
                  Q.preventDefault();
                  const Z = R()
                    .filter((te) => !te.disabled)
                    .map((te) => te.ref.current);
                  Bz.includes(Q.key) && Z.reverse(), lme(Z);
                }),
                onBlur: qe(n.onBlur, (Q) => {
                  Q.currentTarget.contains(Q.target) ||
                    (window.clearTimeout(V.current), (N.current = ""));
                }),
                onPointerMove: qe(
                  n.onPointerMove,
                  $g((Q) => {
                    const M = Q.target,
                      I = B.current !== Q.clientX;
                    if (Q.currentTarget.contains(M) && I) {
                      const F = Q.clientX > B.current ? "right" : "left";
                      (z.current = F), (B.current = Q.clientX);
                    }
                  })
                ),
              }),
            }),
          }),
        }),
      }),
    });
  });
Kz.displayName = aa;
var Jfe = "MenuGroup",
  KL = E.forwardRef((n, e) => {
    const { __scopeMenu: t, ...s } = n;
    return u.jsx(Et.div, { role: "group", ...s, ref: e });
  });
KL.displayName = Jfe;
var eme = "MenuLabel",
  Yz = E.forwardRef((n, e) => {
    const { __scopeMenu: t, ...s } = n;
    return u.jsx(Et.div, { ...s, ref: e });
  });
Yz.displayName = eme;
var Fx = "MenuItem",
  i3 = "menu.itemSelect",
  NE = E.forwardRef((n, e) => {
    const { disabled: t = !1, onSelect: s, ...r } = n,
      i = E.useRef(null),
      a = Nv(Fx, n.__scopeMenu),
      o = qL(Fx, n.__scopeMenu),
      l = Nt(e, i),
      c = E.useRef(!1),
      h = () => {
        const m = i.current;
        if (!t && m) {
          const p = new CustomEvent(i3, { bubbles: !0, cancelable: !0 });
          m.addEventListener(i3, (g) => s?.(g), { once: !0 }),
            UH(m, p),
            p.defaultPrevented ? (c.current = !1) : a.onClose();
        }
      };
    return u.jsx(Xz, {
      ...r,
      ref: l,
      disabled: t,
      onClick: qe(n.onClick, h),
      onPointerDown: (m) => {
        n.onPointerDown?.(m), (c.current = !0);
      },
      onPointerUp: qe(n.onPointerUp, (m) => {
        c.current || m.currentTarget?.click();
      }),
      onKeyDown: qe(n.onKeyDown, (m) => {
        const p = o.searchRef.current !== "";
        t ||
          (p && m.key === " ") ||
          (hk.includes(m.key) && (m.currentTarget.click(), m.preventDefault()));
      }),
    });
  });
NE.displayName = Fx;
var Xz = E.forwardRef((n, e) => {
    const { __scopeMenu: t, disabled: s = !1, textValue: r, ...i } = n,
      a = qL(Fx, t),
      o = Vz(t),
      l = E.useRef(null),
      c = Nt(e, l),
      [h, m] = E.useState(!1),
      [p, g] = E.useState("");
    return (
      E.useEffect(() => {
        const y = l.current;
        y && g((y.textContent ?? "").trim());
      }, [i.children]),
      u.jsx(Ug.ItemSlot, {
        scope: t,
        disabled: s,
        textValue: r ?? p,
        children: u.jsx(Ufe, {
          asChild: !0,
          ...o,
          focusable: !s,
          children: u.jsx(Et.div, {
            role: "menuitem",
            "data-highlighted": h ? "" : void 0,
            "aria-disabled": s || void 0,
            "data-disabled": s ? "" : void 0,
            ...i,
            ref: c,
            onPointerMove: qe(
              n.onPointerMove,
              $g((y) => {
                s
                  ? a.onItemLeave(y)
                  : (a.onItemEnter(y),
                    y.defaultPrevented ||
                      y.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: qe(
              n.onPointerLeave,
              $g((y) => a.onItemLeave(y))
            ),
            onFocus: qe(n.onFocus, () => m(!0)),
            onBlur: qe(n.onBlur, () => m(!1)),
          }),
        }),
      })
    );
  }),
  tme = "MenuCheckboxItem",
  Qz = E.forwardRef((n, e) => {
    const { checked: t = !1, onCheckedChange: s, ...r } = n;
    return u.jsx(nG, {
      scope: n.__scopeMenu,
      checked: t,
      children: u.jsx(NE, {
        role: "menuitemcheckbox",
        "aria-checked": Ux(t) ? "mixed" : t,
        ...r,
        ref: e,
        "data-state": QL(t),
        onSelect: qe(r.onSelect, () => s?.(Ux(t) ? !0 : !t), {
          checkForDefaultPrevented: !1,
        }),
      }),
    });
  });
Qz.displayName = tme;
var Zz = "MenuRadioGroup",
  [nme, sme] = ud(Zz, { value: void 0, onValueChange: () => {} }),
  Jz = E.forwardRef((n, e) => {
    const { value: t, onValueChange: s, ...r } = n,
      i = ua(s);
    return u.jsx(nme, {
      scope: n.__scopeMenu,
      value: t,
      onValueChange: i,
      children: u.jsx(KL, { ...r, ref: e }),
    });
  });
Jz.displayName = Zz;
var eG = "MenuRadioItem",
  tG = E.forwardRef((n, e) => {
    const { value: t, ...s } = n,
      r = sme(eG, n.__scopeMenu),
      i = t === r.value;
    return u.jsx(nG, {
      scope: n.__scopeMenu,
      checked: i,
      children: u.jsx(NE, {
        role: "menuitemradio",
        "aria-checked": i,
        ...s,
        ref: e,
        "data-state": QL(i),
        onSelect: qe(s.onSelect, () => r.onValueChange?.(t), {
          checkForDefaultPrevented: !1,
        }),
      }),
    });
  });
tG.displayName = eG;
var YL = "MenuItemIndicator",
  [nG, rme] = ud(YL, { checked: !1 }),
  sG = E.forwardRef((n, e) => {
    const { __scopeMenu: t, forceMount: s, ...r } = n,
      i = rme(YL, t);
    return u.jsx(Pi, {
      present: s || Ux(i.checked) || i.checked === !0,
      children: u.jsx(Et.span, { ...r, ref: e, "data-state": QL(i.checked) }),
    });
  });
sG.displayName = YL;
var ime = "MenuSeparator",
  rG = E.forwardRef((n, e) => {
    const { __scopeMenu: t, ...s } = n;
    return u.jsx(Et.div, {
      role: "separator",
      "aria-orientation": "horizontal",
      ...s,
      ref: e,
    });
  });
rG.displayName = ime;
var ame = "MenuArrow",
  iG = E.forwardRef((n, e) => {
    const { __scopeMenu: t, ...s } = n,
      r = Mv(t);
    return u.jsx(DE, { ...r, ...s, ref: e });
  });
iG.displayName = ame;
var XL = "MenuSub",
  [ome, aG] = ud(XL),
  oG = (n) => {
    const { __scopeMenu: e, children: t, open: s = !1, onOpenChange: r } = n,
      i = qc(XL, e),
      a = Mv(e),
      [o, l] = E.useState(null),
      [c, h] = E.useState(null),
      m = ua(r);
    return (
      E.useEffect(() => (i.open === !1 && m(!1), () => m(!1)), [i.open, m]),
      u.jsx(Cv, {
        ...a,
        children: u.jsx(zz, {
          scope: e,
          open: s,
          onOpenChange: m,
          content: c,
          onContentChange: h,
          children: u.jsx(ome, {
            scope: e,
            contentId: $r(),
            triggerId: $r(),
            trigger: o,
            onTriggerChange: l,
            children: t,
          }),
        }),
      })
    );
  };
oG.displayName = XL;
var Rp = "MenuSubTrigger",
  lG = E.forwardRef((n, e) => {
    const t = qc(Rp, n.__scopeMenu),
      s = Nv(Rp, n.__scopeMenu),
      r = aG(Rp, n.__scopeMenu),
      i = qL(Rp, n.__scopeMenu),
      a = E.useRef(null),
      { pointerGraceTimerRef: o, onPointerGraceIntentChange: l } = i,
      c = { __scopeMenu: n.__scopeMenu },
      h = E.useCallback(() => {
        a.current && window.clearTimeout(a.current), (a.current = null);
      }, []);
    return (
      E.useEffect(() => h, [h]),
      E.useEffect(() => {
        const m = o.current;
        return () => {
          window.clearTimeout(m), l(null);
        };
      }, [o, l]),
      u.jsx(zL, {
        asChild: !0,
        ...c,
        children: u.jsx(Xz, {
          id: r.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": t.open,
          "aria-controls": r.contentId,
          "data-state": dG(t.open),
          ...n,
          ref: bE(e, r.onTriggerChange),
          onClick: (m) => {
            n.onClick?.(m),
              !(n.disabled || m.defaultPrevented) &&
                (m.currentTarget.focus(), t.open || t.onOpenChange(!0));
          },
          onPointerMove: qe(
            n.onPointerMove,
            $g((m) => {
              i.onItemEnter(m),
                !m.defaultPrevented &&
                  !n.disabled &&
                  !t.open &&
                  !a.current &&
                  (i.onPointerGraceIntentChange(null),
                  (a.current = window.setTimeout(() => {
                    t.onOpenChange(!0), h();
                  }, 100)));
            })
          ),
          onPointerLeave: qe(
            n.onPointerLeave,
            $g((m) => {
              h();
              const p = t.content?.getBoundingClientRect();
              if (p) {
                const g = t.content?.dataset.side,
                  y = g === "right",
                  b = y ? -5 : 5,
                  w = p[y ? "left" : "right"],
                  S = p[y ? "right" : "left"];
                i.onPointerGraceIntentChange({
                  area: [
                    { x: m.clientX + b, y: m.clientY },
                    { x: w, y: p.top },
                    { x: S, y: p.top },
                    { x: S, y: p.bottom },
                    { x: w, y: p.bottom },
                  ],
                  side: g,
                }),
                  window.clearTimeout(o.current),
                  (o.current = window.setTimeout(
                    () => i.onPointerGraceIntentChange(null),
                    300
                  ));
              } else {
                if ((i.onTriggerLeave(m), m.defaultPrevented)) return;
                i.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: qe(n.onKeyDown, (m) => {
            const p = i.searchRef.current !== "";
            n.disabled ||
              (p && m.key === " ") ||
              (Hfe[s.dir].includes(m.key) &&
                (t.onOpenChange(!0), t.content?.focus(), m.preventDefault()));
          }),
        }),
      })
    );
  });
lG.displayName = Rp;
var cG = "MenuSubContent",
  uG = E.forwardRef((n, e) => {
    const t = qz(aa, n.__scopeMenu),
      { forceMount: s = t.forceMount, ...r } = n,
      i = qc(aa, n.__scopeMenu),
      a = Nv(aa, n.__scopeMenu),
      o = aG(cG, n.__scopeMenu),
      l = E.useRef(null),
      c = Nt(e, l);
    return u.jsx(Ug.Provider, {
      scope: n.__scopeMenu,
      children: u.jsx(Pi, {
        present: s || i.open,
        children: u.jsx(Ug.Slot, {
          scope: n.__scopeMenu,
          children: u.jsx(WL, {
            id: o.contentId,
            "aria-labelledby": o.triggerId,
            ...r,
            ref: c,
            align: "start",
            side: a.dir === "rtl" ? "left" : "right",
            disableOutsidePointerEvents: !1,
            disableOutsideScroll: !1,
            trapFocus: !1,
            onOpenAutoFocus: (h) => {
              a.isUsingKeyboardRef.current && l.current?.focus(),
                h.preventDefault();
            },
            onCloseAutoFocus: (h) => h.preventDefault(),
            onFocusOutside: qe(n.onFocusOutside, (h) => {
              h.target !== o.trigger && i.onOpenChange(!1);
            }),
            onEscapeKeyDown: qe(n.onEscapeKeyDown, (h) => {
              a.onClose(), h.preventDefault();
            }),
            onKeyDown: qe(n.onKeyDown, (h) => {
              const m = h.currentTarget.contains(h.target),
                p = Vfe[a.dir].includes(h.key);
              m &&
                p &&
                (i.onOpenChange(!1), o.trigger?.focus(), h.preventDefault());
            }),
          }),
        }),
      }),
    });
  });
uG.displayName = cG;
function dG(n) {
  return n ? "open" : "closed";
}
function Ux(n) {
  return n === "indeterminate";
}
function QL(n) {
  return Ux(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
function lme(n) {
  const e = document.activeElement;
  for (const t of n)
    if (t === e || (t.focus(), document.activeElement !== e)) return;
}
function cme(n, e) {
  return n.map((t, s) => n[(e + s) % n.length]);
}
function ume(n, e, t) {
  const r = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e,
    i = t ? n.indexOf(t) : -1;
  let a = cme(n, Math.max(i, 0));
  r.length === 1 && (a = a.filter((c) => c !== t));
  const l = a.find((c) => c.toLowerCase().startsWith(r.toLowerCase()));
  return l !== t ? l : void 0;
}
function dme(n, e) {
  const { x: t, y: s } = n;
  let r = !1;
  for (let i = 0, a = e.length - 1; i < e.length; a = i++) {
    const o = e[i],
      l = e[a],
      c = o.x,
      h = o.y,
      m = l.x,
      p = l.y;
    h > s != p > s && t < ((m - c) * (s - h)) / (p - h) + c && (r = !r);
  }
  return r;
}
function hme(n, e) {
  if (!e) return !1;
  const t = { x: n.clientX, y: n.clientY };
  return dme(t, e);
}
function $g(n) {
  return (e) => (e.pointerType === "mouse" ? n(e) : void 0);
}
var fme = Gz,
  mme = zL,
  pme = Wz,
  gme = Kz,
  vme = KL,
  yme = Yz,
  bme = NE,
  xme = Qz,
  wme = Jz,
  Eme = tG,
  Sme = sG,
  Tme = rG,
  _me = iG,
  Ame = oG,
  Rme = lG,
  kme = uG,
  OE = "DropdownMenu",
  [Cme, ZMe] = Pr(OE, [Hz]),
  Mr = Hz(),
  [Ime, hG] = Cme(OE),
  fG = (n) => {
    const {
        __scopeDropdownMenu: e,
        children: t,
        dir: s,
        open: r,
        defaultOpen: i,
        onOpenChange: a,
        modal: o = !0,
      } = n,
      l = Mr(e),
      c = E.useRef(null),
      [h, m] = ci({ prop: r, defaultProp: i ?? !1, onChange: a, caller: OE });
    return u.jsx(Ime, {
      scope: e,
      triggerId: $r(),
      triggerRef: c,
      contentId: $r(),
      open: h,
      onOpenChange: m,
      onOpenToggle: E.useCallback(() => m((p) => !p), [m]),
      modal: o,
      children: u.jsx(fme, {
        ...l,
        open: h,
        onOpenChange: m,
        dir: s,
        modal: o,
        children: t,
      }),
    });
  };
fG.displayName = OE;
var mG = "DropdownMenuTrigger",
  pG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, disabled: s = !1, ...r } = n,
      i = hG(mG, t),
      a = Mr(t);
    return u.jsx(mme, {
      asChild: !0,
      ...a,
      children: u.jsx(Et.button, {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": s ? "" : void 0,
        disabled: s,
        ...r,
        ref: bE(e, i.triggerRef),
        onPointerDown: qe(n.onPointerDown, (o) => {
          !s &&
            o.button === 0 &&
            o.ctrlKey === !1 &&
            (i.onOpenToggle(), i.open || o.preventDefault());
        }),
        onKeyDown: qe(n.onKeyDown, (o) => {
          s ||
            (["Enter", " "].includes(o.key) && i.onOpenToggle(),
            o.key === "ArrowDown" && i.onOpenChange(!0),
            ["Enter", " ", "ArrowDown"].includes(o.key) && o.preventDefault());
        }),
      }),
    });
  });
pG.displayName = mG;
var Lme = "DropdownMenuPortal",
  gG = (n) => {
    const { __scopeDropdownMenu: e, ...t } = n,
      s = Mr(e);
    return u.jsx(pme, { ...s, ...t });
  };
gG.displayName = Lme;
var vG = "DropdownMenuContent",
  yG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = hG(vG, t),
      i = Mr(t),
      a = E.useRef(!1);
    return u.jsx(gme, {
      id: r.contentId,
      "aria-labelledby": r.triggerId,
      ...i,
      ...s,
      ref: e,
      onCloseAutoFocus: qe(n.onCloseAutoFocus, (o) => {
        a.current || r.triggerRef.current?.focus(),
          (a.current = !1),
          o.preventDefault();
      }),
      onInteractOutside: qe(n.onInteractOutside, (o) => {
        const l = o.detail.originalEvent,
          c = l.button === 0 && l.ctrlKey === !0,
          h = l.button === 2 || c;
        (!r.modal || h) && (a.current = !0);
      }),
      style: {
        ...n.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
yG.displayName = vG;
var Dme = "DropdownMenuGroup",
  Pme = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(vme, { ...r, ...s, ref: e });
  });
Pme.displayName = Dme;
var Mme = "DropdownMenuLabel",
  bG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(yme, { ...r, ...s, ref: e });
  });
bG.displayName = Mme;
var Nme = "DropdownMenuItem",
  xG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(bme, { ...r, ...s, ref: e });
  });
xG.displayName = Nme;
var Ome = "DropdownMenuCheckboxItem",
  wG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(xme, { ...r, ...s, ref: e });
  });
wG.displayName = Ome;
var jme = "DropdownMenuRadioGroup",
  Fme = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(wme, { ...r, ...s, ref: e });
  });
Fme.displayName = jme;
var Ume = "DropdownMenuRadioItem",
  EG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(Eme, { ...r, ...s, ref: e });
  });
EG.displayName = Ume;
var $me = "DropdownMenuItemIndicator",
  SG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(Sme, { ...r, ...s, ref: e });
  });
SG.displayName = $me;
var Bme = "DropdownMenuSeparator",
  TG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(Tme, { ...r, ...s, ref: e });
  });
TG.displayName = Bme;
var Hme = "DropdownMenuArrow",
  Vme = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(_me, { ...r, ...s, ref: e });
  });
Vme.displayName = Hme;
var zme = (n) => {
    const {
        __scopeDropdownMenu: e,
        children: t,
        open: s,
        onOpenChange: r,
        defaultOpen: i,
      } = n,
      a = Mr(e),
      [o, l] = ci({
        prop: s,
        defaultProp: i ?? !1,
        onChange: r,
        caller: "DropdownMenuSub",
      });
    return u.jsx(Ame, { ...a, open: o, onOpenChange: l, children: t });
  },
  Gme = "DropdownMenuSubTrigger",
  _G = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(Rme, { ...r, ...s, ref: e });
  });
_G.displayName = Gme;
var qme = "DropdownMenuSubContent",
  AG = E.forwardRef((n, e) => {
    const { __scopeDropdownMenu: t, ...s } = n,
      r = Mr(t);
    return u.jsx(kme, {
      ...r,
      ...s,
      ref: e,
      style: {
        ...n.style,
        "--radix-dropdown-menu-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width":
          "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height":
          "var(--radix-popper-anchor-height)",
      },
    });
  });
AG.displayName = qme;
var Wme = fG,
  Kme = pG,
  Yme = gG,
  RG = yG,
  kG = bG,
  CG = xG,
  IG = wG,
  LG = EG,
  Xme = SG,
  DG = TG,
  Qme = zme,
  PG = _G,
  MG = AG;
const Ii = Wme,
  Li = Kme,
  ZL = Qme,
  jE = E.forwardRef(({ className: n, inset: e, children: t, ...s }, r) =>
    u.jsxs(PG, {
      ref: r,
      className: Le(
        "flex cursor-default select-none items-center px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        e && "pl-8",
        n
      ),
      ...s,
      children: [t, u.jsx(ile, { className: "ml-auto h-4 w-4" })],
    })
  );
jE.displayName = PG.displayName;
const FE = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(MG, {
    ref: t,
    className: Le(
      "z-50 min-w-[8rem] overflow-hidden rounded border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      n
    ),
    ...e,
  })
);
FE.displayName = MG.displayName;
const ui = E.forwardRef(({ className: n, sideOffset: e = 4, ...t }, s) =>
  u.jsx(Yme, {
    children: u.jsx(RG, {
      ref: s,
      sideOffset: e,
      className: Le(
        "z-50 min-w-[8rem] overflow-hidden rounded-xl border border-border bg-inbetween-background p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        n
      ),
      ...t,
    }),
  })
);
ui.displayName = RG.displayName;
const jn = E.forwardRef(({ className: n, inset: e, ...t }, s) =>
  u.jsx(CG, {
    ref: s,
    className: Le(
      "relative flex cursor-default select-none items-center rounded px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      e && "pl-8",
      n
    ),
    ...t,
  })
);
jn.displayName = CG.displayName;
const Zme = E.forwardRef(({ className: n, children: e, checked: t, ...s }, r) =>
  u.jsxs(IG, {
    ref: r,
    className: Le(
      "relative flex cursor-default select-none items-center rounded-xl py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      n
    ),
    checked: t,
    ...s,
    children: [
      u.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: u.jsx(Xme, { children: u.jsx(zs, { className: "h-4 w-4" }) }),
      }),
      e,
    ],
  })
);
Zme.displayName = IG.displayName;
const Jme = E.forwardRef(({ className: n, children: e, ...t }, s) =>
  u.jsx(LG, {
    ref: s,
    className: Le(
      "relative flex cursor-default select-none items-center rounded-xl py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      n
    ),
    ...t,
    children: e,
  })
);
Jme.displayName = LG.displayName;
const epe = E.forwardRef(({ className: n, inset: e, ...t }, s) =>
  u.jsx(kG, {
    ref: s,
    className: Le("px-2 py-1.5 text-sm font-semibold", e && "pl-8", n),
    ...t,
  })
);
epe.displayName = kG.displayName;
const Bg = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(DG, { ref: t, className: Le("-mx-1 my-1 h-px bg-muted", n), ...e })
);
Bg.displayName = DG.displayName;
const tpe = () => {
    const n = es(),
      { user: e } = ks(),
      t = Pt((ge) => ge.currentTeam),
      s = Pt((ge) => ge.isLoadingTeams),
      r = Pt((ge) => ge.createNewFlask),
      i = t?.team_type === "free_team",
      a = s,
      o = E.useRef(null),
      l = E.useRef(null),
      [c, h] = E.useState(""),
      [m, p] = E.useState([]),
      [g, y] = E.useState(!1),
      [b, w] = E.useState(0),
      [S, A] = E.useState(0),
      [_, R] = E.useState(!1),
      [C, D] = E.useState(!1),
      [L, P] = E.useState([]),
      [V, N] = E.useState(new Set()),
      [W, H] = E.useState(!1),
      [z, B] = E.useState(new Map()),
      [q, O] = E.useState(null),
      U = 10,
      j = 20 * 1024 * 1024 * 1024,
      [Q, M] = E.useState(!1),
      [I, F] = E.useState(!1),
      [Y, J] = E.useState(!1),
      [X, Z] = E.useState(!1),
      [te, ce] = E.useState(!1),
      [pe, se] = E.useState(!1),
      be = (ge) => {
        const re = Array.from(ge.target.files || []);
        if (re.length === 0) return;
        if (re.length > U) {
          Ms({
            title: "Too many files",
            description: `Maximum ${U} files allowed`,
            variant: "destructive",
          }),
            o.current && (o.current.value = "");
          return;
        }
        if (re.filter((ne) => !ne.type.startsWith("video/")).length > 0) {
          Ms({
            title: "Invalid files",
            description: "Please select only video files",
            variant: "destructive",
          }),
            o.current && (o.current.value = "");
          return;
        }
        if (re.reduce((ne, ie) => ne + ie.size, 0) > j) {
          Ms({
            title: "Files too large",
            description: "Total size cannot exceed 20GB",
            variant: "destructive",
          }),
            o.current && (o.current.value = "");
          return;
        }
        p(re), h("");
      },
      K = async () => {
        if (m.length === 0 || !e) return;
        R(!0), w(0), A(0);
        const ge = [],
          re = new Map();
        try {
          for (let fe = 0; fe < m.length; fe++) {
            const ke = m[fe];
            A(fe), w(0);
            const ne = await Ut("/api/mux/upload/create", {
              method: "POST",
              body: JSON.stringify({ title: ke.name }),
            });
            if (!ne.ok)
              throw new Error(`Failed to create upload for ${ke.name}`);
            const { uploadUrl: ie, assetId: Ne } = await ne.json();
            ge.push(Ne),
              await new Promise(($e, ot) => {
                const st = new XMLHttpRequest();
                O(st),
                  st.upload.addEventListener("progress", (ht) => {
                    ht.lengthComputable && w((ht.loaded / ht.total) * 100);
                  }),
                  st.addEventListener("load", () => {
                    st.status === 200 || st.status === 201
                      ? $e()
                      : ot(new Error(`Upload failed with status ${st.status}`)),
                      O(null);
                  }),
                  st.addEventListener("error", () => {
                    ot(new Error("Upload failed")), O(null);
                  }),
                  st.addEventListener("abort", () => {
                    ot(new Error("Upload cancelled")), O(null);
                  }),
                  st.open("PUT", ie),
                  st.setRequestHeader("Content-Type", ke.type),
                  st.send(ke);
              });
          }
          P(ge), R(!1), D(!0), N(new Set());
          for (const fe of ge) {
            const ke = setInterval(async () => {
              try {
                const ne = await Ut(`/api/assets/${fe}`);
                if (ne.ok) {
                  const ie = await ne.json();
                  ie.asset &&
                    ie.asset.status === "ready" &&
                    (clearInterval(ke),
                    re.delete(fe),
                    N((Ne) => new Set([...Ne, fe])),
                    N((Ne) => {
                      const $e = new Set([...Ne, fe]);
                      return (
                        $e.size === ge.length && (D(!1), H(!0), ve(ge)), $e
                      );
                    }));
                }
              } catch (ne) {
                console.error(`Error checking asset ${fe} status:`, ne);
              }
            }, 2e3);
            re.set(fe, ke);
          }
          B(re);
        } catch (fe) {
          console.error("Upload error:", fe),
            re.forEach((ke) => clearInterval(ke)),
            Ms({
              title: "Upload Failed",
              description:
                fe instanceof Error
                  ? fe.message
                  : "Failed to upload videos. Please try again.",
              variant: "destructive",
            }),
            R(!1),
            D(!1),
            w(0),
            P([]),
            N(new Set());
        }
      },
      ve = async (ge) => {
        if (e?.id)
          try {
            let re;
            m.length === 1
              ? (re = m[0].name)
              : (re = `New Flask (${m.length} assets)`);
            const fe = await r({ userId: e.id, name: re, assetIds: ge });
            if (!fe) throw new Error("Failed to create flask");
            J(!0),
              setTimeout(() => {
                n(`/flask/${fe.id}`);
              }, 1500);
          } catch (re) {
            console.error("Error creating flask:", re),
              Ms({
                title: "Error",
                description: "Failed to create flask. Please try again.",
                variant: "destructive",
              });
          } finally {
            H(!1);
          }
      },
      Ee = async () => {
        window.confirm("Are you sure you want to cancel the upload?") &&
          (q && q.abort(),
          z.forEach((re) => clearInterval(re)),
          B(new Map()),
          R(!1),
          D(!1),
          w(0),
          P([]),
          N(new Set()),
          p([]),
          O(null),
          A(0),
          o.current && (o.current.value = ""));
      };
    de.useEffect(
      () => () => {
        z.forEach((ge) => clearInterval(ge)), J(!1);
      },
      [z]
    );
    const De = async () => {
      if (!e) {
        M(!0);
        return;
      }
      if (m.length > 0) {
        if (i && !a) {
          y(!0);
          return;
        }
        if (L.length === 0) {
          await K();
          return;
        }
        if (C || (L.length > 0 && V.size < L.length)) return;
      } else if (!c.trim()) return;
      H(!0);
      try {
        if (c.trim() && m.length === 0) {
          const ge = await Aue(c);
          if (!ge.valid) {
            Ms({
              title: "Invalid YouTube URL",
              description:
                "error" in ge ? ge.error : "Please enter a valid YouTube URL",
              variant: "destructive",
            }),
              ce(!0),
              setTimeout(() => ce(!1), 3e3),
              H(!1);
            return;
          }
          const re = await r({
            userId: e.id,
            youtubeUrl: c,
            name: ge.title || "YouTube Video",
            thumbnail: ge.thumbnail,
          });
          if (!re) throw new Error("Failed to create flask");
          J(!0),
            setTimeout(() => {
              n(`/flask/${re.id}`);
            }, 1500);
        } else if (L.length > 0 && V.size === L.length) {
          await ve(L);
          return;
        } else throw new Error("No valid input for flask creation");
      } catch (ge) {
        console.error("Error creating flask:", ge),
          Ms({
            title: "Error",
            description: "Failed to create flask. Please try again.",
            variant: "destructive",
          });
      } finally {
        H(!1);
      }
    };
    return u.jsxs("div", {
      className:
        "w-full md:w-auto flex flex-col items-center gap-4 px-4 md:px-0",
      children: [
        u.jsx("div", {
          className: "flex flex-col items-center w-full md:w-auto",
          children: u.jsx("div", {
            className:
              "relative flex items-center justify-center w-full md:w-auto",
            children: u.jsx("div", {
              className: "relative w-full md:w-auto",
              children: u.jsxs("div", {
                className:
                  "h-[48px] md:h-[64px] rounded-full md:max-w-[600px] bg-element-background/50 bg-gradient-to-t from-element-background via-element-background to-text-primary/5  border-t border-text-primary/30 shadow-2xl flex items-center p-1.5 w-full",
                children: [
                  u.jsxs(Ii, {
                    onOpenChange: se,
                    children: [
                      u.jsx(Li, {
                        asChild: !0,
                        children: u.jsx("div", {
                          className: "cursor-pointer",
                          children: u.jsx(Ig, {
                            className:
                              "mr-2 md:mr-4 z-10 ml-3 md:ml-6 scale-75 md:scale-100",
                            isOpen: pe,
                          }),
                        }),
                      }),
                      u.jsxs(ui, {
                        align: "start",
                        className: "bg-card-background border-border w-64",
                        children: [
                          u.jsx(jn, {
                            onClick: () => {
                              navigator.clipboard.writeText(
                                "This is the best video collaboration tool I've ever used: https://www.flask.do"
                              ),
                                Z(!0),
                                setTimeout(() => Z(!1), 2e3),
                                se(!1),
                                Ms({
                                  title: "Link copied!",
                                  description: "Share Flask with your friends",
                                });
                            },
                            className:
                              "text-text-primary hover:bg-card-background/50 cursor-pointer py-3",
                            children: u.jsxs("div", {
                              className: "flex items-center w-full gap-4",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-5 flex items-center justify-center flex-shrink-0",
                                  children: u.jsx(PH, { className: "h-4 w-4" }),
                                }),
                                u.jsx("span", {
                                  children: X
                                    ? "Link copied!"
                                    : "Share Flask with friends",
                                }),
                              ],
                            }),
                          }),
                          u.jsx(jn, {
                            onClick: () => n("/"),
                            className:
                              "text-text-primary hover:bg-card-background/50 cursor-pointer py-3",
                            children: u.jsxs("div", {
                              className: "flex items-center w-full gap-4",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-5 flex items-center justify-center flex-shrink-0",
                                  children: u.jsx(rle, {
                                    className: "h-4 w-4",
                                  }),
                                }),
                                u.jsx("span", {
                                  children: "Go to Landing Page",
                                }),
                              ],
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                  u.jsx("div", {
                    className: "relative flex-1 ml-2 md:ml-5",
                    children: u.jsxs("div", {
                      className: Le(
                        "flex items-center rounded-full h-full bg-card-background border-b border-border/70 gap-2 px-1.5 py-1.5 md:min-w-[300px]"
                      ),
                      children: [
                        m.length > 0
                          ? u.jsx("div", {
                              className:
                                "flex items-center gap-2 px-3 py-2.5 flex-1 max-w-full h-full",
                              children: _
                                ? u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsxs("span", {
                                        className:
                                          "text-sm text-text-primary truncate flex-1 animate-pulse opacity-80",
                                        children: [
                                          "Uploading ",
                                          Math.round(b),
                                          "%",
                                          m.length > 1 &&
                                            ` (${S + 1} of ${m.length})`,
                                        ],
                                      }),
                                      u.jsx("button", {
                                        onClick: (ge) => {
                                          ge.stopPropagation(), Ee();
                                        },
                                        className:
                                          "ml-2 text-text-secondary hover:text-text-primary transition-colors flex-shrink-0 rounded-full p-1 hover:bg-element-background/50",
                                        children: u.jsx(Pa, {
                                          className: "w-3 h-3",
                                        }),
                                      }),
                                    ],
                                  })
                                : C
                                ? u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsxs("span", {
                                        className:
                                          "text-sm text-text-primary truncate flex-1 animate-pulse opacity-80",
                                        children: [
                                          "Processing (",
                                          V.size,
                                          " of",
                                          " ",
                                          L.length,
                                          ")",
                                        ],
                                      }),
                                      u.jsx("button", {
                                        onClick: (ge) => {
                                          ge.stopPropagation(), Ee();
                                        },
                                        className:
                                          "ml-2 text-text-secondary hover:text-text-primary transition-colors flex-shrink-0 rounded-full p-1 hover:bg-element-background/50",
                                        children: u.jsx(Pa, {
                                          className: "w-3 h-3",
                                        }),
                                      }),
                                    ],
                                  })
                                : u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx("span", {
                                        className:
                                          "text-sm text-text-primary truncate flex-1",
                                        children:
                                          m.length === 1
                                            ? m[0].name
                                            : `${m.length} files`,
                                      }),
                                      u.jsx("button", {
                                        onClick: (ge) => {
                                          ge.stopPropagation(),
                                            p([]),
                                            P([]),
                                            N(new Set()),
                                            o.current && (o.current.value = "");
                                        },
                                        className:
                                          "ml-2 text-text-secondary hover:text-text-primary transition-colors flex-shrink-0",
                                        children: u.jsx(Pa, {
                                          className: "w-3 h-3",
                                        }),
                                      }),
                                    ],
                                  }),
                            })
                          : u.jsxs(u.Fragment, {
                              children: [
                                u.jsx(Br, {
                                  delayDuration: 100,
                                  children: u.jsxs(Xn, {
                                    open: I || te,
                                    onOpenChange: F,
                                    children: [
                                      u.jsx(Qn, {
                                        asChild: !0,
                                        children: u.jsxs("div", {
                                          className: "relative flex-1",
                                          children: [
                                            u.jsx("input", {
                                              type: "text",
                                              value: c,
                                              onChange: (ge) =>
                                                h(ge.target.value),
                                              onKeyDown: (ge) => {
                                                ge.key === "Enter" &&
                                                  (ge.preventDefault(), De());
                                              },
                                              className:
                                                "bg-transparent border-none outline-none text-text-secondary text-sm pl-4 mb-1 pr-3 w-full min-w-0",
                                              placeholder: "",
                                            }),
                                            !c &&
                                              u.jsxs("div", {
                                                className:
                                                  "absolute left-4 top-1/2 -translate-y-1/2 text-sm text-text-secondary pointer-events-none flex items-center gap-2",
                                                children: [
                                                  u.jsx("span", {
                                                    className: "md:hidden",
                                                    children: "Video link",
                                                  }),
                                                  u.jsx("span", {
                                                    className:
                                                      "hidden md:inline",
                                                    children:
                                                      "Paste Video link",
                                                  }),
                                                  u.jsx("div", {
                                                    className:
                                                      "hidden md:flex items-center gap-1 opacity-50",
                                                    children: u.jsx("svg", {
                                                      className: "w-5 h-5",
                                                      viewBox: "0 0 24 24",
                                                      fill: "currentColor",
                                                      children: u.jsx("path", {
                                                        d: "M21.582,6.186c-0.23-0.86-0.908-1.538-1.768-1.768C18.254,4,12,4,12,4S5.746,4,4.186,4.418 c-0.86,0.23-1.538,0.908-1.768,1.768C2,7.746,2,12,2,12s0,4.254,0.418,5.814c0.23,0.86,0.908,1.538,1.768,1.768 C5.746,20,12,20,12,20s6.254,0,7.814-0.418c0.861-0.23,1.538-0.908,1.768-1.768C22,16.254,22,12,22,12S22,7.746,21.582,6.186z M10,15.464V8.536L16,12L10,15.464z",
                                                      }),
                                                    }),
                                                  }),
                                                  u.jsx("span", {
                                                    className:
                                                      "hidden md:inline",
                                                    children: "or",
                                                  }),
                                                ],
                                              }),
                                          ],
                                        }),
                                      }),
                                      u.jsx(Pn, {
                                        side: "bottom",
                                        className: "mt-5 rounded-3xl",
                                        children: te
                                          ? u.jsxs("div", {
                                              className: "p-3",
                                              children: [
                                                u.jsx("p", {
                                                  className:
                                                    "text-text-primary",
                                                  children:
                                                    "Link not recognized.",
                                                }),
                                                u.jsx("p", {
                                                  className:
                                                    "text-text-secondary",
                                                  children:
                                                    "YouTube unlisted and public videos are supported",
                                                }),
                                              ],
                                            })
                                          : u.jsxs("div", {
                                              className:
                                                "space-y-2 min-w-72 p-3 ",
                                              children: [
                                                u.jsxs("div", {
                                                  className:
                                                    "flex justify-between items-center",
                                                  children: [
                                                    u.jsx("span", {
                                                      className:
                                                        "text-text-primary font-bold",
                                                      children: "YouTube",
                                                    }),
                                                    u.jsx("span", {
                                                      className:
                                                        "text-text-primary text-right ml-4",
                                                      children:
                                                        "Public or Unlisted videos and Shorts",
                                                    }),
                                                  ],
                                                }),
                                                u.jsxs("div", {
                                                  className:
                                                    "flex justify-between items-center",
                                                  children: [
                                                    u.jsx("span", {
                                                      className:
                                                        "text-text-secondary font-bold",
                                                      children: "Google Drive",
                                                    }),
                                                    u.jsx("span", {
                                                      className:
                                                        "text-text-secondary text-right ml-4",
                                                      children: "Coming soon",
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            }),
                                      }),
                                    ],
                                  }),
                                }),
                                !c.trim() &&
                                  u.jsxs("button", {
                                    onClick: () => {
                                      if (!e) {
                                        M(!0);
                                        return;
                                      }
                                      if (i && !a) {
                                        y(!0);
                                        return;
                                      }
                                      o.current?.click();
                                    },
                                    className: Le(
                                      "button-secondary flex items-center gap-1 md:gap-2 px-2 md:px-3 py-2 md:py-2.5 text-xs md:text-sm flex-shrink-0"
                                    ),
                                    children: [
                                      u.jsx(_le, {
                                        className:
                                          "w-3 md:w-4 h-3 md:h-4 text-text-primary",
                                      }),
                                      u.jsx("span", {
                                        className: "hidden sm:inline",
                                        children: "Upload",
                                      }),
                                    ],
                                  }),
                              ],
                            }),
                        u.jsx("input", {
                          ref: o,
                          type: "file",
                          accept: "video/*",
                          multiple: !0,
                          className: "hidden",
                          onChange: be,
                        }),
                      ],
                    }),
                  }),
                  u.jsx(Br, {
                    delayDuration: 0,
                    children: u.jsxs(Xn, {
                      children: [
                        u.jsx(Qn, {
                          asChild: !0,
                          children: u.jsx("div", {
                            className: "ml-1.5",
                            children: u.jsx("button", {
                              ref: l,
                              onClick: De,
                              disabled:
                                W ||
                                _ ||
                                C ||
                                Y ||
                                (m.length === 0 && c.trim() === ""),
                              className: Le(
                                "button-primary flex min-w-8 md:min-w-12 items-center justify-center py-1 transition-all duration-300 font-semibold cursor-pointer rounded-full disabled:opacity-40 disabled:cursor-default h-8 md:h-12 ml-1 md:ml-2 text-xs md:text-sm",
                                W || _ || C || Y
                                  ? "px-2 md:px-3"
                                  : "px-3 md:px-4",
                                W ||
                                  _ ||
                                  C ||
                                  Y ||
                                  (m.length === 0 && c.trim() === "")
                                  ? "opacity-40"
                                  : ""
                              ),
                              children:
                                W || _ || C || Y
                                  ? u.jsx("div", {
                                      className: "animate-spin h-4 w-4",
                                      children: u.jsxs("svg", {
                                        className: "h-4 w-4",
                                        fill: "none",
                                        viewBox: "0 0 24 24",
                                        children: [
                                          u.jsx("circle", {
                                            className: "opacity-25",
                                            cx: "12",
                                            cy: "12",
                                            r: "10",
                                            stroke: "currentColor",
                                            strokeWidth: "4",
                                          }),
                                          u.jsx("path", {
                                            className: "opacity-75",
                                            fill: "currentColor",
                                            d: "m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
                                          }),
                                        ],
                                      }),
                                    })
                                  : u.jsxs(u.Fragment, {
                                      children: [
                                        u.jsx(yE, {
                                          className: "w-4 h-4 md:hidden",
                                        }),
                                        u.jsx("span", {
                                          className:
                                            "text-sm font-medium hidden md:inline",
                                          children: "Create Flask",
                                        }),
                                      ],
                                    }),
                            }),
                          }),
                        }),
                        u.jsx(Pn, {
                          side: "bottom",
                          className: "mt-2",
                          children: u.jsx("p", {
                            children:
                              "Add a video (Link or Upload) to create a Flask",
                          }),
                        }),
                      ],
                    }),
                  }),
                ],
              }),
            }),
          }),
        }),
        u.jsx($de, { open: Q, onOpenChange: M }),
        u.jsx(Bde, {
          open: g,
          onOpenChange: y,
          title: "Use YouTube to Add a Video",
        }),
      ],
    });
  },
  a3 = () => {
    const { user: n } = ks(),
      e = Dr(),
      t = Pt((r) => r.currentTeam),
      s = e.pathname === "/dash";
    return u.jsx("div", {
      className:
        "relative w-full bg-transparent text-white/80 transition-colors overflow-visible duration-200",
      children: u.jsx("div", {
        className: "w-full",
        children: u.jsxs("div", {
          className: "flex items-center justify-between gap-4",
          children: [
            n && s && u.jsx(tpe, {}),
            !s && u.jsx("div", { className: "flex-1" }),
            n &&
              s &&
              t &&
              t.team_type === "free_team" &&
              u.jsx("a", {
                href: "/#pricing",
                className: "h-[48px] hidden md:block",
                children: u.jsxs("div", {
                  className:
                    "button-primary h-full flex items-center gap-2 px-4 mr-5 cursor-pointer",
                  children: [
                    u.jsx("span", {
                      className: "text-sm !font-semibold",
                      children: "Upgrade to Flask Pro",
                    }),
                    u.jsx(yE, { className: "w-4 h-4" }),
                  ],
                }),
              }),
          ],
        }),
      }),
    });
  };
var NG = "en",
  JL = {},
  fk = {};
function OG() {
  return NG;
}
function npe(n) {
  NG = n;
}
function spe(n) {
  return JL[n];
}
function rpe(n) {
  if (!n) throw new Error("No locale data passed");
  (JL[n.locale] = n), (fk[n.locale.toLowerCase()] = n.locale);
}
function o3(n) {
  if (JL[n]) return n;
  if (fk[n.toLowerCase()]) return fk[n.toLowerCase()];
}
function jG(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = e.localeMatcher || "lookup";
  switch (t) {
    case "lookup":
      return l3(n);
    case "best fit":
      return l3(n);
    default:
      throw new RangeError('Invalid "localeMatcher" option: '.concat(t));
  }
}
function l3(n) {
  var e = o3(n);
  if (e) return e;
  for (var t = n.split("-"); n.length > 1; ) {
    t.pop(), (n = t.join("-"));
    var s = o3(n);
    if (s) return s;
  }
}
var he = {
  af: function (e) {
    return e == 1 ? "one" : "other";
  },
  am: function (e) {
    return e >= 0 && e <= 1 ? "one" : "other";
  },
  ar: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e,
      r = s && t[0].slice(-2);
    return e == 0
      ? "zero"
      : e == 1
      ? "one"
      : e == 2
      ? "two"
      : r >= 3 && r <= 10
      ? "few"
      : r >= 11 && r <= 99
      ? "many"
      : "other";
  },
  ast: function (e) {
    var t = String(e).split("."),
      s = !t[1];
    return e == 1 && s ? "one" : "other";
  },
  be: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e,
      r = s && t[0].slice(-1),
      i = s && t[0].slice(-2);
    return r == 1 && i != 11
      ? "one"
      : r >= 2 && r <= 4 && (i < 12 || i > 14)
      ? "few"
      : (s && r == 0) || (r >= 5 && r <= 9) || (i >= 11 && i <= 14)
      ? "many"
      : "other";
  },
  br: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e,
      r = s && t[0].slice(-1),
      i = s && t[0].slice(-2),
      a = s && t[0].slice(-6);
    return r == 1 && i != 11 && i != 71 && i != 91
      ? "one"
      : r == 2 && i != 12 && i != 72 && i != 92
      ? "two"
      : (r == 3 || r == 4 || r == 9) &&
        (i < 10 || i > 19) &&
        (i < 70 || i > 79) &&
        (i < 90 || i > 99)
      ? "few"
      : e != 0 && s && a == 0
      ? "many"
      : "other";
  },
  bs: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = t[1] || "",
      i = !t[1],
      a = s.slice(-1),
      o = s.slice(-2),
      l = r.slice(-1),
      c = r.slice(-2);
    return (i && a == 1 && o != 11) || (l == 1 && c != 11)
      ? "one"
      : (i && a >= 2 && a <= 4 && (o < 12 || o > 14)) ||
        (l >= 2 && l <= 4 && (c < 12 || c > 14))
      ? "few"
      : "other";
  },
  ca: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-6);
    return e == 1 && r ? "one" : s != 0 && i == 0 && r ? "many" : "other";
  },
  ceb: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = t[1] || "",
      i = !t[1],
      a = s.slice(-1),
      o = r.slice(-1);
    return (i && (s == 1 || s == 2 || s == 3)) ||
      (i && a != 4 && a != 6 && a != 9) ||
      (!i && o != 4 && o != 6 && o != 9)
      ? "one"
      : "other";
  },
  cs: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1];
    return e == 1 && r
      ? "one"
      : s >= 2 && s <= 4 && r
      ? "few"
      : r
      ? "other"
      : "many";
  },
  cy: function (e) {
    return e == 0
      ? "zero"
      : e == 1
      ? "one"
      : e == 2
      ? "two"
      : e == 3
      ? "few"
      : e == 6
      ? "many"
      : "other";
  },
  da: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = Number(t[0]) == e;
    return e == 1 || (!r && (s == 0 || s == 1)) ? "one" : "other";
  },
  dsb: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = t[1] || "",
      i = !t[1],
      a = s.slice(-2),
      o = r.slice(-2);
    return (i && a == 1) || o == 1
      ? "one"
      : (i && a == 2) || o == 2
      ? "two"
      : (i && (a == 3 || a == 4)) || o == 3 || o == 4
      ? "few"
      : "other";
  },
  dz: function (e) {
    return "other";
  },
  es: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-6);
    return e == 1 ? "one" : s != 0 && i == 0 && r ? "many" : "other";
  },
  ff: function (e) {
    return e >= 0 && e < 2 ? "one" : "other";
  },
  fr: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-6);
    return e >= 0 && e < 2 ? "one" : s != 0 && i == 0 && r ? "many" : "other";
  },
  ga: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e;
    return e == 1
      ? "one"
      : e == 2
      ? "two"
      : s && e >= 3 && e <= 6
      ? "few"
      : s && e >= 7 && e <= 10
      ? "many"
      : "other";
  },
  gd: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e;
    return e == 1 || e == 11
      ? "one"
      : e == 2 || e == 12
      ? "two"
      : (s && e >= 3 && e <= 10) || (s && e >= 13 && e <= 19)
      ? "few"
      : "other";
  },
  he: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1];
    return (s == 1 && r) || (s == 0 && !r)
      ? "one"
      : s == 2 && r
      ? "two"
      : "other";
  },
  is: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = (t[1] || "").replace(/0+$/, ""),
      i = Number(t[0]) == e,
      a = s.slice(-1),
      o = s.slice(-2);
    return (i && a == 1 && o != 11) || (r % 10 == 1 && r % 100 != 11)
      ? "one"
      : "other";
  },
  ksh: function (e) {
    return e == 0 ? "zero" : e == 1 ? "one" : "other";
  },
  lt: function (e) {
    var t = String(e).split("."),
      s = t[1] || "",
      r = Number(t[0]) == e,
      i = r && t[0].slice(-1),
      a = r && t[0].slice(-2);
    return i == 1 && (a < 11 || a > 19)
      ? "one"
      : i >= 2 && i <= 9 && (a < 11 || a > 19)
      ? "few"
      : s != 0
      ? "many"
      : "other";
  },
  lv: function (e) {
    var t = String(e).split("."),
      s = t[1] || "",
      r = s.length,
      i = Number(t[0]) == e,
      a = i && t[0].slice(-1),
      o = i && t[0].slice(-2),
      l = s.slice(-2),
      c = s.slice(-1);
    return (i && a == 0) ||
      (o >= 11 && o <= 19) ||
      (r == 2 && l >= 11 && l <= 19)
      ? "zero"
      : (a == 1 && o != 11) ||
        (r == 2 && c == 1 && l != 11) ||
        (r != 2 && c == 1)
      ? "one"
      : "other";
  },
  mk: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = t[1] || "",
      i = !t[1],
      a = s.slice(-1),
      o = s.slice(-2),
      l = r.slice(-1),
      c = r.slice(-2);
    return (i && a == 1 && o != 11) || (l == 1 && c != 11) ? "one" : "other";
  },
  mt: function (e) {
    var t = String(e).split("."),
      s = Number(t[0]) == e,
      r = s && t[0].slice(-2);
    return e == 1
      ? "one"
      : e == 2
      ? "two"
      : e == 0 || (r >= 3 && r <= 10)
      ? "few"
      : r >= 11 && r <= 19
      ? "many"
      : "other";
  },
  pa: function (e) {
    return e == 0 || e == 1 ? "one" : "other";
  },
  pl: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-1),
      a = s.slice(-2);
    return e == 1 && r
      ? "one"
      : r && i >= 2 && i <= 4 && (a < 12 || a > 14)
      ? "few"
      : (r && s != 1 && (i == 0 || i == 1)) ||
        (r && i >= 5 && i <= 9) ||
        (r && a >= 12 && a <= 14)
      ? "many"
      : "other";
  },
  pt: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-6);
    return s == 0 || s == 1 ? "one" : s != 0 && i == 0 && r ? "many" : "other";
  },
  ro: function (e) {
    var t = String(e).split("."),
      s = !t[1],
      r = Number(t[0]) == e,
      i = r && t[0].slice(-2);
    return e == 1 && s
      ? "one"
      : !s || e == 0 || (e != 1 && i >= 1 && i <= 19)
      ? "few"
      : "other";
  },
  ru: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-1),
      a = s.slice(-2);
    return r && i == 1 && a != 11
      ? "one"
      : r && i >= 2 && i <= 4 && (a < 12 || a > 14)
      ? "few"
      : (r && i == 0) || (r && i >= 5 && i <= 9) || (r && a >= 11 && a <= 14)
      ? "many"
      : "other";
  },
  se: function (e) {
    return e == 1 ? "one" : e == 2 ? "two" : "other";
  },
  si: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = t[1] || "";
    return e == 0 || e == 1 || (s == 0 && r == 1) ? "one" : "other";
  },
  sl: function (e) {
    var t = String(e).split("."),
      s = t[0],
      r = !t[1],
      i = s.slice(-2);
    return r && i == 1
      ? "one"
      : r && i == 2
      ? "two"
      : (r && (i == 3 || i == 4)) || !r
      ? "few"
      : "other";
  },
};
he.as = he.am;
he.az = he.af;
he.bg = he.af;
he.bn = he.am;
he.brx = he.af;
he.ce = he.af;
he.chr = he.af;
he.de = he.ast;
he.ee = he.af;
he.el = he.af;
he.en = he.ast;
he.et = he.ast;
he.eu = he.af;
he.fa = he.am;
he.fi = he.ast;
he.fil = he.ceb;
he.fo = he.af;
he.fur = he.af;
he.fy = he.ast;
he.gl = he.ast;
he.gu = he.am;
he.ha = he.af;
he.hi = he.am;
he.hr = he.bs;
he.hsb = he.dsb;
he.hu = he.af;
he.hy = he.ff;
he.ia = he.ast;
he.id = he.dz;
he.ig = he.dz;
he.it = he.ca;
he.ja = he.dz;
he.jgo = he.af;
he.jv = he.dz;
he.ka = he.af;
he.kea = he.dz;
he.kk = he.af;
he.kl = he.af;
he.km = he.dz;
he.kn = he.am;
he.ko = he.dz;
he.ks = he.af;
he.ku = he.af;
he.ky = he.af;
he.lb = he.af;
he.lkt = he.dz;
he.lo = he.dz;
he.ml = he.af;
he.mn = he.af;
he.mr = he.af;
he.ms = he.dz;
he.my = he.dz;
he.nb = he.af;
he.ne = he.af;
he.nl = he.ast;
he.nn = he.af;
he.no = he.af;
he.or = he.af;
he.pcm = he.am;
he.ps = he.af;
he.rm = he.af;
he.sah = he.dz;
he.sc = he.ast;
he.sd = he.af;
he.sk = he.cs;
he.so = he.af;
he.sq = he.af;
he.sr = he.bs;
he.su = he.dz;
he.sv = he.ast;
he.sw = he.ast;
he.ta = he.af;
he.te = he.af;
he.th = he.dz;
he.ti = he.pa;
he.tk = he.af;
he.to = he.dz;
he.tr = he.af;
he.ug = he.af;
he.uk = he.ru;
he.ur = he.ast;
he.uz = he.af;
he.vi = he.dz;
he.wae = he.af;
he.wo = he.dz;
he.xh = he.af;
he.yi = he.ast;
he.yo = he.dz;
he.yue = he.dz;
he.zh = he.dz;
he.zu = he.am;
function c3(n) {
  return n === "pt-PT" ? n : ape(n);
}
var ipe = /^([a-z0-9]+)/i;
function ape(n) {
  var e = n.match(ipe);
  if (!e) throw new TypeError("Invalid locale: ".concat(n));
  return e[1];
}
function ope(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function u3(n, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    (s.enumerable = s.enumerable || !1),
      (s.configurable = !0),
      "value" in s && (s.writable = !0),
      Object.defineProperty(n, s.key, s);
  }
}
function lpe(n, e, t) {
  return (
    e && u3(n.prototype, e),
    t && u3(n, t),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  );
}
var mk = (function () {
  function n(e, t) {
    ope(this, n);
    var s = n.supportedLocalesOf(e);
    if (s.length === 0) throw new RangeError("Unsupported locale: " + e);
    if (t && t.type !== "cardinal")
      throw new RangeError('Only "cardinal" "type" is supported');
    this.$ = he[c3(s[0])];
  }
  return (
    lpe(
      n,
      [
        {
          key: "select",
          value: function (t) {
            return this.$(t);
          },
        },
      ],
      [
        {
          key: "supportedLocalesOf",
          value: function (t) {
            return (
              typeof t == "string" && (t = [t]),
              t.filter(function (s) {
                return he[c3(s)];
              })
            );
          },
        },
      ]
    ),
    n
  );
})();
function pk(n) {
  "@babel/helpers - typeof";
  return (
    (pk =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    pk(n)
  );
}
function d3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function h3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? d3(Object(t), !0).forEach(function (s) {
          cpe(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : d3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function cpe(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function f3(n, e) {
  return fpe(n) || hpe(n, e) || dpe(n, e) || upe();
}
function upe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dpe(n, e) {
  if (n) {
    if (typeof n == "string") return m3(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return m3(n, e);
  }
}
function m3(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, s = new Array(e); t < e; t++) s[t] = n[t];
  return s;
}
function hpe(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t != null) {
    var s = [],
      r = !0,
      i = !1,
      a,
      o;
    try {
      for (
        t = t.call(n);
        !(r = (a = t.next()).done) && (s.push(a.value), !(e && s.length === e));
        r = !0
      );
    } catch (l) {
      (i = !0), (o = l);
    } finally {
      try {
        !r && t.return != null && t.return();
      } finally {
        if (i) throw o;
      }
    }
    return s;
  }
}
function fpe(n) {
  if (Array.isArray(n)) return n;
}
function mpe(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function ppe(n, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    (s.enumerable = s.enumerable || !1),
      (s.configurable = !0),
      "value" in s && (s.writable = !0),
      Object.defineProperty(n, s.key, s);
  }
}
function gpe(n, e, t) {
  return (
    e && ppe(n.prototype, e),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  );
}
var vpe = [
    "second",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "quarter",
    "year",
  ],
  ype = ["auto", "always"],
  bpe = ["long", "short", "narrow"],
  xpe = ["lookup", "best fit"],
  jc = (function () {
    function n() {
      var e =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      mpe(this, n);
      var s = t.numeric,
        r = t.style,
        i = t.localeMatcher;
      if (
        ((this.numeric = "always"),
        (this.style = "long"),
        (this.localeMatcher = "lookup"),
        s !== void 0)
      ) {
        if (ype.indexOf(s) < 0)
          throw new RangeError('Invalid "numeric" option: '.concat(s));
        this.numeric = s;
      }
      if (r !== void 0) {
        if (bpe.indexOf(r) < 0)
          throw new RangeError('Invalid "style" option: '.concat(r));
        this.style = r;
      }
      if (i !== void 0) {
        if (xpe.indexOf(i) < 0)
          throw new RangeError('Invalid "localeMatcher" option: '.concat(i));
        this.localeMatcher = i;
      }
      if (
        (typeof e == "string" && (e = [e]),
        e.push(OG()),
        (this.locale = n.supportedLocalesOf(e, {
          localeMatcher: this.localeMatcher,
        })[0]),
        !this.locale)
      )
        throw new Error("No supported locale was found");
      mk.supportedLocalesOf(this.locale).length > 0
        ? (this.pluralRules = new mk(this.locale))
        : console.warn('"'.concat(this.locale, '" locale is not supported')),
        typeof Intl < "u" && Intl.NumberFormat
          ? ((this.numberFormat = new Intl.NumberFormat(this.locale)),
            (this.numberingSystem =
              this.numberFormat.resolvedOptions().numberingSystem))
          : (this.numberingSystem = "latn"),
        (this.locale = jG(this.locale, { localeMatcher: this.localeMatcher }));
    }
    return (
      gpe(n, [
        {
          key: "format",
          value: function () {
            var t = p3(arguments),
              s = f3(t, 2),
              r = s[0],
              i = s[1];
            return this.getRule(r, i).replace(
              "{0}",
              this.formatNumber(Math.abs(r))
            );
          },
        },
        {
          key: "formatToParts",
          value: function () {
            var t = p3(arguments),
              s = f3(t, 2),
              r = s[0],
              i = s[1],
              a = this.getRule(r, i),
              o = a.indexOf("{0}");
            if (o < 0) return [{ type: "literal", value: a }];
            var l = [];
            return (
              o > 0 && l.push({ type: "literal", value: a.slice(0, o) }),
              (l = l.concat(
                this.formatNumberToParts(Math.abs(r)).map(function (c) {
                  return h3(h3({}, c), {}, { unit: i });
                })
              )),
              o + 3 < a.length - 1 &&
                l.push({ type: "literal", value: a.slice(o + 3) }),
              l
            );
          },
        },
        {
          key: "getRule",
          value: function (t, s) {
            var r = spe(this.locale)[this.style][s];
            if (typeof r == "string") return r;
            if (this.numeric === "auto") {
              if (t === -2 || t === -1) {
                var i = r["previous".concat(t === -1 ? "" : "-" + Math.abs(t))];
                if (i) return i;
              } else if (t === 1 || t === 2) {
                var a = r["next".concat(t === 1 ? "" : "-" + Math.abs(t))];
                if (a) return a;
              } else if (t === 0 && r.current) return r.current;
            }
            var o = r[_pe(t) ? "past" : "future"];
            if (typeof o == "string") return o;
            var l =
              (this.pluralRules && this.pluralRules.select(Math.abs(t))) ||
              "other";
            return o[l] || o.other;
          },
        },
        {
          key: "formatNumber",
          value: function (t) {
            return this.numberFormat ? this.numberFormat.format(t) : String(t);
          },
        },
        {
          key: "formatNumberToParts",
          value: function (t) {
            return this.numberFormat && this.numberFormat.formatToParts
              ? this.numberFormat.formatToParts(t)
              : [{ type: "integer", value: this.formatNumber(t) }];
          },
        },
        {
          key: "resolvedOptions",
          value: function () {
            return {
              locale: this.locale,
              style: this.style,
              numeric: this.numeric,
              numberingSystem: this.numberingSystem,
            };
          },
        },
      ]),
      n
    );
  })();
jc.supportedLocalesOf = function (n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof n == "string") n = [n];
  else if (!Array.isArray(n)) throw new TypeError('Invalid "locales" argument');
  return n.filter(function (t) {
    return jG(t, e);
  });
};
jc.addLocale = rpe;
jc.setDefaultLocale = npe;
jc.getDefaultLocale = OG;
jc.PluralRules = mk;
var I1 = 'Invalid "unit" argument';
function wpe(n) {
  if (pk(n) === "symbol") throw new TypeError(I1);
  if (typeof n != "string") throw new RangeError("".concat(I1, ": ").concat(n));
  if (
    (n[n.length - 1] === "s" && (n = n.slice(0, n.length - 1)),
    vpe.indexOf(n) < 0)
  )
    throw new RangeError("".concat(I1, ": ").concat(n));
  return n;
}
var Epe = 'Invalid "number" argument';
function Spe(n) {
  if (((n = Number(n)), Number.isFinite && !Number.isFinite(n)))
    throw new RangeError("".concat(Epe, ": ").concat(n));
  return n;
}
function Tpe(n) {
  return 1 / n === -1 / 0;
}
function _pe(n) {
  return n < 0 || (n === 0 && Tpe(n));
}
function p3(n) {
  if (n.length < 2) throw new TypeError('"unit" argument is required');
  return [Spe(n[0]), wpe(n[1])];
}
function $x(n) {
  "@babel/helpers - typeof";
  return (
    ($x =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    $x(n)
  );
}
function Ape(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Rpe(n, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    (s.enumerable = s.enumerable || !1),
      (s.configurable = !0),
      "value" in s && (s.writable = !0),
      Object.defineProperty(n, s.key, s);
  }
}
function kpe(n, e, t) {
  return (
    e && Rpe(n.prototype, e),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  );
}
var g3 = (function () {
  function n() {
    Ape(this, n), (this.cache = {});
  }
  return (
    kpe(n, [
      {
        key: "get",
        value: function () {
          for (
            var t = this.cache, s = arguments.length, r = new Array(s), i = 0;
            i < s;
            i++
          )
            r[i] = arguments[i];
          for (var a = 0, o = r; a < o.length; a++) {
            var l = o[a];
            if ($x(t) !== "object") return;
            t = t[l];
          }
          return t;
        },
      },
      {
        key: "put",
        value: function () {
          for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
            s[r] = arguments[r];
          for (
            var i = s.pop(), a = s.pop(), o = this.cache, l = 0, c = s;
            l < c.length;
            l++
          ) {
            var h = c[l];
            $x(o[h]) !== "object" && (o[h] = {}), (o = o[h]);
          }
          return (o[a] = i);
        },
      },
    ]),
    n
  );
})();
function gk(n) {
  "@babel/helpers - typeof";
  return (
    (gk =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    gk(n)
  );
}
function Cpe(n, e) {
  var t = (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t) return (t = t.call(n)).next.bind(t);
  if (Array.isArray(n) || (t = Ipe(n)) || e) {
    t && (n = t);
    var s = 0;
    return function () {
      return s >= n.length ? { done: !0 } : { done: !1, value: n[s++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ipe(n, e) {
  if (n) {
    if (typeof n == "string") return v3(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return v3(n, e);
  }
}
function v3(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, s = new Array(e); t < e; t++) s[t] = n[t];
  return s;
}
function Lpe(n, e) {
  for (var t = Cpe(n), s; !(s = t()).done; ) {
    var r = s.value;
    if (e(r)) return r;
    for (var i = r.split("-"); i.length > 1; )
      if ((i.pop(), (r = i.join("-")), e(r))) return r;
  }
  throw new Error(
    "No locale data has been registered for any of the locales: ".concat(
      n.join(", ")
    )
  );
}
function Dpe() {
  var n = (typeof Intl > "u" ? "undefined" : gk(Intl)) === "object";
  return n && typeof Intl.DateTimeFormat == "function";
}
function vk(n) {
  "@babel/helpers - typeof";
  return (
    (vk =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    vk(n)
  );
}
function Ppe(n) {
  return (
    Npe(n) &&
    (Array.isArray(n.steps) ||
      Array.isArray(n.gradation) ||
      Array.isArray(n.flavour) ||
      typeof n.flavour == "string" ||
      Array.isArray(n.labels) ||
      typeof n.labels == "string" ||
      Array.isArray(n.units) ||
      typeof n.custom == "function")
  );
}
var Mpe = {}.constructor;
function Npe(n) {
  return vk(n) !== void 0 && n !== null && n.constructor === Mpe;
}
var bl = 60,
  Bx = 60 * bl,
  Bu = 24 * Bx,
  yk = 7 * Bu,
  bk = 30.44 * Bu,
  FG = (146097 / 400) * Bu;
function af(n) {
  switch (n) {
    case "second":
      return 1;
    case "minute":
      return bl;
    case "hour":
      return Bx;
    case "day":
      return Bu;
    case "week":
      return yk;
    case "month":
      return bk;
    case "year":
      return FG;
  }
}
function UG(n) {
  return n.factor !== void 0 ? n.factor : af(n.unit || n.formatAs) || 1;
}
function Hg(n) {
  switch (n) {
    case "floor":
      return Math.floor;
    default:
      return Math.round;
  }
}
function eD(n) {
  switch (n) {
    case "floor":
      return 1;
    default:
      return 0.5;
  }
}
function xk(n) {
  "@babel/helpers - typeof";
  return (
    (xk =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    xk(n)
  );
}
function $G(n, e) {
  var t = e.prevStep,
    s = e.timestamp,
    r = e.now,
    i = e.future,
    a = e.round,
    o;
  return (
    t && (t.id || t.unit) && (o = n["threshold_for_".concat(t.id || t.unit)]),
    o === void 0 &&
      n.threshold !== void 0 &&
      ((o = n.threshold), typeof o == "function" && (o = o(r, i))),
    o === void 0 && (o = n.minTime),
    xk(o) === "object" &&
      (t && t.id && o[t.id] !== void 0 ? (o = o[t.id]) : (o = o.default)),
    typeof o == "function" &&
      (o = o(s, {
        future: i,
        getMinTimeForUnit: function (c, h) {
          return y3(c, h || (t && t.formatAs), { round: a });
        },
      })),
    o === void 0 &&
      n.test &&
      (n.test(s, { now: r, future: i }) ? (o = 0) : (o = 9007199254740991)),
    o === void 0 &&
      (t
        ? n.formatAs &&
          t.formatAs &&
          (o = y3(n.formatAs, t.formatAs, { round: a }))
        : (o = 0)),
    o === void 0 &&
      console.warn(
        "[javascript-time-ago] A step should specify `minTime`:\n" +
          JSON.stringify(n, null, 2)
      ),
    o
  );
}
function y3(n, e, t) {
  var s = t.round,
    r = af(n),
    i;
  if ((e === "now" ? (i = af(n)) : (i = af(e)), r !== void 0 && i !== void 0))
    return r - i * (1 - eD(s));
}
function b3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function Ope(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? b3(Object(t), !0).forEach(function (s) {
          jpe(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : b3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function jpe(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function Fpe(n, e, t) {
  var s = t.now,
    r = t.future,
    i = t.round,
    a = t.units;
  n = $pe(n, a);
  var o = Upe(n, e, { now: s, future: r, round: i });
  {
    if (o) {
      var l = n[n.indexOf(o) - 1],
        c = n[n.indexOf(o) + 1];
      return [l, o, c];
    }
    return [void 0, void 0, n[0]];
  }
}
function Upe(n, e, t) {
  var s = t.now,
    r = t.future,
    i = t.round;
  if (n.length !== 0) {
    var a = BG(n, e, { now: s, future: r || e < 0, round: i });
    if (a !== -1) {
      var o = n[a];
      if (o.granularity) {
        var l = Hg(i)(Math.abs(e) / UG(o) / o.granularity) * o.granularity;
        if (l === 0 && a > 0) return n[a - 1];
      }
      return o;
    }
  }
}
function BG(n, e, t) {
  var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
    r = $G(n[s], Ope({ prevStep: n[s - 1], timestamp: t.now - e * 1e3 }, t));
  return r === void 0 || Math.abs(e) < r
    ? s - 1
    : s === n.length - 1
    ? s
    : BG(n, e, t, s + 1);
}
function $pe(n, e) {
  return n.filter(function (t) {
    var s = t.unit,
      r = t.formatAs;
    return (s = s || r), s ? e.indexOf(s) >= 0 : !0;
  });
}
function Bpe(n, e, t) {
  var s = t.now,
    r = t.round;
  if (af(n)) {
    var i = af(n) * 1e3,
      a = e > s,
      o = Math.abs(e - s),
      l = Hg(r)(o / i) * i;
    return a ? (l > 0 ? o - l + Vpe(r, i) : o - l + 1) : -(o - l) + Hpe(r, i);
  }
}
function Hpe(n, e) {
  return eD(n) * e;
}
function Vpe(n, e) {
  return (1 - eD(n)) * e + 1;
}
var zpe = 365 * 24 * 60 * 60 * 1e3,
  HG = 1e3 * zpe;
function Gpe(n, e, t) {
  var s = t.prevStep,
    r = t.nextStep,
    i = t.now,
    a = t.future,
    o = t.round,
    l = n.getTime ? n.getTime() : n,
    c = function (y) {
      return Bpe(y, l, { now: i, round: o });
    },
    h = Wpe(a ? e : r, l, { future: a, now: i, round: o, prevStep: a ? s : e });
  if (h !== void 0) {
    var m;
    if (
      e &&
      (e.getTimeToNextUpdate &&
        (m = e.getTimeToNextUpdate(l, {
          getTimeToNextUpdateForUnit: c,
          getRoundFunction: Hg,
          now: i,
          future: a,
          round: o,
        })),
      m === void 0)
    ) {
      var p = e.unit || e.formatAs;
      p && (m = c(p));
    }
    return m === void 0 ? h : Math.min(m, h);
  }
}
function qpe(n, e, t) {
  var s = t.now,
    r = t.future,
    i = t.round,
    a = t.prevStep,
    o = $G(n, { timestamp: e, now: s, future: r, round: i, prevStep: a });
  if (o !== void 0)
    return r ? e - o * 1e3 + 1 : o === 0 && e === s ? HG : e + o * 1e3;
}
function Wpe(n, e, t) {
  var s = t.now,
    r = t.future,
    i = t.round,
    a = t.prevStep;
  if (n) {
    var o = qpe(n, e, { now: s, future: r, round: i, prevStep: a });
    return o === void 0 ? void 0 : o - s;
  } else return r ? e - s + 1 : HG;
}
var VG = {};
function Vh(n) {
  return VG[n];
}
function zG(n) {
  if (!n) throw new Error("[javascript-time-ago] No locale data passed.");
  VG[n.locale] = n;
}
const Kpe = [
    { formatAs: "now" },
    { formatAs: "second" },
    { formatAs: "minute" },
    { formatAs: "hour" },
    { formatAs: "day" },
    { formatAs: "week" },
    { formatAs: "month" },
    { formatAs: "year" },
  ],
  wk = { steps: Kpe, labels: "long" };
function x3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function w3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? x3(Object(t), !0).forEach(function (s) {
          Ype(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : x3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function Ype(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const Ek = w3(
    w3({}, wk),
    {},
    {
      steps: wk.steps.filter(function (n) {
        return n.formatAs !== "second";
      }),
    }
  ),
  GG = [
    { factor: 1, unit: "now" },
    { threshold: 1, threshold_for_now: 45.5, factor: 1, unit: "second" },
    { threshold: 45.5, factor: bl, unit: "minute" },
    { threshold: 2.5 * bl, granularity: 5, factor: bl, unit: "minute" },
    { threshold: 22.5 * bl, factor: 0.5 * Bx, unit: "half-hour" },
    {
      threshold: 42.5 * bl,
      threshold_for_minute: 52.5 * bl,
      factor: Bx,
      unit: "hour",
    },
    { threshold: (20.5 / 24) * Bu, factor: Bu, unit: "day" },
    { threshold: 5.5 * Bu, factor: yk, unit: "week" },
    { threshold: 3.5 * yk, factor: bk, unit: "month" },
    { threshold: 10.5 * bk, factor: FG, unit: "year" },
  ],
  E3 = {
    gradation: GG,
    flavour: "long",
    units: ["now", "minute", "hour", "day", "week", "month", "year"],
  },
  Xpe = {
    gradation: GG,
    flavour: "long-time",
    units: ["now", "minute", "hour", "day", "week", "month", "year"],
  };
function qG(n) {
  return n instanceof Date ? n : new Date(n);
}
var Sk = [{ formatAs: "second" }, { formatAs: "minute" }, { formatAs: "hour" }],
  go = {},
  Qpe = {
    minTime: function (e, t) {
      t.future;
      var s = t.getMinTimeForUnit;
      return s("day");
    },
    format: function (e, t) {
      return (
        go[t] || (go[t] = {}),
        go[t].dayMonth ||
          (go[t].dayMonth = new Intl.DateTimeFormat(t, {
            month: "short",
            day: "numeric",
          })),
        go[t].dayMonth.format(qG(e))
      );
    },
  },
  Zpe = {
    minTime: function (e, t) {
      var s = t.future;
      if (s) {
        var r = new Date(new Date(e).getFullYear(), 0).getTime() - 1;
        return (e - r) / 1e3;
      } else {
        var i = new Date(new Date(e).getFullYear() + 1, 0).getTime();
        return (i - e) / 1e3;
      }
    },
    format: function (e, t) {
      return (
        go[t] || (go[t] = {}),
        go[t].dayMonthYear ||
          (go[t].dayMonthYear = new Intl.DateTimeFormat(t, {
            year: "numeric",
            month: "short",
            day: "numeric",
          })),
        go[t].dayMonthYear.format(qG(e))
      );
    },
  };
Dpe()
  ? Sk.push(Qpe, Zpe)
  : Sk.push(
      { formatAs: "day" },
      { formatAs: "week" },
      { formatAs: "month" },
      { formatAs: "year" }
    );
const td = { steps: Sk, labels: ["mini", "short-time", "narrow", "short"] };
function S3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function T3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? S3(Object(t), !0).forEach(function (s) {
          Jpe(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : S3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function Jpe(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const ege = T3(
  T3({}, td),
  {},
  { steps: [{ formatAs: "now" }].concat(td.steps) }
);
function _3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function A3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? _3(Object(t), !0).forEach(function (s) {
          tge(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : _3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function tge(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const Tk = A3(
  A3({}, td),
  {},
  {
    steps: td.steps.filter(function (n) {
      return n.formatAs !== "second";
    }),
  }
);
function R3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function k3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? R3(Object(t), !0).forEach(function (s) {
          nge(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : R3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function nge(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const sge = k3(
  k3({}, Tk),
  {},
  { steps: [{ formatAs: "now" }].concat(Tk.steps) }
);
function C3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function Iy(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? C3(Object(t), !0).forEach(function (s) {
          rge(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : C3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function rge(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const ige = Iy(
    Iy({}, td),
    {},
    {
      steps: td.steps
        .filter(function (n) {
          return n.formatAs !== "second";
        })
        .map(function (n) {
          return n.formatAs === "minute"
            ? Iy(Iy({}, n), {}, { minTime: bl })
            : n;
        }),
    }
  ),
  Vg = {
    steps: [
      { formatAs: "second" },
      { formatAs: "minute" },
      { formatAs: "hour" },
      { formatAs: "day" },
      { formatAs: "month" },
      { formatAs: "year" },
    ],
    labels: ["mini", "short-time", "narrow", "short"],
  };
function I3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function L3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? I3(Object(t), !0).forEach(function (s) {
          age(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : I3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function age(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const oge = L3(
  L3({}, Vg),
  {},
  { steps: [{ formatAs: "now" }].concat(Vg.steps) }
);
function D3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function P3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? D3(Object(t), !0).forEach(function (s) {
          lge(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : D3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function lge(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const _k = P3(
  P3({}, Vg),
  {},
  {
    steps: Vg.steps.filter(function (n) {
      return n.formatAs !== "second";
    }),
  }
);
function M3(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function N3(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? M3(Object(t), !0).forEach(function (s) {
          cge(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : M3(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function cge(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const uge = N3(
  N3({}, _k),
  {},
  { steps: [{ formatAs: "now" }].concat(_k.steps) }
);
function dge(n) {
  switch (n) {
    case "default":
    case "round":
      return wk;
    case "round-minute":
      return Ek;
    case "approximate":
      return E3;
    case "time":
    case "approximate-time":
      return Xpe;
    case "mini":
      return Vg;
    case "mini-now":
      return oge;
    case "mini-minute":
      return _k;
    case "mini-minute-now":
      return uge;
    case "twitter":
      return td;
    case "twitter-now":
      return ege;
    case "twitter-minute":
      return Tk;
    case "twitter-minute-now":
      return sge;
    case "twitter-first-minute":
      return ige;
    default:
      return E3;
  }
}
function Hx(n) {
  "@babel/helpers - typeof";
  return (
    (Hx =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    Hx(n)
  );
}
function hge(n, e) {
  var t = (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t) return (t = t.call(n)).next.bind(t);
  if (Array.isArray(n) || (t = WG(n)) || e) {
    t && (n = t);
    var s = 0;
    return function () {
      return s >= n.length ? { done: !0 } : { done: !1, value: n[s++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function fge(n, e) {
  return gge(n) || pge(n, e) || WG(n, e) || mge();
}
function mge() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function WG(n, e) {
  if (n) {
    if (typeof n == "string") return O3(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return O3(n, e);
  }
}
function O3(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, s = new Array(e); t < e; t++) s[t] = n[t];
  return s;
}
function pge(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t != null) {
    var s = [],
      r = !0,
      i = !1,
      a,
      o;
    try {
      for (
        t = t.call(n);
        !(r = (a = t.next()).done) && (s.push(a.value), !(e && s.length === e));
        r = !0
      );
    } catch (l) {
      (i = !0), (o = l);
    } finally {
      try {
        !r && t.return != null && t.return();
      } finally {
        if (i) throw o;
      }
    }
    return s;
  }
}
function gge(n) {
  if (Array.isArray(n)) return n;
}
function vge(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function yge(n, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t];
    (s.enumerable = s.enumerable || !1),
      (s.configurable = !0),
      "value" in s && (s.writable = !0),
      Object.defineProperty(n, s.key, s);
  }
}
function bge(n, e, t) {
  return (
    e && yge(n.prototype, e),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  );
}
var Ma = (function () {
    function n() {
      var e =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        s = t.polyfill;
      vge(this, n),
        typeof e == "string" && (e = [e]),
        (this.locale = Lpe(e.concat(n.getDefaultLocale()), Vh)),
        typeof Intl < "u" &&
          Intl.NumberFormat &&
          (this.numberFormat = new Intl.NumberFormat(this.locale)),
        s === !1
          ? ((this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat),
            (this.IntlPluralRules = Intl.PluralRules))
          : ((this.IntlRelativeTimeFormat = jc),
            (this.IntlPluralRules = jc.PluralRules)),
        (this.relativeTimeFormatCache = new g3()),
        (this.pluralRulesCache = new g3());
    }
    return (
      bge(n, [
        {
          key: "format",
          value: function (t, s, r) {
            r || (s && !Tge(s) ? ((r = s), (s = void 0)) : (r = {})),
              s || (s = Ek),
              typeof s == "string" && (s = dge(s));
            var i = xge(t),
              a = this.getLabels(s.flavour || s.labels),
              o = a.labels,
              l = a.labelsType,
              c;
            s.now !== void 0 && (c = s.now),
              c === void 0 && r.now !== void 0 && (c = r.now),
              c === void 0 && (c = Date.now());
            var h = (c - i) / 1e3,
              m = r.future || h < 0,
              p = Sge(o, Vh(this.locale).now, Vh(this.locale).long, m);
            if (s.custom) {
              var g = s.custom({
                now: c,
                date: new Date(i),
                time: i,
                elapsed: h,
                locale: this.locale,
              });
              if (g !== void 0) return g;
            }
            var y = Ege(s.units, o, p),
              b = r.round || s.round,
              w = Fpe(s.gradation || s.steps || Ek.steps, h, {
                now: c,
                units: y,
                round: b,
                future: m,
              }),
              S = fge(w, 3),
              A = S[0],
              _ = S[1],
              R = S[2],
              C =
                this.formatDateForStep(i, _, h, {
                  labels: o,
                  labelsType: l,
                  nowLabel: p,
                  now: c,
                  future: m,
                  round: b,
                }) || "";
            if (r.getTimeToNextUpdate) {
              var D = Gpe(i, _, {
                nextStep: R,
                prevStep: A,
                now: c,
                future: m,
                round: b,
              });
              return [C, D];
            }
            return C;
          },
        },
        {
          key: "formatDateForStep",
          value: function (t, s, r, i) {
            var a = this,
              o = i.labels,
              l = i.labelsType,
              c = i.nowLabel,
              h = i.now,
              m = i.future,
              p = i.round;
            if (s) {
              if (s.format)
                return s.format(t, this.locale, {
                  formatAs: function (S, A) {
                    return a.formatValue(A, S, { labels: o, future: m });
                  },
                  now: h,
                  future: m,
                });
              var g = s.unit || s.formatAs;
              if (!g)
                throw new Error(
                  "[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: ".concat(
                    JSON.stringify(s)
                  )
                );
              if (g === "now") return c;
              var y = Math.abs(r) / UG(s);
              s.granularity && (y = Hg(p)(y / s.granularity) * s.granularity);
              var b = -1 * Math.sign(r) * Hg(p)(y);
              switch ((b === 0 && (m ? (b = 0) : (b = -0)), l)) {
                case "long":
                case "short":
                case "narrow":
                  return this.getFormatter(l).format(b, g);
                default:
                  return this.formatValue(b, g, { labels: o, future: m });
              }
            }
          },
        },
        {
          key: "formatValue",
          value: function (t, s, r) {
            var i = r.labels,
              a = r.future;
            return this.getFormattingRule(i, s, t, { future: a }).replace(
              "{0}",
              this.formatNumber(Math.abs(t))
            );
          },
        },
        {
          key: "getFormattingRule",
          value: function (t, s, r, i) {
            var a = i.future;
            if ((this.locale, (t = t[s]), typeof t == "string")) return t;
            var o =
                r === 0 ? (a ? "future" : "past") : r < 0 ? "past" : "future",
              l = t[o] || t;
            if (typeof l == "string") return l;
            var c = this.getPluralRules().select(Math.abs(r));
            return l[c] || l.other;
          },
        },
        {
          key: "formatNumber",
          value: function (t) {
            return this.numberFormat ? this.numberFormat.format(t) : String(t);
          },
        },
        {
          key: "getFormatter",
          value: function (t) {
            return (
              this.relativeTimeFormatCache.get(this.locale, t) ||
              this.relativeTimeFormatCache.put(
                this.locale,
                t,
                new this.IntlRelativeTimeFormat(this.locale, { style: t })
              )
            );
          },
        },
        {
          key: "getPluralRules",
          value: function () {
            return (
              this.pluralRulesCache.get(this.locale) ||
              this.pluralRulesCache.put(
                this.locale,
                new this.IntlPluralRules(this.locale)
              )
            );
          },
        },
        {
          key: "getLabels",
          value: function () {
            var t =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : [];
            typeof t == "string" && (t = [t]),
              (t = t.map(function (o) {
                switch (o) {
                  case "tiny":
                  case "mini-time":
                    return "mini";
                  default:
                    return o;
                }
              })),
              (t = t.concat("long"));
            for (var s = Vh(this.locale), r = hge(t), i; !(i = r()).done; ) {
              var a = i.value;
              if (s[a]) return { labelsType: a, labels: s[a] };
            }
          },
        },
      ]),
      n
    );
  })(),
  KG = "en";
Ma.getDefaultLocale = function () {
  return KG;
};
Ma.setDefaultLocale = function (n) {
  return (KG = n);
};
Ma.addDefaultLocale = function (n) {
  if (j3)
    return console.error(
      "[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`."
    );
  (j3 = !0), Ma.setDefaultLocale(n.locale), Ma.addLocale(n);
};
var j3;
Ma.addLocale = function (n) {
  zG(n), jc.addLocale(n);
};
Ma.locale = Ma.addLocale;
Ma.addLabels = function (n, e, t) {
  var s = Vh(n);
  s || (zG({ locale: n }), (s = Vh(n))), (s[e] = t);
};
function xge(n) {
  if (n.constructor === Date || wge(n)) return n.getTime();
  if (typeof n == "number") return n;
  throw new Error(
    "Unsupported relative time formatter input: ".concat(Hx(n), ", ").concat(n)
  );
}
function wge(n) {
  return Hx(n) === "object" && typeof n.getTime == "function";
}
function Ege(n, e, t) {
  var s = Object.keys(e);
  return (
    t && s.push("now"),
    n &&
      (s = n.filter(function (r) {
        return r === "now" || s.indexOf(r) >= 0;
      })),
    s
  );
}
function Sge(n, e, t, s) {
  var r = n.now || (e && e.now);
  if (r) return typeof r == "string" ? r : s ? r.future : r.past;
  if (t && t.second && t.second.current) return t.second.current;
}
function Tge(n) {
  return typeof n == "string" || Ppe(n);
}
const _ge = {
  locale: "en",
  long: {
    year: {
      previous: "last year",
      current: "this year",
      next: "next year",
      past: { one: "{0} year ago", other: "{0} years ago" },
      future: { one: "in {0} year", other: "in {0} years" },
    },
    quarter: {
      previous: "last quarter",
      current: "this quarter",
      next: "next quarter",
      past: { one: "{0} quarter ago", other: "{0} quarters ago" },
      future: { one: "in {0} quarter", other: "in {0} quarters" },
    },
    month: {
      previous: "last month",
      current: "this month",
      next: "next month",
      past: { one: "{0} month ago", other: "{0} months ago" },
      future: { one: "in {0} month", other: "in {0} months" },
    },
    week: {
      previous: "last week",
      current: "this week",
      next: "next week",
      past: { one: "{0} week ago", other: "{0} weeks ago" },
      future: { one: "in {0} week", other: "in {0} weeks" },
    },
    day: {
      previous: "yesterday",
      current: "today",
      next: "tomorrow",
      past: { one: "{0} day ago", other: "{0} days ago" },
      future: { one: "in {0} day", other: "in {0} days" },
    },
    hour: {
      current: "this hour",
      past: { one: "{0} hour ago", other: "{0} hours ago" },
      future: { one: "in {0} hour", other: "in {0} hours" },
    },
    minute: {
      current: "this minute",
      past: { one: "{0} minute ago", other: "{0} minutes ago" },
      future: { one: "in {0} minute", other: "in {0} minutes" },
    },
    second: {
      current: "now",
      past: { one: "{0} second ago", other: "{0} seconds ago" },
      future: { one: "in {0} second", other: "in {0} seconds" },
    },
  },
  short: {
    year: {
      previous: "last yr.",
      current: "this yr.",
      next: "next yr.",
      past: "{0} yr. ago",
      future: "in {0} yr.",
    },
    quarter: {
      previous: "last qtr.",
      current: "this qtr.",
      next: "next qtr.",
      past: { one: "{0} qtr. ago", other: "{0} qtrs. ago" },
      future: { one: "in {0} qtr.", other: "in {0} qtrs." },
    },
    month: {
      previous: "last mo.",
      current: "this mo.",
      next: "next mo.",
      past: "{0} mo. ago",
      future: "in {0} mo.",
    },
    week: {
      previous: "last wk.",
      current: "this wk.",
      next: "next wk.",
      past: "{0} wk. ago",
      future: "in {0} wk.",
    },
    day: {
      previous: "yesterday",
      current: "today",
      next: "tomorrow",
      past: { one: "{0} day ago", other: "{0} days ago" },
      future: { one: "in {0} day", other: "in {0} days" },
    },
    hour: { current: "this hour", past: "{0} hr. ago", future: "in {0} hr." },
    minute: {
      current: "this minute",
      past: "{0} min. ago",
      future: "in {0} min.",
    },
    second: { current: "now", past: "{0} sec. ago", future: "in {0} sec." },
  },
  narrow: {
    year: {
      previous: "last yr.",
      current: "this yr.",
      next: "next yr.",
      past: "{0}y ago",
      future: "in {0}y",
    },
    quarter: {
      previous: "last qtr.",
      current: "this qtr.",
      next: "next qtr.",
      past: "{0}q ago",
      future: "in {0}q",
    },
    month: {
      previous: "last mo.",
      current: "this mo.",
      next: "next mo.",
      past: "{0}mo ago",
      future: "in {0}mo",
    },
    week: {
      previous: "last wk.",
      current: "this wk.",
      next: "next wk.",
      past: "{0}w ago",
      future: "in {0}w",
    },
    day: {
      previous: "yesterday",
      current: "today",
      next: "tomorrow",
      past: "{0}d ago",
      future: "in {0}d",
    },
    hour: { current: "this hour", past: "{0}h ago", future: "in {0}h" },
    minute: { current: "this minute", past: "{0}m ago", future: "in {0}m" },
    second: { current: "now", past: "{0}s ago", future: "in {0}s" },
  },
  now: { now: { current: "now", future: "in a moment", past: "just now" } },
  mini: {
    year: "{0}yr",
    month: "{0}mo",
    week: "{0}wk",
    day: "{0}d",
    hour: "{0}h",
    minute: "{0}m",
    second: "{0}s",
    now: "now",
  },
  "short-time": {
    year: "{0} yr.",
    month: "{0} mo.",
    week: "{0} wk.",
    day: { one: "{0} day", other: "{0} days" },
    hour: "{0} hr.",
    minute: "{0} min.",
    second: "{0} sec.",
  },
  "long-time": {
    year: { one: "{0} year", other: "{0} years" },
    month: { one: "{0} month", other: "{0} months" },
    week: { one: "{0} week", other: "{0} weeks" },
    day: { one: "{0} day", other: "{0} days" },
    hour: { one: "{0} hour", other: "{0} hours" },
    minute: { one: "{0} minute", other: "{0} minutes" },
    second: { one: "{0} second", other: "{0} seconds" },
  },
};
function zg(n) {
  if (!isFinite(n) || isNaN(n) || n < 0) return "--:--";
  const e = Math.floor(n / 3600),
    t = Math.floor((n % 3600) / 60),
    s = Math.floor(n % 60),
    r = String(t).padStart(2, "0"),
    i = String(s).padStart(2, "0");
  return e > 0 ? `${String(e).padStart(2, "0")}:${r}:${i}` : `${r}:${i}`;
}
Ma.addDefaultLocale(_ge);
const Age = new Ma("en-US");
function YG(n) {
  return Age.format(n, "twitter-minute-now");
}
const Vx = ({
    assets: n,
    flaskName: e,
    className: t,
    style: s,
    onLoad: r,
    onError: i,
  }) => {
    const [a, o] = E.useState(!1),
      [l, c] = E.useState(!1),
      [h, m] = E.useState(0),
      p = E.useMemo(
        () =>
          !n || n.length === 0
            ? null
            : n.find(
                (S) => S.asset_type === "youtube" || S.asset_type === "native"
              ),
        [n]
      ),
      g = E.useMemo(() => {
        if (!p) return null;
        if (p.thumbnail_url && h === 0) return p.thumbnail_url;
        if (p.asset_type === "youtube") {
          const S =
            p.youtube_video_id || (p.youtube_url ? Sf(p.youtube_url) : null);
          if (S) {
            const A = p.thumbnail_url ? h - 1 : h;
            return A === 0
              ? `https://img.youtube.com/vi/${S}/maxresdefault.jpg`
              : A === 1
              ? `https://img.youtube.com/vi/${S}/hqdefault.jpg`
              : A === 2
              ? `https://img.youtube.com/vi/${S}/mqdefault.jpg`
              : `https://img.youtube.com/vi/${S}/default.jpg`;
          }
        }
        if (p.asset_type === "native" && p.mux_playback_id) {
          const S = p.duration || 0,
            A = Math.floor(S / 2);
          return `https://image.mux.com/${p.mux_playback_id}/thumbnail.jpg?time=${A}&width=640&height=360&fit_mode=crop`;
        }
        return null;
      }, [p, h]);
    E.useEffect(() => {
      o(!1), c(!1), m(0);
    }, [p?.id]);
    const y = () => {
        c(!0), o(!1), r?.();
      },
      b = () => {
        const S = p?.thumbnail_url ? 4 : 3;
        p && h < S ? m((A) => A + 1) : (o(!0), i?.());
      },
      w = p?.thumbnail_url ? 4 : 3;
    return !g || (a && h >= w)
      ? u.jsx("div", {
          className: Le("bg-gradient-to-br from-gray-800 to-gray-500", t),
          style: s,
          children: u.jsx("div", {
            className: "flex items-center justify-center h-full",
            children: u.jsx("svg", {
              className: "w-12 h-12 text-gray-600",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24",
              children: u.jsx("path", {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 1.5,
                d: "M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z",
              }),
            }),
          }),
        })
      : u.jsx("img", {
          src: g,
          alt: e || "Flask thumbnail",
          className: t,
          style: s,
          onLoad: y,
          onError: b,
          loading: "lazy",
        });
  },
  Rge = ({
    width: n = 48,
    height: e = 49,
    className: t = "",
    color: s = "currentColor",
  }) =>
    u.jsxs("svg", {
      width: n,
      height: e,
      viewBox: "0 0 48 49",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: t,
      children: [
        u.jsx("path", {
          d: "M18.3339 40.7253H11.9219C9.36164 40.7253 7.28613 38.6498 7.28613 36.0896V12.9107C7.28613 10.3504 9.36164 8.2749 11.9219 8.2749H36.078C38.6383 8.2749 40.7138 10.3504 40.7138 12.9107V17.8139",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M13.8418 16.3691L34.1582 16.3691",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M13.8418 24.7246L18.6201 24.7246",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M13.8418 33.0801L18.6201 33.0801",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("rect", {
          x: "25.4512",
          y: "24.7246",
          width: "15.2627",
          height: "16.0007",
          rx: "3",
          stroke: s,
          strokeWidth: "4",
        }),
      ],
    }),
  XG = ({ text: n, className: e }) =>
    u.jsx("div", {
      className: Le("inline-flex items-center ", e),
      children: u.jsx("span", {
        className: "text-xs font-medium text-text-primary whitespace-nowrap",
        children: n,
      }),
    }),
  ta = E.forwardRef(({ className: n, type: e, ...t }, s) =>
    u.jsx("input", {
      type: e,
      className: Le(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        n
      ),
      ref: s,
      ...t,
    })
  );
ta.displayName = "Input";
const Ak = ({ children: n, className: e }) =>
    u.jsx("div", {
      className: Le(
        "bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 flex gap-2",
        e
      ),
      children: u.jsxs("div", {
        className: "text-xs text-blue-300/90",
        children: [
          u.jsx("span", { className: "font-bold", children: "Tip:" }),
          " ",
          n,
        ],
      }),
    }),
  QG = ({ isOpen: n, onClose: e }) => {
    const t = E.useRef(null);
    return (
      es(),
      E.useEffect(() => {
        n && t.current && t.current.play().catch(() => {});
      }, [n]),
      u.jsx(os, {
        open: n,
        onOpenChange: e,
        children: u.jsxs(Jn, {
          className: "sm:max-w-[600px]",
          onClick: (s) => s.stopPropagation(),
          children: [
            u.jsx(bs, {
              children: u.jsx(xs, { children: "How to add assets to a Flask" }),
            }),
            u.jsxs("div", {
              className: "space-y-4",
              children: [
                u.jsxs("div", {
                  className:
                    "bg-element-background/50 rounded-lg p-4 space-y-3",
                  children: [
                    u.jsx("div", {
                      className: "flex items-center gap-3",
                      children: u.jsxs("div", {
                        className: "flex-1",
                        children: [
                          u.jsx("h3", {
                            className:
                              "text-sm font-medium text-text-primary mb-1",
                            children: "Upload multiple videos from device",
                          }),
                          u.jsx("p", {
                            className: "text-xs text-text-secondary",
                            children:
                              "They will all be added to a single Flask",
                          }),
                        ],
                      }),
                    }),
                    u.jsx(Ak, {
                      children:
                        "You can use this to review and share many files. e.g. 20 YouTube shorts",
                    }),
                  ],
                }),
                u.jsxs("div", {
                  className:
                    "bg-element-background/50 rounded-lg p-4 space-y-3",
                  children: [
                    u.jsx("div", {
                      className: "flex items-center gap-3",
                      children: u.jsxs("div", {
                        className: "flex-1",
                        children: [
                          u.jsx("h3", {
                            className:
                              "text-sm font-medium text-text-primary mb-1",
                            children: "Drag existing flasks",
                          }),
                          u.jsx("p", {
                            className: "text-xs text-text-secondary",
                            children:
                              "This moves their assets into the current flask.",
                          }),
                        ],
                      }),
                    }),
                    u.jsx("div", {
                      className:
                        "relative w-full rounded-lg overflow-hidden bg-black/20",
                      children: u.jsxs("video", {
                        ref: t,
                        className: "w-full h-auto",
                        autoPlay: !0,
                        loop: !0,
                        muted: !0,
                        playsInline: !0,
                        controls: !1,
                        children: [
                          u.jsx("source", {
                            src: "/videos/flask-drag-demo.mp4",
                            type: "video/mp4",
                          }),
                          "Your browser does not support the video tag.",
                        ],
                      }),
                    }),
                    u.jsx(Ak, {
                      children:
                        "You can merge multiple versions and revisions of the same project into a single Flask.",
                    }),
                  ],
                }),
              ],
            }),
            u.jsx(xr, {
              className: "mt-6",
              children: u.jsx("div", {
                onClick: e,
                className:
                  "button-primary flex items-center rounded-xl justify-center px-6 py-3 cursor-pointer text-sm font-medium",
                children: u.jsx("span", { children: "Got it" }),
              }),
            }),
          ],
        }),
      })
    );
  },
  Rk = ({
    flask: n,
    onDelete: e,
    availableTags: t = [],
    onTagUpdate: s,
    isPlaceholder: r = !1,
    showEmptyState: i = !1,
    isLoading: a = !1,
  }) => {
    const o = es(),
      l = Pt((z) => z.updateFlaskOptimistic),
      [c, h] = E.useState(n.flask_tag),
      [m, p] = E.useState(!1),
      [g, y] = E.useState(n.name || ""),
      [b, w] = E.useState(!1),
      [S, A] = E.useState(!1);
    de.useEffect(() => {
      h(n.flask_tag);
    }, [n.flask_tag]),
      de.useEffect(() => {
        y(n.name || "");
      }, [n.name]);
    const _ = E.useMemo(() => {
        let z = n.updated_at || n.created_at;
        if (n.assets && n.assets.length > 0) {
          const B = n.assets
            .map((U) => U.updated_at)
            .filter(Boolean)
            .map((U) => Math.floor(new Date(U).getTime() / 6e4));
          new Set(B).size === 1 && n.assets.length > 0
            ? n.assets.forEach((U) => {
                const j = U.created_at;
                j && (!z || new Date(j) > new Date(z)) && (z = j);
              })
            : n.assets.forEach((U) => {
                const j = U.updated_at || U.created_at;
                j && (!z || new Date(j) > new Date(z)) && (z = j);
              });
        }
        if (!z) return "Never";
        try {
          return YG(new Date(z));
        } catch {
          return "Invalid date";
        }
      }, [n.updated_at, n.created_at, n.assets]),
      R = E.useMemo(() => {
        const z = n.assets?.[0];
        if (!z || !z.duration) return null;
        const B = z.duration,
          q = Math.floor(B / 3600),
          O = Math.floor((B % 3600) / 60),
          U = Math.floor(B % 60);
        return q > 0
          ? `${q}:${O.toString().padStart(2, "0")}:${U.toString().padStart(
              2,
              "0"
            )}`
          : `${O}:${U.toString().padStart(2, "0")}`;
      }, [n.assets]),
      C = n.element_count || 0,
      D = (z) => {
        z.stopPropagation();
        const B = `${window.location.origin}/flask/${n.id}`;
        navigator.clipboard.writeText(B).then(() => {
          Xe.success("Link copied!");
        });
      },
      L = () => {
        r || o(`/flask/${n.id}`);
      },
      P = (z) => {
        const B = z === "none" ? null : z;
        if (B) {
          const q = t.find((O) => O.id === B);
          h(q || null);
        } else h(null);
        s && s(n.id, B);
      },
      V = (z) => {
        z.stopPropagation(), e(n.id, n.name || "Untitled Flask");
      },
      N = (z) => {
        z.stopPropagation(), p(!0);
      },
      W = async () => {
        const z = g.trim();
        if (!z || z === n.name) {
          p(!1);
          return;
        }
        w(!0);
        try {
          await l(n.id, { name: z }),
            Xe.success("Flask renamed successfully"),
            p(!1);
        } catch (B) {
          console.error("Failed to rename flask:", B),
            Xe.error("Failed to rename flask");
        } finally {
          w(!1);
        }
      },
      H = (n.assets?.length || 0) > 1;
    return u.jsxs("div", {
      className: Le(
        "group border-t border-transparent rounded-[36px] ",
        r
          ? "cursor-default"
          : "cursor-pointer hover:bg-element-background/50 hover:border-border/50 border border-transparent",
        r && a && "animate-opacity-shimmer"
      ),
      onClick: L,
      children: [
        u.jsx("div", {
          className: "p-3 md:p-5 relative",
          children: u.jsxs("div", {
            className: "relative w-full aspect-video",
            children: [
              !r &&
                H &&
                u.jsxs(u.Fragment, {
                  children: [
                    u.jsx("div", {
                      className:
                        "absolute inset-0 bg-card-background rounded-3xl border-t shadow-2xl border-text-primary/10 transform -translate-y-9 group-hover:-translate-y-12 mx-10 transition-transform duration-300 z-10",
                    }),
                    u.jsx("div", {
                      className:
                        "absolute inset-0 rounded-3xl border-t shadow-2xl border-text-primary/20 bg-black overflow-hidden transform -translate-y-5 mx-4 group-hover:-translate-y-6 transition-transform duration-300 z-20",
                      children: u.jsx(Vx, {
                        assets: n.assets?.slice(1, 2) || [],
                        flaskName: n.name,
                        className:
                          "absolute inset-0 w-full h-full object-cover",
                      }),
                    }),
                  ],
                }),
              u.jsxs("div", {
                className: Le(
                  "relative w-full h-full rounded-3xl border-t bg-element-background/20 overflow-hidden duration-200 shadow-xl transition-all z-30",
                  r
                    ? "border-text-primary/5"
                    : "border-text-primary/30 group-hover:border-text-primary/60"
                ),
                children: [
                  u.jsx("div", {
                    className: Le(
                      "absolute inset-0 transition-opacity duration-200"
                    ),
                    children: r
                      ? u.jsx("div", {
                          className:
                            "absolute inset-0 w-full h-full bg-gradient-to-tr from-element-background/20 to-transparent",
                          children:
                            i &&
                            !a &&
                            u.jsxs("div", {
                              className:
                                "flex flex-col items-center justify-center h-full text-text-primary pointer-events-none",
                              children: [
                                u.jsx("p", {
                                  className: "text-lg mb-2 text-center",
                                  children: "No Flasks yet ",
                                }),
                                u.jsx("p", {
                                  className:
                                    "text-xs text-text-secondary text-center px-4",
                                  children: "Your first Flask goes here",
                                }),
                              ],
                            }),
                        })
                      : u.jsx(Vx, {
                          assets: H
                            ? n.assets?.slice(0, 1) || []
                            : n.assets || [],
                          flaskName: n.name,
                          className:
                            "absolute inset-0 w-full h-full object-cover",
                        }),
                  }),
                  !r &&
                    u.jsx("div", {
                      className: Le(
                        "absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent"
                      ),
                    }),
                  !r &&
                    c &&
                    u.jsx("div", {
                      className:
                        "absolute top-3 left-3 hidden md:block pointer-events-none",
                      children: u.jsxs("div", {
                        className:
                          "flex items-center gap-2 px-3 py-1.5 bg-black/60 rounded-lg",
                        children: [
                          u.jsx(ek, {
                            className: "h-4 w-4 text-white flex-shrink-0",
                          }),
                          u.jsx("span", {
                            className:
                              "text-sm font-medium text-white whitespace-nowrap",
                            children: c.name,
                          }),
                        ],
                      }),
                    }),
                  !r &&
                    u.jsx(Br, {
                      children: u.jsxs("div", {
                        className:
                          "absolute bottom-3 right-3 flex items-center gap-2",
                        children: [
                          u.jsxs(Xn, {
                            children: [
                              u.jsx(Qn, {
                                asChild: !0,
                                children: u.jsxs("div", {
                                  className: Le(
                                    "flex items-center gap-1 px-2 py-1 bg-black/60 rounded-full text-xs text-text-secondary",
                                    "group-hover:text-text-primary transition-colors duration-200"
                                  ),
                                  children: [
                                    u.jsx(Rge, { width: 12, height: 12 }),
                                    u.jsx("span", { children: C }),
                                  ],
                                }),
                              }),
                              u.jsx(Pn, {
                                children: u.jsxs("p", {
                                  children: [C, " Comments in the Flask"],
                                }),
                              }),
                            ],
                          }),
                          R &&
                            u.jsxs(Xn, {
                              children: [
                                u.jsx(Qn, {
                                  asChild: !0,
                                  children: u.jsxs("div", {
                                    className: Le(
                                      "flex items-center gap-1 px-2 py-1 bg-black/60 rounded-full text-xs text-text-secondary",
                                      "group-hover:text-text-primary transition-colors duration-200"
                                    ),
                                    children: [
                                      u.jsx(Lg, { className: "h-3 w-3" }),
                                      u.jsx("span", { children: R }),
                                    ],
                                  }),
                                }),
                                u.jsx(Pn, {
                                  children: u.jsx("p", {
                                    children: "Duration",
                                  }),
                                }),
                              ],
                            }),
                        ],
                      }),
                    }),
                ],
              }),
            ],
          }),
        }),
        u.jsx("div", {
          className: "px-4 pb-4 md:px-6 md:pb-6 -mt-2",
          children: u.jsxs("div", {
            className: "flex items-start justify-between gap-2",
            children: [
              u.jsxs("div", {
                className: "flex-1 min-w-0",
                children: [
                  u.jsx("h3", {
                    className: "text-sm font-bold text-foreground truncate",
                    children: r
                      ? u.jsx("div", {
                          className:
                            "h-4 bg-element-background/30 border-t border-white/5 rounded w-24",
                        })
                      : n.name || "Untitled Flask",
                  }),
                  u.jsx("div", {
                    className: "text-xs text-muted-foreground mt-1",
                    children: r
                      ? u.jsx("div", {
                          className:
                            "h-3 bg-element-background/30 border-t border-white/5 rounded w-16",
                        })
                      : `Last edit: ${_}`,
                  }),
                ],
              }),
              !r &&
                u.jsx("div", {
                  className: "flex items-center gap-2 flex-shrink-0",
                  children: u.jsxs(Ii, {
                    children: [
                      u.jsx(Li, {
                        asChild: !0,
                        onClick: (z) => z.stopPropagation(),
                        children: u.jsx(et, {
                          variant: "ghost",
                          size: "icon",
                          className: "h-8 w-8 hover:bg-accent/50",
                          children: u.jsx(cL, { className: "h-4 w-4" }),
                        }),
                      }),
                      u.jsxs(ui, {
                        align: "end",
                        className: "bg-card-background border-border w-64 p-2",
                        children: [
                          u.jsxs(jn, {
                            onClick: D,
                            className: "cursor-pointer px-3 py-2.5 rounded-md",
                            children: [
                              u.jsx(PH, { className: "h-4 w-4 mr-3" }),
                              "Copy link",
                            ],
                          }),
                          u.jsxs(jn, {
                            onClick: N,
                            className: "cursor-pointer px-3 py-2.5 rounded-md",
                            children: [
                              u.jsx(Dg, { className: "h-4 w-4 mr-3" }),
                              "Rename flask",
                            ],
                          }),
                          u.jsxs(ZL, {
                            children: [
                              u.jsxs(jE, {
                                className:
                                  "cursor-pointer px-3 py-2.5 rounded-md",
                                children: [
                                  u.jsx(ek, { className: "h-4 w-4 mr-3" }),
                                  u.jsx("span", {
                                    children: c ? c.name : "Add tag",
                                  }),
                                ],
                              }),
                              u.jsxs(FE, {
                                className:
                                  "bg-card-background border-border w-64 p-2",
                                children: [
                                  t.length === 0
                                    ? u.jsx("div", {
                                        className: "px-2 py-3 text-center",
                                        children: u.jsx("p", {
                                          className:
                                            "text-sm text-muted-foreground",
                                          children: "No tags yet",
                                        }),
                                      })
                                    : u.jsx(u.Fragment, {
                                        children: t.map((z) =>
                                          u.jsxs(
                                            jn,
                                            {
                                              onClick: (B) => {
                                                B.stopPropagation(), P(z.id);
                                              },
                                              className: Le(
                                                "cursor-pointer px-3 py-2.5 rounded-md flex items-center justify-between",
                                                c?.id === z.id && "bg-accent"
                                              ),
                                              children: [
                                                u.jsxs("div", {
                                                  className:
                                                    "flex items-center gap-2",
                                                  children: [
                                                    c?.id === z.id &&
                                                      u.jsx(zs, {
                                                        className: "h-4 w-4",
                                                      }),
                                                    u.jsx(XG, {
                                                      text: z.name,
                                                      className: "text-xs",
                                                    }),
                                                  ],
                                                }),
                                                c?.id === z.id &&
                                                  u.jsx(Pa, {
                                                    className:
                                                      "h-3 w-3 text-muted-foreground",
                                                    onClick: (B) => {
                                                      B.stopPropagation(),
                                                        P("none");
                                                    },
                                                  }),
                                              ],
                                            },
                                            z.id
                                          )
                                        ),
                                      }),
                                  u.jsx("div", {
                                    className: "h-px bg-border my-1",
                                  }),
                                  u.jsxs(jn, {
                                    onClick: (z) => {
                                      z.stopPropagation(),
                                        window.dispatchEvent(
                                          new CustomEvent("sidebar-create-tag")
                                        );
                                    },
                                    className:
                                      "cursor-pointer px-3 py-2.5 rounded-md",
                                    children: [
                                      u.jsx(Zu, { className: "h-4 w-4 mr-3" }),
                                      "Create tag",
                                    ],
                                  }),
                                ],
                              }),
                            ],
                          }),
                          u.jsxs(jn, {
                            onClick: (z) => {
                              z.stopPropagation(), A(!0);
                            },
                            className: "cursor-pointer px-3 py-2.5 rounded-md",
                            children: [
                              u.jsx(Zu, { className: "h-4 w-4 mr-3" }),
                              "Add asset/version",
                            ],
                          }),
                          u.jsxs(jn, {
                            onClick: V,
                            className:
                              "text-red-500 hover:text-red-500 focus:text-red-500 cursor-pointer px-3 py-2.5 rounded-md",
                            children: [
                              u.jsx(Mg, {
                                className: "h-4 w-4 mr-3 opacity-100",
                              }),
                              "Delete flask",
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
            ],
          }),
        }),
        u.jsx(QG, { isOpen: S, onClose: () => A(!1) }),
        u.jsx(os, {
          open: m,
          onOpenChange: p,
          children: u.jsxs(Jn, {
            onOpenAutoFocus: (z) => {
              z.preventDefault();
              const q = z.currentTarget.querySelector("input");
              q && (q.focus(), q.select());
            },
            children: [
              u.jsx(bs, { children: u.jsx(xs, { children: "Rename Flask" }) }),
              u.jsx(ta, {
                value: g,
                onChange: (z) => y(z.target.value),
                placeholder: "Enter flask name",
                onKeyDown: (z) => {
                  z.key === "Enter" && W();
                },
              }),
              u.jsxs(xr, {
                children: [
                  u.jsx(et, {
                    variant: "outline",
                    onClick: () => {
                      y(n.name || ""), p(!1);
                    },
                    children: "Cancel",
                  }),
                  u.jsx(et, {
                    onClick: W,
                    disabled: b || !g.trim() || g.trim() === n.name,
                    children: b ? "Saving..." : "Save",
                  }),
                ],
              }),
            ],
          }),
        }),
      ],
    });
  },
  UE =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u";
function Gf(n) {
  const e = Object.prototype.toString.call(n);
  return e === "[object Window]" || e === "[object global]";
}
function tD(n) {
  return "nodeType" in n;
}
function Hr(n) {
  var e, t;
  return n
    ? Gf(n)
      ? n
      : tD(n) &&
        (e = (t = n.ownerDocument) == null ? void 0 : t.defaultView) != null
      ? e
      : window
    : window;
}
function nD(n) {
  const { Document: e } = Hr(n);
  return n instanceof e;
}
function Ov(n) {
  return Gf(n) ? !1 : n instanceof Hr(n).HTMLElement;
}
function ZG(n) {
  return n instanceof Hr(n).SVGElement;
}
function qf(n) {
  return n
    ? Gf(n)
      ? n.document
      : tD(n)
      ? nD(n)
        ? n
        : Ov(n) || ZG(n)
        ? n.ownerDocument
        : document
      : document
    : document;
}
const Al = UE ? E.useLayoutEffect : E.useEffect;
function $E(n) {
  const e = E.useRef(n);
  return (
    Al(() => {
      e.current = n;
    }),
    E.useCallback(function () {
      for (var t = arguments.length, s = new Array(t), r = 0; r < t; r++)
        s[r] = arguments[r];
      return e.current == null ? void 0 : e.current(...s);
    }, [])
  );
}
function kge() {
  const n = E.useRef(null),
    e = E.useCallback((s, r) => {
      n.current = setInterval(s, r);
    }, []),
    t = E.useCallback(() => {
      n.current !== null && (clearInterval(n.current), (n.current = null));
    }, []);
  return [e, t];
}
function Gg(n, e) {
  e === void 0 && (e = [n]);
  const t = E.useRef(n);
  return (
    Al(() => {
      t.current !== n && (t.current = n);
    }, e),
    t
  );
}
function jv(n, e) {
  const t = E.useRef();
  return E.useMemo(() => {
    const s = n(t.current);
    return (t.current = s), s;
  }, [...e]);
}
function zx(n) {
  const e = $E(n),
    t = E.useRef(null),
    s = E.useCallback((r) => {
      r !== t.current && e?.(r, t.current), (t.current = r);
    }, []);
  return [t, s];
}
function Gx(n) {
  const e = E.useRef();
  return (
    E.useEffect(() => {
      e.current = n;
    }, [n]),
    e.current
  );
}
let L1 = {};
function BE(n, e) {
  return E.useMemo(() => {
    if (e) return e;
    const t = L1[n] == null ? 0 : L1[n] + 1;
    return (L1[n] = t), n + "-" + t;
  }, [n, e]);
}
function JG(n) {
  return function (e) {
    for (
      var t = arguments.length, s = new Array(t > 1 ? t - 1 : 0), r = 1;
      r < t;
      r++
    )
      s[r - 1] = arguments[r];
    return s.reduce(
      (i, a) => {
        const o = Object.entries(a);
        for (const [l, c] of o) {
          const h = i[l];
          h != null && (i[l] = h + n * c);
        }
        return i;
      },
      { ...e }
    );
  };
}
const of = JG(1),
  qx = JG(-1);
function Cge(n) {
  return "clientX" in n && "clientY" in n;
}
function sD(n) {
  if (!n) return !1;
  const { KeyboardEvent: e } = Hr(n.target);
  return e && n instanceof e;
}
function Ige(n) {
  if (!n) return !1;
  const { TouchEvent: e } = Hr(n.target);
  return e && n instanceof e;
}
function Wx(n) {
  if (Ige(n)) {
    if (n.touches && n.touches.length) {
      const { clientX: e, clientY: t } = n.touches[0];
      return { x: e, y: t };
    } else if (n.changedTouches && n.changedTouches.length) {
      const { clientX: e, clientY: t } = n.changedTouches[0];
      return { x: e, y: t };
    }
  }
  return Cge(n) ? { x: n.clientX, y: n.clientY } : null;
}
const Af = Object.freeze({
    Translate: {
      toString(n) {
        if (!n) return;
        const { x: e, y: t } = n;
        return (
          "translate3d(" +
          (e ? Math.round(e) : 0) +
          "px, " +
          (t ? Math.round(t) : 0) +
          "px, 0)"
        );
      },
    },
    Scale: {
      toString(n) {
        if (!n) return;
        const { scaleX: e, scaleY: t } = n;
        return "scaleX(" + e + ") scaleY(" + t + ")";
      },
    },
    Transform: {
      toString(n) {
        if (n)
          return [Af.Translate.toString(n), Af.Scale.toString(n)].join(" ");
      },
    },
    Transition: {
      toString(n) {
        let { property: e, duration: t, easing: s } = n;
        return e + " " + t + "ms " + s;
      },
    },
  }),
  F3 =
    "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function Lge(n) {
  return n.matches(F3) ? n : n.querySelector(F3);
}
const Dge = { display: "none" };
function Pge(n) {
  let { id: e, value: t } = n;
  return de.createElement("div", { id: e, style: Dge }, t);
}
function Mge(n) {
  let { id: e, announcement: t, ariaLiveType: s = "assertive" } = n;
  const r = {
    position: "fixed",
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap",
  };
  return de.createElement(
    "div",
    { id: e, style: r, role: "status", "aria-live": s, "aria-atomic": !0 },
    t
  );
}
function Nge() {
  const [n, e] = E.useState("");
  return {
    announce: E.useCallback((s) => {
      s != null && e(s);
    }, []),
    announcement: n,
  };
}
const e7 = E.createContext(null);
function Oge(n) {
  const e = E.useContext(e7);
  E.useEffect(() => {
    if (!e)
      throw new Error(
        "useDndMonitor must be used within a children of <DndContext>"
      );
    return e(n);
  }, [n, e]);
}
function jge() {
  const [n] = E.useState(() => new Set()),
    e = E.useCallback((s) => (n.add(s), () => n.delete(s)), [n]);
  return [
    E.useCallback(
      (s) => {
        let { type: r, event: i } = s;
        n.forEach((a) => {
          var o;
          return (o = a[r]) == null ? void 0 : o.call(a, i);
        });
      },
      [n]
    ),
    e,
  ];
}
const Fge = {
    draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `,
  },
  Uge = {
    onDragStart(n) {
      let { active: e } = n;
      return "Picked up draggable item " + e.id + ".";
    },
    onDragOver(n) {
      let { active: e, over: t } = n;
      return t
        ? "Draggable item " +
            e.id +
            " was moved over droppable area " +
            t.id +
            "."
        : "Draggable item " + e.id + " is no longer over a droppable area.";
    },
    onDragEnd(n) {
      let { active: e, over: t } = n;
      return t
        ? "Draggable item " + e.id + " was dropped over droppable area " + t.id
        : "Draggable item " + e.id + " was dropped.";
    },
    onDragCancel(n) {
      let { active: e } = n;
      return "Dragging was cancelled. Draggable item " + e.id + " was dropped.";
    },
  };
function $ge(n) {
  let {
    announcements: e = Uge,
    container: t,
    hiddenTextDescribedById: s,
    screenReaderInstructions: r = Fge,
  } = n;
  const { announce: i, announcement: a } = Nge(),
    o = BE("DndLiveRegion"),
    [l, c] = E.useState(!1);
  if (
    (E.useEffect(() => {
      c(!0);
    }, []),
    Oge(
      E.useMemo(
        () => ({
          onDragStart(m) {
            let { active: p } = m;
            i(e.onDragStart({ active: p }));
          },
          onDragMove(m) {
            let { active: p, over: g } = m;
            e.onDragMove && i(e.onDragMove({ active: p, over: g }));
          },
          onDragOver(m) {
            let { active: p, over: g } = m;
            i(e.onDragOver({ active: p, over: g }));
          },
          onDragEnd(m) {
            let { active: p, over: g } = m;
            i(e.onDragEnd({ active: p, over: g }));
          },
          onDragCancel(m) {
            let { active: p, over: g } = m;
            i(e.onDragCancel({ active: p, over: g }));
          },
        }),
        [i, e]
      )
    ),
    !l)
  )
    return null;
  const h = de.createElement(
    de.Fragment,
    null,
    de.createElement(Pge, { id: s, value: r.draggable }),
    de.createElement(Mge, { id: o, announcement: a })
  );
  return t ? ri.createPortal(h, t) : h;
}
var Gs;
(function (n) {
  (n.DragStart = "dragStart"),
    (n.DragMove = "dragMove"),
    (n.DragEnd = "dragEnd"),
    (n.DragCancel = "dragCancel"),
    (n.DragOver = "dragOver"),
    (n.RegisterDroppable = "registerDroppable"),
    (n.SetDroppableDisabled = "setDroppableDisabled"),
    (n.UnregisterDroppable = "unregisterDroppable");
})(Gs || (Gs = {}));
function Kx() {}
function U3(n, e) {
  return E.useMemo(() => ({ sensor: n, options: e ?? {} }), [n, e]);
}
function Bge() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return E.useMemo(() => [...e].filter((s) => s != null), [...e]);
}
const ja = Object.freeze({ x: 0, y: 0 });
function Hge(n, e) {
  const t = Wx(n);
  if (!t) return "0 0";
  const s = {
    x: ((t.x - e.left) / e.width) * 100,
    y: ((t.y - e.top) / e.height) * 100,
  };
  return s.x + "% " + s.y + "%";
}
function Vge(n, e) {
  let {
      data: { value: t },
    } = n,
    {
      data: { value: s },
    } = e;
  return s - t;
}
function zge(n, e) {
  if (!n || n.length === 0) return null;
  const [t] = n;
  return t[e];
}
function Gge(n, e) {
  const t = Math.max(e.top, n.top),
    s = Math.max(e.left, n.left),
    r = Math.min(e.left + e.width, n.left + n.width),
    i = Math.min(e.top + e.height, n.top + n.height),
    a = r - s,
    o = i - t;
  if (s < r && t < i) {
    const l = e.width * e.height,
      c = n.width * n.height,
      h = a * o,
      m = h / (l + c - h);
    return Number(m.toFixed(4));
  }
  return 0;
}
const t7 = (n) => {
  let { collisionRect: e, droppableRects: t, droppableContainers: s } = n;
  const r = [];
  for (const i of s) {
    const { id: a } = i,
      o = t.get(a);
    if (o) {
      const l = Gge(o, e);
      l > 0 && r.push({ id: a, data: { droppableContainer: i, value: l } });
    }
  }
  return r.sort(Vge);
};
function qge(n, e, t) {
  return {
    ...n,
    scaleX: e && t ? e.width / t.width : 1,
    scaleY: e && t ? e.height / t.height : 1,
  };
}
function n7(n, e) {
  return n && e ? { x: n.left - e.left, y: n.top - e.top } : ja;
}
function Wge(n) {
  return function (t) {
    for (
      var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1;
      i < s;
      i++
    )
      r[i - 1] = arguments[i];
    return r.reduce(
      (a, o) => ({
        ...a,
        top: a.top + n * o.y,
        bottom: a.bottom + n * o.y,
        left: a.left + n * o.x,
        right: a.right + n * o.x,
      }),
      { ...t }
    );
  };
}
const Kge = Wge(1);
function s7(n) {
  if (n.startsWith("matrix3d(")) {
    const e = n.slice(9, -1).split(/, /);
    return { x: +e[12], y: +e[13], scaleX: +e[0], scaleY: +e[5] };
  } else if (n.startsWith("matrix(")) {
    const e = n.slice(7, -1).split(/, /);
    return { x: +e[4], y: +e[5], scaleX: +e[0], scaleY: +e[3] };
  }
  return null;
}
function Yge(n, e, t) {
  const s = s7(e);
  if (!s) return n;
  const { scaleX: r, scaleY: i, x: a, y: o } = s,
    l = n.left - a - (1 - r) * parseFloat(t),
    c = n.top - o - (1 - i) * parseFloat(t.slice(t.indexOf(" ") + 1)),
    h = r ? n.width / r : n.width,
    m = i ? n.height / i : n.height;
  return { width: h, height: m, top: c, right: l + h, bottom: c + m, left: l };
}
const Xge = { ignoreTransform: !1 };
function Fv(n, e) {
  e === void 0 && (e = Xge);
  let t = n.getBoundingClientRect();
  if (e.ignoreTransform) {
    const { transform: c, transformOrigin: h } = Hr(n).getComputedStyle(n);
    c && (t = Yge(t, c, h));
  }
  const { top: s, left: r, width: i, height: a, bottom: o, right: l } = t;
  return { top: s, left: r, width: i, height: a, bottom: o, right: l };
}
function $3(n) {
  return Fv(n, { ignoreTransform: !0 });
}
function Qge(n) {
  const e = n.innerWidth,
    t = n.innerHeight;
  return { top: 0, left: 0, right: e, bottom: t, width: e, height: t };
}
function Zge(n, e) {
  return (
    e === void 0 && (e = Hr(n).getComputedStyle(n)), e.position === "fixed"
  );
}
function Jge(n, e) {
  e === void 0 && (e = Hr(n).getComputedStyle(n));
  const t = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((r) => {
    const i = e[r];
    return typeof i == "string" ? t.test(i) : !1;
  });
}
function rD(n, e) {
  const t = [];
  function s(r) {
    if ((e != null && t.length >= e) || !r) return t;
    if (nD(r) && r.scrollingElement != null && !t.includes(r.scrollingElement))
      return t.push(r.scrollingElement), t;
    if (!Ov(r) || ZG(r) || t.includes(r)) return t;
    const i = Hr(n).getComputedStyle(r);
    return r !== n && Jge(r, i) && t.push(r), Zge(r, i) ? t : s(r.parentNode);
  }
  return n ? s(n) : t;
}
function r7(n) {
  const [e] = rD(n, 1);
  return e ?? null;
}
function D1(n) {
  return !UE || !n
    ? null
    : Gf(n)
    ? n
    : tD(n)
    ? nD(n) || n === qf(n).scrollingElement
      ? window
      : Ov(n)
      ? n
      : null
    : null;
}
function i7(n) {
  return Gf(n) ? n.scrollX : n.scrollLeft;
}
function a7(n) {
  return Gf(n) ? n.scrollY : n.scrollTop;
}
function kk(n) {
  return { x: i7(n), y: a7(n) };
}
var ir;
(function (n) {
  (n[(n.Forward = 1)] = "Forward"), (n[(n.Backward = -1)] = "Backward");
})(ir || (ir = {}));
function o7(n) {
  return !UE || !n ? !1 : n === document.scrollingElement;
}
function l7(n) {
  const e = { x: 0, y: 0 },
    t = o7(n)
      ? { height: window.innerHeight, width: window.innerWidth }
      : { height: n.clientHeight, width: n.clientWidth },
    s = { x: n.scrollWidth - t.width, y: n.scrollHeight - t.height },
    r = n.scrollTop <= e.y,
    i = n.scrollLeft <= e.x,
    a = n.scrollTop >= s.y,
    o = n.scrollLeft >= s.x;
  return {
    isTop: r,
    isLeft: i,
    isBottom: a,
    isRight: o,
    maxScroll: s,
    minScroll: e,
  };
}
const eve = { x: 0.2, y: 0.2 };
function tve(n, e, t, s, r) {
  let { top: i, left: a, right: o, bottom: l } = t;
  s === void 0 && (s = 10), r === void 0 && (r = eve);
  const { isTop: c, isBottom: h, isLeft: m, isRight: p } = l7(n),
    g = { x: 0, y: 0 },
    y = { x: 0, y: 0 },
    b = { height: e.height * r.y, width: e.width * r.x };
  return (
    !c && i <= e.top + b.height
      ? ((g.y = ir.Backward),
        (y.y = s * Math.abs((e.top + b.height - i) / b.height)))
      : !h &&
        l >= e.bottom - b.height &&
        ((g.y = ir.Forward),
        (y.y = s * Math.abs((e.bottom - b.height - l) / b.height))),
    !p && o >= e.right - b.width
      ? ((g.x = ir.Forward),
        (y.x = s * Math.abs((e.right - b.width - o) / b.width)))
      : !m &&
        a <= e.left + b.width &&
        ((g.x = ir.Backward),
        (y.x = s * Math.abs((e.left + b.width - a) / b.width))),
    { direction: g, speed: y }
  );
}
function nve(n) {
  if (n === document.scrollingElement) {
    const { innerWidth: i, innerHeight: a } = window;
    return { top: 0, left: 0, right: i, bottom: a, width: i, height: a };
  }
  const { top: e, left: t, right: s, bottom: r } = n.getBoundingClientRect();
  return {
    top: e,
    left: t,
    right: s,
    bottom: r,
    width: n.clientWidth,
    height: n.clientHeight,
  };
}
function c7(n) {
  return n.reduce((e, t) => of(e, kk(t)), ja);
}
function sve(n) {
  return n.reduce((e, t) => e + i7(t), 0);
}
function rve(n) {
  return n.reduce((e, t) => e + a7(t), 0);
}
function u7(n, e) {
  if ((e === void 0 && (e = Fv), !n)) return;
  const { top: t, left: s, bottom: r, right: i } = e(n);
  r7(n) &&
    (r <= 0 || i <= 0 || t >= window.innerHeight || s >= window.innerWidth) &&
    n.scrollIntoView({ block: "center", inline: "center" });
}
const ive = [
  ["x", ["left", "right"], sve],
  ["y", ["top", "bottom"], rve],
];
class iD {
  constructor(e, t) {
    (this.rect = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.right = void 0),
      (this.left = void 0);
    const s = rD(t),
      r = c7(s);
    (this.rect = { ...e }), (this.width = e.width), (this.height = e.height);
    for (const [i, a, o] of ive)
      for (const l of a)
        Object.defineProperty(this, l, {
          get: () => {
            const c = o(s),
              h = r[i] - c;
            return this.rect[l] + h;
          },
          enumerable: !0,
        });
    Object.defineProperty(this, "rect", { enumerable: !1 });
  }
}
class Yp {
  constructor(e) {
    (this.target = void 0),
      (this.listeners = []),
      (this.removeAll = () => {
        this.listeners.forEach((t) => {
          var s;
          return (s = this.target) == null
            ? void 0
            : s.removeEventListener(...t);
        });
      }),
      (this.target = e);
  }
  add(e, t, s) {
    var r;
    (r = this.target) == null || r.addEventListener(e, t, s),
      this.listeners.push([e, t, s]);
  }
}
function ave(n) {
  const { EventTarget: e } = Hr(n);
  return n instanceof e ? n : qf(n);
}
function P1(n, e) {
  const t = Math.abs(n.x),
    s = Math.abs(n.y);
  return typeof e == "number"
    ? Math.sqrt(t ** 2 + s ** 2) > e
    : "x" in e && "y" in e
    ? t > e.x && s > e.y
    : "x" in e
    ? t > e.x
    : "y" in e
    ? s > e.y
    : !1;
}
var Zi;
(function (n) {
  (n.Click = "click"),
    (n.DragStart = "dragstart"),
    (n.Keydown = "keydown"),
    (n.ContextMenu = "contextmenu"),
    (n.Resize = "resize"),
    (n.SelectionChange = "selectionchange"),
    (n.VisibilityChange = "visibilitychange");
})(Zi || (Zi = {}));
function B3(n) {
  n.preventDefault();
}
function ove(n) {
  n.stopPropagation();
}
var Nn;
(function (n) {
  (n.Space = "Space"),
    (n.Down = "ArrowDown"),
    (n.Right = "ArrowRight"),
    (n.Left = "ArrowLeft"),
    (n.Up = "ArrowUp"),
    (n.Esc = "Escape"),
    (n.Enter = "Enter"),
    (n.Tab = "Tab");
})(Nn || (Nn = {}));
const d7 = {
    start: [Nn.Space, Nn.Enter],
    cancel: [Nn.Esc],
    end: [Nn.Space, Nn.Enter, Nn.Tab],
  },
  lve = (n, e) => {
    let { currentCoordinates: t } = e;
    switch (n.code) {
      case Nn.Right:
        return { ...t, x: t.x + 25 };
      case Nn.Left:
        return { ...t, x: t.x - 25 };
      case Nn.Down:
        return { ...t, y: t.y + 25 };
      case Nn.Up:
        return { ...t, y: t.y - 25 };
    }
  };
class h7 {
  constructor(e) {
    (this.props = void 0),
      (this.autoScrollEnabled = !1),
      (this.referenceCoordinates = void 0),
      (this.listeners = void 0),
      (this.windowListeners = void 0),
      (this.props = e);
    const {
      event: { target: t },
    } = e;
    (this.props = e),
      (this.listeners = new Yp(qf(t))),
      (this.windowListeners = new Yp(Hr(t))),
      (this.handleKeyDown = this.handleKeyDown.bind(this)),
      (this.handleCancel = this.handleCancel.bind(this)),
      this.attach();
  }
  attach() {
    this.handleStart(),
      this.windowListeners.add(Zi.Resize, this.handleCancel),
      this.windowListeners.add(Zi.VisibilityChange, this.handleCancel),
      setTimeout(() => this.listeners.add(Zi.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const { activeNode: e, onStart: t } = this.props,
      s = e.node.current;
    s && u7(s), t(ja);
  }
  handleKeyDown(e) {
    if (sD(e)) {
      const { active: t, context: s, options: r } = this.props,
        {
          keyboardCodes: i = d7,
          coordinateGetter: a = lve,
          scrollBehavior: o = "smooth",
        } = r,
        { code: l } = e;
      if (i.end.includes(l)) {
        this.handleEnd(e);
        return;
      }
      if (i.cancel.includes(l)) {
        this.handleCancel(e);
        return;
      }
      const { collisionRect: c } = s.current,
        h = c ? { x: c.left, y: c.top } : ja;
      this.referenceCoordinates || (this.referenceCoordinates = h);
      const m = a(e, { active: t, context: s.current, currentCoordinates: h });
      if (m) {
        const p = qx(m, h),
          g = { x: 0, y: 0 },
          { scrollableAncestors: y } = s.current;
        for (const b of y) {
          const w = e.code,
            {
              isTop: S,
              isRight: A,
              isLeft: _,
              isBottom: R,
              maxScroll: C,
              minScroll: D,
            } = l7(b),
            L = nve(b),
            P = {
              x: Math.min(
                w === Nn.Right ? L.right - L.width / 2 : L.right,
                Math.max(w === Nn.Right ? L.left : L.left + L.width / 2, m.x)
              ),
              y: Math.min(
                w === Nn.Down ? L.bottom - L.height / 2 : L.bottom,
                Math.max(w === Nn.Down ? L.top : L.top + L.height / 2, m.y)
              ),
            },
            V = (w === Nn.Right && !A) || (w === Nn.Left && !_),
            N = (w === Nn.Down && !R) || (w === Nn.Up && !S);
          if (V && P.x !== m.x) {
            const W = b.scrollLeft + p.x,
              H = (w === Nn.Right && W <= C.x) || (w === Nn.Left && W >= D.x);
            if (H && !p.y) {
              b.scrollTo({ left: W, behavior: o });
              return;
            }
            H
              ? (g.x = b.scrollLeft - W)
              : (g.x =
                  w === Nn.Right ? b.scrollLeft - C.x : b.scrollLeft - D.x),
              g.x && b.scrollBy({ left: -g.x, behavior: o });
            break;
          } else if (N && P.y !== m.y) {
            const W = b.scrollTop + p.y,
              H = (w === Nn.Down && W <= C.y) || (w === Nn.Up && W >= D.y);
            if (H && !p.x) {
              b.scrollTo({ top: W, behavior: o });
              return;
            }
            H
              ? (g.y = b.scrollTop - W)
              : (g.y = w === Nn.Down ? b.scrollTop - C.y : b.scrollTop - D.y),
              g.y && b.scrollBy({ top: -g.y, behavior: o });
            break;
          }
        }
        this.handleMove(e, of(qx(m, this.referenceCoordinates), g));
      }
    }
  }
  handleMove(e, t) {
    const { onMove: s } = this.props;
    e.preventDefault(), s(t);
  }
  handleEnd(e) {
    const { onEnd: t } = this.props;
    e.preventDefault(), this.detach(), t();
  }
  handleCancel(e) {
    const { onCancel: t } = this.props;
    e.preventDefault(), this.detach(), t();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
h7.activators = [
  {
    eventName: "onKeyDown",
    handler: (n, e, t) => {
      let { keyboardCodes: s = d7, onActivation: r } = e,
        { active: i } = t;
      const { code: a } = n.nativeEvent;
      if (s.start.includes(a)) {
        const o = i.activatorNode.current;
        return o && n.target !== o
          ? !1
          : (n.preventDefault(), r?.({ event: n.nativeEvent }), !0);
      }
      return !1;
    },
  },
];
function H3(n) {
  return !!(n && "distance" in n);
}
function V3(n) {
  return !!(n && "delay" in n);
}
class aD {
  constructor(e, t, s) {
    var r;
    s === void 0 && (s = ave(e.event.target)),
      (this.props = void 0),
      (this.events = void 0),
      (this.autoScrollEnabled = !0),
      (this.document = void 0),
      (this.activated = !1),
      (this.initialCoordinates = void 0),
      (this.timeoutId = null),
      (this.listeners = void 0),
      (this.documentListeners = void 0),
      (this.windowListeners = void 0),
      (this.props = e),
      (this.events = t);
    const { event: i } = e,
      { target: a } = i;
    (this.props = e),
      (this.events = t),
      (this.document = qf(a)),
      (this.documentListeners = new Yp(this.document)),
      (this.listeners = new Yp(s)),
      (this.windowListeners = new Yp(Hr(a))),
      (this.initialCoordinates = (r = Wx(i)) != null ? r : ja),
      (this.handleStart = this.handleStart.bind(this)),
      (this.handleMove = this.handleMove.bind(this)),
      (this.handleEnd = this.handleEnd.bind(this)),
      (this.handleCancel = this.handleCancel.bind(this)),
      (this.handleKeydown = this.handleKeydown.bind(this)),
      (this.removeTextSelection = this.removeTextSelection.bind(this)),
      this.attach();
  }
  attach() {
    const {
      events: e,
      props: {
        options: { activationConstraint: t, bypassActivationConstraint: s },
      },
    } = this;
    if (
      (this.listeners.add(e.move.name, this.handleMove, { passive: !1 }),
      this.listeners.add(e.end.name, this.handleEnd),
      e.cancel && this.listeners.add(e.cancel.name, this.handleCancel),
      this.windowListeners.add(Zi.Resize, this.handleCancel),
      this.windowListeners.add(Zi.DragStart, B3),
      this.windowListeners.add(Zi.VisibilityChange, this.handleCancel),
      this.windowListeners.add(Zi.ContextMenu, B3),
      this.documentListeners.add(Zi.Keydown, this.handleKeydown),
      t)
    ) {
      if (
        s != null &&
        s({
          event: this.props.event,
          activeNode: this.props.activeNode,
          options: this.props.options,
        })
      )
        return this.handleStart();
      if (V3(t)) {
        (this.timeoutId = setTimeout(this.handleStart, t.delay)),
          this.handlePending(t);
        return;
      }
      if (H3(t)) {
        this.handlePending(t);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(),
      this.windowListeners.removeAll(),
      setTimeout(this.documentListeners.removeAll, 50),
      this.timeoutId !== null &&
        (clearTimeout(this.timeoutId), (this.timeoutId = null));
  }
  handlePending(e, t) {
    const { active: s, onPending: r } = this.props;
    r(s, e, this.initialCoordinates, t);
  }
  handleStart() {
    const { initialCoordinates: e } = this,
      { onStart: t } = this.props;
    e &&
      ((this.activated = !0),
      this.documentListeners.add(Zi.Click, ove, { capture: !0 }),
      this.removeTextSelection(),
      this.documentListeners.add(Zi.SelectionChange, this.removeTextSelection),
      t(e));
  }
  handleMove(e) {
    var t;
    const { activated: s, initialCoordinates: r, props: i } = this,
      {
        onMove: a,
        options: { activationConstraint: o },
      } = i;
    if (!r) return;
    const l = (t = Wx(e)) != null ? t : ja,
      c = qx(r, l);
    if (!s && o) {
      if (H3(o)) {
        if (o.tolerance != null && P1(c, o.tolerance))
          return this.handleCancel();
        if (P1(c, o.distance)) return this.handleStart();
      }
      if (V3(o) && P1(c, o.tolerance)) return this.handleCancel();
      this.handlePending(o, c);
      return;
    }
    e.cancelable && e.preventDefault(), a(l);
  }
  handleEnd() {
    const { onAbort: e, onEnd: t } = this.props;
    this.detach(), this.activated || e(this.props.active), t();
  }
  handleCancel() {
    const { onAbort: e, onCancel: t } = this.props;
    this.detach(), this.activated || e(this.props.active), t();
  }
  handleKeydown(e) {
    e.code === Nn.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var e;
    (e = this.document.getSelection()) == null || e.removeAllRanges();
  }
}
const cve = {
  cancel: { name: "pointercancel" },
  move: { name: "pointermove" },
  end: { name: "pointerup" },
};
class f7 extends aD {
  constructor(e) {
    const { event: t } = e,
      s = qf(t.target);
    super(e, cve, s);
  }
}
f7.activators = [
  {
    eventName: "onPointerDown",
    handler: (n, e) => {
      let { nativeEvent: t } = n,
        { onActivation: s } = e;
      return !t.isPrimary || t.button !== 0 ? !1 : (s?.({ event: t }), !0);
    },
  },
];
const uve = { move: { name: "mousemove" }, end: { name: "mouseup" } };
var Ck;
(function (n) {
  n[(n.RightClick = 2)] = "RightClick";
})(Ck || (Ck = {}));
class m7 extends aD {
  constructor(e) {
    super(e, uve, qf(e.event.target));
  }
}
m7.activators = [
  {
    eventName: "onMouseDown",
    handler: (n, e) => {
      let { nativeEvent: t } = n,
        { onActivation: s } = e;
      return t.button === Ck.RightClick ? !1 : (s?.({ event: t }), !0);
    },
  },
];
const M1 = {
  cancel: { name: "touchcancel" },
  move: { name: "touchmove" },
  end: { name: "touchend" },
};
class p7 extends aD {
  constructor(e) {
    super(e, M1);
  }
  static setup() {
    return (
      window.addEventListener(M1.move.name, e, { capture: !1, passive: !1 }),
      function () {
        window.removeEventListener(M1.move.name, e);
      }
    );
    function e() {}
  }
}
p7.activators = [
  {
    eventName: "onTouchStart",
    handler: (n, e) => {
      let { nativeEvent: t } = n,
        { onActivation: s } = e;
      const { touches: r } = t;
      return r.length > 1 ? !1 : (s?.({ event: t }), !0);
    },
  },
];
var Xp;
(function (n) {
  (n[(n.Pointer = 0)] = "Pointer"),
    (n[(n.DraggableRect = 1)] = "DraggableRect");
})(Xp || (Xp = {}));
var Yx;
(function (n) {
  (n[(n.TreeOrder = 0)] = "TreeOrder"),
    (n[(n.ReversedTreeOrder = 1)] = "ReversedTreeOrder");
})(Yx || (Yx = {}));
function dve(n) {
  let {
    acceleration: e,
    activator: t = Xp.Pointer,
    canScroll: s,
    draggingRect: r,
    enabled: i,
    interval: a = 5,
    order: o = Yx.TreeOrder,
    pointerCoordinates: l,
    scrollableAncestors: c,
    scrollableAncestorRects: h,
    delta: m,
    threshold: p,
  } = n;
  const g = fve({ delta: m, disabled: !i }),
    [y, b] = kge(),
    w = E.useRef({ x: 0, y: 0 }),
    S = E.useRef({ x: 0, y: 0 }),
    A = E.useMemo(() => {
      switch (t) {
        case Xp.Pointer:
          return l ? { top: l.y, bottom: l.y, left: l.x, right: l.x } : null;
        case Xp.DraggableRect:
          return r;
      }
    }, [t, r, l]),
    _ = E.useRef(null),
    R = E.useCallback(() => {
      const D = _.current;
      if (!D) return;
      const L = w.current.x * S.current.x,
        P = w.current.y * S.current.y;
      D.scrollBy(L, P);
    }, []),
    C = E.useMemo(() => (o === Yx.TreeOrder ? [...c].reverse() : c), [o, c]);
  E.useEffect(() => {
    if (!i || !c.length || !A) {
      b();
      return;
    }
    for (const D of C) {
      if (s?.(D) === !1) continue;
      const L = c.indexOf(D),
        P = h[L];
      if (!P) continue;
      const { direction: V, speed: N } = tve(D, P, A, e, p);
      for (const W of ["x", "y"]) g[W][V[W]] || ((N[W] = 0), (V[W] = 0));
      if (N.x > 0 || N.y > 0) {
        b(), (_.current = D), y(R, a), (w.current = N), (S.current = V);
        return;
      }
    }
    (w.current = { x: 0, y: 0 }), (S.current = { x: 0, y: 0 }), b();
  }, [
    e,
    R,
    s,
    b,
    i,
    a,
    JSON.stringify(A),
    JSON.stringify(g),
    y,
    c,
    C,
    h,
    JSON.stringify(p),
  ]);
}
const hve = {
  x: { [ir.Backward]: !1, [ir.Forward]: !1 },
  y: { [ir.Backward]: !1, [ir.Forward]: !1 },
};
function fve(n) {
  let { delta: e, disabled: t } = n;
  const s = Gx(e);
  return jv(
    (r) => {
      if (t || !s || !r) return hve;
      const i = { x: Math.sign(e.x - s.x), y: Math.sign(e.y - s.y) };
      return {
        x: {
          [ir.Backward]: r.x[ir.Backward] || i.x === -1,
          [ir.Forward]: r.x[ir.Forward] || i.x === 1,
        },
        y: {
          [ir.Backward]: r.y[ir.Backward] || i.y === -1,
          [ir.Forward]: r.y[ir.Forward] || i.y === 1,
        },
      };
    },
    [t, e, s]
  );
}
function mve(n, e) {
  const t = e != null ? n.get(e) : void 0,
    s = t ? t.node.current : null;
  return jv(
    (r) => {
      var i;
      return e == null ? null : (i = s ?? r) != null ? i : null;
    },
    [s, e]
  );
}
function pve(n, e) {
  return E.useMemo(
    () =>
      n.reduce((t, s) => {
        const { sensor: r } = s,
          i = r.activators.map((a) => ({
            eventName: a.eventName,
            handler: e(a.handler, s),
          }));
        return [...t, ...i];
      }, []),
    [n, e]
  );
}
var qg;
(function (n) {
  (n[(n.Always = 0)] = "Always"),
    (n[(n.BeforeDragging = 1)] = "BeforeDragging"),
    (n[(n.WhileDragging = 2)] = "WhileDragging");
})(qg || (qg = {}));
var Ik;
(function (n) {
  n.Optimized = "optimized";
})(Ik || (Ik = {}));
const z3 = new Map();
function gve(n, e) {
  let { dragging: t, dependencies: s, config: r } = e;
  const [i, a] = E.useState(null),
    { frequency: o, measure: l, strategy: c } = r,
    h = E.useRef(n),
    m = w(),
    p = Gg(m),
    g = E.useCallback(
      function (S) {
        S === void 0 && (S = []),
          !p.current &&
            a((A) =>
              A === null ? S : A.concat(S.filter((_) => !A.includes(_)))
            );
      },
      [p]
    ),
    y = E.useRef(null),
    b = jv(
      (S) => {
        if (m && !t) return z3;
        if (!S || S === z3 || h.current !== n || i != null) {
          const A = new Map();
          for (let _ of n) {
            if (!_) continue;
            if (i && i.length > 0 && !i.includes(_.id) && _.rect.current) {
              A.set(_.id, _.rect.current);
              continue;
            }
            const R = _.node.current,
              C = R ? new iD(l(R), R) : null;
            (_.rect.current = C), C && A.set(_.id, C);
          }
          return A;
        }
        return S;
      },
      [n, i, t, m, l]
    );
  return (
    E.useEffect(() => {
      h.current = n;
    }, [n]),
    E.useEffect(() => {
      m || g();
    }, [t, m]),
    E.useEffect(() => {
      i && i.length > 0 && a(null);
    }, [JSON.stringify(i)]),
    E.useEffect(() => {
      m ||
        typeof o != "number" ||
        y.current !== null ||
        (y.current = setTimeout(() => {
          g(), (y.current = null);
        }, o));
    }, [o, m, g, ...s]),
    {
      droppableRects: b,
      measureDroppableContainers: g,
      measuringScheduled: i != null,
    }
  );
  function w() {
    switch (c) {
      case qg.Always:
        return !1;
      case qg.BeforeDragging:
        return t;
      default:
        return !t;
    }
  }
}
function oD(n, e) {
  return jv(
    (t) => (n ? t || (typeof e == "function" ? e(n) : n) : null),
    [e, n]
  );
}
function vve(n, e) {
  return oD(n, e);
}
function yve(n) {
  let { callback: e, disabled: t } = n;
  const s = $E(e),
    r = E.useMemo(() => {
      if (t || typeof window > "u" || typeof window.MutationObserver > "u")
        return;
      const { MutationObserver: i } = window;
      return new i(s);
    }, [s, t]);
  return E.useEffect(() => () => r?.disconnect(), [r]), r;
}
function HE(n) {
  let { callback: e, disabled: t } = n;
  const s = $E(e),
    r = E.useMemo(() => {
      if (t || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const { ResizeObserver: i } = window;
      return new i(s);
    }, [t]);
  return E.useEffect(() => () => r?.disconnect(), [r]), r;
}
function bve(n) {
  return new iD(Fv(n), n);
}
function G3(n, e, t) {
  e === void 0 && (e = bve);
  const [s, r] = E.useState(null);
  function i() {
    r((l) => {
      if (!n) return null;
      if (n.isConnected === !1) {
        var c;
        return (c = l ?? t) != null ? c : null;
      }
      const h = e(n);
      return JSON.stringify(l) === JSON.stringify(h) ? l : h;
    });
  }
  const a = yve({
      callback(l) {
        if (n)
          for (const c of l) {
            const { type: h, target: m } = c;
            if (
              h === "childList" &&
              m instanceof HTMLElement &&
              m.contains(n)
            ) {
              i();
              break;
            }
          }
      },
    }),
    o = HE({ callback: i });
  return (
    Al(() => {
      i(),
        n
          ? (o?.observe(n),
            a?.observe(document.body, { childList: !0, subtree: !0 }))
          : (o?.disconnect(), a?.disconnect());
    }, [n]),
    s
  );
}
function xve(n) {
  const e = oD(n);
  return n7(n, e);
}
const q3 = [];
function wve(n) {
  const e = E.useRef(n),
    t = jv(
      (s) =>
        n
          ? s &&
            s !== q3 &&
            n &&
            e.current &&
            n.parentNode === e.current.parentNode
            ? s
            : rD(n)
          : q3,
      [n]
    );
  return (
    E.useEffect(() => {
      e.current = n;
    }, [n]),
    t
  );
}
function Eve(n) {
  const [e, t] = E.useState(null),
    s = E.useRef(n),
    r = E.useCallback((i) => {
      const a = D1(i.target);
      a && t((o) => (o ? (o.set(a, kk(a)), new Map(o)) : null));
    }, []);
  return (
    E.useEffect(() => {
      const i = s.current;
      if (n !== i) {
        a(i);
        const o = n
          .map((l) => {
            const c = D1(l);
            return c
              ? (c.addEventListener("scroll", r, { passive: !0 }), [c, kk(c)])
              : null;
          })
          .filter((l) => l != null);
        t(o.length ? new Map(o) : null), (s.current = n);
      }
      return () => {
        a(n), a(i);
      };
      function a(o) {
        o.forEach((l) => {
          const c = D1(l);
          c?.removeEventListener("scroll", r);
        });
      }
    }, [r, n]),
    E.useMemo(
      () =>
        n.length
          ? e
            ? Array.from(e.values()).reduce((i, a) => of(i, a), ja)
            : c7(n)
          : ja,
      [n, e]
    )
  );
}
function W3(n, e) {
  e === void 0 && (e = []);
  const t = E.useRef(null);
  return (
    E.useEffect(() => {
      t.current = null;
    }, e),
    E.useEffect(() => {
      const s = n !== ja;
      s && !t.current && (t.current = n), !s && t.current && (t.current = null);
    }, [n]),
    t.current ? qx(n, t.current) : ja
  );
}
function Sve(n) {
  E.useEffect(
    () => {
      if (!UE) return;
      const e = n.map((t) => {
        let { sensor: s } = t;
        return s.setup == null ? void 0 : s.setup();
      });
      return () => {
        for (const t of e) t?.();
      };
    },
    n.map((e) => {
      let { sensor: t } = e;
      return t;
    })
  );
}
function Tve(n, e) {
  return E.useMemo(
    () =>
      n.reduce((t, s) => {
        let { eventName: r, handler: i } = s;
        return (
          (t[r] = (a) => {
            i(a, e);
          }),
          t
        );
      }, {}),
    [n, e]
  );
}
function g7(n) {
  return E.useMemo(() => (n ? Qge(n) : null), [n]);
}
const K3 = [];
function _ve(n, e) {
  e === void 0 && (e = Fv);
  const [t] = n,
    s = g7(t ? Hr(t) : null),
    [r, i] = E.useState(K3);
  function a() {
    i(() => (n.length ? n.map((l) => (o7(l) ? s : new iD(e(l), l))) : K3));
  }
  const o = HE({ callback: a });
  return (
    Al(() => {
      o?.disconnect(), a(), n.forEach((l) => o?.observe(l));
    }, [n]),
    r
  );
}
function v7(n) {
  if (!n) return null;
  if (n.children.length > 1) return n;
  const e = n.children[0];
  return Ov(e) ? e : n;
}
function Ave(n) {
  let { measure: e } = n;
  const [t, s] = E.useState(null),
    r = E.useCallback(
      (c) => {
        for (const { target: h } of c)
          if (Ov(h)) {
            s((m) => {
              const p = e(h);
              return m ? { ...m, width: p.width, height: p.height } : p;
            });
            break;
          }
      },
      [e]
    ),
    i = HE({ callback: r }),
    a = E.useCallback(
      (c) => {
        const h = v7(c);
        i?.disconnect(), h && i?.observe(h), s(h ? e(h) : null);
      },
      [e, i]
    ),
    [o, l] = zx(a);
  return E.useMemo(() => ({ nodeRef: o, rect: t, setRef: l }), [t, o, l]);
}
const Rve = [
    { sensor: f7, options: {} },
    { sensor: h7, options: {} },
  ],
  kve = { current: {} },
  Sb = {
    draggable: { measure: $3 },
    droppable: {
      measure: $3,
      strategy: qg.WhileDragging,
      frequency: Ik.Optimized,
    },
    dragOverlay: { measure: Fv },
  };
class Qp extends Map {
  get(e) {
    var t;
    return e != null && (t = super.get(e)) != null ? t : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((e) => {
      let { disabled: t } = e;
      return !t;
    });
  }
  getNodeFor(e) {
    var t, s;
    return (t = (s = this.get(e)) == null ? void 0 : s.node.current) != null
      ? t
      : void 0;
  }
}
const Cve = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: new Map(),
    droppableRects: new Map(),
    droppableContainers: new Qp(),
    over: null,
    dragOverlay: { nodeRef: { current: null }, rect: null, setRef: Kx },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: Sb,
    measureDroppableContainers: Kx,
    windowRect: null,
    measuringScheduled: !1,
  },
  y7 = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: { draggable: "" },
    dispatch: Kx,
    draggableNodes: new Map(),
    over: null,
    measureDroppableContainers: Kx,
  },
  Uv = E.createContext(y7),
  b7 = E.createContext(Cve);
function Ive() {
  return {
    draggable: {
      active: null,
      initialCoordinates: { x: 0, y: 0 },
      nodes: new Map(),
      translate: { x: 0, y: 0 },
    },
    droppable: { containers: new Qp() },
  };
}
function Lve(n, e) {
  switch (e.type) {
    case Gs.DragStart:
      return {
        ...n,
        draggable: {
          ...n.draggable,
          initialCoordinates: e.initialCoordinates,
          active: e.active,
        },
      };
    case Gs.DragMove:
      return n.draggable.active == null
        ? n
        : {
            ...n,
            draggable: {
              ...n.draggable,
              translate: {
                x: e.coordinates.x - n.draggable.initialCoordinates.x,
                y: e.coordinates.y - n.draggable.initialCoordinates.y,
              },
            },
          };
    case Gs.DragEnd:
    case Gs.DragCancel:
      return {
        ...n,
        draggable: {
          ...n.draggable,
          active: null,
          initialCoordinates: { x: 0, y: 0 },
          translate: { x: 0, y: 0 },
        },
      };
    case Gs.RegisterDroppable: {
      const { element: t } = e,
        { id: s } = t,
        r = new Qp(n.droppable.containers);
      return (
        r.set(s, t), { ...n, droppable: { ...n.droppable, containers: r } }
      );
    }
    case Gs.SetDroppableDisabled: {
      const { id: t, key: s, disabled: r } = e,
        i = n.droppable.containers.get(t);
      if (!i || s !== i.key) return n;
      const a = new Qp(n.droppable.containers);
      return (
        a.set(t, { ...i, disabled: r }),
        { ...n, droppable: { ...n.droppable, containers: a } }
      );
    }
    case Gs.UnregisterDroppable: {
      const { id: t, key: s } = e,
        r = n.droppable.containers.get(t);
      if (!r || s !== r.key) return n;
      const i = new Qp(n.droppable.containers);
      return (
        i.delete(t), { ...n, droppable: { ...n.droppable, containers: i } }
      );
    }
    default:
      return n;
  }
}
function Dve(n) {
  let { disabled: e } = n;
  const { active: t, activatorEvent: s, draggableNodes: r } = E.useContext(Uv),
    i = Gx(s),
    a = Gx(t?.id);
  return (
    E.useEffect(() => {
      if (!e && !s && i && a != null) {
        if (!sD(i) || document.activeElement === i.target) return;
        const o = r.get(a);
        if (!o) return;
        const { activatorNode: l, node: c } = o;
        if (!l.current && !c.current) return;
        requestAnimationFrame(() => {
          for (const h of [l.current, c.current]) {
            if (!h) continue;
            const m = Lge(h);
            if (m) {
              m.focus();
              break;
            }
          }
        });
      }
    }, [s, e, r, a, i]),
    null
  );
}
function x7(n, e) {
  let { transform: t, ...s } = e;
  return n != null && n.length
    ? n.reduce((r, i) => i({ transform: r, ...s }), t)
    : t;
}
function Pve(n) {
  return E.useMemo(
    () => ({
      draggable: { ...Sb.draggable, ...n?.draggable },
      droppable: { ...Sb.droppable, ...n?.droppable },
      dragOverlay: { ...Sb.dragOverlay, ...n?.dragOverlay },
    }),
    [n?.draggable, n?.droppable, n?.dragOverlay]
  );
}
function Mve(n) {
  let { activeNode: e, measure: t, initialRect: s, config: r = !0 } = n;
  const i = E.useRef(!1),
    { x: a, y: o } = typeof r == "boolean" ? { x: r, y: r } : r;
  Al(() => {
    if ((!a && !o) || !e) {
      i.current = !1;
      return;
    }
    if (i.current || !s) return;
    const c = e?.node.current;
    if (!c || c.isConnected === !1) return;
    const h = t(c),
      m = n7(h, s);
    if (
      (a || (m.x = 0),
      o || (m.y = 0),
      (i.current = !0),
      Math.abs(m.x) > 0 || Math.abs(m.y) > 0)
    ) {
      const p = r7(c);
      p && p.scrollBy({ top: m.y, left: m.x });
    }
  }, [e, a, o, s, t]);
}
const VE = E.createContext({ ...ja, scaleX: 1, scaleY: 1 });
var yc;
(function (n) {
  (n[(n.Uninitialized = 0)] = "Uninitialized"),
    (n[(n.Initializing = 1)] = "Initializing"),
    (n[(n.Initialized = 2)] = "Initialized");
})(yc || (yc = {}));
const Nve = E.memo(function (e) {
    var t, s, r, i;
    let {
      id: a,
      accessibility: o,
      autoScroll: l = !0,
      children: c,
      sensors: h = Rve,
      collisionDetection: m = t7,
      measuring: p,
      modifiers: g,
      ...y
    } = e;
    const b = E.useReducer(Lve, void 0, Ive),
      [w, S] = b,
      [A, _] = jge(),
      [R, C] = E.useState(yc.Uninitialized),
      D = R === yc.Initialized,
      {
        draggable: { active: L, nodes: P, translate: V },
        droppable: { containers: N },
      } = w,
      W = L != null ? P.get(L) : null,
      H = E.useRef({ initial: null, translated: null }),
      z = E.useMemo(() => {
        var Vt;
        return L != null
          ? { id: L, data: (Vt = W?.data) != null ? Vt : kve, rect: H }
          : null;
      }, [L, W]),
      B = E.useRef(null),
      [q, O] = E.useState(null),
      [U, j] = E.useState(null),
      Q = Gg(y, Object.values(y)),
      M = BE("DndDescribedBy", a),
      I = E.useMemo(() => N.getEnabled(), [N]),
      F = Pve(p),
      {
        droppableRects: Y,
        measureDroppableContainers: J,
        measuringScheduled: X,
      } = gve(I, {
        dragging: D,
        dependencies: [V.x, V.y],
        config: F.droppable,
      }),
      Z = mve(P, L),
      te = E.useMemo(() => (U ? Wx(U) : null), [U]),
      ce = ts(),
      pe = vve(Z, F.draggable.measure);
    Mve({
      activeNode: L != null ? P.get(L) : null,
      config: ce.layoutShiftCompensation,
      initialRect: pe,
      measure: F.draggable.measure,
    });
    const se = G3(Z, F.draggable.measure, pe),
      be = G3(Z ? Z.parentElement : null),
      K = E.useRef({
        activatorEvent: null,
        active: null,
        activeNode: Z,
        collisionRect: null,
        collisions: null,
        droppableRects: Y,
        draggableNodes: P,
        draggingNode: null,
        draggingNodeRect: null,
        droppableContainers: N,
        over: null,
        scrollableAncestors: [],
        scrollAdjustedTranslate: null,
      }),
      ve = N.getNodeFor((t = K.current.over) == null ? void 0 : t.id),
      Ee = Ave({ measure: F.dragOverlay.measure }),
      De = (s = Ee.nodeRef.current) != null ? s : Z,
      ge = D ? ((r = Ee.rect) != null ? r : se) : null,
      re = !!(Ee.nodeRef.current && Ee.rect),
      fe = xve(re ? null : se),
      ke = g7(De ? Hr(De) : null),
      ne = wve(D ? ve ?? Z : null),
      ie = _ve(ne),
      Ne = x7(g, {
        transform: { x: V.x - fe.x, y: V.y - fe.y, scaleX: 1, scaleY: 1 },
        activatorEvent: U,
        active: z,
        activeNodeRect: se,
        containerNodeRect: be,
        draggingNodeRect: ge,
        over: K.current.over,
        overlayNodeRect: Ee.rect,
        scrollableAncestors: ne,
        scrollableAncestorRects: ie,
        windowRect: ke,
      }),
      $e = te ? of(te, V) : null,
      ot = Eve(ne),
      st = W3(ot),
      ht = W3(ot, [se]),
      xt = of(Ne, st),
      _e = ge ? Kge(ge, Ne) : null,
      Ue =
        z && _e
          ? m({
              active: z,
              collisionRect: _e,
              droppableRects: Y,
              droppableContainers: I,
              pointerCoordinates: $e,
            })
          : null,
      He = zge(Ue, "id"),
      [Ve, Ze] = E.useState(null),
      ct = re ? Ne : of(Ne, ht),
      ft = qge(ct, (i = Ve?.rect) != null ? i : null, se),
      Ye = E.useRef(null),
      Ot = E.useCallback(
        (Vt, Zt) => {
          let { sensor: ln, options: Je } = Zt;
          if (B.current == null) return;
          const Ge = P.get(B.current);
          if (!Ge) return;
          const mt = Vt.nativeEvent,
            zt = new ln({
              active: B.current,
              activeNode: Ge,
              event: mt,
              options: Je,
              context: K,
              onAbort(le) {
                if (!P.get(le)) return;
                const { onDragAbort: Ke } = Q.current,
                  ut = { id: le };
                Ke?.(ut), A({ type: "onDragAbort", event: ut });
              },
              onPending(le, je, Ke, ut) {
                if (!P.get(le)) return;
                const { onDragPending: kt } = Q.current,
                  Kt = {
                    id: le,
                    constraint: je,
                    initialCoordinates: Ke,
                    offset: ut,
                  };
                kt?.(Kt), A({ type: "onDragPending", event: Kt });
              },
              onStart(le) {
                const je = B.current;
                if (je == null) return;
                const Ke = P.get(je);
                if (!Ke) return;
                const { onDragStart: ut } = Q.current,
                  St = {
                    activatorEvent: mt,
                    active: { id: je, data: Ke.data, rect: H },
                  };
                ri.unstable_batchedUpdates(() => {
                  ut?.(St),
                    C(yc.Initializing),
                    S({
                      type: Gs.DragStart,
                      initialCoordinates: le,
                      active: je,
                    }),
                    A({ type: "onDragStart", event: St }),
                    O(Ye.current),
                    j(mt);
                });
              },
              onMove(le) {
                S({ type: Gs.DragMove, coordinates: le });
              },
              onEnd: an(Gs.DragEnd),
              onCancel: an(Gs.DragCancel),
            });
          Ye.current = zt;
          function an(le) {
            return async function () {
              const {
                active: Ke,
                collisions: ut,
                over: St,
                scrollAdjustedTranslate: kt,
              } = K.current;
              let Kt = null;
              if (Ke && kt) {
                const { cancelDrop: jt } = Q.current;
                (Kt = {
                  activatorEvent: mt,
                  active: Ke,
                  collisions: ut,
                  delta: kt,
                  over: St,
                }),
                  le === Gs.DragEnd &&
                    typeof jt == "function" &&
                    (await Promise.resolve(jt(Kt))) &&
                    (le = Gs.DragCancel);
              }
              (B.current = null),
                ri.unstable_batchedUpdates(() => {
                  S({ type: le }),
                    C(yc.Uninitialized),
                    Ze(null),
                    O(null),
                    j(null),
                    (Ye.current = null);
                  const jt = le === Gs.DragEnd ? "onDragEnd" : "onDragCancel";
                  if (Kt) {
                    const _n = Q.current[jt];
                    _n?.(Kt), A({ type: jt, event: Kt });
                  }
                });
            };
          }
        },
        [P]
      ),
      $t = E.useCallback(
        (Vt, Zt) => (ln, Je) => {
          const Ge = ln.nativeEvent,
            mt = P.get(Je);
          if (B.current !== null || !mt || Ge.dndKit || Ge.defaultPrevented)
            return;
          const zt = { active: mt };
          Vt(ln, Zt.options, zt) === !0 &&
            ((Ge.dndKit = { capturedBy: Zt.sensor }),
            (B.current = Je),
            Ot(ln, Zt));
        },
        [P, Ot]
      ),
      wn = pve(h, $t);
    Sve(h),
      Al(() => {
        se && R === yc.Initializing && C(yc.Initialized);
      }, [se, R]),
      E.useEffect(() => {
        const { onDragMove: Vt } = Q.current,
          {
            active: Zt,
            activatorEvent: ln,
            collisions: Je,
            over: Ge,
          } = K.current;
        if (!Zt || !ln) return;
        const mt = {
          active: Zt,
          activatorEvent: ln,
          collisions: Je,
          delta: { x: xt.x, y: xt.y },
          over: Ge,
        };
        ri.unstable_batchedUpdates(() => {
          Vt?.(mt), A({ type: "onDragMove", event: mt });
        });
      }, [xt.x, xt.y]),
      E.useEffect(() => {
        const {
          active: Vt,
          activatorEvent: Zt,
          collisions: ln,
          droppableContainers: Je,
          scrollAdjustedTranslate: Ge,
        } = K.current;
        if (!Vt || B.current == null || !Zt || !Ge) return;
        const { onDragOver: mt } = Q.current,
          zt = Je.get(He),
          an =
            zt && zt.rect.current
              ? {
                  id: zt.id,
                  rect: zt.rect.current,
                  data: zt.data,
                  disabled: zt.disabled,
                }
              : null,
          le = {
            active: Vt,
            activatorEvent: Zt,
            collisions: ln,
            delta: { x: Ge.x, y: Ge.y },
            over: an,
          };
        ri.unstable_batchedUpdates(() => {
          Ze(an), mt?.(le), A({ type: "onDragOver", event: le });
        });
      }, [He]),
      Al(() => {
        (K.current = {
          activatorEvent: U,
          active: z,
          activeNode: Z,
          collisionRect: _e,
          collisions: Ue,
          droppableRects: Y,
          draggableNodes: P,
          draggingNode: De,
          draggingNodeRect: ge,
          droppableContainers: N,
          over: Ve,
          scrollableAncestors: ne,
          scrollAdjustedTranslate: xt,
        }),
          (H.current = { initial: ge, translated: _e });
      }, [z, Z, Ue, _e, P, De, ge, Y, N, Ve, ne, xt]),
      dve({
        ...ce,
        delta: V,
        draggingRect: _e,
        pointerCoordinates: $e,
        scrollableAncestors: ne,
        scrollableAncestorRects: ie,
      });
    const Bn = E.useMemo(
        () => ({
          active: z,
          activeNode: Z,
          activeNodeRect: se,
          activatorEvent: U,
          collisions: Ue,
          containerNodeRect: be,
          dragOverlay: Ee,
          draggableNodes: P,
          droppableContainers: N,
          droppableRects: Y,
          over: Ve,
          measureDroppableContainers: J,
          scrollableAncestors: ne,
          scrollableAncestorRects: ie,
          measuringConfiguration: F,
          measuringScheduled: X,
          windowRect: ke,
        }),
        [z, Z, se, U, Ue, be, Ee, P, N, Y, Ve, J, ne, ie, F, X, ke]
      ),
      Ws = E.useMemo(
        () => ({
          activatorEvent: U,
          activators: wn,
          active: z,
          activeNodeRect: se,
          ariaDescribedById: { draggable: M },
          dispatch: S,
          draggableNodes: P,
          over: Ve,
          measureDroppableContainers: J,
        }),
        [U, wn, z, se, S, M, P, Ve, J]
      );
    return de.createElement(
      e7.Provider,
      { value: _ },
      de.createElement(
        Uv.Provider,
        { value: Ws },
        de.createElement(
          b7.Provider,
          { value: Bn },
          de.createElement(VE.Provider, { value: ft }, c)
        ),
        de.createElement(Dve, { disabled: o?.restoreFocus === !1 })
      ),
      de.createElement($ge, { ...o, hiddenTextDescribedById: M })
    );
    function ts() {
      const Vt = q?.autoScrollEnabled === !1,
        Zt = typeof l == "object" ? l.enabled === !1 : l === !1,
        ln = D && !Vt && !Zt;
      return typeof l == "object" ? { ...l, enabled: ln } : { enabled: ln };
    }
  }),
  Ove = E.createContext(null),
  Y3 = "button",
  jve = "Draggable";
function Fve(n) {
  let { id: e, data: t, disabled: s = !1, attributes: r } = n;
  const i = BE(jve),
    {
      activators: a,
      activatorEvent: o,
      active: l,
      activeNodeRect: c,
      ariaDescribedById: h,
      draggableNodes: m,
      over: p,
    } = E.useContext(Uv),
    {
      role: g = Y3,
      roleDescription: y = "draggable",
      tabIndex: b = 0,
    } = r ?? {},
    w = l?.id === e,
    S = E.useContext(w ? VE : Ove),
    [A, _] = zx(),
    [R, C] = zx(),
    D = Tve(a, e),
    L = Gg(t);
  Al(
    () => (
      m.set(e, { id: e, key: i, node: A, activatorNode: R, data: L }),
      () => {
        const V = m.get(e);
        V && V.key === i && m.delete(e);
      }
    ),
    [m, e]
  );
  const P = E.useMemo(
    () => ({
      role: g,
      tabIndex: b,
      "aria-disabled": s,
      "aria-pressed": w && g === Y3 ? !0 : void 0,
      "aria-roledescription": y,
      "aria-describedby": h.draggable,
    }),
    [s, g, b, w, y, h.draggable]
  );
  return {
    active: l,
    activatorEvent: o,
    activeNodeRect: c,
    attributes: P,
    isDragging: w,
    listeners: s ? void 0 : D,
    node: A,
    over: p,
    setNodeRef: _,
    setActivatorNodeRef: C,
    transform: S,
  };
}
function Uve() {
  return E.useContext(b7);
}
const $ve = "Droppable",
  Bve = { timeout: 25 };
function Hve(n) {
  let { data: e, disabled: t = !1, id: s, resizeObserverConfig: r } = n;
  const i = BE($ve),
    {
      active: a,
      dispatch: o,
      over: l,
      measureDroppableContainers: c,
    } = E.useContext(Uv),
    h = E.useRef({ disabled: t }),
    m = E.useRef(!1),
    p = E.useRef(null),
    g = E.useRef(null),
    { disabled: y, updateMeasurementsFor: b, timeout: w } = { ...Bve, ...r },
    S = Gg(b ?? s),
    A = E.useCallback(() => {
      if (!m.current) {
        m.current = !0;
        return;
      }
      g.current != null && clearTimeout(g.current),
        (g.current = setTimeout(() => {
          c(Array.isArray(S.current) ? S.current : [S.current]),
            (g.current = null);
        }, w));
    }, [w]),
    _ = HE({ callback: A, disabled: y || !a }),
    R = E.useCallback(
      (P, V) => {
        _ && (V && (_.unobserve(V), (m.current = !1)), P && _.observe(P));
      },
      [_]
    ),
    [C, D] = zx(R),
    L = Gg(e);
  return (
    E.useEffect(() => {
      !_ ||
        !C.current ||
        (_.disconnect(), (m.current = !1), _.observe(C.current));
    }, [C, _]),
    E.useEffect(
      () => (
        o({
          type: Gs.RegisterDroppable,
          element: { id: s, key: i, disabled: t, node: C, rect: p, data: L },
        }),
        () => o({ type: Gs.UnregisterDroppable, key: i, id: s })
      ),
      [s]
    ),
    E.useEffect(() => {
      t !== h.current.disabled &&
        (o({ type: Gs.SetDroppableDisabled, id: s, key: i, disabled: t }),
        (h.current.disabled = t));
    }, [s, i, t, o]),
    { active: a, rect: p, isOver: l?.id === s, node: C, over: l, setNodeRef: D }
  );
}
function Vve(n) {
  let { animation: e, children: t } = n;
  const [s, r] = E.useState(null),
    [i, a] = E.useState(null),
    o = Gx(t);
  return (
    !t && !s && o && r(o),
    Al(() => {
      if (!i) return;
      const l = s?.key,
        c = s?.props.id;
      if (l == null || c == null) {
        r(null);
        return;
      }
      Promise.resolve(e(c, i)).then(() => {
        r(null);
      });
    }, [e, s, i]),
    de.createElement(
      de.Fragment,
      null,
      t,
      s ? E.cloneElement(s, { ref: a }) : null
    )
  );
}
const zve = { x: 0, y: 0, scaleX: 1, scaleY: 1 };
function Gve(n) {
  let { children: e } = n;
  return de.createElement(
    Uv.Provider,
    { value: y7 },
    de.createElement(VE.Provider, { value: zve }, e)
  );
}
const qve = { position: "fixed", touchAction: "none" },
  Wve = (n) => (sD(n) ? "transform 250ms ease" : void 0),
  Kve = E.forwardRef((n, e) => {
    let {
      as: t,
      activatorEvent: s,
      adjustScale: r,
      children: i,
      className: a,
      rect: o,
      style: l,
      transform: c,
      transition: h = Wve,
    } = n;
    if (!o) return null;
    const m = r ? c : { ...c, scaleX: 1, scaleY: 1 },
      p = {
        ...qve,
        width: o.width,
        height: o.height,
        top: o.top,
        left: o.left,
        transform: Af.Transform.toString(m),
        transformOrigin: r && s ? Hge(s, o) : void 0,
        transition: typeof h == "function" ? h(s) : h,
        ...l,
      };
    return de.createElement(t, { className: a, style: p, ref: e }, i);
  }),
  Yve = (n) => (e) => {
    let { active: t, dragOverlay: s } = e;
    const r = {},
      { styles: i, className: a } = n;
    if (i != null && i.active)
      for (const [o, l] of Object.entries(i.active))
        l !== void 0 &&
          ((r[o] = t.node.style.getPropertyValue(o)),
          t.node.style.setProperty(o, l));
    if (i != null && i.dragOverlay)
      for (const [o, l] of Object.entries(i.dragOverlay))
        l !== void 0 && s.node.style.setProperty(o, l);
    return (
      a != null && a.active && t.node.classList.add(a.active),
      a != null && a.dragOverlay && s.node.classList.add(a.dragOverlay),
      function () {
        for (const [l, c] of Object.entries(r)) t.node.style.setProperty(l, c);
        a != null && a.active && t.node.classList.remove(a.active);
      }
    );
  },
  Xve = (n) => {
    let {
      transform: { initial: e, final: t },
    } = n;
    return [
      { transform: Af.Transform.toString(e) },
      { transform: Af.Transform.toString(t) },
    ];
  },
  Qve = {
    duration: 250,
    easing: "ease",
    keyframes: Xve,
    sideEffects: Yve({ styles: { active: { opacity: "0" } } }),
  };
function Zve(n) {
  let {
    config: e,
    draggableNodes: t,
    droppableContainers: s,
    measuringConfiguration: r,
  } = n;
  return $E((i, a) => {
    if (e === null) return;
    const o = t.get(i);
    if (!o) return;
    const l = o.node.current;
    if (!l) return;
    const c = v7(a);
    if (!c) return;
    const { transform: h } = Hr(a).getComputedStyle(a),
      m = s7(h);
    if (!m) return;
    const p = typeof e == "function" ? e : Jve(e);
    return (
      u7(l, r.draggable.measure),
      p({
        active: { id: i, data: o.data, node: l, rect: r.draggable.measure(l) },
        draggableNodes: t,
        dragOverlay: { node: a, rect: r.dragOverlay.measure(c) },
        droppableContainers: s,
        measuringConfiguration: r,
        transform: m,
      })
    );
  });
}
function Jve(n) {
  const {
    duration: e,
    easing: t,
    sideEffects: s,
    keyframes: r,
  } = { ...Qve, ...n };
  return (i) => {
    let { active: a, dragOverlay: o, transform: l, ...c } = i;
    if (!e) return;
    const h = { x: o.rect.left - a.rect.left, y: o.rect.top - a.rect.top },
      m = {
        scaleX: l.scaleX !== 1 ? (a.rect.width * l.scaleX) / o.rect.width : 1,
        scaleY: l.scaleY !== 1 ? (a.rect.height * l.scaleY) / o.rect.height : 1,
      },
      p = { x: l.x - h.x, y: l.y - h.y, ...m },
      g = r({
        ...c,
        active: a,
        dragOverlay: o,
        transform: { initial: l, final: p },
      }),
      [y] = g,
      b = g[g.length - 1];
    if (JSON.stringify(y) === JSON.stringify(b)) return;
    const w = s?.({ active: a, dragOverlay: o, ...c }),
      S = o.node.animate(g, { duration: e, easing: t, fill: "forwards" });
    return new Promise((A) => {
      S.onfinish = () => {
        w?.(), A();
      };
    });
  };
}
let X3 = 0;
function e0e(n) {
  return E.useMemo(() => {
    if (n != null) return X3++, X3;
  }, [n]);
}
const t0e = de.memo((n) => {
    let {
      adjustScale: e = !1,
      children: t,
      dropAnimation: s,
      style: r,
      transition: i,
      modifiers: a,
      wrapperElement: o = "div",
      className: l,
      zIndex: c = 999,
    } = n;
    const {
        activatorEvent: h,
        active: m,
        activeNodeRect: p,
        containerNodeRect: g,
        draggableNodes: y,
        droppableContainers: b,
        dragOverlay: w,
        over: S,
        measuringConfiguration: A,
        scrollableAncestors: _,
        scrollableAncestorRects: R,
        windowRect: C,
      } = Uve(),
      D = E.useContext(VE),
      L = e0e(m?.id),
      P = x7(a, {
        activatorEvent: h,
        active: m,
        activeNodeRect: p,
        containerNodeRect: g,
        draggingNodeRect: w.rect,
        over: S,
        overlayNodeRect: w.rect,
        scrollableAncestors: _,
        scrollableAncestorRects: R,
        transform: D,
        windowRect: C,
      }),
      V = oD(p),
      N = Zve({
        config: s,
        draggableNodes: y,
        droppableContainers: b,
        measuringConfiguration: A,
      }),
      W = V ? w.setRef : void 0;
    return de.createElement(
      Gve,
      null,
      de.createElement(
        Vve,
        { animation: N },
        m && L
          ? de.createElement(
              Kve,
              {
                key: L,
                id: m.id,
                ref: W,
                as: o,
                activatorEvent: h,
                adjustScale: e,
                className: l,
                transition: i,
                rect: V,
                style: { zIndex: c, ...r },
                transform: P,
              },
              t
            )
          : null
      )
    );
  }),
  n0e = ({
    flask: n,
    onDelete: e,
    availableTags: t,
    onTagUpdate: s,
    isDragging: r,
    isDragOver: i,
  }) => {
    const {
        attributes: a,
        listeners: o,
        setNodeRef: l,
        transform: c,
      } = Fve({ id: n.id, data: n }),
      { setNodeRef: h } = Hve({ id: n.id, data: n }),
      m = { transform: Af.Translate.toString(c), opacity: r ? 0 : 1 },
      p = (g) => {
        l(g), h(g);
      };
    return u.jsx("div", {
      ref: p,
      style: m,
      ...a,
      ...o,
      className: Le(
        r ? "cursor-grabbing" : "cursor-grab",
        "transition-all duration-200",
        i && !r && "ring-2 ring-white ring-opacity-50 rounded-3xl scale-105"
      ),
      children: u.jsx(Rk, {
        flask: n,
        onDelete: e,
        availableTags: t,
        onTagUpdate: s,
      }),
    });
  },
  s0e = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    flaskName: s,
    isDeleting: r = !1,
  }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[425px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: [
                  u.jsx(Mg, { className: "h-5 w-5 text-destructive" }),
                  "Delete Flask",
                ],
              }),
              u.jsxs(Cl, {
                className: "pt-4",
                children: [
                  "Are you sure you want to delete ",
                  u.jsxs("strong", { children: ['"', s, '"'] }),
                  "?",
                  u.jsx("br", {}),
                  u.jsx("br", {}),
                  "This action cannot be undone. All content, annotations, and associated data will be permanently deleted.",
                ],
              }),
            ],
          }),
          u.jsxs(xr, {
            className: "pt-6",
            children: [
              u.jsx(et, {
                variant: "outline",
                onClick: e,
                disabled: r,
                children: "Cancel",
              }),
              u.jsx(et, {
                variant: "destructive",
                onClick: t,
                disabled: r,
                children: r
                  ? u.jsxs(u.Fragment, {
                      children: [
                        u.jsx("span", {
                          className: "animate-spin h-4 w-4 mr-2",
                          children: "",
                        }),
                        "Deleting...",
                      ],
                    })
                  : u.jsxs(u.Fragment, {
                      children: [
                        u.jsx(Mg, { className: "h-4 w-4 mr-2" }),
                        "Delete Flask",
                      ],
                    }),
              }),
            ],
          }),
        ],
      }),
    }),
  w7 = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    tagName: s,
    isDeleting: r = !1,
  }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[425px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: [
                  u.jsx(ek, { className: "h-5 w-5 text-destructive" }),
                  "Delete Tag",
                ],
              }),
              u.jsxs(Cl, {
                className: "pt-4",
                children: [
                  "Are you sure you want to delete ",
                  u.jsxs("strong", { children: ['"', s, '"'] }),
                  "?",
                  u.jsx("br", {}),
                  u.jsx("br", {}),
                  "All flasks with this tag will lose it. This action cannot be undone.",
                ],
              }),
            ],
          }),
          u.jsxs(xr, {
            className: "pt-6",
            children: [
              u.jsx(et, {
                variant: "outline",
                onClick: e,
                disabled: r,
                children: "Cancel",
              }),
              u.jsx(et, {
                variant: "destructive",
                onClick: t,
                disabled: r,
                children: r ? "Deleting..." : "Delete Tag",
              }),
            ],
          }),
        ],
      }),
    }),
  r0e = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    sourceFlask: s,
    targetFlask: r,
    isMerging: i,
    isProTeam: a = !1,
  }) => {
    const o = es();
    if (!s || !r) return null;
    const l = () => {
      e(), o("/#pricing");
    };
    return u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[500px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: ["Move Assets to ", r.name],
              }),
              u.jsxs(Cl, {
                className: "pt-4 space-y-4",
                children: [
                  a
                    ? u.jsxs(u.Fragment, {
                        children: [
                          u.jsxs("div", {
                            className: "flex flex-col items-center space-y-3",
                            children: [
                              u.jsxs("div", {
                                className:
                                  "w-full bg-element-background/50 rounded-lg p-4",
                                children: [
                                  u.jsx("div", {
                                    className:
                                      "text-sm font-medium text-text-primary truncate mb-2",
                                    children: s.name,
                                  }),
                                  s.assets &&
                                    s.assets.length > 0 &&
                                    u.jsxs("div", {
                                      className:
                                        "flex gap-2 overflow-x-auto mb-2",
                                      children: [
                                        s.assets
                                          .slice(0, 3)
                                          .map((c, h) =>
                                            u.jsx(
                                              "div",
                                              {
                                                className:
                                                  "relative w-16 h-16 flex-shrink-0 rounded overflow-hidden bg-black/20",
                                                children: u.jsx(Vx, {
                                                  assets: [c],
                                                  className:
                                                    "absolute inset-0 w-full h-full object-cover",
                                                }),
                                              },
                                              c.id || h
                                            )
                                          ),
                                        s.assets.length > 3 &&
                                          u.jsxs("div", {
                                            className:
                                              "w-16 h-16 flex-shrink-0 rounded bg-black/40 flex items-center justify-center text-xs text-text-secondary",
                                            children: [
                                              "+",
                                              s.assets.length - 3,
                                            ],
                                          }),
                                      ],
                                    }),
                                  u.jsxs("div", {
                                    className: "text-xs text-text-secondary",
                                    children: [s.assetCount || 0, " assets"],
                                  }),
                                ],
                              }),
                              u.jsx("div", {
                                className: "flex items-center justify-center",
                                children: u.jsx(sle, {
                                  className: "h-5 w-5 text-text-secondary",
                                }),
                              }),
                              u.jsxs("div", {
                                className:
                                  "w-full bg-element-background/50 rounded-lg p-4 border border-text-primary",
                                children: [
                                  u.jsx("div", {
                                    className:
                                      "text-sm font-medium text-text-primary truncate mb-2",
                                    children: r.name,
                                  }),
                                  r.assets &&
                                    r.assets.length > 0 &&
                                    u.jsxs("div", {
                                      className:
                                        "flex gap-2 overflow-x-auto mb-2",
                                      children: [
                                        r.assets
                                          .slice(0, 3)
                                          .map((c, h) =>
                                            u.jsx(
                                              "div",
                                              {
                                                className:
                                                  "relative w-16 h-16 flex-shrink-0 rounded overflow-hidden bg-black/20",
                                                children: u.jsx(Vx, {
                                                  assets: [c],
                                                  className:
                                                    "absolute inset-0 w-full h-full object-cover",
                                                }),
                                              },
                                              c.id || h
                                            )
                                          ),
                                        r.assets.length > 3 &&
                                          u.jsxs("div", {
                                            className:
                                              "w-16 h-16 flex-shrink-0 rounded bg-black/40 flex items-center justify-center text-xs text-text-secondary",
                                            children: [
                                              "+",
                                              r.assets.length - 3,
                                            ],
                                          }),
                                      ],
                                    }),
                                  u.jsxs("div", {
                                    className: "text-xs text-text-secondary",
                                    children: [r.assetCount || 0, " assets"],
                                  }),
                                ],
                              }),
                            ],
                          }),
                          u.jsx("div", {
                            className: "space-y-2 text-sm",
                            children: u.jsxs("div", {
                              className: "text-sm text-text-secondary",
                              children: [
                                "All assets, notes and recordings from the Flask",
                                " ",
                                u.jsx("span", {
                                  className: "text-text-primary",
                                  children: s.name,
                                }),
                                " ",
                                "will be moved into the Flask",
                                " ",
                                u.jsx("span", {
                                  className: "text-text-primary",
                                  children: r.name,
                                }),
                                ".",
                              ],
                            }),
                          }),
                        ],
                      })
                    : u.jsx("div", {
                        className: " py-2 space-y-4",
                        children: u.jsx("div", {
                          className: "text-sm text-text-primary font-medium",
                          children:
                            "Upgrade to Flask Pro to add multiple assets to a Flask.",
                        }),
                      }),
                  u.jsx(Ak, {
                    children:
                      "You can use this feature to have multiple versions and revisions of the same project into a single Flask.",
                  }),
                ],
              }),
            ],
          }),
          u.jsx(xr, {
            className: "mt-6",
            children: a
              ? u.jsxs(u.Fragment, {
                  children: [
                    u.jsx(et, {
                      variant: "ghost",
                      onClick: e,
                      disabled: i,
                      children: "Cancel",
                    }),
                    u.jsx(et, {
                      onClick: t,
                      disabled: i,
                      className: "min-w-[120px] font-semibold",
                      children: i
                        ? u.jsxs(u.Fragment, {
                            children: [
                              u.jsx(wo, {
                                className: "mr-2 h-4 w-4 animate-spin",
                              }),
                              "Moving...",
                            ],
                          })
                        : `Move ${s.assetCount || 0} Assets`,
                    }),
                  ],
                })
              : u.jsxs(u.Fragment, {
                  children: [
                    u.jsx(et, {
                      variant: "ghost",
                      onClick: e,
                      children: "Cancel",
                    }),
                    u.jsx(et, {
                      onClick: l,
                      className: " font-semibold",
                      children: "Upgrade",
                    }),
                  ],
                }),
          }),
        ],
      }),
    });
  },
  Q3 = () => {
    const { user: n, isInitialized: e } = ks(),
      t = es();
    Sv(n?.id);
    const s = Pt((K) => K.currentTeam),
      r = Pt((K) => K.flasks),
      i = Pt((K) => K.tags),
      a = Pt((K) => K.flaskFilter.tagId),
      o = Pt((K) => K.flaskFilter.searchTerm),
      l = Pt((K) => K.skeleton.showFlaskGrid),
      c = Pt((K) => K.updateFlaskTagOptimistic),
      h = Pt((K) => K.deleteTagOptimistic),
      m = Pt((K) => K.deleteFlaskOptimistic),
      p = Pt((K) => K.setFlasks),
      [g, y] = E.useState(!1),
      [b, w] = E.useState(null),
      [S, A] = E.useState(null),
      [_, R] = E.useState(!1),
      [C, D] = E.useState(!1),
      [L, P] = E.useState(null),
      [V, N] = E.useState(null),
      [W, H] = E.useState(!1),
      [z, B] = E.useState(null),
      [q, O] = E.useState(null),
      [U, j] = E.useState(!1),
      Q = E.useMemo(() => {
        let K = r;
        if ((a && (K = K.filter((ve) => ve.flask_tag?.id === a)), o)) {
          const ve = o.toLowerCase();
          K = K.filter((Ee) => Ee.name.toLowerCase().includes(ve));
        }
        return [...K].sort((ve, Ee) => {
          const De = (fe) => {
              let ke = new Date(fe.updated_at || fe.created_at || 0).getTime();
              if (fe.assets && fe.assets.length > 0) {
                const ne = fe.assets
                  .map(($e) => $e.updated_at)
                  .filter(Boolean)
                  .map(($e) => Math.floor(new Date($e).getTime() / 6e4));
                if (new Set(ne).size === 1 && fe.assets.length > 0) {
                  const $e = Math.max(
                    ...fe.assets.map((ot) =>
                      new Date(ot.created_at || 0).getTime()
                    )
                  );
                  ke = Math.max(ke, $e);
                } else {
                  const $e = Math.max(
                    ...fe.assets.map((ot) =>
                      new Date(ot.updated_at || ot.created_at || 0).getTime()
                    )
                  );
                  ke = Math.max(ke, $e);
                }
              }
              return ke;
            },
            ge = De(ve);
          return De(Ee) - ge;
        });
      }, [r, a, o]),
      M = E.useCallback(
        async (K, ve) => {
          await c(K, ve);
        },
        [c]
      ),
      I = E.useCallback((K, ve) => {
        w({ id: K, name: ve }), y(!0);
      }, []),
      F = E.useCallback(async () => {
        b && (D(!0), await m(b.id), D(!1), y(!1), w(null));
      }, [b, m]),
      Y = E.useCallback(async () => {
        S && (D(!0), await h(S.id), D(!1), R(!1), A(null));
      }, [S, h]);
    de.useEffect(
      () => () => {
        document.body.style.cursor = "";
      },
      []
    );
    const J = Bge(
        U3(m7, { activationConstraint: { distance: 10 } }),
        U3(p7, { activationConstraint: { delay: 250, tolerance: 5 } })
      ),
      X = (K) => {
        P(K.active.id), (document.body.style.cursor = "grabbing");
      },
      Z = (K) => {
        const ve = K.over?.id;
        N(ve && ve !== L ? ve : null);
      },
      te = (K) => {
        const { active: ve, over: Ee } = K;
        if (
          (P(null),
          N(null),
          (document.body.style.cursor = ""),
          !Ee || ve.id === Ee.id)
        )
          return;
        const De = Q.find((re) => re.id === ve.id),
          ge = Q.find((re) => re.id === Ee.id);
        if (De && ge) {
          const re = {
              ...De,
              assetCount: De.assets?.length || 0,
              elementCount: De.element_count || 0,
              assets: De.assets || [],
            },
            fe = {
              ...ge,
              assetCount: ge.assets?.length || 0,
              elementCount: ge.element_count || 0,
              assets: ge.assets || [],
            };
          B(re), O(fe), H(!0);
        }
      },
      ce = E.useCallback(async () => {
        if (!(!z || !q)) {
          j(!0);
          try {
            const K = await Ut(`/api/flasks/${q.id}/merge`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ sourceFlaskId: z.id }),
            });
            if (!K.ok) {
              const ge = await K.json();
              throw new Error(ge.error || "Failed to merge flasks");
            }
            const ve = await K.json(),
              De = Pt.getState().flasks.filter((ge) => ge.id !== z.id);
            p(De),
              Xe.success(ve.message || "Flasks merged successfully"),
              H(!1),
              B(null),
              O(null),
              t(`/flask/${q.id}`);
          } catch (K) {
            console.error("Error merging flasks:", K),
              Xe.error(
                K instanceof Error ? K.message : "Failed to merge flasks"
              );
          } finally {
            j(!1);
          }
        }
      }, [z, q, p, t]),
      pe = () => {
        P(null), N(null), (document.body.style.cursor = "");
      },
      se = E.useMemo(() => Q.find((K) => K.id === L), [Q, L]),
      be = E.useMemo(() => {
        const K = Q.length,
          ve = 18,
          Ee = [];
        Q.forEach((ge) => {
          Ee.push({ type: "flask", id: ge.id, data: ge, key: ge.id });
        });
        const De = ve - K;
        for (let ge = 0; ge < De; ge++)
          Ee.push({
            type: "placeholder",
            id: `placeholder-${ge}`,
            data: null,
            key: `placeholder-${ge}`,
            showEmptyState: K === 0 && ge === 0,
            isLoading: l,
          });
        return Ee;
      }, [Q, l]);
    return !n && e
      ? u.jsx("div", {
          className: "space-y-6",
          children: u.jsx("div", {
            className:
              "grid grid-cols-2 sm:grid-cols-2 xl:grid-cols-3 gap-2 md:gap-4",
            children: u.jsx("div", {
              className:
                "bg-gradient-to-tr from-element-background/50 to-transparent border border-border/20 rounded-xl aspect-[4/3] flex items-center justify-center",
              children: u.jsxs("div", {
                className:
                  "flex flex-col items-center text-text-primary pointer-events-none",
                children: [
                  u.jsx("p", {
                    className: "text-lg mb-2 text-center",
                    children: "No Flasks yet ",
                  }),
                  u.jsx("p", {
                    className: "text-xs text-text-secondary text-center px-4",
                    children: "Sign in to create your first Flask",
                  }),
                ],
              }),
            }),
          }),
        })
      : u.jsxs(u.Fragment, {
          children: [
            u.jsxs(Nve, {
              sensors: J,
              onDragStart: X,
              onDragOver: Z,
              onDragEnd: te,
              onDragCancel: pe,
              collisionDetection: t7,
              children: [
                u.jsx("div", {
                  className: "space-y-6",
                  children: u.jsx("div", {
                    className:
                      "grid grid-cols-2 sm:grid-cols-2 xl:grid-cols-3 gap-2 md:gap-4 relative",
                    children: be.map((K) => {
                      if (K.type === "flask")
                        return u.jsx(
                          n0e,
                          {
                            flask: K.data,
                            onDelete: I,
                            availableTags: i || [],
                            onTagUpdate: M,
                            isDragging: L === K.data.id,
                            isDragOver: V === K.data.id,
                          },
                          K.key
                        );
                      {
                        const ve = {
                          id: K.id,
                          name: "",
                          created_at: "",
                          updated_at: "",
                          assets: [],
                          element_count: 0,
                          flask_tag: null,
                          user_id: "",
                          access_level: "private",
                        };
                        return u.jsx(
                          Rk,
                          {
                            flask: ve,
                            onDelete: () => {},
                            availableTags: [],
                            onTagUpdate: () => {},
                            isPlaceholder: !0,
                            showEmptyState: K.showEmptyState,
                            isLoading: K.isLoading,
                          },
                          K.key
                        );
                      }
                    }),
                  }),
                }),
                u.jsx(t0e, {
                  children: se
                    ? u.jsx("div", {
                        className: "opacity-90 cursor-grabbing",
                        children: u.jsx(Rk, {
                          flask: se,
                          onDelete: () => {},
                          availableTags: [],
                          onTagUpdate: () => {},
                        }),
                      })
                    : null,
                }),
              ],
            }),
            b &&
              u.jsx(s0e, {
                isOpen: g,
                onClose: () => {
                  y(!1), w(null);
                },
                onConfirm: F,
                flaskName: b.name,
                isDeleting: C,
              }),
            S &&
              u.jsx(w7, {
                isOpen: _,
                onClose: () => {
                  R(!1), A(null);
                },
                onConfirm: Y,
                tagName: S.name,
                isDeleting: C,
              }),
            u.jsx(r0e, {
              isOpen: W,
              onClose: () => {
                H(!1), B(null), O(null);
              },
              onConfirm: ce,
              sourceFlask: z,
              targetFlask: q,
              isMerging: U,
              isProTeam: s?.team_type === "pro_team",
            }),
          ],
        });
  },
  i0e = ({ onTeamChange: n }) => {
    const e = es(),
      { user: t } = ks(),
      [s, r] = od();
    Sv(t?.id);
    const i = Pt((p) => p.currentTeam),
      a = Pt((p) => p.userTeams),
      o = Pt((p) => p.isLoadingTeams),
      l = Pt((p) => p.switchTeam),
      c = async (p) => {
        await l(p);
        const g = a.find((y) => y.id === p);
        n && g && n({ id: g.id, name: g.name });
      },
      h = () => {
        e("/#pricing");
      },
      m = () => {
        const p = new URLSearchParams(s);
        p.set("settings", "team"), r(p);
      };
    return u.jsx("div", {
      className: "relative",
      children: u.jsxs("div", {
        className:
          "group w-full bg-card-background border-b border-border/70 rounded-2xl overflow-hidden flex items-center hover:opacity-80 transition-all duration-200",
        children: [
          u.jsxs(Ii, {
            children: [
              u.jsx(Li, {
                asChild: !0,
                children: u.jsx("div", {
                  className:
                    "flex-1 py-3 px-5 min-w-0 overflow-hidden cursor-pointer",
                  children: u.jsxs("div", {
                    className: "flex items-center justify-between",
                    children: [
                      u.jsxs("div", {
                        className: "flex flex-col min-w-0",
                        children: [
                          u.jsx("div", {
                            className:
                              "text-sm font-medium text-foreground truncate",
                            children: i ? i.name : "Select Team",
                          }),
                          u.jsx("div", {
                            className: "text-xs text-text-secondary",
                            children:
                              i &&
                              u.jsx("span", {
                                children:
                                  i.team_type === "pro_team"
                                    ? "Pro Team"
                                    : "Free Team",
                              }),
                          }),
                        ],
                      }),
                      u.jsx("div", {
                        className: "flex items-center ml-4",
                        children: u.jsx(IH, {
                          className: "h-4 w-4 text-text-secondary",
                        }),
                      }),
                    ],
                  }),
                }),
              }),
              u.jsxs(ui, {
                align: "start",
                className:
                  "w-full min-w-[var(--radix-dropdown-menu-trigger-width)]",
                children: [
                  u.jsxs(jn, {
                    onClick: m,
                    className: "cursor-pointer py-3 px-4",
                    children: [
                      u.jsx(RU, { className: "h-4 w-4 mr-2" }),
                      "Team Settings",
                    ],
                  }),
                  u.jsx(Bg, {}),
                  u.jsx("div", {
                    className: "px-4 py-2",
                    children: u.jsx("div", {
                      className:
                        "text-xs font-semibold text-muted-foreground uppercase tracking-wider",
                      children: "Switch Team",
                    }),
                  }),
                  o
                    ? u.jsx(jn, {
                        disabled: !0,
                        className: "py-3 px-4",
                        children: "Loading teams...",
                      })
                    : a.length === 0
                    ? u.jsx(jn, {
                        disabled: !0,
                        className: "py-3 px-4",
                        children: "No teams found",
                      })
                    : a.map((p) =>
                        u.jsxs(
                          jn,
                          {
                            onClick: () => c(p.id),
                            className:
                              "flex items-center justify-between cursor-pointer py-3 px-4",
                            children: [
                              u.jsxs("div", {
                                className: "flex flex-col min-w-0 flex-1 mr-3",
                                children: [
                                  u.jsx("span", {
                                    className: "font-medium truncate",
                                    children: p.name,
                                  }),
                                  u.jsx("div", {
                                    className:
                                      "text-xs text-muted-foreground mt-1",
                                    children: u.jsx("span", {
                                      children:
                                        p.team_type === "pro_team"
                                          ? "Pro Team"
                                          : "Free Team",
                                    }),
                                  }),
                                ],
                              }),
                              i?.id === p.id &&
                                u.jsx(zs, {
                                  className: "h-4 w-4 text-primary",
                                }),
                            ],
                          },
                          p.id
                        )
                      ),
                  u.jsx(Bg, {}),
                  u.jsxs(jn, {
                    onClick: h,
                    className: "cursor-pointer py-3 px-4",
                    children: [
                      u.jsx(Zu, { className: "h-4 w-4 mr-2" }),
                      "Create New Team",
                    ],
                  }),
                ],
              }),
            ],
          }),
          u.jsx(et, {
            variant: "ghost",
            size: "icon",
            onClick: m,
            className:
              "h-8 w-8 hover:bg-card-background rounded-lg transition-colors mr-2",
            children: u.jsx(RU, { className: "h-4 w-4 text-muted-foreground" }),
          }),
        ],
      }),
    });
  };
function a0e({
  topLeftCornerRadius: n,
  topRightCornerRadius: e,
  bottomRightCornerRadius: t,
  bottomLeftCornerRadius: s,
  width: r,
  height: i,
}) {
  const a = { topLeft: -1, topRight: -1, bottomLeft: -1, bottomRight: -1 },
    o = { topLeft: n, topRight: e, bottomLeft: s, bottomRight: t };
  return (
    Object.entries(o)
      .sort(([, l], [, c]) => c - l)
      .forEach(([l, c]) => {
        const h = l,
          m = o0e[h],
          p = Math.min(
            ...m.map((g) => {
              const y = o[g.corner];
              if (c === 0 && y === 0) return 0;
              const b = a[g.corner],
                w = g.side === "top" || g.side === "bottom" ? r : i;
              return b >= 0 ? w - a[g.corner] : (c / (c + y)) * w;
            })
          );
        (a[h] = p), (o[h] = Math.min(c, p));
      }),
    {
      topLeft: { radius: o.topLeft, roundingAndSmoothingBudget: a.topLeft },
      topRight: { radius: o.topRight, roundingAndSmoothingBudget: a.topRight },
      bottomLeft: {
        radius: o.bottomLeft,
        roundingAndSmoothingBudget: a.bottomLeft,
      },
      bottomRight: {
        radius: o.bottomRight,
        roundingAndSmoothingBudget: a.bottomRight,
      },
    }
  );
}
const o0e = {
  topLeft: [
    { corner: "topRight", side: "top" },
    { corner: "bottomLeft", side: "left" },
  ],
  topRight: [
    { corner: "topLeft", side: "top" },
    { corner: "bottomRight", side: "right" },
  ],
  bottomLeft: [
    { corner: "bottomRight", side: "bottom" },
    { corner: "topLeft", side: "left" },
  ],
  bottomRight: [
    { corner: "bottomLeft", side: "bottom" },
    { corner: "topRight", side: "right" },
  ],
};
function cp({
  cornerRadius: n,
  cornerSmoothing: e,
  preserveSmoothing: t,
  roundingAndSmoothingBudget: s,
}) {
  let r = (1 + e) * n;
  if (!t) {
    const y = s / n - 1;
    (e = Math.min(e, y)), (r = Math.min(r, s));
  }
  const i = 90 * (1 - e),
    a = Math.sin(Ly(i / 2)) * n * Math.sqrt(2),
    o = (90 - i) / 2,
    l = n * Math.tan(Ly(o / 2)),
    c = 45 * e,
    h = l * Math.cos(Ly(c)),
    m = h * Math.tan(Ly(c));
  let p = (r - a - h - m) / 3,
    g = 2 * p;
  if (t && r > s) {
    const y = s - m - a - h,
      b = y / 6,
      w = y - b;
    (p = Math.min(p, w)), (g = y - p), (r = Math.min(r, s));
  }
  return { a: g, b: p, c: h, d: m, p: r, arcSectionLength: a, cornerRadius: n };
}
function Z3({
  width: n,
  height: e,
  topLeftPathParams: t,
  topRightPathParams: s,
  bottomLeftPathParams: r,
  bottomRightPathParams: i,
}) {
  return `
    M ${n - s.p} 0
    ${l0e(s)}
    L ${n} ${e - i.p}
    ${c0e(i)}
    L ${r.p} ${e}
    ${u0e(r)}
    L 0 ${t.p}
    ${d0e(t)}
    Z
  `
    .replace(/[\t\s\n]+/g, " ")
    .trim();
}
function l0e({
  cornerRadius: n,
  a: e,
  b: t,
  c: s,
  d: r,
  p: i,
  arcSectionLength: a,
}) {
  return n
    ? Fc`
    c ${e} 0 ${e + t} 0 ${e + t + s} ${r}
    a ${n} ${n} 0 0 1 ${a} ${a}
    c ${r} ${s}
        ${r} ${t + s}
        ${r} ${e + t + s}`
    : Fc`l ${i} 0`;
}
function c0e({
  cornerRadius: n,
  a: e,
  b: t,
  c: s,
  d: r,
  p: i,
  arcSectionLength: a,
}) {
  return n
    ? Fc`
    c 0 ${e}
      0 ${e + t}
      ${-r} ${e + t + s}
    a ${n} ${n} 0 0 1 -${a} ${a}
    c ${-s} ${r}
      ${-(t + s)} ${r}
      ${-(e + t + s)} ${r}`
    : Fc`l 0 ${i}`;
}
function u0e({
  cornerRadius: n,
  a: e,
  b: t,
  c: s,
  d: r,
  p: i,
  arcSectionLength: a,
}) {
  return n
    ? Fc`
    c ${-e} 0
      ${-(e + t)} 0
      ${-(e + t + s)} ${-r}
    a ${n} ${n} 0 0 1 -${a} -${a}
    c ${-r} ${-s}
      ${-r} ${-(t + s)}
      ${-r} ${-(e + t + s)}`
    : Fc`l ${-i} 0`;
}
function d0e({
  cornerRadius: n,
  a: e,
  b: t,
  c: s,
  d: r,
  p: i,
  arcSectionLength: a,
}) {
  return n
    ? Fc`
    c 0 ${-e}
      0 ${-(e + t)}
      ${r} ${-(e + t + s)}
    a ${n} ${n} 0 0 1 ${a} -${a}
    c ${s} ${-r}
      ${t + s} ${-r}
      ${e + t + s} ${-r}`
    : Fc`l 0 ${-i}`;
}
function Ly(n) {
  return (n * Math.PI) / 180;
}
function Fc(n, ...e) {
  return n.reduce((t, s, r) => {
    let i = e[r];
    return typeof i == "number" ? t + s + i.toFixed(4) : t + s + (i ?? "");
  }, "");
}
function N1({
  cornerRadius: n = 0,
  topLeftCornerRadius: e,
  topRightCornerRadius: t,
  bottomRightCornerRadius: s,
  bottomLeftCornerRadius: r,
  cornerSmoothing: i,
  width: a,
  height: o,
  preserveSmoothing: l = !1,
}) {
  if (
    ((e = e ?? n),
    (t = t ?? n),
    (r = r ?? n),
    (s = s ?? n),
    e === t && t === s && s === r && r === e)
  ) {
    const g = Math.min(a, o) / 2,
      y = Math.min(e, g),
      b = cp({
        cornerRadius: y,
        cornerSmoothing: i,
        preserveSmoothing: l,
        roundingAndSmoothingBudget: g,
      });
    return Z3({
      width: a,
      height: o,
      topLeftPathParams: b,
      topRightPathParams: b,
      bottomLeftPathParams: b,
      bottomRightPathParams: b,
    });
  }
  const {
    topLeft: c,
    topRight: h,
    bottomLeft: m,
    bottomRight: p,
  } = a0e({
    topLeftCornerRadius: e,
    topRightCornerRadius: t,
    bottomRightCornerRadius: s,
    bottomLeftCornerRadius: r,
    width: a,
    height: o,
  });
  return Z3({
    width: a,
    height: o,
    topLeftPathParams: cp({
      cornerSmoothing: i,
      preserveSmoothing: l,
      cornerRadius: c.radius,
      roundingAndSmoothingBudget: c.roundingAndSmoothingBudget,
    }),
    topRightPathParams: cp({
      cornerSmoothing: i,
      preserveSmoothing: l,
      cornerRadius: h.radius,
      roundingAndSmoothingBudget: h.roundingAndSmoothingBudget,
    }),
    bottomRightPathParams: cp({
      cornerSmoothing: i,
      preserveSmoothing: l,
      cornerRadius: p.radius,
      roundingAndSmoothingBudget: p.roundingAndSmoothingBudget,
    }),
    bottomLeftPathParams: cp({
      cornerSmoothing: i,
      preserveSmoothing: l,
      cornerRadius: m.radius,
      roundingAndSmoothingBudget: m.roundingAndSmoothingBudget,
    }),
  });
}
const h0e = (n = 8) => {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let t = "";
    for (let s = 0; s < n; s++)
      t += e.charAt(Math.floor(Math.random() * e.length));
    return `squircle-${t}`;
  },
  f0e = (n, e) => {
    let t = document.getElementById(e);
    t ||
      ((t = document.createElement("style")),
      (t.id = e),
      document.head.appendChild(t)),
      (t.textContent = n);
  },
  m0e = (n, e, t) => {
    const s = n.clientWidth,
      r = n.clientHeight,
      i = {
        preserveSmoothing: !0,
        cornerSmoothing: 1,
        width: s,
        height: r,
        ...e,
      };
    e.borderWidth
      ? (n.classList.add(t),
        f0e(
          `
        .${t} {
          position: relative;
          clip-path: path('${N1(i)}');
        }

        .${t}::before {
          content: '';
          display: block;
          position: absolute;
          inset: ${e.borderWidth}px;  
          z-index: -1;
          clip-path: path('${N1({
            ...i,
            width: s - e.borderWidth * 2,
            height: r - e.borderWidth * 2,
            cornerRadius: e.cornerRadius - e.borderWidth,
          })}');
        }
      `,
          `style-${t}`
        ))
      : (n.style.clipPath = `path('${N1(i)}')`);
  },
  p0e = (n, e) => {
    const t = h0e();
    let s;
    const r = (a) => (a !== void 0 && (e = a), m0e(n, e, t)),
      i = new ResizeObserver(() => {
        const a = s;
        (s = [n.clientWidth, n.clientHeight]),
          (a?.[0] !== s[0] || a?.[1] !== s[1]) && r();
      });
    return (
      i.observe(n),
      (r.disconnect = () => {
        n.classList.remove(t),
          document.querySelector(`#style-${t}`)?.remove(),
          i.disconnect();
      }),
      r
    );
  },
  g0e = (n) => {
    const e = {};
    for (const t in n) n[t] !== void 0 && (e[t] = n[t]);
    return e;
  },
  v0e = E.forwardRef(
    (
      {
        children: n,
        as: e = "div",
        cornerRadius: t,
        topLeftCornerRadius: s,
        topRightCornerRadius: r,
        bottomRightCornerRadius: i,
        bottomLeftCornerRadius: a,
        cornerSmoothing: o,
        preserveSmoothing: l,
        borderWidth: c,
        ...h
      },
      m
    ) => {
      const p = E.useRef(),
        g = E.useCallback(
          (y) => {
            const b = g0e({
              cornerRadius: t,
              topLeftCornerRadius: s,
              topRightCornerRadius: r,
              bottomRightCornerRadius: i,
              bottomLeftCornerRadius: a,
              cornerSmoothing: o,
              preserveSmoothing: l,
              borderWidth: c,
            });
            p.current?.disconnect(),
              y && (p.current = p0e(y, b)),
              typeof m == "function" ? m(y) : m && (m.current = y);
          },
          [t, s, r, i, a, o, l, c]
        );
      return de.createElement(e, { ref: g, ...h }, n);
    }
  ),
  zE = de.forwardRef(
    (
      {
        children: n,
        className: e,
        cornerRadius: t = 12,
        cornerSmoothing: s = 1,
        preserveSmoothing: r = !0,
        borderWidth: i,
        style: a,
        as: o = "div",
        ...l
      },
      c
    ) =>
      u.jsx(v0e, {
        ref: c,
        cornerRadius: t,
        cornerSmoothing: s,
        preserveSmoothing: r,
        borderWidth: i,
        as: o,
        className: Le(e),
        style: a,
        ...l,
        children: n,
      })
  );
zE.displayName = "Squircle";
const y0e = de.forwardRef((n, e) =>
  u.jsx(zE, { ref: e, cornerRadius: 8, ...n })
);
y0e.displayName = "SquircleSm";
const E7 = de.forwardRef((n, e) =>
  u.jsx(zE, { ref: e, cornerRadius: 12, ...n })
);
E7.displayName = "SquircleMd";
const b0e = de.forwardRef((n, e) =>
  u.jsx(zE, { ref: e, cornerRadius: 16, ...n })
);
b0e.displayName = "SquircleLg";
const Lk = de.memo(
    ({
      iconOnly: n = !1,
      largeIcon: e = !1,
      fullHeightIcon: t = !1,
      primaryButton: s = !1,
    }) => {
      const { user: r, profile: i, isInitialized: a, signOut: o } = ks(),
        l = es(),
        c = Dr(),
        h = (R) => (R ? R.split(" ")[0] : null),
        m =
          r && i
            ? {
                id: r.id,
                full_name: i.full_name,
                avatar_url: i.avatar_url,
                email: r.email,
              }
            : null,
        p = () => {
          const R = c.pathname + c.search,
            C = `/login?returnUrl=${encodeURIComponent(R)}`;
          l(C);
        },
        g = () => l("/dash"),
        y = async () => {
          try {
            await o(), Xe.success("Signed out successfully");
            const R = c.pathname;
            R.startsWith("/flask/")
              ? l(R)
              : R === "/dash" || R.startsWith("/team")
              ? l("/")
              : l(c.pathname);
          } catch (R) {
            console.error("Error signing out:", R),
              Xe.error("Failed to sign out");
          }
        },
        b = () => l("/#talk-to-us"),
        w = () =>
          u.jsxs(ui, {
            align: "end",
            className: "bg-card-background border-border w-64",
            children: [
              u.jsxs(jn, {
                disabled: !0,
                className: "text-text-primary flex flex-col items-start",
                children: [
                  u.jsx("div", {
                    className: "text-xs text-text-secondary",
                    children: "You're logged in as",
                  }),
                  u.jsx("div", { className: "font-medium", children: r.email }),
                ],
              }),
              u.jsx(Bg, { className: "bg-border" }),
              u.jsx(jn, {
                onClick: b,
                className: "text-text-primary hover:bg-card-background/50",
                children: u.jsxs("div", {
                  className: "flex items-center w-full gap-4",
                  children: [
                    u.jsx("div", {
                      className:
                        "w-5 flex items-center justify-center flex-shrink-0",
                      children: u.jsx(ple, { className: "h-4 w-4" }),
                    }),
                    u.jsx("span", { children: "Help and Feedback" }),
                  ],
                }),
              }),
              u.jsx(Bg, { className: "bg-border" }),
              u.jsx(jn, {
                onClick: y,
                className: "text-text-primary hover:bg-card-background/50",
                children: u.jsxs("div", {
                  className: "flex items-center w-full gap-4",
                  children: [
                    u.jsx("div", {
                      className:
                        "w-5 flex items-center justify-center flex-shrink-0",
                      children: u.jsx(fle, { className: "h-4 w-4" }),
                    }),
                    u.jsx("span", { children: "Sign out" }),
                  ],
                }),
              }),
            ],
          });
      if (!a)
        return n
          ? u.jsx(yo, { circle: !0, width: 40, height: 40 })
          : u.jsx(E7, {
              cornerRadius: 14,
              className: "px-4 py-2",
              children: u.jsx(yo, { width: 80 }),
            });
      if (!r)
        return n
          ? u.jsxs(Ii, {
              children: [
                u.jsx(Li, {
                  asChild: !0,
                  children: u.jsx(et, {
                    variant: "ghost",
                    className:
                      "h-7 w-7  font-semibold hover:bg-transparent transition-all duration-200 text-card-background rounded-none border-0",
                    children: u.jsx(tk, { className: "h-5 w-5 text-gray-400" }),
                  }),
                }),
                u.jsx(ui, {
                  align: "end",
                  className: "bg-card-background border-border",
                  children: u.jsxs(jn, {
                    onClick: p,
                    className:
                      "text-text-primary hover:bg-card-background/50 flex items-center",
                    children: [
                      u.jsx(tk, { className: "mr-2 h-4 w-4" }),
                      "Sign In",
                    ],
                  }),
                }),
              ],
            })
          : u.jsx("div", {
              onClick: g,
              className: Le(
                "px-4 bg-text-primary bg-gradient-to-t from-teal-300/30 via-text-primary/90 to-text-primary/90 rounded-full py-2",
                "text-card-background flex items-center justify-center",
                "hover:bg-text-primary transition-all duration-200 font-semibold cursor-pointer"
              ),
              children: u.jsx("span", {
                className: "text-xs font-medium",
                children: "Get Started ",
              }),
            });
      const A = h(i?.full_name) || r.email?.split("@")[0] || "User",
        _ = r?.user_metadata?.avatar_url || r?.user_metadata?.picture;
      return u.jsx(u.Fragment, {
        children: u.jsxs(Ii, {
          children: [
            u.jsx(Li, {
              asChild: !0,
              children: n
                ? u.jsx(et, {
                    variant: "ghost",
                    className: Le(
                      "p-0 font-semibold hover:bg-transparent transition-all duration-200 text-card-background rounded-none border-0",
                      t ? "h-full w-auto" : "h-7"
                    ),
                    children: u.jsx(Ng, {
                      user: m,
                      src: _,
                      size: t ? "full" : "sm",
                    }),
                  })
                : u.jsxs("div", {
                    className:
                      "px-2 md:px-5 py-3 rounded-2xl h-full w-full hover:opacity-80 text-text-primary flex justify-between items-center gap-3 transition-all duration-200 cursor-pointer",
                    children: [
                      u.jsxs("div", {
                        className: "flex flex-col md:flex",
                        children: [
                          u.jsx("span", {
                            className: "text-sm font-medium hidden md:block",
                            children: A,
                          }),
                          u.jsx("span", {
                            className:
                              "text-xs text-text-secondary hidden md:block",
                            children: r.email,
                          }),
                        ],
                      }),
                      u.jsx(Ng, { user: m, src: _, size: "sm" }),
                    ],
                  }),
            }),
            u.jsx(w, {}),
          ],
        }),
      });
    }
  ),
  S7 = ({ isOpen: n, onClose: e }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "w-[90vw] max-w-md",
        style: {
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          margin: 0,
        },
        children: [
          u.jsx(bs, {
            className: "text-center",
            children: u.jsx(xs, {
              className: "text-xl font-semibold mb-4",
              children: "Limited Features on Mobile",
            }),
          }),
          u.jsxs("div", {
            className: "text-center space-y-4",
            children: [
              u.jsx("p", {
                className: "text-text-secondary",
                children: "Flask is not yet built for mobile.",
              }),
              u.jsxs("p", {
                className: "text-text-secondary",
                children: [
                  " ",
                  "While it works to leave a quick comment, to use Flask, open it on Desktop.",
                ],
              }),
              u.jsx("button", {
                className:
                  "button-primary w-full flex items-center justify-center px-6 py-3 text-sm font-medium rounded-xl",
                onClick: e,
                children: "Got it",
              }),
            ],
          }),
        ],
      }),
    }),
  x0e = ({ tag: n }) =>
    u.jsx(XG, { text: n.name, className: "text-xs transition-colors" }),
  w0e = ({
    tag: n,
    selectedTagId: e,
    onTagClick: t,
    onTagDelete: s,
    getFlaskCountForTag: r,
  }) => {
    const [i, a] = E.useState(!1);
    return u.jsxs(
      "button",
      {
        onMouseEnter: () => a(!0),
        onMouseLeave: () => a(!1),
        onClick: () => t(n.id),
        className: Le(
          "group flex items-center justify-between px-4 py-3 rounded-lg text-left transition-colors w-full",
          e === n.id
            ? "bg-card-background border-b border-border/50 text-foreground"
            : "text-muted-foreground hover:text-foreground hover:bg-card-background/30"
        ),
        children: [
          u.jsxs("div", {
            className: "flex items-center gap-2",
            children: [
              u.jsx(x0e, { tag: n }),
              i &&
                u.jsx("button", {
                  onClick: (o) => {
                    o.stopPropagation(), s(n);
                  },
                  className:
                    "p-0.5 hover:bg-card-background/50 rounded transition-colors",
                  children: u.jsx(Pa, {
                    className:
                      "h-3 w-3 text-muted-foreground hover:text-foreground",
                  }),
                }),
            ],
          }),
          u.jsx("span", {
            className: "text-xs text-muted-foreground",
            children: r(n.id),
          }),
        ],
      },
      n.id
    );
  },
  E0e = de.memo(function () {
    const { user: e } = ks();
    Sv(e?.id);
    const t = Pt((q) => q.tags),
      s = Pt((q) => q.flasks),
      r = Pt((q) => q.currentTeam),
      i = Pt((q) => q.flaskFilter.tagId),
      a = Pt((q) => q.flaskFilter.userId),
      o = Pt((q) => q.setFlaskTagFilter),
      l = Pt((q) => q.setFlaskUserFilter),
      c = Pt((q) => q.createTagOptimistic),
      h = Pt((q) => q.deleteTagOptimistic),
      m = Pt((q) => q.skeleton.showSidebar),
      p = Pt((q) => q.userProfiles),
      [g, y] = E.useState(!1),
      [b, w] = E.useState(""),
      [S, A] = E.useState(null),
      [_, R] = E.useState(!1),
      C = de.useRef(null);
    de.useEffect(() => {
      const q = () => {
        y(!0),
          w(""),
          setTimeout(() => {
            C.current?.focus();
          }, 100);
      };
      return (
        window.addEventListener("sidebar-create-tag", q),
        () => {
          window.removeEventListener("sidebar-create-tag", q);
        }
      );
    }, []);
    const D = E.useCallback(
        (q) => {
          i === q ? o(null) : (o(q), l(null));
        },
        [i, o, l]
      ),
      L = E.useCallback(() => {
        o(null), l(null);
      }, [o, l]);
    E.useCallback(
      (q) => {
        a === q ? l(null) : (l(q), o(null));
      },
      [a, o, l]
    );
    const P = E.useCallback(
        (q) => {
          let O = s;
          return (
            a && (O = O.filter((U) => U.user_id === a)),
            q ? O.filter((U) => U.flask_tag?.id === q).length : O.length
          );
        },
        [s, a]
      ),
      V = E.useCallback((q) => s.filter((O) => O.user_id === q).length, [s]);
    E.useMemo(() => {
      const q = new Map();
      return (
        r?.members &&
          r.members.forEach((O) => {
            q.set(O.user_id, {
              id: O.user_id,
              name:
                O.user?.full_name ||
                O.display_name ||
                O.user?.email ||
                O.email ||
                "Unknown",
              email: O.user?.email || O.email,
              avatarUrl: O.user?.avatar_url || O.avatar_url,
              flaskCount: V(O.user_id),
              isTeamMember: !0,
            });
          }),
        s.forEach((O) => {
          if (O.user_id && !q.has(O.user_id)) {
            const U = p[O.user_id];
            q.set(O.user_id, {
              id: O.user_id,
              name:
                U?.full_name || U?.name || U?.email?.split("@")[0] || "Unknown",
              email: U?.email,
              avatarUrl: U?.avatar_url,
              flaskCount: V(O.user_id),
              isTeamMember: !1,
            });
          }
        }),
        Array.from(q.values())
      );
    }, [r?.members, s, p, V]);
    const N = E.useCallback(() => {
        y(!0), w("");
      }, []),
      W = E.useCallback(async () => {
        if (!b.trim()) {
          y(!1);
          return;
        }
        y(!1);
        const q = b.trim();
        w("");
        try {
          await c(q);
        } catch (O) {
          console.error("Failed to create tag:", O);
        }
      }, [b, c]),
      H = E.useCallback(
        (q) => {
          q.key === "Enter"
            ? (q.preventDefault(), W())
            : q.key === "Escape" && (q.preventDefault(), y(!1), w(""));
        },
        [W]
      ),
      z = E.useCallback((q) => {
        A(q), R(!0);
      }, []),
      B = E.useCallback(async () => {
        S && (await h(S.id), R(!1), A(null));
      }, [S, h]);
    return m
      ? u.jsxs("div", {
          className: "flex flex-col gap-6",
          children: [
            u.jsx("div", {
              className:
                "w-full rounded-2xl bg-element-background/30 h-24 animate-pulse",
            }),
            u.jsx("div", {
              className: "flex flex-col gap-2",
              children: u.jsx("div", {
                className:
                  "h-12 bg-element-background/30  rounded-lg animate-pulse",
              }),
            }),
            u.jsxs("div", {
              className: "flex flex-col gap-3",
              children: [
                u.jsx("div", {
                  className: "px-4",
                  children: u.jsx("div", {
                    className:
                      "h-4 bg-element-background/30  rounded w-12 animate-pulse",
                  }),
                }),
                u.jsx("div", {
                  className: "flex flex-col gap-2",
                  children: Array.from({ length: 2 }).map((q, O) =>
                    u.jsx(
                      "div",
                      {
                        className: "px-4",
                        children: u.jsx("div", {
                          className:
                            "h-10 bg-element-background/30 rounded-lg animate-pulse",
                        }),
                      },
                      `tag-${O}`
                    )
                  ),
                }),
              ],
            }),
          ],
        })
      : u.jsxs("div", {
          className: "flex flex-col gap-6",
          children: [
            u.jsx("div", {
              className: "flex flex-col gap-2",
              children: u.jsxs("button", {
                onClick: L,
                className: Le(
                  "flex items-center justify-between px-4 py-3 rounded-lg text-left transition-colors",
                  !i && !a
                    ? "bg-card-background text-foreground border-b border-border/50"
                    : "text-muted-foreground hover:text-foreground hover:bg-card-background/30"
                ),
                children: [
                  u.jsx("span", {
                    className: "text-sm ",
                    children: "All Flasks",
                  }),
                  u.jsx("span", {
                    className: "text-xs text-muted-foreground",
                    children: P(null),
                  }),
                ],
              }),
            }),
            u.jsxs("div", {
              className: "flex flex-col gap-3",
              children: [
                u.jsxs("div", {
                  className: "flex items-center justify-between px-4 pr-2",
                  children: [
                    u.jsx("h3", {
                      className:
                        "text-xs font-semibold text-text-secondary uppercase tracking-wider",
                      children: "TAGS",
                    }),
                    u.jsx("button", {
                      onClick: N,
                      className:
                        "w-6 h-6 rounded-sm hover:bg-card-background  flex items-center justify-center transition-colors",
                      children: u.jsx("span", {
                        className: "text-xs text-text-primary font-bold",
                        children: "+",
                      }),
                    }),
                  ],
                }),
                u.jsxs("div", {
                  className: "flex flex-col gap-1 ",
                  children: [
                    g &&
                      u.jsx("div", {
                        className: "px-4 py-2",
                        children: u.jsx("input", {
                          ref: C,
                          type: "text",
                          value: b,
                          onChange: (q) => w(q.target.value),
                          onKeyDown: H,
                          onBlur: (q) => {
                            b.trim() ? W() : y(!1);
                          },
                          autoFocus: !0,
                          className:
                            "w-full px-3 py-1.5 rounded-lg text-sm text-text-primary border border-dashed border-border/50 bg-transparent outline-none focus:border-border focus:bg-border/20 transition-all",
                          placeholder: "Tag name",
                        }),
                      }),
                    u.jsx("div", {
                      id: "sidebar-tag-creator-trigger",
                      style: { display: "none" },
                    }),
                    t && t.length > 0
                      ? t.map((q) =>
                          u.jsx(
                            w0e,
                            {
                              tag: q,
                              selectedTagId: i,
                              onTagClick: D,
                              onTagDelete: z,
                              getFlaskCountForTag: P,
                            },
                            q.id
                          )
                        )
                      : u.jsx("div", {
                          className: "px-4 py-3 text-sm text-muted-foreground",
                          children: "No tags yet",
                        }),
                  ],
                }),
              ],
            }),
            u.jsx("div", { children: u.jsx(i0e, {}) }),
            S &&
              u.jsx(w7, {
                isOpen: _,
                onClose: () => {
                  R(!1), A(null);
                },
                onConfirm: B,
                tagName: S.name,
              }),
          ],
        });
  }),
  S0e = de.memo(function () {
    const { user: e } = ks();
    Sv(e?.id), Pt((a) => a.currentTeam);
    const [t, s] = E.useState(!1),
      [r, i] = E.useState(() => window.innerWidth < 768);
    return (
      E.useEffect(() => {
        const a = () => i(window.innerWidth < 768);
        return (
          window.addEventListener("resize", a),
          () => window.removeEventListener("resize", a)
        );
      }, []),
      E.useEffect(() => {
        r && s(!0);
      }, [r]),
      u.jsxs("div", {
        className: "min-h-screen bg-card-background text-foreground relative",
        children: [
          u.jsx("main", {
            className: "px-4 md:px-16 pb-32",
            children: u.jsx("div", {
              className: "w-full",
              children: e
                ? u.jsx("div", {
                    className: "relative",
                    children: u.jsxs("div", {
                      className: "relative min-h-screen",
                      children: [
                        u.jsx("div", {
                          className: "w-full mt-8 mb-6",
                          children: u.jsx(a3, {}),
                        }),
                        u.jsxs("div", {
                          className:
                            "flex flex-col xl:flex-row h-full min-h-screen gap-2 md:gap-4",
                          children: [
                            u.jsx("div", {
                              className: "flex-1 order-1 xl:order-1",
                              children: u.jsx(Q3, {}),
                            }),
                            u.jsx("div", {
                              className: "w-full xl:w-80 order-2 xl:order-2",
                              children: u.jsxs("div", {
                                className: "flex flex-col gap-4",
                                children: [
                                  u.jsx("div", {
                                    className:
                                      "bg-element-background/50 border-t mt-[22px] border-text-primary/30 p-3  rounded-3xl",
                                    children: u.jsx(E0e, {}),
                                  }),
                                  u.jsx("div", {
                                    className:
                                      "w-full bg-element-background/50 border-t border-text-primary/30 rounded-3xl overflow-hidden shadow-2xl",
                                    children: u.jsx(Lk, {}),
                                  }),
                                ],
                              }),
                            }),
                          ],
                        }),
                      ],
                    }),
                  })
                : u.jsxs(u.Fragment, {
                    children: [u.jsx(a3, {}), u.jsx(Q3, {})],
                  }),
            }),
          }),
          u.jsx("div", {
            className: "relative mt-auto",
            children: u.jsx(nV, {}),
          }),
          u.jsx(S7, { isOpen: t, onClose: () => s(!1) }),
        ],
      })
    );
  }),
  T0e = de.memo(function () {
    return u.jsx(E.Suspense, {
      fallback: u.jsx("div", { className: "min-h-screen" }),
      children: u.jsx(S0e, {}),
    });
  }),
  Dk = ({ onClick: n, loading: e = !1, className: t = "" }) =>
    u.jsxs(et, {
      onClick: n,
      disabled: e,
      variant: "default",
      className: `flex items-center button-primary text-md gap-2 py-4 font-bold ${t}`,
      children: [
        e
          ? u.jsx(wo, { className: "mr-2 h-4 w-4 animate-spin" })
          : u.jsxs("svg", {
              className: " h-4 w-4 text-black",
              viewBox: "0 0 24 24",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              children: [
                u.jsx("path", {
                  d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z",
                  fill: "#000000",
                }),
                u.jsx("path", {
                  d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z",
                  fill: "#000000",
                }),
                u.jsx("path", {
                  d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z",
                  fill: "#000000",
                }),
                u.jsx("path", {
                  d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z",
                  fill: "#000000",
                }),
              ],
            }),
        "Continue with Google",
      ],
    }),
  _0e = ({ className: n, children: e }) =>
    u.jsxs(u.Fragment, {
      children: [
        u.jsx("style", {
          children: `
        @keyframes shimmer {
          0% {
            transform: translateX(-100%);
          }
          100% {
            transform: translateX(200%);
          }
        }
        .shimmer-effect::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.2),
            transparent
          );
          animation: shimmer 2s ease-in-out infinite;
        }
      `,
        }),
        u.jsx("div", {
          className: Le(
            "shimmer-effect relative overflow-hidden",
            "bg-gradient-to-r from-border/20 via-border/40 to-border/20",
            n
          ),
          children: e,
        }),
      ],
    }),
  A0e = () => {
    const [n] = od(),
      e = es(),
      t = RH(),
      { user: s, isLoading: r } = ks(),
      [i, a] = E.useState(!1),
      o = n.get("returnUrl") || n.get("redirect") || "/dash";
    de.useEffect(() => {
      if (s && !r) {
        const c = setTimeout(() => {
          o.startsWith("http://") || o.startsWith("https://")
            ? (window.location.href = o)
            : e(o);
        }, 100);
        return () => clearTimeout(c);
      }
    }, [s, r, o, e]);
    const l = async () => {
      try {
        a(!0), await t(o);
      } catch (c) {
        console.error("Google auth error:", c), a(!1);
      }
    };
    return u.jsxs("div", {
      className:
        "min-h-screen w-screen bg-card-background flex flex-col overflow-hidden relative",
      children: [
        o === "/dash" &&
          u.jsx("div", {
            className: "absolute inset-0 z-0",
            children: u.jsx("img", {
              src: "/images/blurredbg@0.33x.jpg",
              alt: "",
              className: "w-full h-full object-cover",
            }),
          }),
        u.jsx("div", {
          className:
            "relative z-10 flex-1 flex flex-col items-center justify-center p-4 gap-3",
          children: u.jsxs("div", {
            className: "w-full max-w-sm",
            children: [
              u.jsxs("div", {
                className:
                  "bg-element-background border-t border-text-primary/30 rounded-[40px] shadow-2xl shadow-black/50 p-4 flex flex-col items-center gap-4",
                children: [
                  u.jsxs("div", {
                    className: "",
                    children: [u.jsx(gL, {}), " "],
                  }),
                  u.jsxs("div", {
                    className: "text-center space-y-3 w-full mt-4",
                    children: [
                      u.jsx("p", {
                        className: "text-sm text-text-secondary font-medium",
                        children: "Sign in to continue",
                      }),
                      r
                        ? u.jsx(_0e, {
                            className: "w-full h-[48px] rounded-lg",
                            children: u.jsx("div", {
                              className:
                                "w-full h-full bg-border/20 rounded-lg",
                            }),
                          })
                        : u.jsx(Dk, {
                            onClick: l,
                            loading: i,
                            className: " py-6 px-8 text-md w-full rounded-full",
                          }),
                    ],
                  }),
                ],
              }),
              u.jsxs("p", {
                className: "text-xs text-text-secondary text-center mt-4 px-16",
                children: [
                  "Continuing, you agree to the",
                  " ",
                  u.jsx("a", {
                    href: "/terms-of-service",
                    className: "text-text-primary hover:underline",
                    children: "Terms of Service",
                  }),
                  " ",
                  "and",
                  " ",
                  u.jsx("a", {
                    href: "/privacy",
                    className: "text-text-primary hover:underline",
                    children: "Privacy Policy",
                  }),
                  ".",
                ],
              }),
            ],
          }),
        }),
      ],
    });
  };
function R0e() {
  return u.jsx(A0e, {});
}
const k0e = (n) => {
    const e = _H(),
      t = Zoe(),
      s = hn((r) => r.isInitialized);
    return N6({
      queryKey: ["flask-access", n, e?.id],
      queryFn: async () => {
        if (!n)
          return {
            flask: null,
            hasViewAccess: !1,
            hasEditAccess: !1,
            isOwner: !1,
            accessLevel: null,
            error: "not-found",
          };
        try {
          const r = await Ut(`/api/flasks/${n}`);
          if (!r.ok) {
            const c = await r.json().catch(() => ({}));
            if (r.status === 404)
              return {
                flask: null,
                hasViewAccess: !1,
                hasEditAccess: !1,
                isOwner: !1,
                accessLevel: null,
                error: "not-found",
              };
            if (r.status === 401)
              return {
                flask: null,
                hasViewAccess: !1,
                hasEditAccess: !1,
                isOwner: !1,
                accessLevel: null,
                error: "auth-required",
              };
            if (r.status === 403)
              return {
                flask: null,
                hasViewAccess: !1,
                hasEditAccess: !1,
                isOwner: !1,
                accessLevel: null,
                error: "access-denied",
              };
            throw new Error(`HTTP ${r.status}`);
          }
          const i = await r.json(),
            a = e?.id === i.user_id,
            o = i.canEdit || !1;
          return {
            flask: i,
            hasViewAccess: !0,
            hasEditAccess: o,
            isOwner: a,
            accessLevel: i.access_level || "private",
            error: null,
          };
        } catch (r) {
          return (
            console.error("Error fetching flask access:", r),
            {
              flask: null,
              hasViewAccess: !1,
              hasEditAccess: !1,
              isOwner: !1,
              accessLevel: null,
              error: "network-error",
            }
          );
        }
      },
      enabled: !!n && s && !t,
      retry: (r, i) => {
        if (i && typeof i == "object" && "error" in i) {
          const a = i;
          if (["auth-required", "access-denied", "not-found"].includes(a.error))
            return !1;
        }
        return r < 2;
      },
      staleTime: 300 * 1e3,
      gcTime: 600 * 1e3,
    });
  },
  J3 = ({ error: n, accessLevel: e, onSignIn: t }) => {
    const s = es(),
      r = RH();
    return u.jsx("div", {
      className:
        "min-h-screen w-full flex items-center justify-center bg-card-background relative",
      children: u.jsxs("div", {
        className: "flex flex-col items-center justify-center w-full z-10",
        children: [
          u.jsx(Ig, {}),
          u.jsx("p", {
            className: "text-white/60 mb-8 max-w-xs text-center",
            children:
              "This Flask may not exist or you might not have permission to view it.",
          }),
          n === "auth-required" && t
            ? u.jsx(Dk, { onClick: t })
            : n === "auth-required"
            ? u.jsx(Dk, {
                onClick: () => {
                  const i = window.location.pathname;
                  r(i);
                },
              })
            : u.jsx(et, {
                onClick: () => s("/"),
                variant: "link",
                className: "mt-4 text-white/80",
                children: "Go Back",
              }),
        ],
      }),
    });
  },
  Tb = (n, e) => {
    Bt.isAvailable() &&
      Bt.capture(`recording_${n}`, {
        ...e,
        timestamp: new Date().toISOString(),
      });
  },
  C0e = (n) => {
    Bt.isAvailable() &&
      Bt.capture("flask_shared", { ...n, timestamp: new Date().toISOString() });
  },
  I0e = (n) => {
    Bt.isAvailable() &&
      Bt.capture("element_created", {
        ...n,
        timestamp: new Date().toISOString(),
      });
  },
  pr = [];
for (let n = 0; n < 256; ++n) pr.push((n + 256).toString(16).slice(1));
function L0e(n, e = 0) {
  return (
    pr[n[e + 0]] +
    pr[n[e + 1]] +
    pr[n[e + 2]] +
    pr[n[e + 3]] +
    "-" +
    pr[n[e + 4]] +
    pr[n[e + 5]] +
    "-" +
    pr[n[e + 6]] +
    pr[n[e + 7]] +
    "-" +
    pr[n[e + 8]] +
    pr[n[e + 9]] +
    "-" +
    pr[n[e + 10]] +
    pr[n[e + 11]] +
    pr[n[e + 12]] +
    pr[n[e + 13]] +
    pr[n[e + 14]] +
    pr[n[e + 15]]
  ).toLowerCase();
}
let O1;
const D0e = new Uint8Array(16);
function P0e() {
  if (!O1) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    O1 = crypto.getRandomValues.bind(crypto);
  }
  return O1(D0e);
}
const M0e =
    typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  e$ = { randomUUID: M0e };
function j1(n, e, t) {
  if (e$.randomUUID && !n) return e$.randomUUID();
  n = n || {};
  const s = n.random ?? n.rng?.() ?? P0e();
  if (s.length < 16) throw new Error("Random bytes length must be >= 16");
  return (s[6] = (s[6] & 15) | 64), (s[8] = (s[8] & 63) | 128), L0e(s);
}
const N0e = 320,
  O0e = { text: 120, asset: 480, link: 1, recording: 180 },
  j0e = 200,
  F0e = 100;
function U0e(n) {
  const { elementType: e, customWidth: t } = n,
    s = Math.max(t || N0e, j0e);
  let r;
  return (r = O0e[e]), (r = Math.max(r, F0e)), { width: s, height: r };
}
const $0e = () => U0e({ elementType: "text" }),
  $n = Di()(
    $a(
      ha((n, e) => ({
        saveStatus: "idle",
        lastSyncedTime: null,
        pendingOperations: 0,
        activeUploads: 0,
        setSaveStatus: (t) => {
          n((s) => {
            (s.saveStatus = t),
              t === "synced" && (s.lastSyncedTime = new Date());
          });
        },
        startUpload: () => {
          n((t) => {
            (t.activeUploads += 1), (t.saveStatus = "uploading");
          });
        },
        endUpload: () => {
          n((t) => {
            (t.activeUploads -= 1),
              t.activeUploads === 0 && t.pendingOperations === 0
                ? ((t.saveStatus = "synced"), (t.lastSyncedTime = new Date()))
                : t.activeUploads === 0 &&
                  t.pendingOperations > 0 &&
                  (t.saveStatus = "syncing");
          });
        },
        startOperation: () => {
          n((t) => {
            (t.pendingOperations += 1),
              t.activeUploads === 0 && (t.saveStatus = "syncing");
          });
        },
        endOperation: (t) => {
          n((s) => {
            (s.pendingOperations -= 1),
              s.activeUploads === 0 &&
                s.pendingOperations === 0 &&
                (t
                  ? ((s.saveStatus = "synced"), (s.lastSyncedTime = new Date()))
                  : navigator.onLine
                  ? (s.saveStatus = "error")
                  : (s.saveStatus = "offline"));
          });
        },
        saveElement: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { error: i } = await Ds.from("elements").insert(t);
            if (i) throw i;
            r(!0);
          } catch (i) {
            throw (console.error("Failed to save element:", i), r(!1), i);
          }
        },
        updateElement: async (t, s) => {
          const { startOperation: r, endOperation: i } = e();
          if (Object.keys(s).length !== 0) {
            r();
            try {
              const { error: a } = await Ds.from("elements")
                .update(s)
                .eq("id", t);
              if (a) throw a;
              i(!0);
            } catch (a) {
              throw (console.error("Failed to update element:", a), i(!1), a);
            }
          }
        },
        deleteElement: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { error: i } = await Ds.from("elements").delete().eq("id", t);
            if (i) throw i;
            r(!0);
          } catch (i) {
            throw (console.error("Failed to delete element:", i), r(!1), i);
          }
        },
        loadElements: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { data: i, error: a } = await Ds.from("elements")
              .select(
                `
              *,
              recordings:recording_id (
                duration,
                hls_url,
                thumbnail_url,
                ai_transcript,
                ai_summary,
                ai_processing_status
              )
            `
              )
              .eq("asset_id", t)
              .order("created_at", { ascending: !0 });
            if (a) throw a;
            const o = (i || []).map((l) =>
              l.recordings && l.type === "recording"
                ? {
                    ...l,
                    duration: l.recordings.duration ?? l.duration,
                    videoUrl: l.recordings.hls_url ?? l.video_url,
                    thumbnailUrl: l.recordings.thumbnail_url ?? l.thumbnail_url,
                    aiInsights: {
                      transcript: l.recordings.ai_transcript,
                      summary: l.recordings.ai_summary,
                    },
                    aiSummary: l.ai_summary ?? l.recordings.ai_summary,
                  }
                : l
            );
            return r(!0), o;
          } catch (i) {
            return console.error("Failed to load elements:", i), r(!1), [];
          }
        },
        loadTags: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { data: i, error: a } = await Ds.from("element_tags")
              .select("*")
              .eq("flask_id", t)
              .order("name", { ascending: !0 });
            if (a) throw a;
            return r(!0), i || [];
          } catch (i) {
            return console.error("Failed to load tags:", i), r(!1), [];
          }
        },
        saveTag: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { error: i } = await Ds.from("element_tags").insert(t);
            if (i) throw i;
            r(!0);
          } catch (i) {
            throw (console.error("Failed to save tag:", i), r(!1), i);
          }
        },
        updateTag: async (t, s) => {
          const { startOperation: r, endOperation: i } = e();
          r();
          try {
            const { error: a } = await Ds.from("element_tags")
              .update(s)
              .eq("id", t);
            if (a) throw a;
            i(!0);
          } catch (a) {
            throw (console.error("Failed to update tag:", a), i(!1), a);
          }
        },
        deleteTag: async (t) => {
          const { startOperation: s, endOperation: r } = e();
          s();
          try {
            const { error: i } = await Ds.from("element_tags")
              .delete()
              .eq("id", t);
            if (i) throw i;
            r(!0);
          } catch (i) {
            throw (console.error("Failed to delete tag:", i), r(!1), i);
          }
        },
        renameTag: async (t, s) => {
          const { startOperation: r, endOperation: i } = e();
          r();
          try {
            const { error: a } = await Ds.from("element_tags")
              .update({ name: s })
              .eq("id", t);
            if (a) throw a;
            i(!0);
          } catch (a) {
            throw (console.error("Failed to rename tag:", a), i(!1), a);
          }
        },
        changeTagColor: async (t, s) => {
          const { startOperation: r, endOperation: i } = e();
          r();
          try {
            const { error: a } = await Ds.from("element_tags")
              .update({ color: s })
              .eq("id", t);
            if (a) throw a;
            i(!0);
          } catch (a) {
            throw (console.error("Failed to change tag color:", a), i(!1), a);
          }
        },
      }))
    )
  );
typeof window < "u" &&
  (window.addEventListener("online", () => {
    const n = $n.getState();
    n.saveStatus === "offline" &&
      n.pendingOperations === 0 &&
      n.setSaveStatus("synced");
  }),
  window.addEventListener("offline", () => {
    $n.getState().setSaveStatus("offline");
  }));
const T7 = () => {
    const {
      saveStatus: n,
      lastSyncedTime: e,
      pendingOperations: t,
      activeUploads: s,
    } = $n();
    return {
      state: n,
      lastSyncedTime: e,
      queueLength: 0,
      flaskQueueLength: 0,
      hasUnsavedChanges: t > 0,
      activeUploads: s,
      hasActiveUploads: s > 0,
      setSyncing: () => $n.getState().setSaveStatus("syncing"),
      setSynced: () => $n.getState().setSaveStatus("synced"),
      setOffline: () => $n.getState().setSaveStatus("offline"),
      setError: () => $n.getState().setSaveStatus("error"),
      setIdle: () => $n.getState().setSaveStatus("idle"),
      onRetry: async () => {
        $n.getState().setSaveStatus("synced");
      },
    };
  },
  t$ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useElementPersistence: $n, useSaveStatus: T7 },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Vn = (n) => (n ? 8 : Ln / 2 + 10),
  pt = Di()(
    $a((n, e) => ({
      timelineScale: 1,
      timelineOffset: Vn(typeof window < "u" && window.innerWidth < 768),
      scrollableThreads: new Set(),
      anyThreadNeedsScroll: !1,
      maxVerticalScroll: 0,
      hoveredScrollableThread: null,
      threadScrollOffsets: new Map(),
      activeScrollingThread: null,
      scrollEnabledThreads: new Set(),
      scrollEnabledAtOffset: null,
      threadContainerRefs: new Map(),
      threadMaxScrollHeights: new Map(),
      isScrolling: !1,
      scrollTimeout: null,
      lastScrollTimestamp: 0,
      isAutoFollowEnabled: !1,
      viewportWidth: typeof window < "u" ? window.innerWidth : 1920,
      isMobile: typeof window < "u" && window.innerWidth < 768,
      duration: 0,
      visibleTimeStart: 0,
      visibleTimeEnd: 0,
      visibleDuration: 0,
      playbarWidth: 0,
      setTimelineScale: (t) => {
        const s = e(),
          r = Math.max(0, s.viewportWidth - Vn(s.isMobile) * 2) * t,
          i = s.duration / t,
          o = (-s.timelineOffset / r) * s.duration,
          l = o + i;
        n({
          timelineScale: t,
          playbarWidth: r,
          visibleDuration: i,
          visibleTimeStart: o,
          visibleTimeEnd: l,
        });
      },
      setTimelineOffset: (t) => {
        const s = e(),
          r =
            Math.max(0, s.viewportWidth - Vn(s.isMobile) * 2) * s.timelineScale,
          i = s.duration / s.timelineScale,
          a = -t / r,
          o = Math.max(0, a * s.duration),
          l = Math.min(s.duration, o + i);
        n({ timelineOffset: t, visibleTimeStart: o, visibleTimeEnd: l });
      },
      updateThreadScrollability: (t, s, r) => {
        const i = e(),
          a = new Set(i.scrollableThreads);
        s ? a.add(t) : a.delete(t);
        const o = a.size > 0,
          l = o ? Math.max(r, i.maxVerticalScroll) : 0;
        n({
          scrollableThreads: a,
          anyThreadNeedsScroll: o,
          maxVerticalScroll: l,
        });
      },
      clearScrollableThreads: () => {
        n({
          scrollableThreads: new Set(),
          anyThreadNeedsScroll: !1,
          maxVerticalScroll: 0,
          hoveredScrollableThread: null,
        });
      },
      setHoveredScrollableThread: (t) => {
        n({ hoveredScrollableThread: t });
      },
      setThreadScrollOffset: (t, s) => {
        const r = e(),
          i = new Map(r.threadScrollOffsets);
        i.set(t, s), n({ threadScrollOffsets: i });
      },
      setActiveScrollingThread: (t) => {
        n({ activeScrollingThread: t });
      },
      resetAllThreadScrolls: () => {
        e().threadContainerRefs.forEach((s) => {
          s.scrollTop > 0 && (s.scrollTop = 0);
        }),
          n({
            threadScrollOffsets: new Map(),
            activeScrollingThread: null,
            scrollEnabledThreads: new Set(),
            scrollEnabledAtOffset: null,
            threadMaxScrollHeights: new Map(),
          });
      },
      enableThreadScrollOnHover: (t) => {
        const s = e(),
          r = new Set(s.scrollEnabledThreads);
        r.add(t),
          n({
            scrollEnabledThreads: r,
            scrollEnabledAtOffset: s.timelineOffset,
          });
      },
      disableThreadScrollOnLeave: (t) => {
        const s = e(),
          r = new Set(s.scrollEnabledThreads);
        r.delete(t), n({ scrollEnabledThreads: r });
      },
      isThreadScrollEnabled: (t) => e().scrollEnabledThreads.has(t),
      registerThreadContainer: (t, s) => {
        const r = e(),
          i = new Map(r.threadContainerRefs);
        i.set(t, s), n({ threadContainerRefs: i });
      },
      unregisterThreadContainer: (t) => {
        const s = e(),
          r = new Map(s.threadContainerRefs);
        r.delete(t), n({ threadContainerRefs: r });
      },
      scrollThreadToBottom: (t) => {
        const r = e().threadContainerRefs.get(t);
        if (r) {
          const i = r.scrollHeight - r.clientHeight;
          r.scrollTo({ top: Math.max(0, i), behavior: "smooth" });
        }
      },
      scrollThreadToTop: (t) => {
        const r = e().threadContainerRefs.get(t);
        r && r.scrollTo({ top: 0, behavior: "smooth" });
      },
      notifyThreadHeightChanged: (t) => {
        const s = e(),
          r = s.threadContainerRefs.get(t);
        if (!r) return;
        const i = r.scrollHeight - r.scrollTop - r.clientHeight < 50;
        if (s.scrollEnabledThreads.has(t) && i) {
          const a = r.scrollHeight - r.clientHeight;
          r.scrollTo({ top: Math.max(0, a), behavior: "smooth" });
        }
      },
      setThreadMaxScrollHeight: (t, s) => {
        const r = e(),
          i = new Map(r.threadMaxScrollHeights);
        i.set(t, s), n({ threadMaxScrollHeights: i });
      },
      getThreadMaxScrollHeight: (t) =>
        e().threadMaxScrollHeights.get(t) ?? null,
      setIsScrolling: (t) => {
        n({ isScrolling: t });
      },
      startScrolling: () => {
        const t = e();
        t.scrollTimeout && clearTimeout(t.scrollTimeout),
          n({
            isScrolling: !0,
            scrollTimeout: null,
            lastScrollTimestamp: Date.now(),
          });
      },
      stopScrollingDelayed: () => {
        const t = e();
        t.scrollTimeout && clearTimeout(t.scrollTimeout);
        const s = setTimeout(() => {
          n({ isScrolling: !1, scrollTimeout: null });
        }, 500);
        n({ scrollTimeout: s });
      },
      setViewportWidth: (t) => {
        const s = e(),
          r = Math.max(0, t - Vn(s.isMobile) * 2) * s.timelineScale,
          i = s.duration / s.timelineScale;
        n({ viewportWidth: t, playbarWidth: r, visibleDuration: i });
      },
      setDuration: (t) => {
        const s = e(),
          r = t / s.timelineScale;
        n({
          duration: t,
          visibleDuration: r,
          visibleTimeEnd: Math.min(t, s.visibleTimeStart + r),
        });
      },
      updateTimelineTransform: (t, s) => {
        const r = e(),
          a = Math.max(0, r.viewportWidth - Vn(r.isMobile) * 2) * t,
          o = Vn(r.isMobile),
          l = r.viewportWidth - Vn(r.isMobile) - a,
          c = Math.max(l, Math.min(o, s)),
          h = r.duration / t,
          p = (o - c) / a,
          g = Math.max(0, p * r.duration),
          y = Math.min(r.duration, g + h);
        n({
          timelineScale: t,
          timelineOffset: c,
          playbarWidth: a,
          visibleDuration: h,
          visibleTimeStart: g,
          visibleTimeEnd: y,
        });
      },
      applyTransform: (t, s) => {
        e().updateTimelineTransform(t, s);
      },
      smoothZoomToTimeRange: (t, s, r, i) => {
        const a = e(),
          o = a.viewportWidth,
          l = o - Vn(a.isMobile) * 2,
          c = s - t;
        let h;
        if (r && r > 10) h = Math.max(1, Math.min(1200, r));
        else {
          const V = 280 / ((c / a.duration) * l);
          h = Math.max(1, Math.min(1200, V * 1.2));
        }
        const m = (t + s) / 2,
          p = l * h,
          g = (m / a.duration) * p,
          y = o / 2 - g,
          b = o - Vn(a.isMobile) - p,
          w = Vn(a.isMobile),
          S = Math.max(b, Math.min(w, y)),
          A = a.timelineScale,
          _ = a.timelineOffset,
          R = Date.now(),
          C = 800,
          D = () => {
            const L = Date.now() - R,
              P = Math.min(1, L / C);
            let V;
            P < 0.5 ? (V = 2 * P * P) : (V = 1 - 2 * (1 - P) * (1 - P)),
              (V = (Math.sin((V - 0.5) * Math.PI) + 1) / 2);
            const N = A + (h - A) * V,
              W = _ + (S - _) * V;
            a.updateTimelineTransform(N, W),
              P < 1
                ? requestAnimationFrame(D)
                : (a.updateTimelineTransform(h, S), i && i());
          };
        requestAnimationFrame(D);
      },
      progressiveZoomToUngroup: (t, s, r, i) => {
        const a = e();
        let o = 0;
        const l = 10,
          c = () => {
            o++;
            const m = e();
            if (i() && o < l) {
              const g = Math.min(1200, m.timelineScale * 1.5);
              a.smoothZoomToTimeRange(t, s, g, () => {
                setTimeout(c, 150);
              });
            }
          },
          h = a.timelineScale * 2;
        a.smoothZoomToTimeRange(t, s, h, c);
      },
      zoomToShowElements: (t, s) => {
        const r = e(),
          i = Ce.getState();
        if (!i) {
          console.warn("Canvas store not available"), s && s();
          return;
        }
        const a = i.boardState.elements,
          o = i.getElementVisibility;
        if (t.length === 1) {
          const H = a[t[0]];
          if (H && H.links && o(t[0])) {
            const z = H.links.find((B) => B.type === "timeline");
            if (z) {
              let B = 0;
              z.timeRange
                ? (B = (z.timeRange.start + z.timeRange.end) / 2)
                : z.timestamp !== void 0 && (B = z.timestamp);
              const q = (B / r.duration) * 100,
                O = r.timelineScale,
                j = r.viewportWidth * O,
                Q = (Ln / j) * 100,
                I = (-r.timelineOffset / j) * 100,
                F = I + 100 / O,
                Y = q - Q / 2,
                J = q + Q / 2;
              if (Y >= I && J <= F) {
                const Z = [];
                Object.entries(a).forEach(([ce, pe]) => {
                  if (!pe || !pe.links || ce === t[0] || !o(ce)) return;
                  const se = pe.links.find((Ee) => Ee.type === "timeline");
                  if (!se) return;
                  let be;
                  if (se.timeRange)
                    be = (se.timeRange.start + se.timeRange.end) / 2;
                  else if (se.timestamp !== void 0) be = se.timestamp;
                  else return;
                  (Math.abs(be - B) / r.duration) * 100 < Q * 2 &&
                    Z.push({ time: be });
                });
                let te = !1;
                for (const ce of Z)
                  if ((Math.abs(ce.time - B) / r.duration) * 100 < Q) {
                    te = !0;
                    break;
                  }
                if (!te) {
                  s && s();
                  return;
                }
              }
            }
          }
        }
        let l = 0,
          c = !1;
        if (t.length === 1) {
          const H = a[t[0]];
          if (H && H.links && o(t[0])) {
            const z = H.links.find((B) => B.type === "timeline");
            z &&
              (z.timeRange
                ? (l = (z.timeRange.start + z.timeRange.end) / 2)
                : z.timestamp !== void 0 && (l = z.timestamp),
              (c = !0));
          }
        } else {
          let H = 1 / 0,
            z = -1 / 0;
          t.forEach((B) => {
            const q = a[B];
            if (!q || !q.links || !o(B)) return;
            const O = q.links.find((U) => U.type === "timeline");
            O &&
              (O.timeRange
                ? ((H = Math.min(H, O.timeRange.start)),
                  (z = Math.max(z, O.timeRange.end)))
                : O.timestamp !== void 0 &&
                  ((H = Math.min(H, O.timestamp)),
                  (z = Math.max(z, O.timestamp))));
          }),
            H !== 1 / 0 && z !== -1 / 0 && ((l = (H + z) / 2), (c = !0));
        }
        if (!c) {
          console.warn("No valid timeline links found for elements"), s && s();
          return;
        }
        const h = r.viewportWidth,
          m = h - Ln,
          p = [];
        Object.entries(a).forEach(([H, z]) => {
          if (!z || !z.links || !o(H)) return;
          const B = z.links.find((O) => O.type === "timeline");
          if (!B) return;
          let q;
          if (B.timeRange) q = (B.timeRange.start + B.timeRange.end) / 2;
          else if (B.timestamp !== void 0) q = B.timestamp;
          else return;
          p.push({ id: H, time: q });
        }),
          p.sort((H, z) => H.time - z.time);
        let g = 1 / 0;
        t.forEach((H) => {
          const z = p.findIndex((q) => q.id === H);
          if (z === -1) return;
          const B = p[z].time;
          if (z > 0) {
            const q = Math.abs(B - p[z - 1].time);
            q > 0 && (g = Math.min(g, q));
          }
          if (z < p.length - 1) {
            const q = Math.abs(p[z + 1].time - B);
            q > 0 && (g = Math.min(g, q));
          }
        });
        const y = r.timelineScale,
          b = r.timelineOffset,
          w = (Ln / (m * y)) * 100;
        let S = !1;
        if (g !== 1 / 0 && g > 0) {
          const H = (g / r.duration) * 100;
          S = w > H * 0.9;
        }
        const A = m * y,
          _ = (l / r.duration) * A,
          R = -b,
          C = R + h,
          D = _ >= R - Ln / 2 && _ <= C + Ln / 2;
        if (!S && D) {
          s && s();
          return;
        }
        let L;
        if (S)
          if (g === 1 / 0 || g === 0) L = 3;
          else {
            const H = (g / r.duration) * 100,
              z = (Ln * 100) / (m * H);
            L = Math.max(1, Math.min(1200, z * 1.05));
          }
        else L = y;
        let P = b;
        if (!D || S) {
          const H = m * L,
            z = (l / r.duration) * H,
            B = h / 2 - z,
            q = h - Ln / 2 - H,
            O = Ln / 2;
          P = Math.max(q, Math.min(O, B));
        }
        if (t.length === 1) {
          const H = a[t[0]];
          H &&
            H.links &&
            (H.links.find((z) => z.type === "timeline"),
            H.links.find((z) => z.type === "element"));
        }
        if (Math.abs(y - L) < 0.001 && Math.abs(b - P) < 0.5) {
          s && s();
          return;
        }
        const V = Date.now(),
          N = 400,
          W = () => {
            const H = Date.now() - V,
              z = Math.min(1, H / N);
            let B = 1 - Math.pow(1 - z, 3);
            const q = y + (L - y) * B,
              O = b + (P - b) * B;
            r.updateTimelineTransform(q, O),
              z < 1
                ? requestAnimationFrame(W)
                : (r.updateTimelineTransform(L, P), s && s());
          };
        requestAnimationFrame(W);
      },
      resetZoom: (t) => {
        const s = e(),
          r = 1,
          i = Vn(s.isMobile),
          a = s.timelineScale,
          o = s.timelineOffset;
        if (Math.abs(a - r) < 0.001 && Math.abs(o - i) < 0.5) {
          t && t();
          return;
        }
        const l = Date.now(),
          c = 800,
          h = () => {
            const m = Date.now() - l,
              p = Math.min(1, m / c);
            let g;
            p < 0.5 ? (g = 2 * p * p) : (g = 1 - 2 * (1 - p) * (1 - p)),
              (g = (Math.sin((g - 0.5) * Math.PI) + 1) / 2);
            const y = a + (r - a) * g,
              b = o + (i - o) * g;
            s.updateTimelineTransform(y, b),
              p < 1
                ? requestAnimationFrame(h)
                : (s.updateTimelineTransform(r, i), t && t());
          };
        requestAnimationFrame(h);
      },
      enableAutoFollow: () => {
        n({ isAutoFollowEnabled: !0 });
      },
      disableAutoFollow: () => {
        n({ isAutoFollowEnabled: !1 });
      },
      checkAndCenterPlayhead: (t) => {
        const s = e(),
          r = s.duration;
        if (r === 0) return;
        if (t >= s.visibleTimeStart && t <= s.visibleTimeEnd)
          s.enableAutoFollow();
        else {
          const a = s.viewportWidth,
            l = (a - Vn(s.isMobile) * 2) * s.timelineScale,
            c = (t / r) * l,
            h = a / 2 - c,
            m = a - Vn(s.isMobile) - l,
            p = Vn(s.isMobile),
            g = Math.max(m, Math.min(p, h)),
            y = s.timelineOffset,
            b = Date.now(),
            w = 400,
            S = () => {
              const A = Date.now() - b,
                _ = Math.min(1, A / w),
                R = 1 - Math.pow(1 - _, 3),
                C = y + (g - y) * R;
              s.updateTimelineTransform(s.timelineScale, C),
                _ < 1 ? requestAnimationFrame(S) : s.enableAutoFollow();
            };
          requestAnimationFrame(S);
        }
      },
      ensurePlayheadVisible: () => {
        const t = e(),
          r = Be.getState().currentTime,
          i = t.duration;
        if (i === 0) return;
        const a = r >= t.visibleTimeStart && r <= t.visibleTimeEnd,
          l = (t.visibleTimeEnd - t.visibleTimeStart) * 0.15,
          c = r < t.visibleTimeStart + l || r > t.visibleTimeEnd - l;
        if (a && !c) return;
        const h = t.viewportWidth,
          p = (h - Vn(t.isMobile) * 2) * t.timelineScale,
          g = (r / i) * p,
          y = h / 2 - g,
          b = h - Vn(t.isMobile) - p,
          w = Vn(t.isMobile),
          S = Math.max(b, Math.min(w, y)),
          A = t.timelineOffset,
          _ = Date.now(),
          R = 400,
          C = () => {
            const D = Date.now() - _,
              L = Math.min(1, D / R),
              P = 1 - Math.pow(1 - L, 3),
              V = A + (S - A) * P;
            t.updateTimelineTransform(t.timelineScale, V),
              L < 1
                ? requestAnimationFrame(C)
                : t.updateTimelineTransform(t.timelineScale, S);
          };
        requestAnimationFrame(C);
      },
      zoomIn: () => {
        const t = e(),
          s = t.timelineScale,
          r = Math.min(s * 1.5, 1200);
        if (Math.abs(s - r) < 0.001) return;
        const i = (t.visibleTimeStart + t.visibleTimeEnd) / 2,
          a = t.viewportWidth,
          l = (a - Vn(t.isMobile) * 2) * r,
          c = (i / t.duration) * l,
          h = a / 2 - c,
          m = a - Vn(t.isMobile) - l,
          p = Vn(t.isMobile),
          g = Math.max(m, Math.min(p, h)),
          y = t.timelineOffset,
          b = Date.now(),
          w = 400,
          S = () => {
            const A = Date.now() - b,
              _ = Math.min(1, A / w),
              R = 1 - Math.pow(1 - _, 3),
              C = s + (r - s) * R,
              D = y + (g - y) * R;
            t.updateTimelineTransform(C, D),
              _ < 1
                ? requestAnimationFrame(S)
                : t.updateTimelineTransform(r, g);
          };
        requestAnimationFrame(S);
      },
      zoomOut: () => {
        const t = e(),
          s = t.timelineScale,
          r = Math.max(s / 1.5, 1);
        if (Math.abs(s - r) < 0.001) return;
        const i = (t.visibleTimeStart + t.visibleTimeEnd) / 2,
          a = t.viewportWidth,
          l = (a - Vn(t.isMobile) * 2) * r,
          c = (i / t.duration) * l,
          h = a / 2 - c,
          m = a - Vn(t.isMobile) - l,
          p = Vn(t.isMobile),
          g = Math.max(m, Math.min(p, h)),
          y = t.timelineOffset,
          b = Date.now(),
          w = 400,
          S = () => {
            const A = Date.now() - b,
              _ = Math.min(1, A / w),
              R = 1 - Math.pow(1 - _, 3),
              C = s + (r - s) * R,
              D = y + (g - y) * R;
            t.updateTimelineTransform(C, D),
              _ < 1
                ? requestAnimationFrame(S)
                : t.updateTimelineTransform(r, g);
          };
        requestAnimationFrame(S);
      },
      setMobileState: (t) => {
        const s = e();
        if (s.isMobile !== t) {
          const r = Vn(t),
            i = Vn(s.isMobile);
          let a = s.timelineOffset;
          if (i !== r) {
            const o = r - i;
            a = s.timelineOffset + o;
          }
          n({ isMobile: t, timelineOffset: a }),
            s.updateTimelineTransform(s.timelineScale, a);
        }
      },
      getPixelsPerSecond: () => {
        const t = e();
        return t.playbarWidth / t.duration;
      },
      getTimeFromPosition: (t) => {
        const s = e();
        return s.playbarWidth === 0 ? 0 : (t / s.playbarWidth) * s.duration;
      },
      getPositionFromTime: (t) => {
        const s = e();
        return s.duration === 0 ? 0 : (t / s.duration) * s.playbarWidth;
      },
    }))
  ),
  Zp = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useTimelineStore: pt },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  lD = (n, e) => {
    const t = n?.full_name;
    return t
      ? t.split(" ")[0]
      : e && !e.includes("@")
      ? e.split(" ")[0]
      : n?.email
      ? n.email.split("@")[0]
      : e && e.includes("@")
      ? e.split("@")[0]
      : "Unknown";
  },
  n$ = "includeTags",
  s$ = "excludeTags";
typeof window < "u" &&
  window.addEventListener("popstate", () => {
    setTimeout(() => {
      vn.getState().initializeFromUrl();
    }, 100);
  });
const vn = Di()(
  $a(
    ha((n, e) => ({
      filterMode: "include",
      activeFilterIds: [],
      isFilterToolbarOpen: !1,
      isUpdatingFromUrl: !1,
      addFilter: (t, s = !0) =>
        n((r) => {
          r.activeFilterIds.includes(t) || r.activeFilterIds.push(t),
            s &&
              !r.isUpdatingFromUrl &&
              setTimeout(() => e().updateUrlFromState(), 0);
        }),
      removeFilter: (t, s = !0) =>
        n((r) => {
          (r.activeFilterIds = r.activeFilterIds.filter((i) => i !== t)),
            s &&
              !r.isUpdatingFromUrl &&
              setTimeout(() => e().updateUrlFromState(), 0);
        }),
      toggleFilter: (t) => {
        e().activeFilterIds.includes(t)
          ? e().removeFilter(t)
          : e().addFilter(t);
      },
      isFilterActive: (t) => e().activeFilterIds.includes(t),
      setFilterMode: (t) =>
        n((s) => {
          (s.filterMode = t),
            s.isUpdatingFromUrl ||
              setTimeout(() => e().updateUrlFromState(), 0);
        }),
      openFilterToolbar: () =>
        n((t) => {
          t.isFilterToolbarOpen = !0;
        }),
      closeFilterToolbar: () =>
        n((t) => {
          t.isFilterToolbarOpen = !1;
        }),
      toggleFilterToolbar: () =>
        n((t) => {
          t.isFilterToolbarOpen = !t.isFilterToolbarOpen;
        }),
      isElementVisible: (t) => {
        const s = e();
        if (!e().isFilteringActive()) return !0;
        const r = Ce.getState(),
          i = r.getElementTags(t.id),
          a = r.getElementAppTags(t.id),
          o = [],
          l = [],
          c = [];
        s.activeFilterIds.forEach((m) => {
          m.startsWith("apptag:creator:")
            ? l.push(m.replace("apptag:creator:", ""))
            : m.startsWith("apptag:time:")
            ? c.push(m.replace("apptag:time:", ""))
            : o.push(m);
        });
        let h = !1;
        if (
          (o.length > 0 && !h && i?.some((p) => o.includes(p.id)) && (h = !0),
          l.length > 0 && !h)
        ) {
          const m = a?.find((p) => p.type === "creator");
          m && l.includes(m.creatorId) && (h = !0);
        }
        if (c.length > 0 && !h) {
          const m = a?.find((p) => p.type === "creationTime");
          if (m && m.timestamp) {
            const p = m.timestamp * 1e3,
              g = Date.now();
            for (const y of c)
              if (y === "last24h") {
                const b = g - 864e5;
                if (p >= b) {
                  h = !0;
                  break;
                }
              } else if (y === "thisweek") {
                const b = g - 6048e5;
                if (p >= b) {
                  h = !0;
                  break;
                }
              } else if (y === "new" && r.unseenElementIds?.has(t.id)) {
                h = !0;
                break;
              }
          }
        }
        return (
          h ||
            (Object.values(r.boardState.elements).some((g) => {
              const y = g.links?.find((b) => b?.type === "element");
              return y && y.targetElementId === t.id
                ? e().isElementVisible(g)
                : !1;
            }) &&
              (h = !0)),
          (!i || i.length === 0) && (!a || a.length === 0)
            ? s.filterMode === "exclude"
            : s.filterMode === "include"
            ? h
            : !h
        );
      },
      resetFilters: () =>
        n((t) => {
          (t.activeFilterIds = []),
            (t.filterMode = "include"),
            (t.isFilterToolbarOpen = !1);
        }),
      clearAllFilters: () => {
        n((t) => {
          t.activeFilterIds = [];
        }),
          e().updateUrlFromState();
      },
      getVisibleElementCount: () => {
        const s = Ce.getState().boardState.elements,
          r = Object.values(s).filter((a) => a && a.type !== "asset");
        return {
          visible: r.filter((a) => (a ? e().isElementVisible(a) : !1)).length,
          total: r.length,
        };
      },
      isFilteringActive: () => e().activeFilterIds.length > 0,
      updateUrlFromState: () => {
        const t = e();
        if (!window.location.pathname.includes("/flask/")) return;
        const r = new URLSearchParams(window.location.search).get("asset"),
          i = new URLSearchParams();
        if ((r && i.set("asset", r), t.activeFilterIds.length > 0)) {
          const o = t.filterMode === "include" ? n$ : s$;
          i.set(o, t.activeFilterIds.join(","));
        }
        const a = `${window.location.pathname}${
          i.toString() ? "?" + i.toString() : ""
        }`;
        window.history.replaceState({}, "", a);
      },
      initializeFromUrl: () => {
        if (!Ce.getState().isDataLoaded) return;
        const s = new URLSearchParams(window.location.search),
          r = s.get(n$),
          i = s.get(s$);
        if (
          (n((a) => {
            a.isUpdatingFromUrl = !0;
          }),
          r)
        ) {
          const a = r.split(",").filter((o) => o.length > 0);
          n((o) => {
            (o.filterMode = "include"), (o.activeFilterIds = a);
          });
        } else if (i) {
          const a = i.split(",").filter((o) => o.length > 0);
          n((o) => {
            (o.filterMode = "exclude"), (o.activeFilterIds = a);
          });
        } else
          n((a) => {
            (a.filterMode = "include"), (a.activeFilterIds = []);
          });
        n((a) => {
          a.isUpdatingFromUrl = !1;
        });
      },
      syncWithUrl: () => {
        e().initializeFromUrl();
      },
    }))
  )
);
function B0e(n, e, t) {
  return {
    id: `apptag:creator:${n}`,
    type: "apptag",
    name: e,
    appTagType: "creator",
    appTagValue: n,
    avatarUrl: t,
  };
}
function F1(n) {
  let e = "";
  return (
    n === "last24h"
      ? (e = "Last 24 hours")
      : n === "thisweek"
      ? (e = "Last 7 days")
      : n === "new" && (e = "New"),
    {
      id: `apptag:time:${n}`,
      type: "apptag",
      name: e,
      appTagType: "time",
      appTagValue: n,
    }
  );
}
function _7(n) {
  const e = new Map();
  return (
    Object.values(n.boardState.elements).forEach((s) => {
      if (!s || s.type === "asset") return;
      const i = n.getElementAppTags(s.id)?.find((a) => a.type === "creator");
      if (i && i.creatorId && i.creatorName && !e.has(i.creatorId)) {
        const a = i.creatorId ? n.userProfiles[i.creatorId] : void 0,
          o = lD(a, i.creatorName);
        e.set(i.creatorId, { name: o, avatarUrl: i.creatorAvatarUrl });
      }
    }),
    Array.from(e.entries()).map(([s, r]) => B0e(s, r.name, r.avatarUrl))
  );
}
function A7(n) {
  const e = [F1("last24h"), F1("thisweek")];
  return (
    n &&
      n.unseenElementIds &&
      n.unseenElementIds.size > 0 &&
      e.unshift(F1("new")),
    e
  );
}
function Xx(n, e, t, s = 320, r = h8) {
  const i = e?.position || { x: 0, y: 0 },
    a = e?.dimensions || { width: 1200 },
    o = e?.duration || 0,
    l = a.width,
    c = l / (16 / 9),
    m = i.x + l / 2 - t / 2,
    p = o > 0 ? n / o : 0,
    y = m + p * t - s / 2,
    A = i.y + c + 60 + 40 + r;
  return { x: y, y: A };
}
const r$ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, playheadToCanvasCoordinates: Xx },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  H0e = { elements: {}, rootElements: [], tags: {} },
  V0e = {
    scale: gF * 1.5,
    positionX: 0,
    positionY: 0,
    previousScale: gF * 1.5,
    wrapperComponent: null,
    contentComponent: null,
  },
  Ce = Di()(
    $a(
      ha((n, e) => ({
        boardState: H0e,
        isDataLoaded: !1,
        flaskId: null,
        currentAssetId: null,
        availableAssets: [],
        hasEditingPermissions: !1,
        currentUserId: null,
        currentUserName: null,
        currentUserAvatarUrl: null,
        selectedFrames: [],
        selectedChildrenIds: [],
        selectedElementId: void 0,
        currentTextEditElementId: null,
        currentDescriptionEditElementId: null,
        isDragging: !1,
        isFrameDragging: !1,
        isPanning: !1,
        pillOperationState: {
          isActive: !1,
          operationType: null,
          elementId: null,
          linkIndex: null,
          currentTime: null,
          timeRange: null,
        },
        transformState: V0e,
        isAtMinZoom: !0,
        placementMode: null,
        hoveredElementId: null,
        lastPlayheadInteraction: null,
        tagVisibilityState: {},
        creatorVisibilityState: {},
        collapsedElementStates: {},
        activeTagPickerElementId: null,
        filterToolbarOpen: !1,
        currentPlayingRecordingId: null,
        deletionConfirmationState: {
          isOpen: !1,
          elementsToDelete: [],
          onConfirm: null,
        },
        userProfiles: {},
        unseenElementIds: new Set(),
        placeholderElement: { id: null, type: null, timestamp: null },
        newlyCreatedElements: new Set(),
        setBoardState: (t) =>
          n((s) => {
            const r = Object.values(t.elements).filter(
              (i) => i.type === "recording"
            );
            r.length > 0 &&
              (`${r.length}`,
              r.map((i) => ({
                id: i.id,
                recordingState: i.recordingState,
                videoUrl: i.videoUrl,
                thumbnailUrl: i.thumbnailUrl,
              }))),
              (s.boardState = t),
              (s.boardState.elements = { ...t.elements });
          }),
        setIsDataLoaded: (t) =>
          n((s) => {
            s.isDataLoaded = t;
          }),
        setHasEditingPermissions: (t) =>
          n((s) => {
            s.hasEditingPermissions = t;
          }),
        setCurrentUserData: (t, s, r) =>
          n((i) => {
            (i.currentUserId = t),
              (i.currentUserName = s),
              (i.currentUserAvatarUrl = r);
          }),
        setSelectedFrames: (t) => {
          n((s) => {
            s.selectedFrames = t;
          }),
            t.length === 1 && e().seekToElementTimestamp(t[0]);
        },
        setSelectedChildrenIds: (t) =>
          n((s) => {
            s.selectedChildrenIds = t;
          }),
        setSelectedElementId: (t) =>
          n((s) => {
            s.selectedElementId = t;
          }),
        setIsDragging: (t) =>
          n((s) => {
            s.isDragging = t;
          }),
        setIsFrameDragging: (t) =>
          n((s) => {
            s.isFrameDragging = t;
          }),
        setIsPanning: (t) =>
          n((s) => {
            s.isPanning = t;
          }),
        setPlacementMode: (t) =>
          n((s) => {
            s.placementMode = t;
          }),
        setUserProfiles: (t) =>
          n((s) => {
            s.userProfiles = t;
          }),
        setFlaskId: (t) =>
          n((s) => {
            s.flaskId = t;
          }),
        setUnseenElements: (t) =>
          n((s) => {
            s.unseenElementIds = new Set(t);
          }),
        markElementAsSeen: async (t) => {
          n((a) => {
            a.unseenElementIds.delete(t);
          });
          const s = e(),
            { flaskId: r, currentUserId: i } = s;
          if (!(!r || !i))
            try {
              const { currentAssetId: a } = s;
              if (!a) return;
              await Ds.from("asset_last_seen").upsert(
                {
                  user_id: i,
                  asset_id: a,
                  last_seen_at: new Date().toISOString(),
                },
                { onConflict: "user_id,asset_id" }
              ),
                `${t}`;
            } catch (a) {
              console.error("Error updating asset last_seen_at:", a);
            }
        },
        isElementUnseen: (t) => e().unseenElementIds.has(t),
        fetchUnseenElements: async () => {
          const t = e(),
            { flaskId: s, currentAssetId: r, currentUserId: i } = t;
          if (!s || !r || !i) {
            n((a) => {
              a.unseenElementIds = new Set();
            });
            return;
          }
          try {
            const { data: a } = await Ds.from("asset_last_seen")
                .select("last_seen_at")
                .eq("user_id", i)
                .eq("asset_id", r)
                .single(),
              o = a?.last_seen_at || null,
              { data: l, error: c } = await Ds.from("elements")
                .select(
                  "id, created_at, created_by, type, title, content, asset_id, links"
                )
                .eq("asset_id", r)
                .order("created_at", { ascending: !1 });
            if (c) {
              console.error("Error fetching unseen elements:", c);
              return;
            }
            const h =
                l?.filter((g) =>
                  g.created_by === i
                    ? !1
                    : o
                    ? new Date(g.created_at) > new Date(o)
                    : !0
                ) || [],
              m = new Map();
            h.forEach((g) => {
              const y = g.links?.find((b) => b?.type === "element");
              if (y && y.targetElementId) {
                const b = y.targetElementId,
                  w = m.get(b);
                (!w || new Date(g.created_at) > new Date(w.created_at)) &&
                  m.set(b, g);
              } else {
                const b = g.id;
                m.set(b, g);
              }
            });
            const p = Array.from(m.values()).map((g) => g.id);
            n((g) => {
              g.unseenElementIds = new Set(p);
            });
          } catch (a) {
            console.error("Error fetching unseen elements:", a);
          }
        },
        createElement: async (t, s = {}, r, i, a = !1) => {
          const o = e();
          if (!o.hasEditingPermissions)
            return (
              console.warn(
                `Attempted to create ${t} element without editing permissions - blocked`
              ),
              null
            );
          const { rootElements: l, elements: c } = o.boardState,
            h = j1(),
            m = s.createdBy || o.currentUserId,
            p = s.creatorName || o.currentUserName || null,
            g = s.creatorAvatarUrl || o.currentUserAvatarUrl || null;
          let y;
          try {
            const { useToolbarStore: b } = await Lt(async () => {
                const { useToolbarStore: A } = await Promise.resolve().then(
                  () => So
                );
                return { useToolbarStore: A };
              }, void 0),
              w = b.getState(),
              S = w.pendingTimelineLink;
            if (S) {
              const A =
                  S.start === S.end
                    ? { type: "timeline", timestamp: S.start }
                    : {
                        type: "timeline",
                        timeRange: { start: S.start, end: S.end },
                      },
                _ = (s.links || []).filter((R) => R && R.type !== "timeline");
              s = { ...s, links: [..._, A] };
            }
            if (!s.tagIds || s.tagIds.length === 0) {
              const A = w.selectedTags;
              A && A.length > 0 && (s = { ...s, tagIds: A });
            }
          } catch {}
          if (s.links && s.links.length > 0) {
            const b = s.links.find(
              (w) =>
                w.type === "timeline" && w.timestamp !== void 0 && !w.timeRange
            );
            if (b && b.timestamp !== void 0) {
              const w = e().getLastElementAtTimestamp(b.timestamp);
              if (w) {
                const _ = o.boardState.elements[w]?.links?.find(
                  (L) => L.type === "timeline" && L.timestamp !== void 0
                )?.timestamp;
                `${b.timestamp}${_}${w}${Math.abs(
                  (b.timestamp || 0) - (_ || 0)
                )}`;
                const C = e().findRootElementInThread(w) || w,
                  D = s.links.filter(
                    (L) =>
                      !(
                        L.type === "timeline" &&
                        L.timestamp !== void 0 &&
                        !L.timeRange
                      )
                  );
                (s = {
                  ...s,
                  links: [...D, { type: "element", targetElementId: C }],
                }),
                  Lt(async () => {
                    const { toast: L } = await Promise.resolve().then(() => Q_);
                    return { toast: L };
                  }, void 0)
                    .then(({ toast: L }) => {
                      L.info(
                        "There was already something here. Comment added as a reply."
                      );
                    })
                    .catch(() => {
                      console.warn(
                        "[CanvasStore] Failed to show toast notification"
                      );
                    });
              }
            }
          }
          switch (t) {
            case "text":
              const b = $0e();
              y = {
                id: h,
                title:
                  s.title ||
                  `Text ${Object.keys(o.boardState.elements).length + 1}`,
                position: s.position || { x: 0, y: 0 },
                dimensions: s.dimensions || b,
                type: "text",
                children: [],
                content: s.content || "",
                parentId: r,
                createdBy: m,
                createdAt: s.createdAt || new Date().toISOString(),
                creatorName: p,
                creatorAvatarUrl: g,
                links: s.links || [],
                tagIds: s.tagIds || [],
              };
              break;
            case "recording":
              const w = { width: Ln, height: 240 };
              y = {
                id: h,
                title:
                  s.title ||
                  `Recording ${Object.keys(o.boardState.elements).length + 1}`,
                position: s.position || { x: 0, y: 0 },
                dimensions: s.dimensions || w,
                type: "recording",
                children: [],
                recordingType: s.recordingType || "thoughts",
                recordingId: s.recordingId || void 0,
                videoUrl: s.videoUrl || void 0,
                thumbnailUrl: s.thumbnailUrl || void 0,
                errorMessage: s.errorMessage || void 0,
                parentId: r,
                createdBy: m,
                createdAt: s.createdAt || new Date().toISOString(),
                creatorName: p,
                creatorAvatarUrl: g,
                links: s.links || [],
                tagIds: s.tagIds || [],
              };
              break;
            default:
              return console.warn(`Unknown element type: ${t}`), null;
          }
          if (
            (n((b) => {
              (b.boardState.elements[h] = y),
                r
                  ? b.boardState.elements[r] &&
                    b.boardState.elements[r].children.push(h)
                  : b.boardState.rootElements.push(h),
                b.newlyCreatedElements.add(h),
                m &&
                  !b.userProfiles[m] &&
                  (b.userProfiles[m] = { id: m, full_name: p }),
                (b.boardState.elements = { ...b.boardState.elements });
            }),
            !s.skipPersist)
          )
            try {
              await $n
                .getState()
                .saveElement({
                  id: h,
                  flask_id: o.flaskId,
                  asset_id: o.currentAssetId,
                  type: t,
                  title: y.title,
                  content: y.content,
                  links: y.links,
                  tag_ids: y.tagIds,
                  created_by: m,
                  creator_name: p,
                  creator_avatar_url: g,
                  timeline_timestamp: void 0,
                  timeline_start: void 0,
                  timeline_end: void 0,
                  parent_element_id: void 0,
                  ...(t === "recording" && {
                    recording_type: y.recordingType,
                    recording_id: y.recordingId,
                    video_url: y.videoUrl,
                    thumbnail_url: y.thumbnailUrl,
                  }),
                });
            } catch (b) {
              throw (
                (console.error("[CanvasStore] Failed to persist element:", b),
                n((w) => {
                  delete w.boardState.elements[h],
                    (w.boardState.rootElements =
                      w.boardState.rootElements.filter((S) => S !== h)),
                    r &&
                      w.boardState.elements[r] &&
                      (w.boardState.elements[r].children =
                        w.boardState.elements[r].children.filter(
                          (S) => S !== h
                        ));
                }),
                b)
              );
            }
          try {
            const { useToolbarStore: b } = await Lt(async () => {
                const { useToolbarStore: S } = await Promise.resolve().then(
                  () => So
                );
                return { useToolbarStore: S };
              }, void 0),
              w = b.getState();
            w.setPendingTimelineLink(null), w.clearSelectedTags();
          } catch {}
          try {
            const { useTimelineStore: b } = await Lt(async () => {
              const { useTimelineStore: w } = await Promise.resolve().then(
                () => Zp
              );
              return { useTimelineStore: w };
            }, void 0);
            b.getState().zoomToShowElements([h]);
          } catch {}
          if (typeof window < "u" && Bt.isAvailable()) {
            let b;
            t === "text"
              ? (b = "text")
              : t === "recording"
              ? (b =
                  (s.recordingType || "thoughts") === "screen"
                    ? "screen"
                    : "recording")
              : (b = t);
            let w = "other",
              S;
            s?.createdViaKeyboard
              ? ((w = "keyboard_shortcut"), (S = s.keyboardShortcut))
              : i === "keyboard_shortcuts"
              ? (w = "keyboard_shortcut")
              : i === "playheadmenu"
              ? (w = "toolbar_click")
              : i || (w = "toolbar_click"),
              I0e({
                elementId: h,
                flaskId: o.flaskId,
                userId: m,
                type: b,
                createdVia: i,
                input_method: w,
                shortcut_used: S,
              });
          }
          return h;
        },
        createAndStartRecording: async (t) => {
          const {
              recordingType: s,
              linkContext: r,
              timestamp: i,
              targetElementId: a,
              position: o,
              createdVia: l,
            } = t,
            c = e();
          if (!c.hasEditingPermissions)
            return (
              console.warn(
                `Attempted to create ${s} recording element without editing permissions - blocked`
              ),
              { error: "active-recording" }
            );
          let h, m;
          if (r === "element" && a) {
            const p = e().findRootElementInThread(a);
            if (!p)
              return (
                console.warn("Could not find root element in thread"),
                { error: "active-recording" }
              );
            if (!c.boardState.elements[p])
              return (
                console.warn("Root element not found"),
                { error: "active-recording" }
              );
            if (o) h = o;
            else
              return (
                console.warn("Could not find position for root element"),
                { error: "active-recording" }
              );
            m = [{ type: "element", targetElementId: p }];
          } else if (r === "timeline" && i !== void 0) {
            const p = c.boardState.assetId;
            if (!p || !c.boardState.elements[p])
              return (
                console.warn(
                  "No asset found for creating linked recording element"
                ),
                { error: "active-recording" }
              );
            const g = c.boardState.elements[p];
            if (g.type !== "asset")
              return (
                console.warn("Asset element is not of type asset"),
                { error: "active-recording" }
              );
            try {
              const { useMediaStore: y } = await Lt(async () => {
                  const { useMediaStore: w } = await Promise.resolve().then(
                    () => Ra
                  );
                  return { useMediaStore: w };
                }, void 0),
                b = y.getState();
              b.isPlaying && (`${s}`, b.pause());
            } catch (y) {
              console.warn("Could not pause video playback:", y);
            }
            if (o) h = o;
            else {
              const { playheadToCanvasCoordinates: y } = await Lt(async () => {
                  const { playheadToCanvasCoordinates: w } =
                    await Promise.resolve().then(() => r$);
                  return { playheadToCanvasCoordinates: w };
                }, void 0),
                b = g.playbarWidth || g.dimensions?.width || 1200;
              h = y(i, g, b, 320, 30);
            }
            m = [{ type: "timeline", timestamp: i }];
          } else
            return (
              console.error("Invalid parameters for createAndStartRecording"),
              { error: "active-recording" }
            );
          try {
            const p = await e().createElement(
              "recording",
              {
                position: h,
                title:
                  s === "screen" ? "Screen Recording" : "Thoughts Recording",
                recordingType: s,
                links: m,
                _skipAutoRecordingStart: !0,
              },
              void 0,
              l
            );
            if (!p)
              return (
                console.error("Failed to create recording element"),
                { error: "active-recording" }
              );
            if (
              Object.values(c.boardState.elements)
                .filter((w) => w.type === "recording")
                .filter((w) => w.recordingState === "recording").length > 0
            )
              return (
                console.warn(
                  "Cannot start recording - another recording is active"
                ),
                { error: "active-recording" }
              );
            const y = await Lt(
              () => Promise.resolve().then(() => $1),
              void 0
            ).then((w) => w.useRecordingStore.getState());
            return (
              (await y.prepareRecording(p)) && (await y.startRecording(p)), p
            );
          } catch (p) {
            return (
              console.error("Error creating and starting recording:", p),
              { error: "active-recording" }
            );
          }
        },
        updateElement: async (t, s) => {
          const r = e(),
            i = r.boardState.elements[t];
          if (i) {
            if (!r.hasEditingPermissions) {
              console.warn(
                `Attempted to update element ${t} without editing permissions - blocked`
              );
              return;
            }
            if (e().checkElementOwnership(t, "update")) {
              n((a) => {
                a.boardState.elements[t] &&
                  (Object.assign(a.boardState.elements[t], s),
                  (a.boardState.elements = { ...a.boardState.elements }));
              });
              try {
                const a = {};
                if (
                  (s.title !== void 0 && (a.title = s.title),
                  s.links !== void 0 && (a.links = s.links),
                  s.tagIds !== void 0 && (a.tag_ids = s.tagIds),
                  i.type === "text" &&
                    s.content !== void 0 &&
                    (a.content = s.content),
                  i.type === "recording")
                ) {
                  const o = s;
                  o.recordingId !== void 0 && (a.recording_id = o.recordingId),
                    o.videoUrl !== void 0 && (a.video_url = o.videoUrl),
                    o.thumbnailUrl !== void 0 &&
                      (a.thumbnail_url = o.thumbnailUrl),
                    o.duration !== void 0 && (a.duration = o.duration),
                    o.hasAIInsights !== void 0 &&
                      (a.has_ai_insights = o.hasAIInsights),
                    o.aiSummary !== void 0 && (a.ai_summary = o.aiSummary);
                }
                if (
                  (await $n.getState().updateElement(t, a),
                  i.type === "recording")
                ) {
                  const o = s;
                  if (o.aiSummary !== void 0) {
                    const l = i;
                    if (l.recordingId) {
                      const c = { ai_summary: o.aiSummary },
                        { error: h } = await Ds.from("recordings")
                          .update(c)
                          .eq("id", l.recordingId);
                      h &&
                        console.error(
                          "[CanvasStore] Failed to update recording summary in recordings table:",
                          h
                        );
                    }
                  }
                }
              } catch (a) {
                throw (
                  (console.error(
                    "[CanvasStore] Failed to persist element update:",
                    a
                  ),
                  n((o) => {
                    o.boardState.elements[t] &&
                      (Object.assign(o.boardState.elements[t], i),
                      (o.boardState.elements = { ...o.boardState.elements }));
                  }),
                  a)
                );
              }
            }
          }
        },
        deleteElementsDirectly: async (t) => {
          if (!t.length) return 0;
          const s = e();
          if (!s.hasEditingPermissions)
            return (
              console.warn(
                "Attempted to delete elements without editing permissions - blocked"
              ),
              0
            );
          const r = [];
          for (const h of t)
            e().checkElementOwnership(h, "deletion") || r.push(h);
          if (r.length > 0)
            return (
              console.warn(
                `[CanvasStore] Cannot delete ${r.length} elements not owned by current user:`,
                r
              ),
              0
            );
          try {
            const { useRecordingStore: h } = await Lt(async () => {
                const { useRecordingStore: g } = await Promise.resolve().then(
                  () => $1
                );
                return { useRecordingStore: g };
              }, void 0),
              m = h.getState(),
              p = m.activeRecordingElementId;
            p && t.includes(p) && (`${p}`, await m.stopRecording(), `${p}`);
          } catch (h) {
            console.error(
              "[CanvasStore] Error checking/cleaning recording state during deletion:",
              h
            );
          }
          try {
            for (const h of t) {
              const m = s.boardState.elements[h];
              if (m && m.type === "recording") {
                s.currentPlayingRecordingId === h &&
                  (`${h}`, e().pauseRecording(h), `${h}`);
                const { useMediaStore: p } = await Lt(async () => {
                    const { useMediaStore: y } = await Promise.resolve().then(
                      () => Ra
                    );
                    return { useMediaStore: y };
                  }, void 0),
                  g = p.getState();
                g.activeRecordingId === h &&
                  (`${h}`, g.clearActiveRecording(), `${h}`);
              }
            }
          } catch (h) {
            console.error(
              "[CanvasStore] Error checking/cleaning recording playback state during deletion:",
              h
            );
          }
          let i = 0;
          const a = [],
            o = new Set(t),
            l = e().boardState.elements,
            c = (h) => {
              const m = l[h];
              m?.children &&
                m.children.forEach((p) => {
                  o.has(p) || (o.add(p), c(p));
                });
            };
          t.forEach(c),
            n((h) => {
              const m = h.boardState.elements;
              o.forEach((p) => {
                if (m[p]) {
                  const g = m[p];
                  if (g.type === "recording" && g.videoUrl) {
                    const y = g;
                    a.push({ url: y.videoUrl, thumbnailUrl: y.thumbnailUrl });
                  }
                  if (g.parentId && m[g.parentId]) {
                    const y = m[g.parentId];
                    y.children = y.children.filter((b) => b !== p);
                  }
                  delete m[p],
                    i++,
                    h.boardState.assetId === p &&
                      (h.boardState.assetId = void 0);
                }
              }),
                (h.boardState.rootElements = h.boardState.rootElements.filter(
                  (p) => !o.has(p)
                ));
            });
          try {
            const { error: h } = await Ds.from("elements")
              .delete()
              .in("id", Array.from(o));
            if (h) {
              console.error(
                "[CanvasStore] Failed to delete elements from database:",
                h
              );
              const { toast: m } = await Lt(async () => {
                const { toast: p } = await Promise.resolve().then(() => Q_);
                return { toast: p };
              }, void 0);
              m.error("Failed to delete elements. Please try again.");
            } else `${o.size}`;
          } catch (h) {
            console.error(
              "[CanvasStore] Error deleting elements from database:",
              h
            );
            const { toast: m } = await Lt(async () => {
              const { toast: p } = await Promise.resolve().then(() => Q_);
              return { toast: p };
            }, void 0);
            m.error("Failed to delete elements. Please try again.");
          }
          return i;
        },
        setFramePositionDirectly: (t, s) =>
          n((r) => {
            r.boardState.elements[t] &&
              ((r.boardState.elements[t].position = s),
              (r.boardState.elements = { ...r.boardState.elements }));
          }),
        finalizeFramePosition: async (t, s) => {
          e().setFramePositionDirectly(t, s);
        },
        addLinkToElement: async (t, s) => {
          if (!e().hasEditingPermissions) {
            console.warn(
              `Attempted to add link to element ${t} without editing permissions - blocked`
            );
            return;
          }
          if (!e().checkElementOwnership(t, "link addition")) return;
          const i = e().boardState.elements[t];
          if (!i) return;
          const a = [...(i.links || []), s];
          n((o) => {
            const l = o.boardState.elements[t];
            l &&
              ((l.links = a),
              (o.boardState.elements = { ...o.boardState.elements }));
          });
          try {
            await $n.getState().updateElement(t, { links: a });
          } catch (o) {
            console.error("[CanvasStore] Failed to persist link addition:", o);
          }
        },
        updateElementLink: async (t, s, r) => {
          if (!e().hasEditingPermissions) {
            console.warn(
              `Attempted to update link on element ${t} without editing permissions - blocked`
            );
            return;
          }
          if (!e().checkElementOwnership(t, "link update")) return;
          const a = e().boardState.elements[t];
          if (!a || !a.links || !a.links[s]) return;
          const o = [...a.links];
          (o[s] = { ...o[s], ...r }),
            n((l) => {
              const c = l.boardState.elements[t];
              c &&
                ((c.links = o),
                (l.boardState.elements = { ...l.boardState.elements }));
            });
          try {
            await $n.getState().updateElement(t, { links: o });
          } catch (l) {
            console.error("[CanvasStore] Failed to persist link update:", l);
          }
        },
        removeElementLink: async (t, s) => {
          if (!e().hasEditingPermissions) {
            console.warn(
              `Attempted to remove link from element ${t} without editing permissions - blocked`
            );
            return;
          }
          e().checkElementOwnership(t, "link removal") &&
            n((i) => {
              const a = i.boardState.elements[t];
              a &&
                a.links &&
                (a.links.splice(s, 1),
                (i.boardState.elements = { ...i.boardState.elements }));
            });
        },
        updateElementLinkVisual: (t, s, r) => {
          n((i) => {
            const a = i.boardState.elements[t];
            a &&
              a.links &&
              a.links[s] &&
              (Object.assign(a.links[s], r),
              (i.boardState.elements = { ...i.boardState.elements }));
          });
        },
        commitElementLinkUpdate: async (t, s) => {
          if (!e().hasEditingPermissions) {
            console.warn(
              `Attempted to commit link update on element ${t} without editing permissions - blocked`
            );
            return;
          }
          const i = e().boardState.elements[t];
          if (i && i.links)
            try {
              await $n.getState().updateElement(t, { links: i.links });
            } catch (a) {
              console.error("[CanvasStore] Failed to commit link update:", a);
            }
        },
        getAssetElement: () => null,
        getTimelineLinks: () => {
          const t = e(),
            s = [];
          return (
            Object.entries(t.boardState.elements).forEach(([r, i]) => {
              i &&
                i.links &&
                i.links.forEach((a, o) => {
                  a.type === "timeline" &&
                    s.push({ elementId: r, element: i, linkIndex: o, link: a });
                });
            }),
            s
          );
        },
        getElementLinks: () => {
          const t = e(),
            s = [];
          return (
            Object.entries(t.boardState.elements).forEach(([r, i]) => {
              i &&
                i.links &&
                i.links.forEach((a, o) => {
                  a.type === "element" &&
                    s.push({ elementId: r, element: i, linkIndex: o, link: a });
                });
            }),
            s
          );
        },
        hasElementsLinkingToIt: (t) => {
          const s = e();
          for (const r of Object.values(s.boardState.elements))
            if (
              r &&
              r.links &&
              r.links.some(
                (a) => a && a.type === "element" && a.targetElementId === t
              )
            )
              return !0;
          return !1;
        },
        findRootElementInThread: (t) => {
          const s = e(),
            r = s.boardState.elements[t];
          if (!r) return null;
          if (r.links?.some((o) => o.type === "timeline")) return t;
          const a = r.links?.find((o) => o.type === "element");
          if (a && a.targetElementId) {
            const o = new Set();
            let l = a.targetElementId;
            for (; l && !o.has(l); ) {
              o.add(l);
              const c = s.boardState.elements[l];
              if (!c) break;
              if (c.links?.some((p) => p.type === "timeline")) return l;
              const m = c.links?.find((p) => p.type === "element");
              if (m && m.targetElementId) l = m.targetElementId;
              else break;
            }
          }
          return null;
        },
        setElementCollapsed: (t, s) => {
          n((r) => {
            r.collapsedElementStates[t] = s;
          });
        },
        toggleElementCollapsed: (t) => {
          n((s) => {
            s.collapsedElementStates[t] = !s.collapsedElementStates[t];
          });
        },
        isElementCollapsed: (t) => e().collapsedElementStates[t] || !1,
        collapseElements: (t) => {
          n((s) => {
            t.forEach((r) => {
              s.collapsedElementStates[r] = !0;
            });
          });
        },
        expandElements: (t) => {
          n((s) => {
            t.forEach((r) => {
              s.collapsedElementStates[r] = !1;
            });
          });
        },
        setActiveTagPicker: (t) => {
          n((s) => {
            s.activeTagPickerElementId = t;
          });
        },
        initializeCanvas: async (t, s = !1, r = 0) => {
          n((a) => {
            (a.isDataLoaded = !1),
              (a.flaskId = t),
              (a.hasEditingPermissions = s);
          });
          const i = hn.getState();
          i.user &&
            n((a) => {
              (a.currentUserId = i.user.id),
                (a.currentUserName = i.profile?.full_name || i.user.email),
                (a.currentUserAvatarUrl = i.profile?.avatar_url);
            });
          try {
            const { data: a, error: o } = await Ds.from("assets")
              .select("*")
              .eq("flask_id", t)
              .order("created_at", { ascending: !1 });
            if (o) throw o;
            const l = a?.[r] || a?.[0];
            if (!l) throw new Error("No assets found for this flask");
            n((b) => {
              (b.availableAssets = a || []), (b.currentAssetId = l.id);
            });
            const [c, h] = await Promise.all([
                $n.getState().loadElements(l.id),
                $n.getState().loadTags(t),
              ]),
              m = {};
            h.forEach((b) => {
              m[b.id] = {
                id: b.id,
                name: b.name,
                color: b.color || "accent-gray",
              };
            });
            const p = { elements: {}, rootElements: [], tags: m };
            c.forEach((b) => {
              const w = {
                id: b.id,
                type: b.type,
                title: b.title || "",
                position: b.position,
                dimensions: b.dimensions,
                parentId: b.parent_id,
                children: b.children || [],
                createdBy: b.created_by,
                createdAt: b.created_at,
                creatorName: b.creator_name,
                creatorAvatarUrl: b.creator_avatar_url,
                links: b.links || [],
                tagIds: b.tag_ids || [],
              };
              b.type === "text"
                ? (w.content = b.content || "")
                : b.type === "asset"
                ? Object.assign(w, {
                    youtubeUrl: b.youtube_url,
                    playbarWidth: b.playbar_width,
                    duration: b.duration,
                    startTime: b.start_time,
                    playbackRate: b.playback_rate,
                    isMuted: b.is_muted,
                  })
                : b.type === "recording" &&
                  (b.id,
                  b.recordings,
                  b.recordings,
                  b.recordings?.ai_processing_status ?? b.ai_processing_status,
                  b.ai_summary,
                  b.recordings?.ai_transcript ?? b.ai_transcript,
                  (b.recordings?.ai_transcript ?? b.ai_transcript)?.length,
                  Object.assign(w, {
                    recordingType: b.recording_type,
                    recordingId: b.recording_id,
                    videoUrl: b.recordings?.hls_url ?? b.video_url,
                    thumbnailUrl:
                      b.recordings?.thumbnail_url ?? b.thumbnail_url,
                    duration: b.recordings?.duration ?? b.duration,
                    recordingState: "completed",
                    aiStatus:
                      b.recordings?.ai_processing_status ??
                      b.ai_processing_status ??
                      "pending",
                    aiSummary: b.ai_summary || "",
                    hasAIInsights: b.has_ai_insights ?? !1,
                    aiInsights:
                      (b.recordings?.ai_processing_status ??
                        b.ai_processing_status) === "completed" && b.ai_summary
                        ? {
                            transcript:
                              b.recordings?.ai_transcript ?? b.ai_transcript,
                            summary: b.ai_summary,
                          }
                        : void 0,
                  }),
                  b.id,
                  w.aiInsights,
                  w.aiInsights?.transcript),
                (p.elements[b.id] = w),
                b.parent_id || p.rootElements.push(b.id),
                b.type === "asset" && (p.assetId = b.id);
            }),
              n((b) => {
                (b.boardState = {
                  elements: p.elements || {},
                  rootElements: p.rootElements || [],
                  tags: p.tags || {},
                  assetId: p.assetId,
                }),
                  (b.boardState.elements = { ...p.elements });
              });
            const g = new Set();
            if (
              (Object.values(p.elements).forEach((b) => {
                b.createdBy && g.add(b.createdBy);
              }),
              g.size > 0)
            ) {
              g.size;
              try {
                await hn.getState().fetchUserProfiles(Array.from(g));
                const b = hn.getState().userProfiles;
                n((w) => {
                  (w.userProfiles = { ...b }),
                    Object.values(w.boardState.elements).forEach((S) => {
                      if (S.createdBy && b[S.createdBy]) {
                        const A = b[S.createdBy];
                        (S.creatorName =
                          A.name || A.full_name || A.email || S.creatorName),
                          (S.creatorAvatarUrl =
                            A.avatar_url || S.creatorAvatarUrl);
                      }
                    }),
                    (w.boardState.elements = { ...w.boardState.elements });
                });
              } catch (b) {
                console.error(
                  "[CanvasStore] Failed to fetch user profiles:",
                  b
                );
              }
            }
            n((b) => {
              b.isDataLoaded = !0;
            }),
              await e().fetchUnseenElements();
            const { useTimelineStore: y } = await Lt(async () => {
              const { useTimelineStore: b } = await Promise.resolve().then(
                () => Zp
              );
              return { useTimelineStore: b };
            }, void 0);
            y.getState().resetZoom();
          } catch (a) {
            throw (
              (console.error("[CanvasStore] Canvas initialization failed:", a),
              n((o) => {
                (o.isDataLoaded = !1),
                  (o.boardState = { elements: {}, rootElements: [], tags: {} });
              }),
              a)
            );
          }
        },
        switchAsset: async (t) => {
          const s = e();
          if (s.currentAssetId === t) return;
          if (!s.availableAssets.find((i) => i.id === t)) {
            console.error(
              "[CanvasStore] Asset not found in available assets:",
              t
            );
            return;
          }
          n((i) => {
            (i.isDataLoaded = !1), (i.currentAssetId = t);
          });
          try {
            const [i, a] = await Promise.all([
                $n.getState().loadElements(t),
                $n.getState().loadTags(s.flaskId),
              ]),
              o = {};
            a.forEach((h) => {
              o[h.id] = {
                id: h.id,
                name: h.name,
                color: h.color || "accent-gray",
              };
            });
            const l = { elements: {}, rootElements: [], tags: o };
            i.forEach((h) => {
              const m = {
                id: h.id,
                type: h.type,
                title: h.title || "",
                position: h.position,
                dimensions: h.dimensions,
                parentId: h.parent_id,
                children: h.children || [],
                createdBy: h.created_by,
                createdAt: h.created_at,
                creatorName: h.creator_name,
                creatorAvatarUrl: h.creator_avatar_url,
                links: h.links || [],
                tagIds: h.tag_ids || [],
              };
              h.type === "text"
                ? (m.content = h.content || "")
                : h.type === "recording" &&
                  Object.assign(m, {
                    recordingType: h.recording_type,
                    recordingId: h.recording_id,
                    videoUrl: h.video_url,
                    thumbnailUrl: h.thumbnail_url,
                    duration: h.duration,
                    recordingState: "completed",
                    aiStatus: h.ai_processing_status || "pending",
                    aiSummary: h.ai_summary || "",
                    hasAIInsights: !1,
                    aiInsights:
                      h.ai_processing_status === "completed" && h.ai_summary
                        ? { transcript: h.ai_transcript, summary: h.ai_summary }
                        : void 0,
                  }),
                (l.elements[h.id] = m),
                h.parent_id || l.rootElements.push(h.id);
            }),
              n((h) => {
                (h.boardState = l),
                  (h.boardState.elements = { ...l.elements }),
                  (h.isDataLoaded = !0);
              }),
              await e().fetchUnseenElements();
            const { useTimelineStore: c } = await Lt(async () => {
              const { useTimelineStore: h } = await Promise.resolve().then(
                () => Zp
              );
              return { useTimelineStore: h };
            }, void 0);
            c.getState().resetZoom();
          } catch (i) {
            throw (
              (console.error("[CanvasStore] Failed to switch asset:", i),
              n((a) => {
                a.isDataLoaded = !0;
              }),
              i)
            );
          }
        },
        reset: () =>
          n((t) => {
            (t.boardState = { elements: {}, rootElements: [], tags: {} }),
              (t.isDataLoaded = !1),
              (t.selectedFrames = []),
              (t.selectedChildrenIds = []),
              (t.selectedElementId = void 0),
              (t.isDragging = !1),
              (t.isFrameDragging = !1),
              (t.isPanning = !1),
              (t.pillOperationState = {
                isActive: !1,
                operationType: null,
                elementId: null,
                linkIndex: null,
                currentTime: null,
                timeRange: null,
              }),
              (t.placementMode = null),
              (t.userProfiles = {}),
              (t.flaskId = null),
              (t.currentAssetId = null),
              (t.availableAssets = []),
              (t.currentUserId = null),
              (t.currentUserName = null),
              (t.currentUserAvatarUrl = null),
              (t.currentTextEditElementId = null),
              (t.currentDescriptionEditElementId = null),
              (t.hoveredElementId = null),
              (t.lastPlayheadInteraction = null),
              (t.tagVisibilityState = {}),
              (t.creatorVisibilityState = {}),
              (t.filterToolbarOpen = !1),
              (t.currentPlayingRecordingId = null);
          }),
        centerViewportOnElements: () => !1,
        startPillOperation: (t, s, r, i, a) => {
          n((o) => {
            o.pillOperationState = {
              isActive: !0,
              operationType: t,
              elementId: s,
              linkIndex: r,
              currentTime: i,
              timeRange: a || null,
            };
          });
        },
        updatePillOperation: (t, s) => {
          n((r) => {
            r.pillOperationState = {
              ...r.pillOperationState,
              currentTime: t,
              timeRange: s || null,
            };
          });
        },
        endPillOperation: () => {
          n((t) => {
            t.pillOperationState = {
              isActive: !1,
              operationType: null,
              elementId: null,
              linkIndex: null,
              currentTime: null,
              timeRange: null,
            };
          });
        },
        selectElement: (t, s) => {
          e().getElementVisibility(t) &&
            (n((i) => {
              (i.selectedFrames = [t]), (i.selectedChildrenIds = [t]);
            }),
            e().markElementAsSeen(t),
            e().seekToElementTimestamp(t));
        },
        toggleElementSelection: (t) => {
          if (!e().getElementVisibility(t)) return;
          const r = e(),
            { selectedFrames: i } = r;
          i.includes(t)
            ? n((a) => {
                (a.selectedFrames = []), (a.selectedChildrenIds = []);
              })
            : (n((a) => {
                (a.selectedFrames = [t]), (a.selectedChildrenIds = [t]);
              }),
              e().seekToElementTimestamp(t));
        },
        clearSelection: () => {
          e(),
            Lt(async () => {
              const { useToolbarStore: t } = await Promise.resolve().then(
                () => So
              );
              return { useToolbarStore: t };
            }, void 0).then(({ useToolbarStore: t }) => {
              const s = t.getState();
              s.state,
                s.textContent,
                s.textContent.trim(),
                s.state === "focused" &&
                  !s.textContent.trim() &&
                  !s.editingElementId &&
                  (s.clearText(), s.exitToIdle());
            }),
            n((t) => {
              (t.selectedFrames = []), (t.selectedChildrenIds = []);
            });
        },
        selectElementWithModifiers: (t) => {
          e(),
            e().getElementVisibility(t) &&
              (Lt(async () => {
                const { useToolbarStore: r } = await Promise.resolve().then(
                  () => So
                );
                return { useToolbarStore: r };
              }, void 0).then(({ useToolbarStore: r }) => {
                const { state: i, exitToIdle: a, clearText: o } = r.getState();
                i === "focused" && (o(), a());
              }),
              n((r) => {
                (r.selectedFrames = [t]), (r.selectedChildrenIds = [t]);
              }),
              e().seekToElementTimestamp(t));
        },
        seekToElementTimestamp: (t) => {
          const s = e(),
            r = s.boardState.elements[t];
          if (!r || !r.links || s.currentTextEditElementId === t) return;
          const i = r.links.find((o) => o.type === "timeline");
          if (!i) return;
          let a;
          if (i.timeRange) a = i.timeRange.start;
          else if (i.timestamp !== void 0) a = i.timestamp;
          else return;
          Lt(async () => {
            const { useMediaStore: o } = await Promise.resolve().then(() => Ra);
            return { useMediaStore: o };
          }, void 0)
            .then(({ useMediaStore: o }) => {
              const l = o.getState();
              l.playerRef && l.isReady && l.seek(a);
            })
            .catch((o) => {
              console.warn(
                "[CanvasStore] Failed to import media store for seeking:",
                o
              );
            });
        },
        enterTextEditMode: (t) => {
          if (e().currentTextEditElementId === t) {
            e().exitTextEditMode();
            return;
          }
          if (!e().getElementVisibility(t)) return;
          const r = e().boardState.elements[t];
          if (!r || r.type !== "text") {
            console.warn(
              "[CanvasStore] Cannot enter text edit mode for non-text element:",
              t
            );
            return;
          }
          e().checkElementOwnership(t, "text editing") &&
            n((i) => {
              (i.currentDescriptionEditElementId = null),
                (i.currentTextEditElementId = t),
                (i.selectedFrames = [t]),
                (i.selectedChildrenIds = [t]);
            });
        },
        exitTextEditMode: () =>
          n((t) => {
            t.currentTextEditElementId, (t.currentTextEditElementId = null);
          }),
        isElementInTextEditMode: (t) => e().currentTextEditElementId === t,
        enterDescriptionEditMode: (t) => {
          if (e().currentDescriptionEditElementId === t) {
            e().exitDescriptionEditMode();
            return;
          }
          const s = e().boardState.elements[t];
          !s ||
            s.type !== "recording" ||
            !e().getElementVisibility(t) ||
            n((i) => {
              (i.currentTextEditElementId = null),
                (i.currentDescriptionEditElementId = t),
                (i.selectedElementId = t),
                (i.selectedFrames = []),
                (i.selectedChildrenIds = []);
            });
        },
        exitDescriptionEditMode: () =>
          n((t) => {
            t.currentDescriptionEditElementId = null;
          }),
        isElementInDescriptionEditMode: (t) =>
          e().currentDescriptionEditElementId === t,
        setHoveredElementId: (t) =>
          n((s) => {
            s.hoveredElementId = t;
          }),
        openDeletionConfirmation: (t) =>
          n((s) => {
            s.deletionConfirmationState = {
              isOpen: !0,
              elementsToDelete: t,
              onConfirm: null,
            };
          }),
        closeDeletionConfirmation: () =>
          n((t) => {
            t.deletionConfirmationState = {
              isOpen: !1,
              elementsToDelete: [],
              onConfirm: null,
            };
          }),
        confirmDeletion: async () => {
          const t = e(),
            { elementsToDelete: s } = t.deletionConfirmationState;
          e().closeDeletionConfirmation(),
            s.length > 0 && (await e().deleteElementsDirectly(s));
        },
        deleteElementsWithConfirmation: async (t) => {
          if (!t.length) return;
          if (!e().hasEditingPermissions) {
            console.warn(
              "Attempted to delete elements without editing permissions - blocked"
            );
            return;
          }
          const r = [];
          for (const i of t)
            e().checkElementOwnership(i, "deletion") || r.push(i);
          if (r.length > 0) {
            console.warn(
              `[CanvasStore] Cannot delete ${r.length} elements not owned by current user:`,
              r
            );
            return;
          }
          e().openDeletionConfirmation(t);
        },
        deleteElements: async (t) => (
          await e().deleteElementsWithConfirmation(t), 0
        ),
        createTag: async (t) => {
          const s = e();
          if (!s.hasEditingPermissions || !s.flaskId)
            return (
              console.warn(
                `Attempted to create tag "${t}" without editing permissions - blocked`
              ),
              null
            );
          const r = Object.values(s.boardState.tags || {}).find(
            (h) => h.name.toLowerCase() === t.toLowerCase()
          );
          if (r) return r.id;
          const i = j1(),
            a = [
              "accent-purple",
              "accent-blue",
              "accent-teal",
              "accent-green",
              "accent-lime",
              "accent-orange",
              "accent-red",
            ],
            o = new Set(
              Object.values(s.boardState.tags || {}).map((h) => h.color)
            );
          let l = a.find((h) => !o.has(h));
          if (!l) {
            const m = Object.keys(s.boardState.tags || {}).length % a.length;
            l = a[m];
          }
          const c = { id: i, name: t.trim(), color: l };
          n((h) => {
            h.boardState.tags || (h.boardState.tags = {}),
              (h.boardState.tags[i] = c);
          });
          try {
            await $n
              .getState()
              .saveTag({
                id: i,
                flask_id: s.flaskId,
                name: t.trim(),
                color: l,
                created_by: s.currentUserId,
              });
          } catch (h) {
            throw (
              (n((m) => {
                m.boardState.tags && delete m.boardState.tags[i];
              }),
              h)
            );
          }
          return (
            typeof window < "u" &&
              Bt.isAvailable() &&
              Bt.capture("tag_created", {
                tagId: i,
                flaskId: s.flaskId,
                userId: s.currentUserId,
                name: t.trim(),
              }),
            i
          );
        },
        addTagToElement: async (t, s) => {
          const r = e();
          if (!r.hasEditingPermissions) {
            console.warn(
              `Attempted to add tag to element ${t} without editing permissions - blocked`
            );
            return;
          }
          const i = r.boardState.elements[t];
          if (i) {
            n((a) => {
              const o = a.boardState.elements[t];
              o &&
                (o.tagIds || (o.tagIds = []),
                o.tagIds.includes(s) ||
                  (o.tagIds.push(s),
                  (a.boardState.elements = { ...a.boardState.elements })));
            });
            try {
              const a = i.tagIds ? [...i.tagIds] : [];
              a.includes(s) || a.push(s),
                await $n.getState().updateElement(t, { tag_ids: a }),
                `${s}${t}`;
            } catch (a) {
              console.error("[CanvasStore] Failed to persist tag addition:", a),
                n((o) => {
                  const l = o.boardState.elements[t];
                  l &&
                    l.tagIds &&
                    ((l.tagIds = l.tagIds.filter((c) => c !== s)),
                    (o.boardState.elements = { ...o.boardState.elements }));
                });
            }
          }
        },
        removeTagFromElement: async (t, s) => {
          const r = e();
          if (!r.hasEditingPermissions) {
            console.warn(
              `Attempted to remove tag from element ${t} without editing permissions - blocked`
            );
            return;
          }
          const i = r.boardState.elements[t];
          if (!i || !i.tagIds) return;
          const a = [...i.tagIds];
          n((o) => {
            const l = o.boardState.elements[t];
            l &&
              l.tagIds &&
              ((l.tagIds = l.tagIds.filter((c) => c !== s)),
              (o.boardState.elements = { ...o.boardState.elements }));
          });
          try {
            const o = a.filter((l) => l !== s);
            await $n.getState().updateElement(t, { tag_ids: o }), `${s}${t}`;
          } catch (o) {
            console.error("[CanvasStore] Failed to persist tag removal:", o),
              n((l) => {
                const c = l.boardState.elements[t];
                c &&
                  ((c.tagIds = a),
                  (l.boardState.elements = { ...l.boardState.elements }));
              });
          }
        },
        getTagsByIds: (t) => {
          const r = e().boardState.tags || {};
          return t.map((i) => r[i]).filter(Boolean);
        },
        getAllTags: () => {
          const t = e();
          return Object.values(t.boardState.tags || {});
        },
        getElementTags: (t) => {
          const r = e().boardState.elements[t];
          return !r || !r.tagIds ? [] : e().getTagsByIds(r.tagIds);
        },
        deleteTag: async (t) => {
          const s = e();
          if (!s.hasEditingPermissions) {
            console.warn(
              `Attempted to delete tag ${t} without editing permissions - blocked`
            );
            return;
          }
          const r = s.boardState.tags?.[t];
          n((i) => {
            Object.values(i.boardState.elements).forEach((a) => {
              a.tagIds && (a.tagIds = a.tagIds.filter((o) => o !== t));
            }),
              i.boardState.tags &&
                i.boardState.tags[t] &&
                delete i.boardState.tags[t],
              (i.boardState.elements = { ...i.boardState.elements });
          });
          try {
            await $n.getState().deleteTag(t);
          } catch (i) {
            throw (
              (r &&
                n((a) => {
                  a.boardState.tags || (a.boardState.tags = {}),
                    (a.boardState.tags[t] = r);
                }),
              i)
            );
          }
        },
        renameTag: async (t, s) => {
          const r = e();
          if (!r.hasEditingPermissions) {
            console.warn(
              `Attempted to rename tag ${t} without editing permissions - blocked`
            );
            return;
          }
          const i = r.boardState.tags?.[t];
          if (!i) {
            console.warn(`Tag ${t} not found`);
            return;
          }
          n((a) => {
            a.boardState.tags &&
              a.boardState.tags[t] &&
              (a.boardState.tags[t] = {
                ...a.boardState.tags[t],
                name: s.trim(),
              });
          });
          try {
            await $n.getState().renameTag(t, s.trim());
          } catch (a) {
            throw (
              (n((o) => {
                o.boardState.tags && i && (o.boardState.tags[t] = i);
              }),
              a)
            );
          }
        },
        changeTagColor: async (t, s) => {
          const r = e();
          if (!r.hasEditingPermissions) {
            console.warn(
              `Attempted to change tag color ${t} without editing permissions - blocked`
            );
            return;
          }
          const i = r.boardState.tags?.[t];
          if (!i) {
            console.warn(`Tag ${t} not found`);
            return;
          }
          n((a) => {
            a.boardState.tags &&
              a.boardState.tags[t] &&
              (a.boardState.tags[t] = { ...a.boardState.tags[t], color: s });
          });
          try {
            await $n.getState().changeTagColor(t, s);
          } catch (a) {
            throw (
              (n((o) => {
                o.boardState.tags && i && (o.boardState.tags[t] = i);
              }),
              a)
            );
          }
        },
        computeAppTags: () => {},
        getElementAppTags: (t) => {
          const r = e().boardState.elements[t];
          if (!r || r.type === "asset") return [];
          const i = [];
          if (r.createdBy && r.creatorName) {
            const a = `apptag-creator-${t}`;
            i.push({
              id: a,
              type: "creator",
              elementId: t,
              creatorId: r.createdBy,
              creatorName: r.creatorName,
              creatorAvatarUrl: r.creatorAvatarUrl,
            });
          }
          if (r.createdAt) {
            const a = `apptag-creationtime-${t}`,
              o = new Date(r.createdAt);
            i.push({
              id: a,
              type: "creationTime",
              elementId: t,
              timestamp: Math.floor(o.getTime() / 1e3),
            });
          }
          return (
            r.links &&
              r.links.length > 0 &&
              r.links.forEach((a, o) => {
                if (a.type === "timeline") {
                  const l = `apptag-linktime-${t}-${o}`;
                  a.timestamp !== void 0
                    ? i.push({
                        id: l,
                        type: "linkTime",
                        elementId: t,
                        timestamp: a.timestamp,
                      })
                    : a.timeRange &&
                      i.push({
                        id: l,
                        type: "linkTime",
                        elementId: t,
                        timeRange: a.timeRange,
                      });
                }
              }),
            i
          );
        },
        getAppTagById: (t) => {
          const s = t.match(/^apptag-\w+-(.+?)(?:-\d+)?$/);
          if (!s) return;
          const r = s[1];
          return e()
            .getElementAppTags(r)
            .find((a) => a.id === t);
        },
        setTagVisibility: (t, s) =>
          n((r) => {
            r.tagVisibilityState[t] = s;
          }),
        getTagVisibility: (t) => e().tagVisibilityState[t] ?? !0,
        toggleTagVisibility: (t) => {
          const s = e().getTagVisibility(t);
          e().setTagVisibility(t, !s);
        },
        getElementsWithTag: (t) => {
          const s = e(),
            r = [];
          return (
            Object.entries(s.boardState.elements).forEach(([i, a]) => {
              a.tagIds && a.tagIds.includes(t) && r.push(i);
            }),
            r
          );
        },
        getElementVisibility: (t) => {
          const r = e().boardState.elements[t];
          return !r || r.type === "asset"
            ? !1
            : vn.getState().isElementVisible({ ...r, id: t });
        },
        getVisibleElements: () => {
          const t = e(),
            s = [];
          return (
            Object.entries(t.boardState.elements).forEach(([r, i]) => {
              i.type !== "asset" && e().getElementVisibility(r) && s.push(r);
            }),
            s
          );
        },
        hasElementAtTimestamp: (t, s = 0.05) => {
          const r = e();
          for (const i of Object.values(r.boardState.elements))
            if (!(!i || i.type === "asset") && i.links && i.links.length > 0) {
              for (const a of i.links)
                if (a.type === "timeline") {
                  if (
                    "timestamp" in a &&
                    a.timestamp !== void 0 &&
                    Math.abs(a.timestamp - t) <= s
                  )
                    return !0;
                  if ("timeRange" in a && a.timeRange) {
                    const { start: o, end: l } = a.timeRange;
                    if (t >= o - s && t <= l + s) return !0;
                  }
                }
            }
          return !1;
        },
        getLastElementAtTimestamp: (t, s = 0.05) => {
          const r = e(),
            i = [];
          for (const [a, o] of Object.entries(r.boardState.elements))
            if (!(!o || o.type === "asset") && o.links && o.links.length > 0) {
              for (const l of o.links)
                if (
                  l.type === "timeline" &&
                  "timestamp" in l &&
                  l.timestamp !== void 0 &&
                  Math.abs(l.timestamp - t) <= s
                ) {
                  i.push(a);
                  break;
                }
            }
          return i.length > 0 ? i[0] : null;
        },
        isCurrentUserElementOwner: (t) => {
          const s = e(),
            r = s.boardState.elements[t];
          return r ? r.createdBy === s.currentUserId : !1;
        },
        checkElementOwnership: (t, s) => {
          const r = e(),
            i = r.boardState.elements[t];
          if (!i)
            return (
              console.warn(
                `[CanvasStore] Element ${t} not found for ${s} ownership check`
              ),
              !1
            );
          if (!r.hasEditingPermissions)
            return (
              console.warn(
                `[CanvasStore] User does not have editing permissions for ${s} on element ${t}`
              ),
              !1
            );
          const a = i.createdBy === r.currentUserId;
          return (
            a ||
              console.warn(
                `[CanvasStore] User ${r.currentUserId} is not the owner of element ${t} (owned by ${i.createdBy}) - ${s} blocked`
              ),
            a
          );
        },
        setCreatorVisibility: (t, s) =>
          n((r) => {
            r.creatorVisibilityState[t] = s;
          }),
        getCreatorVisibility: (t) => e().creatorVisibilityState[t] ?? !0,
        toggleCreatorVisibility: (t) => {
          const s = e().getCreatorVisibility(t);
          e().setCreatorVisibility(t, !s);
        },
        getElementsWithCreator: (t) => {
          const s = e(),
            r = [];
          return (
            Object.entries(s.boardState.elements).forEach(([i, a]) => {
              a.createdBy === t && r.push(i);
            }),
            r
          );
        },
        getAllCreators: () => {
          const t = e(),
            s = new Map();
          return (
            Object.values(t.boardState.elements).forEach((r) => {
              if (r.createdBy && r.type !== "asset") {
                const i = r.createdBy;
                if (!s.has(i)) {
                  const a = t.userProfiles[i];
                  s.set(i, {
                    id: i,
                    name: a?.full_name || r.creatorName || i,
                    avatarUrl: a?.avatar_url || r.creatorAvatarUrl,
                  });
                }
              }
            }),
            Array.from(s.values())
          );
        },
        openFilterToolbar: () =>
          n((t) => {
            t.filterToolbarOpen = !0;
          }),
        closeFilterToolbar: () =>
          n((t) => {
            t.filterToolbarOpen = !1;
          }),
        setFilterToolbarOpen: (t) =>
          n((s) => {
            s.filterToolbarOpen = t;
          }),
        playRecording: (t) => {
          Lt(async () => {
            const { useMediaStore: s } = await Promise.resolve().then(() => Ra);
            return { useMediaStore: s };
          }, void 0)
            .then(({ useMediaStore: s }) => {
              const r = s.getState();
              r.isPlaying && r.pause();
            })
            .catch(console.error),
            n((s) => {
              s.currentPlayingRecordingId = t;
            });
        },
        pauseRecording: (t) => {
          e().currentPlayingRecordingId === t &&
            n((r) => {
              r.currentPlayingRecordingId = null;
            });
        },
        pauseAllRecordings: () => {
          n((t) => {
            t.currentPlayingRecordingId = null;
          });
        },
        isRecordingPlaying: (t) => e().currentPlayingRecordingId === t,
        markCanvasInteracted: () => {
          n((t) => {});
        },
        recordPlayheadInteraction: (t) => {
          n((s) => {
            s.lastPlayheadInteraction = {
              timestamp: Date.now(),
              playheadTime: t,
            };
          });
        },
        getLastPlayheadInteraction: () => e().lastPlayheadInteraction,
        clearPlayheadInteraction: () => {
          n((t) => {
            t.lastPlayheadInteraction = null;
          });
        },
        createElementViaKeyboard: async (t) => {
          const s = e();
          if (!s.hasEditingPermissions) {
            console.warn(`Cannot create ${t} element - no editing permissions`);
            return;
          }
          try {
            const { useRecordingStore: o } = await Lt(async () => {
                const { useRecordingStore: h } = await Promise.resolve().then(
                  () => $1
                );
                return { useRecordingStore: h };
              }, void 0),
              l = o.getState();
            if (l.globalState === "recording") {
              `${t}`;
              return;
            }
            if (
              Object.values(l.elements).some(
                (h) => h.state === "preparing" || h.state === "recording"
              )
            ) {
              `${t}`;
              return;
            }
          } catch (o) {
            console.warn("Could not check recording state:", o);
          }
          if (s.currentTextEditElementId || s.currentDescriptionEditElementId)
            return;
          const { useMediaStore: r } = await Lt(async () => {
              const { useMediaStore: o } = await Promise.resolve().then(
                () => Ra
              );
              return { useMediaStore: o };
            }, void 0),
            i = r.getState();
          i.isPlaying && i.pause();
          const a = i.currentTime;
          if (t === "text") {
            const { playheadToCanvasCoordinates: o } = await Lt(async () => {
                const { playheadToCanvasCoordinates: h } =
                  await Promise.resolve().then(() => r$);
                return { playheadToCanvasCoordinates: h };
              }, void 0),
              c = o(a, null, 1200, 320, 30);
            await e().createElement(
              "text",
              {
                position: c,
                content: "",
                title: "Text",
                links: [{ type: "timeline", timestamp: a }],
              },
              void 0,
              "keyboard_shortcuts"
            );
          } else
            await e().createAndStartRecording({
              recordingType: t,
              linkContext: "timeline",
              timestamp: a,
              createdVia: "keyboard_shortcuts",
            });
        },
        createPlaceholderElement: (t) => {
          const s = e(),
            i = Be.getState().currentTime,
            a = `placeholder-${j1()}`,
            l = Xx(i, null, 1200, 320, 30),
            c = {
              id: a,
              title: "Creating...",
              position: l,
              dimensions: { width: Ln, height: t === "text" ? 100 : 240 },
              type: t === "text" ? "text" : "recording",
              children: [],
              content: t === "text" ? "" : void 0,
              recordingType: t !== "text" ? t : void 0,
              createdBy: s.currentUserId,
              createdAt: new Date().toISOString(),
              creatorName: s.currentUserName,
              creatorAvatarUrl: s.currentUserAvatarUrl,
              links: [{ type: "timeline", timestamp: i }],
              isPlaceholder: !0,
            };
          return (
            n((h) => {
              (h.boardState.elements[a] = c),
                h.boardState.rootElements.push(a),
                (h.placeholderElement = { id: a, type: t, timestamp: i });
            }),
            a
          );
        },
        removePlaceholderElement: () => {
          const s = e().placeholderElement.id;
          s &&
            n((r) => {
              delete r.boardState.elements[s],
                (r.boardState.rootElements = r.boardState.rootElements.filter(
                  (i) => i !== s
                )),
                (r.placeholderElement = {
                  id: null,
                  type: null,
                  timestamp: null,
                });
            });
        },
        getPlaceholderElement: () => {
          const t = e(),
            s = t.placeholderElement.id;
          return (s && t.boardState.elements[s]) || null;
        },
        markElementAsAnimated: (t) => {
          n((s) => {
            s.newlyCreatedElements.delete(t);
          });
        },
        getTimelineElementsSorted: () => {
          const t = e(),
            s = [];
          return (
            Object.entries(t.boardState.elements).forEach(([r, i]) => {
              if (i.type === "asset" || !e().getElementVisibility(r)) return;
              const o = i.links?.find((l) => l.type === "timeline");
              if (o) {
                let l;
                if (o.timeRange) l = (o.timeRange.start + o.timeRange.end) / 2;
                else if (o.timestamp !== void 0) l = o.timestamp;
                else return;
                s.push({ elementId: r, timestamp: l });
              }
            }),
            s.sort((r, i) => r.timestamp - i.timestamp),
            s.map((r) => r.elementId),
            s
          );
        },
        cycleToNextElement: () => {
          const t = e(),
            s = e().getTimelineElementsSorted();
          if (s.length === 0) return;
          const r = t.selectedFrames[0];
          let i = -1;
          r && (i = s.findIndex((l) => l.elementId === r));
          const a = (i + 1) % s.length,
            o = s[a];
          o.elementId,
            s.length,
            Lt(async () => {
              const { centerElement: l } = await Promise.resolve().then(
                () => D4
              );
              return { centerElement: l };
            }, void 0).then(({ centerElement: l }) => {
              l(o.elementId);
            });
        },
        cycleToPreviousElement: () => {
          const t = e(),
            s = e().getTimelineElementsSorted();
          if (s.length === 0) return;
          const r = t.selectedFrames[0];
          let i = -1;
          r && (i = s.findIndex((l) => l.elementId === r));
          let a;
          i <= 0 ? (a = s.length - 1) : (a = i - 1);
          const o = s[a];
          o.elementId,
            s.length,
            Lt(async () => {
              const { centerElement: l } = await Promise.resolve().then(
                () => D4
              );
              return { centerElement: l };
            }, void 0).then(({ centerElement: l }) => {
              l(o.elementId);
            });
        },
        getClosestElementToViewportCenter: () => {
          const s = e().getTimelineElementsSorted();
          if (s.length === 0) return null;
          const r = pt.getState(),
            { visibleTimeStart: i, visibleTimeEnd: a } = r,
            o = (i + a) / 2;
          let l = s[0],
            c = Math.abs(l.timestamp - o);
          for (const h of s) {
            const m = Math.abs(h.timestamp - o);
            m < c && ((c = m), (l = h));
          }
          return l.elementId, l.timestamp, l.elementId;
        },
      }))
    )
  );
typeof window < "u" && (window.useCanvasStore = Ce);
const R7 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useCanvasStore: Ce },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  z0e = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4],
  G0e = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2],
  i$ = [0.25, 1, 2, 4],
  a$ = [0.25, 1, 2],
  Be = Di()(
    $a(
      ha((n, e) => ({
        mediaUrl: null,
        videoId: null,
        isPlaying: !1,
        duration: 0,
        currentTime: 0,
        playbackRate: 1,
        isMuted: !1,
        volume: 1,
        isReady: !1,
        isBuffering: !1,
        playerRef: null,
        smoothCurrentTimeAnimationFrame: null,
        lastRealTimeUpdate: 0,
        lastRealCurrentTime: 0,
        videoInfo: { width: 1280, height: 720 },
        isPinned: !1,
        pinnedPlayerHeight: "35vh",
        lastPlayedContext: null,
        isPreviewMode: !1,
        previewTimestamp: null,
        previewSource: null,
        isMouseOverPlaybar: !1,
        isMouseOverPlayhead: !1,
        hoverTimestamp: null,
        isCountingDown: !1,
        countdownProgress: 0,
        countdownStartTime: null,
        previewCountdownTimer: null,
        countdownProgressTimer: null,
        wasPlayingBeforePreview: !1,
        originalPlaybackPosition: null,
        isRestoringFromPreview: !1,
        isRecording: !1,
        recordingType: null,
        recordingTime: 0,
        recordingProgress: 0,
        recordedChunks: [],
        activeRecordingId: null,
        isMainAssetFullscreen: !1,
        activeRecordingUrl: null,
        isRecordingPlaying: !1,
        isRecordingLoading: !1,
        recordingCurrentTime: 0,
        recordingDuration: 0,
        recordingPlaybackRate: 1,
        lastRecordingPlaybackRate: 1,
        isRecordingFullscreen: !1,
        recordingSyncTime: 0,
        isRecordingPlayerHovered: !1,
        setMediaUrl: (t) =>
          n((s) => {
            (s.mediaUrl = t), (s.videoId = t && t !== "native" ? Sf(t) : null);
          }),
        setIsPlaying: (t) =>
          n((s) => {
            s.isPlaying = t;
          }),
        setDuration: (t) =>
          n((s) => {
            s.duration = t;
          }),
        setCurrentTime: (t) => {
          const s = e();
          if (
            (n((r) => {
              (r.currentTime = t),
                (r.lastRealCurrentTime = t),
                (r.lastRealTimeUpdate = performance.now());
            }),
            s.isPlaying && s.smoothCurrentTimeAnimationFrame === null)
          ) {
            const r = () => {
                const a = e();
                if (!a.isPlaying || a.isBuffering) {
                  n((m) => {
                    m.smoothCurrentTimeAnimationFrame = null;
                  });
                  return;
                }
                const l = (performance.now() - a.lastRealTimeUpdate) / 1e3,
                  c = a.lastRealCurrentTime + l * a.playbackRate,
                  h = Math.min(c, a.duration);
                if (
                  (n((m) => {
                    m.currentTime = h;
                  }),
                  a.isPlaying && h < a.duration)
                ) {
                  const m = requestAnimationFrame(r);
                  n((p) => {
                    p.smoothCurrentTimeAnimationFrame = m;
                  });
                } else
                  n((m) => {
                    m.smoothCurrentTimeAnimationFrame = null;
                  });
              },
              i = requestAnimationFrame(r);
            n((a) => {
              a.smoothCurrentTimeAnimationFrame = i;
            });
          }
        },
        setPlaybackRate: (t) =>
          n((s) => {
            s.playbackRate = t;
          }),
        setIsMuted: (t) =>
          n((s) => {
            s.isMuted = t;
          }),
        setVolume: (t) =>
          n((s) => {
            s.volume = t;
          }),
        setIsReady: (t) =>
          n((s) => {
            s.isReady = t;
          }),
        setIsBuffering: (t) =>
          n((s) => {
            s.isBuffering = t;
          }),
        setPlayerRef: (t) =>
          n((s) => {
            s.playerRef = t;
          }),
        setVideoInfo: (t) =>
          n((s) => {
            s.videoInfo = t;
          }),
        setIsPinned: (t) =>
          n((s) => {
            s.isPinned = t;
          }),
        setPinnedPlayerHeight: (t) =>
          n((s) => {
            s.pinnedPlayerHeight = t;
          }),
        setPreviewMode: (t, s) =>
          n((r) => {
            t &&
              !r.isPreviewMode &&
              ((r.wasPlayingBeforePreview = r.isPlaying),
              (r.originalPlaybackPosition = r.currentTime)),
              (r.isPreviewMode = t),
              (r.previewTimestamp = s || null),
              t || (r.previewSource = null);
          }),
        setPreviewTimestamp: (t) =>
          n((s) => {
            s.previewTimestamp = t;
          }),
        setPreviewSource: (t) =>
          n((s) => {
            s.previewSource = t;
          }),
        requestPreview: (t, s) => {
          const { isPreviewMode: r } = e();
          n((i) => {
            (i.previewTimestamp = t),
              (i.previewSource = s),
              r ||
                ((i.wasPlayingBeforePreview = i.isPlaying),
                (i.originalPlaybackPosition = i.currentTime));
          });
        },
        exitPreview: () =>
          n((t) => {
            (t.previewTimestamp = null), (t.previewSource = null);
          }),
        exitPreviewWithoutRestoration: () =>
          n((t) => {
            (t.previewTimestamp = null),
              (t.previewSource = null),
              (t.isPreviewMode = !1),
              (t.wasPlayingBeforePreview = !1),
              (t.originalPlaybackPosition = null),
              (t.isRestoringFromPreview = !1);
          }),
        exitPreviewWithRestoration: () => {
          const {
            playerRef: t,
            isReady: s,
            originalPlaybackPosition: r,
            wasPlayingBeforePreview: i,
          } = e();
          if (
            (n((a) => {
              a.isRestoringFromPreview = !0;
            }),
            t && s && r !== null)
          )
            try {
              typeof t.currentTime == "function" && t.currentTime(r);
            } catch (a) {
              console.error("Error restoring position during preview exit:", a);
            }
          n((a) => {
            (a.previewTimestamp = null),
              (a.previewSource = null),
              (a.isPreviewMode = !1);
          }),
            setTimeout(() => {
              if (
                (n((a) => {
                  a.isRestoringFromPreview = !1;
                }),
                i)
              )
                try {
                  e().play();
                } catch (a) {
                  console.error("Error resuming playback after preview:", a);
                }
              n((a) => {
                (a.wasPlayingBeforePreview = !1),
                  (a.originalPlaybackPosition = null);
              });
            }, 100);
        },
        play: () => {
          const {
            playerRef: t,
            isReady: s,
            activeRecordingId: r,
            isRecordingPlaying: i,
          } = e();
          if (!t || !s) {
            console.warn("Cannot play: Player not ready or initialized");
            return;
          }
          r &&
            i &&
            n((a) => {
              a.isRecordingPlaying = !1;
            }),
            Lt(async () => {
              const { useCanvasStore: a } = await Promise.resolve().then(
                () => R7
              );
              return { useCanvasStore: a };
            }, void 0)
              .then(({ useCanvasStore: a }) => {
                a.getState().pauseAllRecordings();
              })
              .catch(console.error),
            n((a) => {
              (a.isPlaying = !0), (a.lastPlayedContext = "main");
            }),
            Lt(async () => {
              const { useTimelineStore: a } = await Promise.resolve().then(
                () => Zp
              );
              return { useTimelineStore: a };
            }, void 0)
              .then(({ useTimelineStore: a }) => {
                const o = e().currentTime;
                a.getState().checkAndCenterPlayhead(o);
              })
              .catch(console.error);
          try {
            typeof t.play == "function"
              ? t.play()
              : console.warn("Player doesn't have a play method");
          } catch (a) {
            console.error("Error playing video:", a),
              n((o) => {
                o.isPlaying = !1;
              });
          }
        },
        pause: () => {
          const {
            playerRef: t,
            isReady: s,
            smoothCurrentTimeAnimationFrame: r,
          } = e();
          if (!t || !s) {
            console.warn("Cannot pause: Player not ready or initialized");
            return;
          }
          r !== null && cancelAnimationFrame(r),
            n((i) => {
              (i.isPlaying = !1), (i.smoothCurrentTimeAnimationFrame = null);
            }),
            Lt(async () => {
              const { useTimelineStore: i } = await Promise.resolve().then(
                () => Zp
              );
              return { useTimelineStore: i };
            }, void 0)
              .then(({ useTimelineStore: i }) => {
                i.getState().disableAutoFollow();
              })
              .catch(console.error);
          try {
            typeof t.pause == "function"
              ? t.pause()
              : console.warn("Player doesn't have a pause method");
          } catch (i) {
            console.error("Error pausing video:", i),
              n((a) => {
                a.isPlaying = !0;
              });
          }
        },
        togglePlayPause: () => {
          const { isPlaying: t } = e();
          t ? e().pause() : e().play();
        },
        togglePlayPauseContextAware: () => {
          const {
            activeRecordingId: t,
            isRecordingPlaying: s,
            isPlaying: r,
            lastPlayedContext: i,
            isReady: a,
            isRecordingFullscreen: o,
          } = e();
          t && (o || i === "recording" || i === null || !a)
            ? e().toggleRecordingPlayback()
            : e().togglePlayPause();
        },
        setLastPlayedContext: (t) => {
          n((s) => {
            s.lastPlayedContext = t;
          });
        },
        seek: (t) => {
          const { playerRef: s, isReady: r, duration: i } = e();
          if (!s || !r) {
            console.warn("Cannot seek: Player not ready or initialized");
            return;
          }
          if (typeof s.currentTime != "function") {
            console.warn("Player doesn't have a currentTime method");
            return;
          }
          const a = Math.max(0, Math.min(t, i));
          try {
            s.currentTime(a), e().setCurrentTime(a);
          } catch (o) {
            console.error("Error seeking video:", o);
          }
        },
        cyclePlaybackRate: () => {
          const { playbackRate: t, playerRef: s, videoId: r } = e(),
            i = r ? G0e : z0e,
            o = (i.indexOf(t) + 1) % i.length,
            l = i[o];
          if (
            (n((c) => {
              c.playbackRate = l;
            }),
            s && typeof s.playbackRate == "function")
          )
            try {
              s.playbackRate(l);
            } catch (c) {
              console.error("Error setting playback rate:", c);
            }
        },
        increasePlaybackRate: () => {
          const { playbackRate: t, playerRef: s, videoId: r } = e(),
            i = r ? a$ : i$,
            a = i.indexOf(t);
          if (a === i.length - 1 || (a === -1 && t >= i[i.length - 1])) return;
          const o =
            a === -1 ? i.find((l) => l > t) || i[i.length - 1] : i[a + 1];
          if (
            (n((l) => {
              l.playbackRate = o;
            }),
            s && typeof s.playbackRate == "function")
          )
            try {
              s.playbackRate(o);
            } catch (l) {
              console.error("Error setting playback rate:", l);
            }
        },
        decreasePlaybackRate: () => {
          const { playbackRate: t, playerRef: s, videoId: r } = e(),
            i = r ? a$ : i$,
            a = i.indexOf(t);
          if (a === 0 || (a === -1 && t <= i[0])) return;
          const o =
            a === -1 ? [...i].reverse().find((l) => l < t) || i[0] : i[a - 1];
          if (
            (n((l) => {
              l.playbackRate = o;
            }),
            s && typeof s.playbackRate == "function")
          )
            try {
              s.playbackRate(o);
            } catch (l) {
              console.error("Error setting playback rate:", l);
            }
        },
        toggleMute: () => {
          const { isMuted: t, playerRef: s } = e(),
            r = !t;
          if (
            (n((i) => {
              i.isMuted = r;
            }),
            s && typeof s.muted == "function")
          )
            try {
              s.muted(r);
            } catch (i) {
              console.error("Error setting mute state:", i);
            }
        },
        seekByFrames: (t) => {
          const { playerRef: s, isReady: r, duration: i, isPlaying: a } = e();
          if (!s || !r) {
            console.warn(
              "Cannot seek by frames: Player not ready or initialized"
            );
            return;
          }
          if (typeof s.currentTime != "function") {
            console.warn(
              "Player doesn't have a currentTime method for frame seeking"
            );
            return;
          }
          a && e().pause();
          const o = e().currentTime,
            l = 1 / 30,
            c = Math.max(0, Math.min(o + t * l, i));
          try {
            s.currentTime(c), e().setCurrentTime(c), `${t}${c.toFixed(3)}`;
          } catch (h) {
            console.error("Error seeking by frames:", h);
          }
        },
        seekForwardOneFrame: () => {
          e().seekByFrames(1);
        },
        seekBackwardOneFrame: () => {
          e().seekByFrames(-1);
        },
        seekForwardTenFrames: () => {
          e().seekByFrames(10);
        },
        seekBackwardTenFrames: () => {
          e().seekByFrames(-10);
        },
        initializePlayer: (t) => {
          n((s) => {
            (s.mediaUrl = t),
              (s.videoId = t && t !== "native" ? Sf(t) : null),
              (s.isReady = !1),
              (s.isPlaying = !1),
              (s.duration = 0),
              (s.currentTime = 0);
          });
        },
        handlePlayerReady: (t) => {
          n((s) => {
            (s.playerRef = t), (s.isReady = !0);
          });
        },
        handleTimeUpdate: (t) => {
          const { isPreviewMode: s, isRestoringFromPreview: r } = e();
          !s &&
            !r &&
            n((i) => {
              (i.currentTime = t),
                (i.lastRealCurrentTime = t),
                (i.lastRealTimeUpdate = performance.now());
            });
        },
        handleDurationChange: (t) => {
          n((s) => {
            s.duration = t;
          });
        },
        handlePlay: () => {
          const { isPlaying: t } = e();
          t ||
            n((s) => {
              s.isPlaying = !0;
            });
        },
        handlePause: () => {
          const { isPlaying: t } = e();
          t &&
            n((s) => {
              s.isPlaying = !1;
            });
        },
        handleWaiting: () => {
          n((t) => {
            t.isBuffering = !0;
          });
        },
        handleSeeking: () => {
          n((t) => {
            t.isBuffering = !0;
          });
        },
        handleSeeked: () => {},
        handleCanPlay: () => {
          const { isBuffering: t } = e();
          if (t) {
            n((r) => {
              r.isBuffering = !1;
            });
            const s = e();
            s.isPlaying &&
              s.smoothCurrentTimeAnimationFrame === null &&
              s.setCurrentTime(s.currentTime);
          }
        },
        startRecording: async (t) => {
          n((s) => {
            (s.isRecording = !0),
              (s.recordingType = t),
              (s.recordingTime = 0),
              (s.recordingProgress = 0),
              (s.recordedChunks = []);
          });
        },
        stopRecording: async () => {
          const { recordedChunks: t } = e();
          if (
            (n((s) => {
              (s.isRecording = !1),
                (s.recordingType = null),
                (s.recordingTime = 0),
                (s.recordingProgress = 0);
            }),
            t.length > 0)
          ) {
            const s = new Blob(t, { type: "video/webm" });
            return e().clearRecordingChunks(), s;
          }
          return null;
        },
        pauseRecording: () => {},
        resumeRecording: () => {},
        setRecordingTime: (t) =>
          n((s) => {
            s.recordingTime = t;
          }),
        setRecordingProgress: (t) =>
          n((s) => {
            s.recordingProgress = t;
          }),
        addRecordingChunk: (t) =>
          n((s) => {
            s.recordedChunks.push(t);
          }),
        clearRecordingChunks: () =>
          n((t) => {
            t.recordedChunks = [];
          }),
        setActiveRecording: (t, s) => {
          const r = e();
          r.isPlaying && r.pause();
          const i = Ce.getState(),
            o = hn.getState().user?.id,
            c = i.boardState.elements[t]?.createdBy === o;
          Tb("played", {
            recording_id: t,
            flask_id: i.flaskId,
            viewer_id: o,
            is_owner: c,
            playback_source: "canvas",
          }),
            n((h) => {
              (h.activeRecordingId = t),
                (h.activeRecordingUrl = s),
                (h.isRecordingPlaying = !1),
                (h.recordingCurrentTime = 0),
                (h.recordingDuration = 0),
                (h.recordingPlaybackRate = h.lastRecordingPlaybackRate);
            });
        },
        clearActiveRecording: () =>
          n((t) => {
            (t.activeRecordingId = null),
              (t.activeRecordingUrl = null),
              (t.isRecordingPlaying = !1),
              (t.recordingCurrentTime = 0),
              (t.recordingDuration = 0),
              (t.isRecordingFullscreen = !1),
              (t.lastPlayedContext = "main"),
              (t.isRecordingPlayerHovered = !1);
          }),
        setIsRecordingPlaying: (t) => {
          const s = e();
          t && s.isPlaying && s.pause(),
            n((r) => {
              (r.isRecordingPlaying = t),
                t && (r.lastPlayedContext = "recording");
            });
        },
        setRecordingLoading: (t) => {
          n((s) => {
            s.isRecordingLoading = t;
          });
        },
        toggleRecordingPlayback: () => {
          const t = e();
          !t.isRecordingPlaying && t.isPlaying && t.pause(),
            n((s) => {
              s.isRecordingPlaying = !t.isRecordingPlaying;
            });
        },
        setRecordingPlaybackRate: (t) =>
          n((s) => {
            (s.recordingPlaybackRate = t), (s.lastRecordingPlaybackRate = t);
          }),
        setRecordingFullscreen: (t) => {
          const s = e();
          t && s.isPlaying && s.pause(),
            n((r) => {
              (r.isRecordingFullscreen = t),
                (r.recordingSyncTime = r.recordingCurrentTime);
            });
        },
        toggleRecordingFullscreen: () => {
          const t = e();
          t.setRecordingFullscreen(!t.isRecordingFullscreen);
        },
        setRecordingCurrentTime: (t) =>
          n((s) => {
            s.recordingCurrentTime = t;
          }),
        setRecordingPlayerHovered: (t) =>
          n((s) => {
            s.isRecordingPlayerHovered = t;
          }),
        setMainAssetFullscreen: (t) => {
          n((s) => {
            s.isMainAssetFullscreen = t;
          });
        },
        toggleMainAssetFullscreen: () => {
          const t = e();
          t.setMainAssetFullscreen(!t.isMainAssetFullscreen);
        },
        reset: () =>
          n((t) => {
            (t.mediaUrl = null),
              (t.videoId = null),
              (t.isPlaying = !1),
              (t.duration = 0),
              (t.currentTime = 0),
              (t.playbackRate = 1),
              (t.isMuted = !1),
              (t.volume = 1),
              (t.isReady = !1),
              (t.playerRef = null),
              (t.videoInfo = { width: 1280, height: 720 }),
              (t.isPinned = !1),
              (t.pinnedPlayerHeight = "35vh"),
              (t.lastPlayedContext = null),
              (t.isPreviewMode = !1),
              (t.previewTimestamp = null),
              (t.previewSource = null),
              (t.isMouseOverPlaybar = !1),
              (t.isMouseOverPlayhead = !1),
              (t.hoverTimestamp = null),
              (t.isCountingDown = !1),
              (t.countdownProgress = 0),
              (t.countdownStartTime = null),
              t.previewCountdownTimer &&
                (clearTimeout(t.previewCountdownTimer),
                (t.previewCountdownTimer = null)),
              t.countdownProgressTimer &&
                (clearInterval(t.countdownProgressTimer),
                (t.countdownProgressTimer = null)),
              (t.wasPlayingBeforePreview = !1),
              (t.originalPlaybackPosition = null),
              (t.isRestoringFromPreview = !1),
              (t.isRecording = !1),
              (t.recordingType = null),
              (t.recordingTime = 0),
              (t.recordingProgress = 0),
              (t.recordedChunks = []),
              (t.activeRecordingId = null),
              (t.activeRecordingUrl = null),
              (t.isRecordingPlaying = !1),
              (t.recordingCurrentTime = 0),
              (t.recordingDuration = 0),
              (t.recordingPlaybackRate = 1),
              (t.lastRecordingPlaybackRate = 1),
              (t.isRecordingFullscreen = !1),
              (t.recordingSyncTime = 0),
              (t.isRecordingPlayerHovered = !1);
          }),
        resetPlayer: () =>
          n((t) => {
            (t.isPlaying = !1),
              (t.duration = 0),
              (t.currentTime = 0),
              (t.isReady = !1),
              (t.playerRef = null);
          }),
        resetRecording: () =>
          n((t) => {
            (t.isRecording = !1),
              (t.recordingType = null),
              (t.recordingTime = 0),
              (t.recordingProgress = 0),
              (t.recordedChunks = []);
          }),
        seekPreviewOnly: (t) => {
          const { playerRef: s, duration: r, mediaUrl: i } = e();
          if (!s) {
            console.warn("Cannot seek preview: No player reference", {
              mediaUrl: i,
            });
            return;
          }
          if (typeof s.currentTime != "function") {
            console.warn(
              "Player doesn't have a currentTime method for preview",
              { playerRef: s, mediaUrl: i }
            );
            return;
          }
          const a = Math.max(0, Math.min(t, r || 0));
          try {
            s.currentTime(a);
          } catch (o) {
            console.error("Error seeking for preview:", o, {
              mediaUrl: i,
              safeTime: a,
              duration: r,
            });
          }
        },
        pauseForPreview: () => {
          const { playerRef: t, wasPlayingBeforePreview: s, mediaUrl: r } = e();
          if (!t) {
            console.warn("Cannot pause for preview: No player reference", {
              mediaUrl: r,
            });
            return;
          }
          try {
            typeof t.pause == "function" && s
              ? (t.pause(),
                n((i) => {
                  i.isPlaying = !1;
                }))
              : t.pause;
          } catch (i) {
            console.error("Error pausing for preview:", i, { mediaUrl: r });
          }
        },
        restorePlaybackAfterPreview: () => {
          const {
            playerRef: t,
            isReady: s,
            originalPlaybackPosition: r,
            wasPlayingBeforePreview: i,
          } = e();
          if (!t || !s) {
            console.warn("Cannot restore playback: Player not ready");
            return;
          }
          n((a) => {
            a.isRestoringFromPreview = !0;
          });
          try {
            r !== null &&
              typeof t.currentTime == "function" &&
              t.currentTime(r),
              i && typeof t.play == "function" && t.play();
          } catch (a) {
            console.error("Error restoring playback after preview:", a);
          }
          setTimeout(() => {
            n((a) => {
              (a.wasPlayingBeforePreview = !1),
                (a.originalPlaybackPosition = null),
                (a.isRestoringFromPreview = !1);
            });
          }, 100);
        },
        setupDefensiveCleanup: () => {
          const t = () => {
              e().clearAllHoverStates();
            },
            s = (i) => {
              i.relatedTarget || e().clearAllHoverStates();
            },
            r = () => {
              document.hidden && e().clearAllHoverStates();
            };
          return (
            window.addEventListener("blur", t),
            document.addEventListener("mouseleave", s),
            document.addEventListener("visibilitychange", r),
            () => {
              window.removeEventListener("blur", t),
                document.removeEventListener("mouseleave", s),
                document.removeEventListener("visibilitychange", r);
            }
          );
        },
        setPlaybarHover: (t, s) => {
          e(),
            n((i) => {
              (i.isMouseOverPlaybar = t),
                t && s !== void 0
                  ? (i.hoverTimestamp = s)
                  : t || (i.hoverTimestamp = null);
            });
          const r = e();
          t && !r.isMouseOverPlayhead && s !== void 0
            ? r.isPreviewMode && r.previewSource === "hover"
              ? e().requestPreview(s, "hover")
              : e().startPreviewCountdown(s)
            : (e().stopPreviewCountdown(), t || e().exitPreview());
        },
        setPlayheadHover: (t) => {
          if (
            (n((s) => {
              s.isMouseOverPlayhead = t;
            }),
            t)
          )
            e().stopPreviewCountdown(), e().exitPreview();
          else {
            const { isMouseOverPlaybar: s, hoverTimestamp: r } = e();
            s && r !== null && e().startPreviewCountdown(r);
          }
        },
        clearAllHoverStates: () => {
          n((t) => {
            (t.isMouseOverPlaybar = !1),
              (t.isMouseOverPlayhead = !1),
              (t.hoverTimestamp = null);
          }),
            e().stopPreviewCountdown(),
            e().exitPreview();
        },
        startPreviewCountdown: (t) => {
          const {
            playerRef: s,
            isReady: r,
            duration: i,
            isPreviewMode: a,
            previewSource: o,
            isMouseOverPlayhead: l,
            currentTime: c,
          } = e();
          if (!s || i <= 0 || (a && o !== "hover") || l) return;
          e().stopPreviewCountdown();
          const h = Date.now();
          n((p) => {
            (p.isCountingDown = !0),
              (p.countdownProgress = 0),
              (p.countdownStartTime = h);
          });
          const m = setInterval(() => {
            const {
              countdownStartTime: p,
              isMouseOverPlaybar: g,
              isMouseOverPlayhead: y,
              currentTime: b,
            } = e();
            if (!g || y || !p) {
              e().stopPreviewCountdown();
              return;
            }
            const w = Date.now() - p,
              S = Math.min(w / 100, 1);
            n((A) => {
              A.countdownProgress = S;
            }),
              S >= 1 && (clearInterval(m), e().triggerPreview(t));
          }, 50);
          n((p) => {
            p.countdownProgressTimer = m;
          });
        },
        stopPreviewCountdown: () => {
          const { previewCountdownTimer: t, countdownProgressTimer: s } = e();
          t && clearTimeout(t),
            s && clearInterval(s),
            n((r) => {
              (r.isCountingDown = !1),
                (r.countdownProgress = 0),
                (r.countdownStartTime = null),
                (r.previewCountdownTimer = null),
                (r.countdownProgressTimer = null);
            });
        },
        triggerPreview: (t) => {
          e().stopPreviewCountdown(), e().requestPreview(t, "hover");
        },
      }))
    )
  ),
  k7 = () => {
    const {
      isPlaying: n,
      currentTime: e,
      duration: t,
      playbackRate: s,
      isMuted: r,
      volume: i,
      isPinned: a,
      play: o,
      pause: l,
      togglePlayPause: c,
      seek: h,
      cyclePlaybackRate: m,
      toggleMute: p,
      setVolume: g,
      setIsPinned: y,
      seekByFrames: b,
      seekForwardOneFrame: w,
      seekBackwardOneFrame: S,
      seekForwardTenFrames: A,
      seekBackwardTenFrames: _,
    } = Be();
    return {
      isPlaying: n,
      currentTime: e,
      duration: t,
      playbackRate: s,
      isMuted: r,
      volume: i,
      isPinned: a,
      play: o,
      pause: l,
      togglePlayPause: c,
      seek: h,
      cyclePlaybackRate: m,
      toggleMute: p,
      setVolume: g,
      togglePin: () => y(!a),
      seekByFrames: b,
      seekForwardOneFrame: w,
      seekBackwardOneFrame: S,
      seekForwardTenFrames: A,
      seekBackwardTenFrames: _,
    };
  },
  Ra = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useMediaStore: Be, useVideoControls: k7 },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  vt = Di()(
    $a(
      ha((n, e) => ({
        state: "idle",
        isToolbarHovered: !1,
        isPlayheadHovered: !1,
        textContent: "",
        editingElementId: null,
        recordingType: null,
        recordingStartTime: null,
        recordingDuration: "00:00",
        previewStream: null,
        placeholderElementId: null,
        pendingTimelineLink: null,
        hasManuallyPositionedLink: !1,
        isDraggingLink: !1,
        isPlayheadDragCreatingRange: !1,
        selectedTags: [],
        linkingMode: "timeline",
        targetElementId: null,
        pendingDiscardCallback: null,
        pendingRecordingCancelCallback: null,
        pendingLoginText: null,
        replyToolbar: {
          state: "idle",
          textContent: "",
          threadId: null,
          recordingType: null,
          recordingStartTime: null,
          recordingDuration: "00:00",
          previewStream: null,
          placeholderElementId: null,
          selectedTags: [],
          pendingDiscardCallback: null,
        },
        savePendingLoginText: () => {
          const t = e();
          if (t.textContent.trim()) {
            n((r) => {
              r.pendingLoginText = r.textContent;
            }),
              localStorage.setItem("flask_pending_login_text", t.textContent);
            const s = {
              linkingMode: t.linkingMode,
              targetElementId: t.targetElementId,
              pendingTimelineLink: t.pendingTimelineLink,
              hasManuallyPositionedLink: t.hasManuallyPositionedLink,
            };
            localStorage.setItem(
              "flask_pending_login_linking_state",
              JSON.stringify(s)
            );
          }
        },
        restorePendingLoginText: () => {
          const t = localStorage.getItem("flask_pending_login_text"),
            s = localStorage.getItem("flask_pending_login_linking_state");
          t
            ? (n((r) => {
                if (
                  ((r.textContent = t),
                  (r.pendingLoginText = null),
                  (r.state = "focused"),
                  s)
                )
                  try {
                    const i = JSON.parse(s);
                    (r.linkingMode = i.linkingMode),
                      (r.targetElementId = i.targetElementId),
                      (r.pendingTimelineLink = i.pendingTimelineLink),
                      (r.hasManuallyPositionedLink =
                        i.hasManuallyPositionedLink);
                  } catch (i) {
                    console.error(
                      "[ToolbarStore] Failed to parse saved linking state:",
                      i
                    );
                  }
              }),
              localStorage.removeItem("flask_pending_login_text"),
              localStorage.removeItem("flask_pending_login_linking_state"))
            : e().pendingLoginText &&
              n((i) => {
                (i.textContent = i.pendingLoginText || ""),
                  (i.pendingLoginText = null),
                  (i.state = "focused");
              });
        },
        clearPendingLoginText: () => {
          n((t) => {
            t.pendingLoginText = null;
          }),
            localStorage.removeItem("flask_pending_login_text"),
            localStorage.removeItem("flask_pending_login_linking_state");
        },
        setState: (t) => {
          n((s) => {
            (s.pendingDiscardCallback && s.state !== t) ||
              ((s.state = t),
              t !== "preparing" &&
                t !== "recording" &&
                ((s.recordingType = null),
                (s.recordingStartTime = null),
                (s.recordingDuration = "00:00")));
          });
        },
        setTextContent: (t) => {
          n((s) => {
            (s.textContent = t),
              t &&
                s.state === "idle" &&
                ((s.state = "focused"),
                Lt(async () => {
                  const { useMediaStore: r } = await Promise.resolve().then(
                    () => Ra
                  );
                  return { useMediaStore: r };
                }, void 0).then(({ useMediaStore: r }) => {
                  r.getState().pause();
                }));
          });
        },
        enterFocusedState: () => {
          Lt(async () => {
            const { useMediaStore: t } = await Promise.resolve().then(() => Ra);
            return { useMediaStore: t };
          }, void 0).then(({ useMediaStore: t }) => {
            t.getState().pause();
          }),
            n((t) => {
              t.state = "focused";
            });
        },
        exitToIdle: () => {
          if (e().state === "recording") {
            n((s) => {
              s.pendingRecordingCancelCallback = () => {
                const r = new CustomEvent("toolbarV2CancelRecording");
                window.dispatchEvent(r);
              };
            });
            return;
          }
          n((s) => {
            (s.state = "idle"),
              (s.textContent = ""),
              (s.selectedTags = []),
              (s.editingElementId = null),
              s.linkingMode === "element" &&
                ((s.linkingMode = "timeline"), (s.targetElementId = null)),
              (s.isToolbarHovered = !1),
              (s.hasManuallyPositionedLink = !1),
              (s.isDraggingLink = !1),
              (s.pendingTimelineLink = null);
          });
        },
        clearText: (t = !1) => {
          n((s) => {
            s.pendingDiscardCallback ||
              (s.linkingMode,
              s.targetElementId,
              (s.textContent = ""),
              (s.selectedTags = []),
              s.state === "focused" &&
                !s.editingElementId &&
                ((s.state = "idle"),
                !t &&
                  s.linkingMode === "element" &&
                  ((s.linkingMode = "timeline"), (s.targetElementId = null))));
          });
        },
        startRecording: (t) => {
          const s = e();
          s.linkingMode, s.targetElementId;
          const r = Be.getState();
          r.isPlaying && r.pause(),
            r.isRecordingPlaying && r.setIsRecordingPlaying(!1),
            n((i) => {
              (i.state = "preparing"),
                (i.recordingType = t),
                (i.recordingStartTime = null),
                (i.recordingDuration = "00:00"),
                i.linkingMode,
                i.targetElementId;
            });
        },
        setRecordingDuration: (t) => {
          n((s) => {
            s.recordingDuration = t;
          });
        },
        setPreviewStream: (t) => {
          n((s) => {
            s.previewStream &&
              s.previewStream !== t &&
              s.previewStream.getTracks().forEach((r) => r.stop()),
              (s.previewStream = t);
          });
        },
        stopRecording: () => {
          const t = e();
          t.linkingMode,
            t.targetElementId,
            t.previewStream &&
              t.previewStream.getTracks().forEach((s) => s.stop()),
            n((s) => {
              (s.state = "idle"),
                (s.recordingType = null),
                (s.recordingStartTime = null),
                (s.recordingDuration = "00:00"),
                (s.previewStream = null),
                (s.selectedTags = []),
                s.linkingMode,
                s.targetElementId,
                (s.isToolbarHovered = !1),
                (s.hasManuallyPositionedLink = !1),
                (s.isDraggingLink = !1),
                (s.pendingTimelineLink = null);
            });
        },
        loadElementForEditing: (t, s) => {
          n((r) => {
            (r.state = "focused"),
              (r.editingElementId = t),
              (r.textContent = s);
          });
        },
        clearEditMode: () => {
          n((t) => {
            (t.editingElementId = null),
              (t.textContent = ""),
              (t.state = "idle");
          });
        },
        setPlaceholderElementId: (t) => {
          n((s) => {
            s.placeholderElementId = t;
          });
        },
        setPendingTimelineLink: (t) => {
          n((s) => {
            s.pendingTimelineLink = t;
          });
        },
        setHasManuallyPositionedLink: (t) => {
          n((s) => {
            s.hasManuallyPositionedLink = t;
          });
        },
        setIsDraggingLink: (t) => {
          n((s) => {
            s.isDraggingLink = t;
          });
        },
        setIsPlayheadDragCreatingRange: (t) => {
          n((s) => {
            s.isPlayheadDragCreatingRange = t;
          });
        },
        startPlayheadDragRange: (t) => {
          Lt(async () => {
            const { useMediaStore: s } = await Promise.resolve().then(() => Ra);
            return { useMediaStore: s };
          }, void 0).then(({ useMediaStore: s }) => {
            s.getState().pause();
          }),
            n((s) => {
              (s.state = "focused"),
                (s.isPlayheadDragCreatingRange = !0),
                (s.hasManuallyPositionedLink = !0),
                (s.isDraggingLink = !0),
                (s.pendingTimelineLink = { start: t, end: t });
            });
        },
        setSelectedTags: (t) => {
          n((s) => {
            s.selectedTags = t;
          });
        },
        clearSelectedTags: () => {
          n((t) => {
            t.selectedTags = [];
          });
        },
        startElementLinking: (t) => {
          n((s) => {
            (s.linkingMode = "element"),
              (s.targetElementId = t),
              (s.state = "focused");
          }),
            Lt(async () => {
              const { useMediaStore: s } = await Promise.resolve().then(
                () => Ra
              );
              return { useMediaStore: s };
            }, void 0).then(({ useMediaStore: s }) => {
              s.getState().pause();
            }),
            setTimeout(() => {
              const s = document.querySelector("[data-toolbar-textbox]");
              s && s.focus({ preventScroll: !0 });
            }, 100);
        },
        exitElementLinking: () => {
          n((t) => {
            (t.state = "idle"),
              (t.linkingMode = "timeline"),
              (t.targetElementId = null),
              (t.textContent = ""),
              (t.selectedTags = []);
          });
        },
        setPendingDiscardCallback: (t) => {
          n((s) => {
            s.pendingDiscardCallback = t;
          });
        },
        tryExitFocusedState: (t) => {
          const s = e();
          s.textContent.trim() && !s.editingElementId && s.state === "focused"
            ? n((r) => {
                r.pendingDiscardCallback = t;
              })
            : t();
        },
        setPendingRecordingCancelCallback: (t) => {
          n((s) => {
            s.pendingRecordingCancelCallback = t;
          });
        },
        setToolbarHovered: (t) => {
          n((s) => {
            s.isToolbarHovered = t;
          });
        },
        setPlayheadHovered: (t) => {
          n((s) => {
            s.isPlayheadHovered = t;
          });
        },
        focusTextbox: (t = "timeline") => {
          Be.getState().pause(),
            t === "reply"
              ? (n((s) => {
                  s.replyToolbar.state = "focused";
                }),
                setTimeout(() => {
                  const s = document.querySelector(
                    "[data-reply-toolbar-textbox]"
                  );
                  s && (s.focus({ preventScroll: !0 }), s.select());
                }, 0))
              : (n((s) => {
                  s.state = "focused";
                }),
                setTimeout(() => {
                  const s = document.querySelector("[data-toolbar-textbox]");
                  s && (s.focus({ preventScroll: !0 }), s.select());
                }, 0));
        },
        setReplyToolbarState: (t) => {
          n((s) => {
            s.replyToolbar.state = t;
          });
        },
        setReplyTextContent: (t) => {
          n((s) => {
            (s.replyToolbar.textContent = t),
              t &&
                s.replyToolbar.state === "idle" &&
                ((s.replyToolbar.state = "focused"),
                Lt(async () => {
                  const { useMediaStore: r } = await Promise.resolve().then(
                    () => Ra
                  );
                  return { useMediaStore: r };
                }, void 0).then(({ useMediaStore: r }) => {
                  r.getState().pause();
                }));
          });
        },
        enterReplyFocusedState: (t) => {
          Lt(async () => {
            const { useMediaStore: s } = await Promise.resolve().then(() => Ra);
            return { useMediaStore: s };
          }, void 0).then(({ useMediaStore: s }) => {
            s.getState().pause();
          }),
            n((s) => {
              (s.replyToolbar.state = "focused"), (s.replyToolbar.threadId = t);
            }),
            setTimeout(() => {
              const s = document.querySelector("[data-peek-toolbar-textbox]");
              s && (s.focus({ preventScroll: !0 }), s.select());
            }, 150);
        },
        exitReplyToIdle: () => {
          n((t) => {
            (t.replyToolbar.state = "idle"),
              (t.replyToolbar.textContent = ""),
              (t.replyToolbar.selectedTags = []),
              (t.replyToolbar.threadId = null);
          });
        },
        clearReplyText: () => {
          n((t) => {
            (t.replyToolbar.textContent = ""),
              (t.replyToolbar.selectedTags = []),
              t.replyToolbar.state === "focused" &&
                (t.replyToolbar.state = "idle");
          });
        },
        setReplyThreadId: (t) => {
          n((s) => {
            s.replyToolbar.threadId = t;
          });
        },
        startReplyRecording: (t) => {
          const s = Be.getState();
          s.isPlaying && s.pause(),
            s.isRecordingPlaying && s.setIsRecordingPlaying(!1),
            n((r) => {
              (r.replyToolbar.state = "preparing"),
                (r.replyToolbar.recordingType = t),
                (r.replyToolbar.recordingStartTime = null),
                (r.replyToolbar.recordingDuration = "00:00");
            });
        },
        stopReplyRecording: () => {
          const t = e();
          t.replyToolbar.previewStream &&
            t.replyToolbar.previewStream.getTracks().forEach((s) => s.stop()),
            n((s) => {
              (s.replyToolbar.state = "idle"),
                (s.replyToolbar.recordingType = null),
                (s.replyToolbar.recordingStartTime = null),
                (s.replyToolbar.recordingDuration = "00:00"),
                (s.replyToolbar.previewStream = null),
                (s.replyToolbar.selectedTags = []);
            });
        },
        setReplyPreviewStream: (t) => {
          n((s) => {
            s.replyToolbar.previewStream &&
              s.replyToolbar.previewStream !== t &&
              s.replyToolbar.previewStream.getTracks().forEach((r) => r.stop()),
              (s.replyToolbar.previewStream = t);
          });
        },
        setReplyRecordingDuration: (t) => {
          n((s) => {
            s.replyToolbar.recordingDuration = t;
          });
        },
        setReplyPlaceholderElementId: (t) => {
          n((s) => {
            s.replyToolbar.placeholderElementId = t;
          });
        },
        setReplySelectedTags: (t) => {
          n((s) => {
            s.replyToolbar.selectedTags = t;
          });
        },
        setReplyPendingDiscardCallback: (t) => {
          n((s) => {
            s.replyToolbar.pendingDiscardCallback = t;
          });
        },
        isAnyToolbarRecording: () => {
          const t = e(),
            s = t.state === "preparing" || t.state === "recording",
            r =
              t.replyToolbar.state === "preparing" ||
              t.replyToolbar.state === "recording";
          return s || r;
        },
        reset: () => {
          const t = e();
          t.previewStream &&
            t.previewStream.getTracks().forEach((s) => s.stop()),
            t.replyToolbar.previewStream &&
              t.replyToolbar.previewStream.getTracks().forEach((s) => s.stop()),
            n((s) => {
              (s.state = "idle"),
                (s.textContent = ""),
                (s.editingElementId = null),
                (s.recordingType = null),
                (s.recordingStartTime = null),
                (s.recordingDuration = "00:00"),
                (s.previewStream = null),
                (s.placeholderElementId = null),
                (s.selectedTags = []),
                (s.linkingMode = "timeline"),
                (s.targetElementId = null),
                (s.pendingDiscardCallback = null),
                (s.pendingRecordingCancelCallback = null),
                (s.isToolbarHovered = !1),
                (s.hasManuallyPositionedLink = !1),
                (s.isDraggingLink = !1),
                (s.pendingTimelineLink = null),
                (s.replyToolbar = {
                  state: "idle",
                  textContent: "",
                  threadId: null,
                  recordingType: null,
                  recordingStartTime: null,
                  recordingDuration: "00:00",
                  previewStream: null,
                  placeholderElementId: null,
                  selectedTags: [],
                  pendingDiscardCallback: null,
                });
            });
        },
      }))
    )
  ),
  So = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useToolbarStore: vt },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var U1 = { exports: {} },
  o$;
function q0e() {
  return (
    o$ ||
      ((o$ = 1),
      (function (n) {
        /**
         * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows.
         * @summary Record audio, video or screen inside the browser.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef RecordRTC
         * @class
         * @example
         * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {
         *     type: 'video', // audio or video or gif or canvas
         *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc
         * });
         * recorder.startRecording();
         * @see For further information:
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
         * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}
         */ function e(M, I) {
          if (!M) throw "First parameter is required.";
          (I = I || { type: "video" }), (I = new t(M, I));
          var F = this;
          function Y(re) {
            return (
              I.disableLogs || F.version,
              re && (I = new t(M, re)),
              I.disableLogs || "" + I.type,
              Ee
                ? (Ee.clearRecordedData(),
                  Ee.record(),
                  be("recording"),
                  F.recordingDuration && se(),
                  F)
                : (J(function () {
                    F.recordingDuration && se();
                  }),
                  F)
            );
          }
          function J(re) {
            re &&
              (I.initCallback = function () {
                re(), (re = I.initCallback = null);
              });
            var fe = new s(M, I);
            (Ee = new fe(M, I)),
              Ee.record(),
              be("recording"),
              I.disableLogs || (Ee.constructor.name, I.type);
          }
          function X(re) {
            if (((re = re || function () {}), !Ee)) {
              ve();
              return;
            }
            if (F.state === "paused") {
              F.resumeRecording(),
                setTimeout(function () {
                  X(re);
                }, 1);
              return;
            }
            F.state !== "recording" &&
              !I.disableLogs &&
              console.warn(
                'Recording state should be: "recording", however current state is: ',
                F.state
              ),
              I.disableLogs || "" + I.type,
              I.type !== "gif" ? Ee.stop(fe) : (Ee.stop(), fe()),
              be("stopped");
            function fe(ke) {
              if (!Ee) {
                typeof re.call == "function" ? re.call(F, "") : re("");
                return;
              }
              Object.keys(Ee).forEach(function (Ne) {
                typeof Ee[Ne] != "function" && (F[Ne] = Ee[Ne]);
              });
              var ne = Ee.blob;
              if (!ne)
                if (ke) Ee.blob = ne = ke;
                else throw "Recording failed.";
              if ((ne && !I.disableLogs && (ne.type, S(ne.size)), re)) {
                var ie;
                try {
                  ie = h.createObjectURL(ne);
                } catch {}
                typeof re.call == "function" ? re.call(F, ie) : re(ie);
              }
              I.autoWriteToDisk &&
                pe(function (Ne) {
                  var $e = {};
                  ($e[I.type + "Blob"] = Ne), B.Store($e);
                });
            }
          }
          function Z() {
            if (!Ee) {
              ve();
              return;
            }
            if (F.state !== "recording") {
              I.disableLogs ||
                console.warn(
                  "Unable to pause the recording. Recording state: ",
                  F.state
                );
              return;
            }
            be("paused"), Ee.pause(), I.disableLogs;
          }
          function te() {
            if (!Ee) {
              ve();
              return;
            }
            if (F.state !== "paused") {
              I.disableLogs ||
                console.warn(
                  "Unable to resume the recording. Recording state: ",
                  F.state
                );
              return;
            }
            be("recording"), Ee.resume(), I.disableLogs;
          }
          function ce(re) {
            postMessage(new FileReaderSync().readAsDataURL(re));
          }
          function pe(re, fe) {
            if (!re) throw "Pass a callback function over getDataURL.";
            var ke = fe ? fe.blob : (Ee || {}).blob;
            if (!ke) {
              I.disableLogs ||
                console.warn("Blob encoder did not finish its job yet."),
                setTimeout(function () {
                  pe(re, fe);
                }, 1e3);
              return;
            }
            if (typeof Worker < "u" && !navigator.mozGetUserMedia) {
              var ne = Ne(ce);
              (ne.onmessage = function ($e) {
                re($e.data);
              }),
                ne.postMessage(ke);
            } else {
              var ie = new FileReader();
              ie.readAsDataURL(ke),
                (ie.onload = function ($e) {
                  re($e.target.result);
                });
            }
            function Ne($e) {
              try {
                var ot = h.createObjectURL(
                    new Blob(
                      [
                        $e.toString(),
                        "this.onmessage =  function (eee) {" +
                          $e.name +
                          "(eee.data);}",
                      ],
                      { type: "application/javascript" }
                    )
                  ),
                  st = new Worker(ot);
                return h.revokeObjectURL(ot), st;
              } catch {}
            }
          }
          function se(re) {
            if (((re = re || 0), F.state === "paused")) {
              setTimeout(function () {
                se(re);
              }, 1e3);
              return;
            }
            if (F.state !== "stopped") {
              if (re >= F.recordingDuration) {
                X(F.onRecordingStopped);
                return;
              }
              (re += 1e3),
                setTimeout(function () {
                  se(re);
                }, 1e3);
            }
          }
          function be(re) {
            F &&
              ((F.state = re),
              typeof F.onStateChanged.call == "function"
                ? F.onStateChanged.call(F, re)
                : F.onStateChanged(re));
          }
          var K =
            'It seems that recorder is destroyed or "startRecording" is not invoked for ' +
            I.type +
            " recorder.";
          function ve() {
            I.disableLogs !== !0 && console.warn(K);
          }
          var Ee,
            De = {
              startRecording: Y,
              stopRecording: X,
              pauseRecording: Z,
              resumeRecording: te,
              initRecorder: J,
              setRecordingDuration: function (re, fe) {
                if (typeof re > "u") throw "recordingDuration is required.";
                if (typeof re != "number")
                  throw "recordingDuration must be a number.";
                return (
                  (F.recordingDuration = re),
                  (F.onRecordingStopped = fe || function () {}),
                  {
                    onRecordingStopped: function (ke) {
                      F.onRecordingStopped = ke;
                    },
                  }
                );
              },
              clearRecordedData: function () {
                if (!Ee) {
                  ve();
                  return;
                }
                Ee.clearRecordedData(), I.disableLogs;
              },
              getBlob: function () {
                if (!Ee) {
                  ve();
                  return;
                }
                return Ee.blob;
              },
              getDataURL: pe,
              toURL: function () {
                if (!Ee) {
                  ve();
                  return;
                }
                return h.createObjectURL(Ee.blob);
              },
              getInternalRecorder: function () {
                return Ee;
              },
              save: function (re) {
                if (!Ee) {
                  ve();
                  return;
                }
                A(Ee.blob, re);
              },
              getFromDisk: function (re) {
                if (!Ee) {
                  ve();
                  return;
                }
                e.getFromDisk(I.type, re);
              },
              setAdvertisementArray: function (re) {
                I.advertisement = [];
                for (var fe = re.length, ke = 0; ke < fe; ke++)
                  I.advertisement.push({ duration: ke, image: re[ke] });
              },
              blob: null,
              bufferSize: 0,
              sampleRate: 0,
              buffer: null,
              reset: function () {
                F.state === "recording" &&
                  !I.disableLogs &&
                  console.warn("Stop an active recorder."),
                  Ee &&
                    typeof Ee.clearRecordedData == "function" &&
                    Ee.clearRecordedData(),
                  (Ee = null),
                  be("inactive"),
                  (F.blob = null);
              },
              onStateChanged: function (re) {
                I.disableLogs;
              },
              state: "inactive",
              getState: function () {
                return F.state;
              },
              destroy: function () {
                var re = I.disableLogs;
                (I = { disableLogs: !0 }),
                  F.reset(),
                  be("destroyed"),
                  (De = F = null),
                  L.AudioContextConstructor &&
                    (L.AudioContextConstructor.close(),
                    (L.AudioContextConstructor = null)),
                  (I.disableLogs = re),
                  I.disableLogs;
              },
              version: "5.6.2",
            };
          if (!this) return (F = De), De;
          for (var ge in De) this[ge] = De[ge];
          return (F = this), De;
        }
        (e.version = "5.6.2"),
          (n.exports = e),
          (e.getFromDisk = function (M, I) {
            if (!I) throw "callback is mandatory.";
            "" + (M === "all" ? "blobs" : M + " blob "),
              B.Fetch(function (F, Y) {
                M !== "all" && Y === M + "Blob" && I && I(F),
                  M === "all" && I && I(F, Y.replace("Blob", ""));
              });
          }),
          (e.writeToDisk = function (M) {
            (M = M || {}),
              M.audio && M.video && M.gif
                ? M.audio.getDataURL(function (I) {
                    M.video.getDataURL(function (F) {
                      M.gif.getDataURL(function (Y) {
                        B.Store({ audioBlob: I, videoBlob: F, gifBlob: Y });
                      });
                    });
                  })
                : M.audio && M.video
                ? M.audio.getDataURL(function (I) {
                    M.video.getDataURL(function (F) {
                      B.Store({ audioBlob: I, videoBlob: F });
                    });
                  })
                : M.audio && M.gif
                ? M.audio.getDataURL(function (I) {
                    M.gif.getDataURL(function (F) {
                      B.Store({ audioBlob: I, gifBlob: F });
                    });
                  })
                : M.video && M.gif
                ? M.video.getDataURL(function (I) {
                    M.gif.getDataURL(function (F) {
                      B.Store({ videoBlob: I, gifBlob: F });
                    });
                  })
                : M.audio
                ? M.audio.getDataURL(function (I) {
                    B.Store({ audioBlob: I });
                  })
                : M.video
                ? M.video.getDataURL(function (I) {
                    B.Store({ videoBlob: I });
                  })
                : M.gif &&
                  M.gif.getDataURL(function (I) {
                    B.Store({ gifBlob: I });
                  });
          });
        /**
         * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.
         * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid "config" object.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef RecordRTCConfiguration
         * @class
         * @example
         * var options = RecordRTCConfiguration(mediaStream, options);
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}
         */ function t(M, I) {
          return (
            !I.recorderType &&
              !I.type &&
              (I.audio && I.video
                ? (I.type = "video")
                : I.audio && !I.video && (I.type = "audio")),
            I.recorderType &&
              !I.type &&
              (I.recorderType === H ||
              I.recorderType === W ||
              (typeof Q < "u" && I.recorderType === Q)
                ? (I.type = "video")
                : I.recorderType === q
                ? (I.type = "gif")
                : I.recorderType === N
                ? (I.type = "audio")
                : I.recorderType === V &&
                  ((R(M, "audio").length && R(M, "video").length) ||
                  (!R(M, "audio").length && R(M, "video").length)
                    ? (I.type = "video")
                    : R(M, "audio").length &&
                      !R(M, "video").length &&
                      (I.type = "audio"))),
            typeof V < "u" &&
              typeof MediaRecorder < "u" &&
              "requestData" in MediaRecorder.prototype &&
              (I.mimeType || (I.mimeType = "video/webm"),
              I.type || (I.type = I.mimeType.split("/")[0]),
              I.bitsPerSecond),
            I.type ||
              (I.mimeType && (I.type = I.mimeType.split("/")[0]),
              I.type || (I.type = "audio")),
            I
          );
        }
        /**
         * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.
         * @summary It returns best recorder-type available for your browser.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef GetRecorderType
         * @class
         * @example
         * var RecorderType = GetRecorderType(options);
         * var recorder = new RecorderType(options);
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
         */ function s(M, I) {
          var F;
          return (
            (y || m || p) && (F = N),
            typeof MediaRecorder < "u" &&
              "requestData" in MediaRecorder.prototype &&
              !y &&
              (F = V),
            I.type === "video" &&
              (y || p) &&
              ((F = H),
              typeof Q < "u" && typeof ReadableStream < "u" && (F = Q)),
            I.type === "gif" && (F = q),
            I.type === "canvas" && (F = W),
            P() &&
              F !== W &&
              F !== q &&
              typeof MediaRecorder < "u" &&
              "requestData" in MediaRecorder.prototype &&
              (R(M, "video").length || R(M, "audio").length) &&
              (I.type === "audio"
                ? typeof MediaRecorder.isTypeSupported == "function" &&
                  MediaRecorder.isTypeSupported("audio/webm") &&
                  (F = V)
                : typeof MediaRecorder.isTypeSupported == "function" &&
                  MediaRecorder.isTypeSupported("video/webm") &&
                  (F = V)),
            M instanceof Array && M.length && (F = U),
            I.recorderType && (F = I.recorderType),
            !I.disableLogs && F && F.name && (F.name || F.constructor.name),
            !F && b && (F = V),
            F
          );
        }
        /**
         * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.
         * @summary MRecordRTC stands for "Multiple-RecordRTC".
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef MRecordRTC
         * @class
         * @example
         * var recorder = new MRecordRTC();
         * recorder.addStream(MediaStream);
         * recorder.mediaType = {
         *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder
         *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder
         *     gif: true    // or GifRecorder
         * };
         * // mimeType is optional and should be set only in advance cases.
         * recorder.mimeType = {
         *     audio: 'audio/wav',
         *     video: 'video/webm',
         *     gif:   'image/gif'
         * };
         * recorder.startRecording();
         * @see For further information:
         * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @requires {@link RecordRTC}
         */ function r(M) {
          (this.addStream = function (I) {
            I && (M = I);
          }),
            (this.mediaType = { audio: !0, video: !0 }),
            (this.startRecording = function () {
              var I = this.mediaType,
                F,
                Y = this.mimeType || { audio: null, video: null, gif: null };
              if (
                (typeof I.audio != "function" &&
                  P() &&
                  !R(M, "audio").length &&
                  (I.audio = !1),
                typeof I.video != "function" &&
                  P() &&
                  !R(M, "video").length &&
                  (I.video = !1),
                typeof I.gif != "function" &&
                  P() &&
                  !R(M, "video").length &&
                  (I.gif = !1),
                !I.audio && !I.video && !I.gif)
              )
                throw "MediaStream must have either audio or video tracks.";
              if (
                (I.audio &&
                  ((F = null),
                  typeof I.audio == "function" && (F = I.audio),
                  (this.audioRecorder = new e(M, {
                    type: "audio",
                    bufferSize: this.bufferSize,
                    sampleRate: this.sampleRate,
                    numberOfAudioChannels: this.numberOfAudioChannels || 2,
                    disableLogs: this.disableLogs,
                    recorderType: F,
                    mimeType: Y.audio,
                    timeSlice: this.timeSlice,
                    onTimeStamp: this.onTimeStamp,
                  })),
                  I.video || this.audioRecorder.startRecording()),
                I.video)
              ) {
                (F = null), typeof I.video == "function" && (F = I.video);
                var J = M;
                if (P() && I.audio && typeof I.audio == "function") {
                  var X = R(M, "video")[0];
                  g
                    ? ((J = new w()), J.addTrack(X), F && F === H && (F = V))
                    : ((J = new w()), J.addTrack(X));
                }
                (this.videoRecorder = new e(J, {
                  type: "video",
                  video: this.video,
                  canvas: this.canvas,
                  frameInterval: this.frameInterval || 10,
                  disableLogs: this.disableLogs,
                  recorderType: F,
                  mimeType: Y.video,
                  timeSlice: this.timeSlice,
                  onTimeStamp: this.onTimeStamp,
                  workerPath: this.workerPath,
                  webAssemblyPath: this.webAssemblyPath,
                  frameRate: this.frameRate,
                  bitrate: this.bitrate,
                })),
                  I.audio || this.videoRecorder.startRecording();
              }
              if (I.audio && I.video) {
                var Z = this,
                  te = P() === !0;
                ((I.audio instanceof N && I.video) ||
                  (I.audio !== !0 && I.video !== !0 && I.audio !== I.video)) &&
                  (te = !1),
                  te === !0
                    ? ((Z.audioRecorder = null),
                      Z.videoRecorder.startRecording())
                    : Z.videoRecorder.initRecorder(function () {
                        Z.audioRecorder.initRecorder(function () {
                          Z.videoRecorder.startRecording(),
                            Z.audioRecorder.startRecording();
                        });
                      });
              }
              I.gif &&
                ((F = null),
                typeof I.gif == "function" && (F = I.gif),
                (this.gifRecorder = new e(M, {
                  type: "gif",
                  frameRate: this.frameRate || 200,
                  quality: this.quality || 10,
                  disableLogs: this.disableLogs,
                  recorderType: F,
                  mimeType: Y.gif,
                })),
                this.gifRecorder.startRecording());
            }),
            (this.stopRecording = function (I) {
              (I = I || function () {}),
                this.audioRecorder &&
                  this.audioRecorder.stopRecording(function (F) {
                    I(F, "audio");
                  }),
                this.videoRecorder &&
                  this.videoRecorder.stopRecording(function (F) {
                    I(F, "video");
                  }),
                this.gifRecorder &&
                  this.gifRecorder.stopRecording(function (F) {
                    I(F, "gif");
                  });
            }),
            (this.pauseRecording = function () {
              this.audioRecorder && this.audioRecorder.pauseRecording(),
                this.videoRecorder && this.videoRecorder.pauseRecording(),
                this.gifRecorder && this.gifRecorder.pauseRecording();
            }),
            (this.resumeRecording = function () {
              this.audioRecorder && this.audioRecorder.resumeRecording(),
                this.videoRecorder && this.videoRecorder.resumeRecording(),
                this.gifRecorder && this.gifRecorder.resumeRecording();
            }),
            (this.getBlob = function (I) {
              var F = {};
              return (
                this.audioRecorder && (F.audio = this.audioRecorder.getBlob()),
                this.videoRecorder && (F.video = this.videoRecorder.getBlob()),
                this.gifRecorder && (F.gif = this.gifRecorder.getBlob()),
                I && I(F),
                F
              );
            }),
            (this.destroy = function () {
              this.audioRecorder &&
                (this.audioRecorder.destroy(), (this.audioRecorder = null)),
                this.videoRecorder &&
                  (this.videoRecorder.destroy(), (this.videoRecorder = null)),
                this.gifRecorder &&
                  (this.gifRecorder.destroy(), (this.gifRecorder = null));
            }),
            (this.getDataURL = function (I) {
              this.getBlob(function (J) {
                J.audio && J.video
                  ? F(J.audio, function (X) {
                      F(J.video, function (Z) {
                        I({ audio: X, video: Z });
                      });
                    })
                  : J.audio
                  ? F(J.audio, function (X) {
                      I({ audio: X });
                    })
                  : J.video &&
                    F(J.video, function (X) {
                      I({ video: X });
                    });
              });
              function F(J, X) {
                if (typeof Worker < "u") {
                  var Z = Y(function (pe) {
                    postMessage(new FileReaderSync().readAsDataURL(pe));
                  });
                  (Z.onmessage = function (ce) {
                    X(ce.data);
                  }),
                    Z.postMessage(J);
                } else {
                  var te = new FileReader();
                  te.readAsDataURL(J),
                    (te.onload = function (ce) {
                      X(ce.target.result);
                    });
                }
              }
              function Y(J) {
                var X = h.createObjectURL(
                    new Blob(
                      [
                        J.toString(),
                        "this.onmessage =  function (eee) {" +
                          J.name +
                          "(eee.data);}",
                      ],
                      { type: "application/javascript" }
                    )
                  ),
                  Z = new Worker(X),
                  te;
                if (typeof h < "u") te = h;
                else if (typeof webkitURL < "u") te = webkitURL;
                else throw "Neither URL nor webkitURL detected.";
                return te.revokeObjectURL(X), Z;
              }
            }),
            (this.writeToDisk = function () {
              e.writeToDisk({
                audio: this.audioRecorder,
                video: this.videoRecorder,
                gif: this.gifRecorder,
              });
            }),
            (this.save = function (I) {
              (I = I || { audio: !0, video: !0, gif: !0 }),
                I.audio &&
                  this.audioRecorder &&
                  this.audioRecorder.save(
                    typeof I.audio == "string" ? I.audio : ""
                  ),
                I.video &&
                  this.videoRecorder &&
                  this.videoRecorder.save(
                    typeof I.video == "string" ? I.video : ""
                  ),
                I.gif &&
                  this.gifRecorder &&
                  this.gifRecorder.save(typeof I.gif == "string" ? I.gif : "");
            });
        }
        (r.getFromDisk = e.getFromDisk),
          (r.writeToDisk = e.writeToDisk),
          typeof e < "u" && (e.MRecordRTC = r);
        var i =
          "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
        (function (M) {
          M &&
            (typeof window < "u" ||
              typeof Yn > "u" ||
              ((Yn.navigator = { userAgent: i, getUserMedia: function () {} }),
              Yn.console || (Yn.console = {}),
              (typeof Yn.console.log > "u" || typeof Yn.console.error > "u") &&
                (Yn.console.error = Yn.console.log =
                  Yn.console.log || function () {}),
              typeof document > "u" &&
                ((M.document = {
                  documentElement: {
                    appendChild: function () {
                      return "";
                    },
                  },
                }),
                (document.createElement =
                  document.captureStream =
                  document.mozCaptureStream =
                    function () {
                      var I = {
                        getContext: function () {
                          return I;
                        },
                        play: function () {},
                        pause: function () {},
                        drawImage: function () {},
                        toDataURL: function () {
                          return "";
                        },
                        style: {},
                      };
                      return I;
                    }),
                (M.HTMLVideoElement = function () {})),
              typeof location > "u" &&
                (M.location = { protocol: "file:", href: "", hash: "" }),
              typeof screen > "u" && (M.screen = { width: 0, height: 0 }),
              typeof h > "u" &&
                (M.URL = {
                  createObjectURL: function () {
                    return "";
                  },
                  revokeObjectURL: function () {
                    return "";
                  },
                }),
              (M.window = Yn)));
        })(typeof Yn < "u" ? Yn : null);
        var a = window.requestAnimationFrame;
        if (typeof a > "u") {
          if (typeof webkitRequestAnimationFrame < "u")
            a = webkitRequestAnimationFrame;
          else if (typeof mozRequestAnimationFrame < "u")
            a = mozRequestAnimationFrame;
          else if (typeof msRequestAnimationFrame < "u")
            a = msRequestAnimationFrame;
          else if (typeof a > "u") {
            var o = 0;
            a = function (M, I) {
              var F = new Date().getTime(),
                Y = Math.max(0, 16 - (F - o)),
                J = setTimeout(function () {
                  M(F + Y);
                }, Y);
              return (o = F + Y), J;
            };
          }
        }
        var l = window.cancelAnimationFrame;
        typeof l > "u" &&
          (typeof webkitCancelAnimationFrame < "u"
            ? (l = webkitCancelAnimationFrame)
            : typeof mozCancelAnimationFrame < "u"
            ? (l = mozCancelAnimationFrame)
            : typeof msCancelAnimationFrame < "u"
            ? (l = msCancelAnimationFrame)
            : typeof l > "u" &&
              (l = function (M) {
                clearTimeout(M);
              }));
        var c = window.AudioContext;
        typeof c > "u" &&
          (typeof webkitAudioContext < "u" && (c = webkitAudioContext),
          typeof mozAudioContext < "u" && (c = mozAudioContext));
        var h = window.URL;
        typeof h > "u" && typeof webkitURL < "u" && (h = webkitURL),
          typeof navigator < "u" &&
            typeof navigator.getUserMedia > "u" &&
            (typeof navigator.webkitGetUserMedia < "u" &&
              (navigator.getUserMedia = navigator.webkitGetUserMedia),
            typeof navigator.mozGetUserMedia < "u" &&
              (navigator.getUserMedia = navigator.mozGetUserMedia));
        var m =
            navigator.userAgent.indexOf("Edge") !== -1 &&
            (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob),
          p = !!window.opera || navigator.userAgent.indexOf("OPR/") !== -1,
          g =
            navigator.userAgent.toLowerCase().indexOf("firefox") > -1 &&
            "netscape" in window &&
            / rv:/.test(navigator.userAgent),
          y =
            (!p && !m && !!navigator.webkitGetUserMedia) ||
            _() ||
            navigator.userAgent.toLowerCase().indexOf("chrome/") !== -1,
          b = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        b &&
          !y &&
          navigator.userAgent.indexOf("CriOS") !== -1 &&
          ((b = !1), (y = !0));
        var w = window.MediaStream;
        typeof w > "u" &&
          typeof webkitMediaStream < "u" &&
          (w = webkitMediaStream),
          typeof w < "u" &&
            typeof w.prototype.stop > "u" &&
            (w.prototype.stop = function () {
              this.getTracks().forEach(function (M) {
                M.stop();
              });
            });
        function S(M) {
          var I = 1e3,
            F = ["Bytes", "KB", "MB", "GB", "TB"];
          if (M === 0) return "0 Bytes";
          var Y = parseInt(Math.floor(Math.log(M) / Math.log(I)), 10);
          return (M / Math.pow(I, Y)).toPrecision(3) + " " + F[Y];
        }
        function A(M, I) {
          if (!M) throw "Blob object is required.";
          if (!M.type)
            try {
              M.type = "video/webm";
            } catch {}
          var F = (M.type || "video/webm").split("/")[1];
          if (
            (F.indexOf(";") !== -1 && (F = F.split(";")[0]),
            I && I.indexOf(".") !== -1)
          ) {
            var Y = I.split(".");
            (I = Y[0]), (F = Y[1]);
          }
          var J =
            (I || Math.round(Math.random() * 9999999999) + 888888888) + "." + F;
          if (typeof navigator.msSaveOrOpenBlob < "u")
            return navigator.msSaveOrOpenBlob(M, J);
          if (typeof navigator.msSaveBlob < "u")
            return navigator.msSaveBlob(M, J);
          var X = document.createElement("a");
          (X.href = h.createObjectURL(M)),
            (X.download = J),
            (X.style = "display:none;opacity:0;color:transparent;"),
            (document.body || document.documentElement).appendChild(X),
            typeof X.click == "function"
              ? X.click()
              : ((X.target = "_blank"),
                X.dispatchEvent(
                  new MouseEvent("click", {
                    view: window,
                    bubbles: !0,
                    cancelable: !0,
                  })
                )),
            h.revokeObjectURL(X.href);
        }
        function _() {
          return !!(
            (typeof window < "u" &&
              typeof window.process == "object" &&
              window.process.type === "renderer") ||
            (typeof process < "u" &&
              typeof process.versions == "object" &&
              process.versions.electron) ||
            (typeof navigator == "object" &&
              typeof navigator.userAgent == "string" &&
              navigator.userAgent.indexOf("Electron") >= 0)
          );
        }
        function R(M, I) {
          return !M || !M.getTracks
            ? []
            : M.getTracks().filter(function (F) {
                return F.kind === (I || "audio");
              });
        }
        function C(M, I) {
          "srcObject" in I
            ? (I.srcObject = M)
            : "mozSrcObject" in I
            ? (I.mozSrcObject = M)
            : (I.srcObject = M);
        }
        function D(M, I) {
          if (typeof EBML > "u")
            throw new Error(
              "Please link: https://www.webrtc-experiment.com/EBML.js"
            );
          var F = new EBML.Reader(),
            Y = new EBML.Decoder(),
            J = EBML.tools,
            X = new FileReader();
          (X.onload = function (Z) {
            var te = Y.decode(this.result);
            te.forEach(function (be) {
              F.read(be);
            }),
              F.stop();
            var ce = J.makeMetadataSeekable(F.metadatas, F.duration, F.cues),
              pe = this.result.slice(F.metadataSize),
              se = new Blob([ce, pe], { type: "video/webm" });
            I(se);
          }),
            X.readAsArrayBuffer(M);
        }
        typeof e < "u" &&
          ((e.invokeSaveAsDialog = A),
          (e.getTracks = R),
          (e.getSeekableBlob = D),
          (e.bytesToSize = S),
          (e.isElectron = _));
        /**
         * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. "new AudioContext".
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @example
         * Storage.AudioContext === webkitAudioContext
         * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         */ var L = {};
        typeof c < "u"
          ? (L.AudioContext = c)
          : typeof webkitAudioContext < "u" &&
            (L.AudioContext = webkitAudioContext),
          typeof e < "u" && (e.Storage = L);
        function P() {
          if (g || b || m) return !0;
          var M = navigator.userAgent,
            I = "" + parseFloat(navigator.appVersion),
            F = parseInt(navigator.appVersion, 10),
            Y,
            J;
          return (
            (y || p) && ((Y = M.indexOf("Chrome")), (I = M.substring(Y + 7))),
            (J = I.indexOf(";")) !== -1 && (I = I.substring(0, J)),
            (J = I.indexOf(" ")) !== -1 && (I = I.substring(0, J)),
            (F = parseInt("" + I, 10)),
            isNaN(F) &&
              ((I = "" + parseFloat(navigator.appVersion)),
              (F = parseInt(navigator.appVersion, 10))),
            F >= 49
          );
        }
        /**
         * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.
         * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://github.com/muaz-khan|Muaz Khan}
         * @typedef MediaStreamRecorder
         * @class
         * @example
         * var config = {
         *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis
         *     audioBitsPerSecond : 256 * 8 * 1024,
         *     videoBitsPerSecond : 256 * 8 * 1024,
         *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two
         *     checkForInactiveTracks: true,
         *     timeSlice: 1000, // concatenate intervals based blobs
         *     ondataavailable: function() {} // get intervals based blobs
         * }
         * var recorder = new MediaStreamRecorder(mediaStream, config);
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         *
         *     // or
         *     var blob = recorder.blob;
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {disableLogs:true, initCallback: function, mimeType: "video/webm", timeSlice: 1000}
         * @throws Will throw an error if first argument "MediaStream" is missing. Also throws error if "MediaRecorder API" are not supported by the browser.
         */ function V(M, I) {
          var se = this;
          if (typeof M > "u") throw 'First argument "MediaStream" is required.';
          if (typeof MediaRecorder > "u")
            throw "Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.";
          if (((I = I || { mimeType: "video/webm" }), I.type === "audio")) {
            if (R(M, "video").length && R(M, "audio").length) {
              var F;
              navigator.mozGetUserMedia
                ? ((F = new w()), F.addTrack(R(M, "audio")[0]))
                : (F = new w(R(M, "audio"))),
                (M = F);
            }
            (!I.mimeType ||
              I.mimeType.toString().toLowerCase().indexOf("audio") === -1) &&
              (I.mimeType = y ? "audio/webm" : "audio/ogg"),
              I.mimeType &&
                I.mimeType.toString().toLowerCase() !== "audio/ogg" &&
                navigator.mozGetUserMedia &&
                (I.mimeType = "audio/ogg");
          }
          var Y = [];
          (this.getArrayOfBlobs = function () {
            return Y;
          }),
            (this.record = function () {
              (se.blob = null),
                se.clearRecordedData(),
                (se.timestamps = []),
                (pe = []),
                (Y = []);
              var be = I;
              I.disableLogs,
                te && (te = null),
                y && !P() && (be = "video/vp8"),
                typeof MediaRecorder.isTypeSupported == "function" &&
                  be.mimeType &&
                  (MediaRecorder.isTypeSupported(be.mimeType) ||
                    (I.disableLogs ||
                      console.warn(
                        "MediaRecorder API seems unable to record mimeType:",
                        be.mimeType
                      ),
                    (be.mimeType =
                      I.type === "audio" ? "audio/webm" : "video/webm")));
              try {
                (te = new MediaRecorder(M, be)), (I.mimeType = be.mimeType);
              } catch {
                te = new MediaRecorder(M);
              }
              be.mimeType &&
                !MediaRecorder.isTypeSupported &&
                "canRecordMimeType" in te &&
                te.canRecordMimeType(be.mimeType) === !1 &&
                (I.disableLogs ||
                  console.warn(
                    "MediaRecorder API seems unable to record mimeType:",
                    be.mimeType
                  )),
                (te.ondataavailable = function (K) {
                  if (
                    (K.data && pe.push("ondataavailable: " + S(K.data.size)),
                    typeof I.timeSlice == "number")
                  ) {
                    if (
                      K.data &&
                      K.data.size &&
                      (Y.push(K.data),
                      J(),
                      typeof I.ondataavailable == "function")
                    ) {
                      var ve = I.getNativeBlob
                        ? K.data
                        : new Blob([K.data], { type: X(be) });
                      I.ondataavailable(ve);
                    }
                    return;
                  }
                  if (!K.data || !K.data.size || K.data.size < 100 || se.blob) {
                    se.recordingCallback &&
                      (se.recordingCallback(new Blob([], { type: X(be) })),
                      (se.recordingCallback = null));
                    return;
                  }
                  (se.blob = I.getNativeBlob
                    ? K.data
                    : new Blob([K.data], { type: X(be) })),
                    se.recordingCallback &&
                      (se.recordingCallback(se.blob),
                      (se.recordingCallback = null));
                }),
                (te.onstart = function () {
                  pe.push("started");
                }),
                (te.onpause = function () {
                  pe.push("paused");
                }),
                (te.onresume = function () {
                  pe.push("resumed");
                }),
                (te.onstop = function () {
                  pe.push("stopped");
                }),
                (te.onerror = function (K) {
                  K &&
                    (K.name || (K.name = "UnknownError"),
                    pe.push("error: " + K),
                    I.disableLogs ||
                      (K.name
                        .toString()
                        .toLowerCase()
                        .indexOf("invalidstate") !== -1
                        ? console.error(
                            "The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.",
                            K
                          )
                        : K.name
                            .toString()
                            .toLowerCase()
                            .indexOf("notsupported") !== -1
                        ? console.error(
                            "MIME type (",
                            be.mimeType,
                            ") is not supported.",
                            K
                          )
                        : K.name
                            .toString()
                            .toLowerCase()
                            .indexOf("security") !== -1
                        ? console.error("MediaRecorder security error", K)
                        : K.name === "OutOfMemory"
                        ? console.error(
                            "The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.",
                            K
                          )
                        : K.name === "IllegalStreamModification"
                        ? console.error(
                            "A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.",
                            K
                          )
                        : K.name === "OtherRecordingError"
                        ? console.error(
                            "Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.",
                            K
                          )
                        : K.name === "GenericError"
                        ? console.error(
                            "The UA cannot provide the codec or recording option that has been requested.",
                            K
                          )
                        : console.error("MediaRecorder Error", K)),
                    (function (ve) {
                      if (
                        !se.manuallyStopped &&
                        te &&
                        te.state === "inactive"
                      ) {
                        delete I.timeslice, te.start(600 * 1e3);
                        return;
                      }
                      setTimeout(ve, 1e3);
                    })(),
                    te.state !== "inactive" &&
                      te.state !== "stopped" &&
                      te.stop());
                }),
                typeof I.timeSlice == "number"
                  ? (J(), te.start(I.timeSlice))
                  : te.start(36e5),
                I.initCallback && I.initCallback();
            }),
            (this.timestamps = []);
          function J() {
            se.timestamps.push(new Date().getTime()),
              typeof I.onTimeStamp == "function" &&
                I.onTimeStamp(
                  se.timestamps[se.timestamps.length - 1],
                  se.timestamps
                );
          }
          function X(be) {
            return te && te.mimeType
              ? te.mimeType
              : be.mimeType || "video/webm";
          }
          (this.stop = function (be) {
            (be = be || function () {}),
              (se.manuallyStopped = !0),
              te &&
                ((this.recordingCallback = be),
                te.state === "recording" && te.stop(),
                typeof I.timeSlice == "number" &&
                  setTimeout(function () {
                    (se.blob = new Blob(Y, { type: X(I) })),
                      se.recordingCallback(se.blob);
                  }, 100));
          }),
            (this.pause = function () {
              te && te.state === "recording" && te.pause();
            }),
            (this.resume = function () {
              te && te.state === "paused" && te.resume();
            }),
            (this.clearRecordedData = function () {
              te && te.state === "recording" && se.stop(Z), Z();
            });
          function Z() {
            (Y = []), (te = null), (se.timestamps = []);
          }
          var te;
          this.getInternalRecorder = function () {
            return te;
          };
          function ce() {
            if ("active" in M) {
              if (!M.active) return !1;
            } else if ("ended" in M && M.ended) return !1;
            return !0;
          }
          (this.blob = null),
            (this.getState = function () {
              return (te && te.state) || "inactive";
            });
          var pe = [];
          (this.getAllStates = function () {
            return pe;
          }),
            typeof I.checkForInactiveTracks > "u" &&
              (I.checkForInactiveTracks = !1);
          var se = this;
          (function be() {
            if (!(!te || I.checkForInactiveTracks === !1)) {
              if (ce() === !1) {
                I.disableLogs, se.stop();
                return;
              }
              setTimeout(be, 1e3);
            }
          })(),
            (this.name = "MediaStreamRecorder"),
            (this.toString = function () {
              return this.name;
            });
        }
        typeof e < "u" && (e.MediaStreamRecorder = V);
        /**
         * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring "stereo" audio-recording in chrome.
         * @summary JavaScript standalone object for stereo audio recording.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef StereoAudioRecorder
         * @class
         * @example
         * var recorder = new StereoAudioRecorder(MediaStream, {
         *     sampleRate: 44100,
         *     bufferSize: 4096
         * });
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}
         */ function N(M, I) {
          if (!R(M, "audio").length) throw "Your stream has no audio tracks.";
          I = I || {};
          var F = this,
            Y = [],
            J = [],
            X = !1,
            Z = 0,
            te,
            ce = 2,
            pe = I.desiredSampRate;
          I.leftChannel === !0 && (ce = 1),
            I.numberOfAudioChannels === 1 && (ce = 1),
            (!ce || ce < 1) && (ce = 2),
            I.disableLogs || "" + ce,
            typeof I.checkForInactiveTracks > "u" &&
              (I.checkForInactiveTracks = !0);
          function se() {
            if (I.checkForInactiveTracks === !1) return !0;
            if ("active" in M) {
              if (!M.active) return !1;
            } else if ("ended" in M && M.ended) return !1;
            return !0;
          }
          this.record = function () {
            if (se() === !1) throw "Please make sure MediaStream is active.";
            ke(), (ie = fe = !1), (X = !0), typeof I.timeSlice < "u" && ot();
          };
          function be(st, ht) {
            function xt(Ue, He) {
              var Ve = Ue.numberOfAudioChannels,
                Ze = Ue.leftBuffers.slice(0),
                ct = Ue.rightBuffers.slice(0),
                ft = Ue.sampleRate,
                Ye = Ue.internalInterleavedLength,
                Ot = Ue.desiredSampRate;
              Ve === 2 &&
                ((Ze = Bn(Ze, Ye)),
                (ct = Bn(ct, Ye)),
                Ot && ((Ze = $t(Ze, Ot, ft)), (ct = $t(ct, Ot, ft)))),
                Ve === 1 && ((Ze = Bn(Ze, Ye)), Ot && (Ze = $t(Ze, Ot, ft))),
                Ot && (ft = Ot);
              function $t(je, Ke, ut) {
                var St = Math.round(je.length * (Ke / ut)),
                  kt = [],
                  Kt = Number((je.length - 1) / (St - 1));
                kt[0] = je[0];
                for (var jt = 1; jt < St - 1; jt++) {
                  var _n = jt * Kt,
                    ws = Number(Math.floor(_n)).toFixed(),
                    Es = Number(Math.ceil(_n)).toFixed(),
                    ur = _n - ws;
                  kt[jt] = wn(je[ws], je[Es], ur);
                }
                return (kt[St - 1] = je[je.length - 1]), kt;
              }
              function wn(je, Ke, ut) {
                return je + (Ke - je) * ut;
              }
              function Bn(je, Ke) {
                for (
                  var ut = new Float64Array(Ke), St = 0, kt = je.length, Kt = 0;
                  Kt < kt;
                  Kt++
                ) {
                  var jt = je[Kt];
                  ut.set(jt, St), (St += jt.length);
                }
                return ut;
              }
              function Ws(je, Ke) {
                for (
                  var ut = je.length + Ke.length,
                    St = new Float64Array(ut),
                    kt = 0,
                    Kt = 0;
                  Kt < ut;

                )
                  (St[Kt++] = je[kt]), (St[Kt++] = Ke[kt]), kt++;
                return St;
              }
              function ts(je, Ke, ut) {
                for (var St = ut.length, kt = 0; kt < St; kt++)
                  je.setUint8(Ke + kt, ut.charCodeAt(kt));
              }
              var Vt;
              Ve === 2 && (Vt = Ws(Ze, ct)), Ve === 1 && (Vt = Ze);
              var Zt = Vt.length,
                ln = 44 + Zt * 2,
                Je = new ArrayBuffer(ln),
                Ge = new DataView(Je);
              ts(Ge, 0, "RIFF"),
                Ge.setUint32(4, 36 + Zt * 2, !0),
                ts(Ge, 8, "WAVE"),
                ts(Ge, 12, "fmt "),
                Ge.setUint32(16, 16, !0),
                Ge.setUint16(20, 1, !0),
                Ge.setUint16(22, Ve, !0),
                Ge.setUint32(24, ft, !0),
                Ge.setUint32(28, ft * Ve * 2, !0),
                Ge.setUint16(32, Ve * 2, !0),
                Ge.setUint16(34, 16, !0),
                ts(Ge, 36, "data"),
                Ge.setUint32(40, Zt * 2, !0);
              for (var mt = Zt, zt = 44, an = 1, le = 0; le < mt; le++)
                Ge.setInt16(zt, Vt[le] * (32767 * an), !0), (zt += 2);
              if (He) return He({ buffer: Je, view: Ge });
              postMessage({ buffer: Je, view: Ge });
            }
            if (st.noWorker) {
              xt(st, function (Ue) {
                ht(Ue.buffer, Ue.view);
              });
              return;
            }
            var _e = K(xt);
            (_e.onmessage = function (Ue) {
              ht(Ue.data.buffer, Ue.data.view),
                h.revokeObjectURL(_e.workerURL),
                _e.terminate();
            }),
              _e.postMessage(st);
          }
          function K(st) {
            var ht = h.createObjectURL(
                new Blob(
                  [
                    st.toString(),
                    ";this.onmessage =  function (eee) {" +
                      st.name +
                      "(eee.data);}",
                  ],
                  { type: "application/javascript" }
                )
              ),
              xt = new Worker(ht);
            return (xt.workerURL = ht), xt;
          }
          (this.stop = function (st) {
            (st = st || function () {}),
              (X = !1),
              be(
                {
                  desiredSampRate: pe,
                  sampleRate: re,
                  numberOfAudioChannels: ce,
                  internalInterleavedLength: Z,
                  leftBuffers: Y,
                  rightBuffers: ce === 1 ? [] : J,
                  noWorker: I.noWorker,
                },
                function (ht, xt) {
                  (F.blob = new Blob([xt], { type: "audio/wav" })),
                    (F.buffer = new ArrayBuffer(xt.buffer.byteLength)),
                    (F.view = xt),
                    (F.sampleRate = pe || re),
                    (F.bufferSize = ge),
                    (F.length = Z),
                    (ie = !1),
                    st && st(F.blob);
                }
              );
          }),
            typeof e.Storage > "u" &&
              (e.Storage = {
                AudioContextConstructor: null,
                AudioContext: window.AudioContext || window.webkitAudioContext,
              }),
            (!e.Storage.AudioContextConstructor ||
              e.Storage.AudioContextConstructor.state === "closed") &&
              (e.Storage.AudioContextConstructor =
                new e.Storage.AudioContext());
          var ve = e.Storage.AudioContextConstructor,
            Ee = ve.createMediaStreamSource(M),
            De = [0, 256, 512, 1024, 2048, 4096, 8192, 16384],
            ge = typeof I.bufferSize > "u" ? 4096 : I.bufferSize;
          if (
            (De.indexOf(ge) === -1 &&
              (I.disableLogs || "" + JSON.stringify(De, null, "	")),
            ve.createJavaScriptNode)
          )
            te = ve.createJavaScriptNode(ge, ce, ce);
          else if (ve.createScriptProcessor)
            te = ve.createScriptProcessor(ge, ce, ce);
          else throw "WebAudio API has no support on this browser.";
          Ee.connect(te), I.bufferSize || (ge = te.bufferSize);
          var re =
            typeof I.sampleRate < "u" ? I.sampleRate : ve.sampleRate || 44100;
          (re < 22050 || re > 96e3) && I.disableLogs,
            I.disableLogs || (I.desiredSampRate && "" + I.desiredSampRate);
          var fe = !1;
          (this.pause = function () {
            fe = !0;
          }),
            (this.resume = function () {
              if (se() === !1) throw "Please make sure MediaStream is active.";
              if (!X) {
                I.disableLogs, this.record();
                return;
              }
              fe = !1;
            }),
            (this.clearRecordedData = function () {
              (I.checkForInactiveTracks = !1), X && this.stop(ne), ne();
            });
          function ke() {
            (Y = []),
              (J = []),
              (Z = 0),
              (ie = !1),
              (X = !1),
              (fe = !1),
              (ve = null),
              (F.leftchannel = Y),
              (F.rightchannel = J),
              (F.numberOfAudioChannels = ce),
              (F.desiredSampRate = pe),
              (F.sampleRate = re),
              (F.recordingLength = Z),
              ($e = { left: [], right: [], recordingLength: 0 });
          }
          function ne() {
            te && ((te.onaudioprocess = null), te.disconnect(), (te = null)),
              Ee && (Ee.disconnect(), (Ee = null)),
              ke();
          }
          (this.name = "StereoAudioRecorder"),
            (this.toString = function () {
              return this.name;
            });
          var ie = !1;
          function Ne(st) {
            if (!fe) {
              if (
                (se() === !1 && (I.disableLogs, te.disconnect(), (X = !1)), !X)
              ) {
                Ee && (Ee.disconnect(), (Ee = null));
                return;
              }
              ie ||
                ((ie = !0),
                I.onAudioProcessStarted && I.onAudioProcessStarted(),
                I.initCallback && I.initCallback());
              var ht = st.inputBuffer.getChannelData(0),
                xt = new Float32Array(ht);
              if ((Y.push(xt), ce === 2)) {
                var _e = st.inputBuffer.getChannelData(1),
                  Ue = new Float32Array(_e);
                J.push(Ue);
              }
              (Z += ge),
                (F.recordingLength = Z),
                typeof I.timeSlice < "u" &&
                  (($e.recordingLength += ge),
                  $e.left.push(xt),
                  ce === 2 && $e.right.push(Ue));
            }
          }
          (te.onaudioprocess = Ne),
            ve.createMediaStreamDestination
              ? te.connect(ve.createMediaStreamDestination())
              : te.connect(ve.destination),
            (this.leftchannel = Y),
            (this.rightchannel = J),
            (this.numberOfAudioChannels = ce),
            (this.desiredSampRate = pe),
            (this.sampleRate = re),
            (F.recordingLength = Z);
          var $e = { left: [], right: [], recordingLength: 0 };
          function ot() {
            !X ||
              typeof I.ondataavailable != "function" ||
              typeof I.timeSlice > "u" ||
              ($e.left.length
                ? (be(
                    {
                      desiredSampRate: pe,
                      sampleRate: re,
                      numberOfAudioChannels: ce,
                      internalInterleavedLength: $e.recordingLength,
                      leftBuffers: $e.left,
                      rightBuffers: ce === 1 ? [] : $e.right,
                    },
                    function (st, ht) {
                      var xt = new Blob([ht], { type: "audio/wav" });
                      I.ondataavailable(xt), setTimeout(ot, I.timeSlice);
                    }
                  ),
                  ($e = { left: [], right: [], recordingLength: 0 }))
                : setTimeout(ot, I.timeSlice));
          }
        }
        typeof e < "u" && (e.StereoAudioRecorder = N);
        /**
         * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.
         * @summary HTML2Canvas recording into video WebM.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef CanvasRecorder
         * @class
         * @example
         * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.
         * @param {object} config - {disableLogs:true, initCallback: function}
         */ function W(M, I) {
          if (typeof html2canvas > "u")
            throw "Please link: https://www.webrtc-experiment.com/screenshot.js";
          (I = I || {}), I.frameInterval || (I.frameInterval = 10);
          var F = !1;
          ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(
            function (De) {
              De in document.createElement("canvas") && (F = !0);
            }
          );
          var Y =
              (!!window.webkitRTCPeerConnection ||
                !!window.webkitGetUserMedia) &&
              !!window.chrome,
            J = 50,
            X = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
          Y && X && X[2] && (J = parseInt(X[2], 10)),
            Y && J < 52 && (F = !1),
            I.useWhammyRecorder && (F = !1);
          var Z, te;
          if (F)
            if ((I.disableLogs, M instanceof HTMLCanvasElement)) Z = M;
            else if (M instanceof CanvasRenderingContext2D) Z = M.canvas;
            else
              throw "Please pass either HTMLCanvasElement or CanvasRenderingContext2D.";
          else
            navigator.mozGetUserMedia &&
              (I.disableLogs ||
                console.error("Canvas recording is NOT supported in Firefox."));
          var ce;
          (this.record = function () {
            if (((ce = !0), F && !I.useWhammyRecorder)) {
              var De;
              "captureStream" in Z
                ? (De = Z.captureStream(25))
                : "mozCaptureStream" in Z
                ? (De = Z.mozCaptureStream(25))
                : "webkitCaptureStream" in Z &&
                  (De = Z.webkitCaptureStream(25));
              try {
                var ge = new w();
                ge.addTrack(R(De, "video")[0]), (De = ge);
              } catch {}
              if (!De) throw "captureStream API are NOT available.";
              (te = new V(De, { mimeType: I.mimeType || "video/webm" })),
                te.record();
            } else (Ee.frames = []), (ve = new Date().getTime()), K();
            I.initCallback && I.initCallback();
          }),
            (this.getWebPImages = function (De) {
              if (M.nodeName.toLowerCase() !== "canvas") {
                De();
                return;
              }
              var ge = Ee.frames.length;
              Ee.frames.forEach(function (re, fe) {
                var ke = ge - fe;
                I.disableLogs || ke + "" + ge,
                  I.onEncodingCallback && I.onEncodingCallback(ke, ge);
                var ne = re.image.toDataURL("image/webp", 1);
                Ee.frames[fe].image = ne;
              }),
                I.disableLogs,
                De();
            }),
            (this.stop = function (De) {
              ce = !1;
              var ge = this;
              if (F && te) {
                te.stop(De);
                return;
              }
              this.getWebPImages(function () {
                Ee.compile(function (re) {
                  I.disableLogs,
                    (ge.blob = re),
                    ge.blob.forEach &&
                      (ge.blob = new Blob([], { type: "video/webm" })),
                    De && De(ge.blob),
                    (Ee.frames = []);
                });
              });
            });
          var pe = !1;
          (this.pause = function () {
            if (((pe = !0), te instanceof V)) {
              te.pause();
              return;
            }
          }),
            (this.resume = function () {
              if (((pe = !1), te instanceof V)) {
                te.resume();
                return;
              }
              ce || this.record();
            }),
            (this.clearRecordedData = function () {
              ce && this.stop(se), se();
            });
          function se() {
            (Ee.frames = []), (ce = !1), (pe = !1);
          }
          (this.name = "CanvasRecorder"),
            (this.toString = function () {
              return this.name;
            });
          function be() {
            var De = document.createElement("canvas"),
              ge = De.getContext("2d");
            return (
              (De.width = M.width),
              (De.height = M.height),
              ge.drawImage(M, 0, 0),
              De
            );
          }
          function K() {
            if (pe) return (ve = new Date().getTime()), setTimeout(K, 500);
            if (M.nodeName.toLowerCase() === "canvas") {
              var De = new Date().getTime() - ve;
              (ve = new Date().getTime()),
                Ee.frames.push({ image: be(), duration: De }),
                ce && setTimeout(K, I.frameInterval);
              return;
            }
            html2canvas(M, {
              grabMouse: typeof I.showMousePointer > "u" || I.showMousePointer,
              onrendered: function (ge) {
                var re = new Date().getTime() - ve;
                if (!re) return setTimeout(K, I.frameInterval);
                (ve = new Date().getTime()),
                  Ee.frames.push({
                    image: ge.toDataURL("image/webp", 1),
                    duration: re,
                  }),
                  ce && setTimeout(K, I.frameInterval);
              },
            });
          }
          var ve = new Date().getTime(),
            Ee = new z.Video(100);
        }
        typeof e < "u" && (e.CanvasRecorder = W);
        /**
         * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.
         * @summary Video recording feature in Chrome.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef WhammyRecorder
         * @class
         * @example
         * var recorder = new WhammyRecorder(mediaStream);
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}
         */ function H(M, I) {
          (I = I || {}),
            I.frameInterval || (I.frameInterval = 10),
            I.disableLogs || I.frameInterval,
            (this.record = function () {
              I.width || (I.width = 320),
                I.height || (I.height = 240),
                I.video || (I.video = { width: I.width, height: I.height }),
                I.canvas || (I.canvas = { width: I.width, height: I.height }),
                (ce.width = I.canvas.width || 320),
                (ce.height = I.canvas.height || 240),
                (pe = ce.getContext("2d")),
                I.video && I.video instanceof HTMLVideoElement
                  ? ((se = I.video.cloneNode()),
                    I.initCallback && I.initCallback())
                  : ((se = document.createElement("video")),
                    C(M, se),
                    (se.onloadedmetadata = function () {
                      I.initCallback && I.initCallback();
                    }),
                    (se.width = I.video.width),
                    (se.height = I.video.height)),
                (se.muted = !0),
                se.play(),
                (be = new Date().getTime()),
                (K = new z.Video()),
                I.disableLogs ||
                  (ce.width,
                  ce.height,
                  se.width || ce.width,
                  se.height || ce.height),
                F(I.frameInterval);
            });
          function F(ve) {
            ve = typeof ve < "u" ? ve : 10;
            var Ee = new Date().getTime() - be;
            if (!Ee) return setTimeout(F, ve, ve);
            if (Z) return (be = new Date().getTime()), setTimeout(F, 100);
            (be = new Date().getTime()),
              se.paused && se.play(),
              pe.drawImage(se, 0, 0, ce.width, ce.height),
              K.frames.push({
                duration: Ee,
                image: ce.toDataURL("image/webp"),
              }),
              X || setTimeout(F, ve, ve);
          }
          function Y(ve) {
            var Ee = -1,
              De = ve.length;
            (function ge() {
              if ((Ee++, Ee === De)) {
                ve.callback();
                return;
              }
              setTimeout(function () {
                ve.functionToLoop(ge, Ee);
              }, 1);
            })();
          }
          function J(ve, Ee, De, ge, re) {
            var fe = document.createElement("canvas");
            (fe.width = ce.width), (fe.height = ce.height);
            var ke = fe.getContext("2d"),
              ne = [],
              ie = ve.length,
              Ne = { r: 0, g: 0, b: 0 },
              $e = Math.sqrt(
                Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)
              ),
              ot = 0,
              st = 0,
              ht = !1;
            Y({
              length: ie,
              functionToLoop: function (xt, _e) {
                var Ue,
                  He,
                  Ve,
                  Ze = function () {
                    (!ht && Ve - Ue <= Ve * st) || ((ht = !0), ne.push(ve[_e])),
                      xt();
                  };
                if (ht) Ze();
                else {
                  var ct = new Image();
                  (ct.onload = function () {
                    ke.drawImage(ct, 0, 0, ce.width, ce.height);
                    var ft = ke.getImageData(0, 0, ce.width, ce.height);
                    (Ue = 0), (He = ft.data.length), (Ve = ft.data.length / 4);
                    for (var Ye = 0; Ye < He; Ye += 4) {
                      var Ot = {
                          r: ft.data[Ye],
                          g: ft.data[Ye + 1],
                          b: ft.data[Ye + 2],
                        },
                        $t = Math.sqrt(
                          Math.pow(Ot.r - Ne.r, 2) +
                            Math.pow(Ot.g - Ne.g, 2) +
                            Math.pow(Ot.b - Ne.b, 2)
                        );
                      $t <= $e * ot && Ue++;
                    }
                    Ze();
                  }),
                    (ct.src = ve[_e].image);
                }
              },
              callback: function () {
                (ne = ne.concat(ve.slice(ie))),
                  ne.length <= 0 && ne.push(ve[ve.length - 1]),
                  re(ne);
              },
            });
          }
          var X = !1;
          this.stop = function (ve) {
            (ve = ve || function () {}), (X = !0);
            var Ee = this;
            setTimeout(function () {
              J(K.frames, -1, null, null, function (De) {
                (K.frames = De),
                  I.advertisement &&
                    I.advertisement.length &&
                    (K.frames = I.advertisement.concat(K.frames)),
                  K.compile(function (ge) {
                    (Ee.blob = ge),
                      Ee.blob.forEach &&
                        (Ee.blob = new Blob([], { type: "video/webm" })),
                      ve && ve(Ee.blob);
                  });
              });
            }, 10);
          };
          var Z = !1;
          (this.pause = function () {
            Z = !0;
          }),
            (this.resume = function () {
              (Z = !1), X && this.record();
            }),
            (this.clearRecordedData = function () {
              X || this.stop(te), te();
            });
          function te() {
            (K.frames = []), (X = !0), (Z = !1);
          }
          (this.name = "WhammyRecorder"),
            (this.toString = function () {
              return this.name;
            });
          var ce = document.createElement("canvas"),
            pe = ce.getContext("2d"),
            se,
            be,
            K;
        }
        typeof e < "u" && (e.WhammyRecorder = H);
        /**
         * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}
         * @summary A real time javascript webm encoder based on a canvas hack.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef Whammy
         * @class
         * @example
         * var recorder = new Whammy().Video(15);
         * recorder.add(context || canvas || dataURL);
         * var output = recorder.compile();
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         */ var z = (function () {
          function M(Y) {
            (this.frames = []), (this.duration = Y || 1), (this.quality = 0.8);
          }
          M.prototype.add = function (Y, J) {
            if (
              ("canvas" in Y && (Y = Y.canvas),
              "toDataURL" in Y && (Y = Y.toDataURL("image/webp", this.quality)),
              !/^data:image\/webp;base64,/gi.test(Y))
            )
              throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";
            this.frames.push({ image: Y, duration: J || this.duration });
          };
          function I(Y) {
            var J = h.createObjectURL(
                new Blob(
                  [
                    Y.toString(),
                    "this.onmessage =  function (eee) {" +
                      Y.name +
                      "(eee.data);}",
                  ],
                  { type: "application/javascript" }
                )
              ),
              X = new Worker(J);
            return h.revokeObjectURL(J), X;
          }
          function F(Y) {
            function J(re) {
              var fe = Z(re);
              if (!fe) return [];
              for (
                var ke = 3e4,
                  ne = [
                    {
                      id: 440786851,
                      data: [
                        { data: 1, id: 17030 },
                        { data: 1, id: 17143 },
                        { data: 4, id: 17138 },
                        { data: 8, id: 17139 },
                        { data: "webm", id: 17026 },
                        { data: 2, id: 17031 },
                        { data: 2, id: 17029 },
                      ],
                    },
                    {
                      id: 408125543,
                      data: [
                        {
                          id: 357149030,
                          data: [
                            { data: 1e6, id: 2807729 },
                            { data: "whammy", id: 19840 },
                            { data: "whammy", id: 22337 },
                            { data: De(fe.duration), id: 17545 },
                          ],
                        },
                        {
                          id: 374648427,
                          data: [
                            {
                              id: 174,
                              data: [
                                { data: 1, id: 215 },
                                { data: 1, id: 29637 },
                                { data: 0, id: 156 },
                                { data: "und", id: 2274716 },
                                { data: "V_VP8", id: 134 },
                                { data: "VP8", id: 2459272 },
                                { data: 1, id: 131 },
                                {
                                  id: 224,
                                  data: [
                                    { data: fe.width, id: 176 },
                                    { data: fe.height, id: 186 },
                                  ],
                                },
                              ],
                            },
                          ],
                        },
                      ],
                    },
                  ],
                  ie = 0,
                  Ne = 0;
                ie < re.length;

              ) {
                var $e = [],
                  ot = 0;
                do $e.push(re[ie]), (ot += re[ie].duration), ie++;
                while (ie < re.length && ot < ke);
                var st = 0,
                  ht = { id: 524531317, data: X(Ne, st, $e) };
                ne[1].data.push(ht), (Ne += ot);
              }
              return se(ne);
            }
            function X(re, fe, ke) {
              return [{ data: re, id: 231 }].concat(
                ke.map(function (ne) {
                  var ie = be({
                    frame: ne.data.slice(4),
                    trackNum: 1,
                    timecode: Math.round(fe),
                  });
                  return (fe += ne.duration), { data: ie, id: 163 };
                })
              );
            }
            function Z(re) {
              if (!re[0]) {
                postMessage({
                  error:
                    "Something went wrong. Maybe WebP format is not supported in the current browser.",
                });
                return;
              }
              for (
                var fe = re[0].width,
                  ke = re[0].height,
                  ne = re[0].duration,
                  ie = 1;
                ie < re.length;
                ie++
              )
                ne += re[ie].duration;
              return { duration: ne, width: fe, height: ke };
            }
            function te(re) {
              for (var fe = []; re > 0; ) fe.push(re & 255), (re = re >> 8);
              return new Uint8Array(fe.reverse());
            }
            function ce(re) {
              return new Uint8Array(
                re.split("").map(function (fe) {
                  return fe.charCodeAt(0);
                })
              );
            }
            function pe(re) {
              var fe = [],
                ke =
                  re.length % 8 ? new Array(9 - (re.length % 8)).join("0") : "";
              re = ke + re;
              for (var ne = 0; ne < re.length; ne += 8)
                fe.push(parseInt(re.substr(ne, 8), 2));
              return new Uint8Array(fe);
            }
            function se(re) {
              for (var fe = [], ke = 0; ke < re.length; ke++) {
                var ne = re[ke].data;
                typeof ne == "object" && (ne = se(ne)),
                  typeof ne == "number" && (ne = pe(ne.toString(2))),
                  typeof ne == "string" && (ne = ce(ne));
                var ie = ne.size || ne.byteLength || ne.length,
                  Ne = Math.ceil(Math.ceil(Math.log(ie) / Math.log(2)) / 8),
                  $e = ie.toString(2),
                  ot = new Array(Ne * 7 + 7 + 1 - $e.length).join("0") + $e,
                  st = new Array(Ne).join("0") + "1" + ot;
                fe.push(te(re[ke].id)), fe.push(pe(st)), fe.push(ne);
              }
              return new Blob(fe, { type: "video/webm" });
            }
            function be(re) {
              var fe = 0;
              fe |= 128;
              var ke =
                [re.trackNum | 128, re.timecode >> 8, re.timecode & 255, fe]
                  .map(function (ne) {
                    return String.fromCharCode(ne);
                  })
                  .join("") + re.frame;
              return ke;
            }
            function K(re) {
              for (
                var fe = re.RIFF[0].WEBP[0],
                  ke = fe.indexOf("*"),
                  ne = 0,
                  ie = [];
                ne < 4;
                ne++
              )
                ie[ne] = fe.charCodeAt(ke + 3 + ne);
              var Ne, $e, ot;
              return (
                (ot = (ie[1] << 8) | ie[0]),
                (Ne = ot & 16383),
                (ot = (ie[3] << 8) | ie[2]),
                ($e = ot & 16383),
                { width: Ne, height: $e, data: fe, riff: re }
              );
            }
            function ve(re, fe) {
              return parseInt(
                re
                  .substr(fe + 4, 4)
                  .split("")
                  .map(function (ke) {
                    var ne = ke.charCodeAt(0).toString(2);
                    return new Array(8 - ne.length + 1).join("0") + ne;
                  })
                  .join(""),
                2
              );
            }
            function Ee(re) {
              for (var fe = 0, ke = {}; fe < re.length; ) {
                var ne = re.substr(fe, 4),
                  ie = ve(re, fe),
                  Ne = re.substr(fe + 4 + 4, ie);
                (fe += 8 + ie),
                  (ke[ne] = ke[ne] || []),
                  ne === "RIFF" || ne === "LIST"
                    ? ke[ne].push(Ee(Ne))
                    : ke[ne].push(Ne);
              }
              return ke;
            }
            function De(re) {
              return [].slice
                .call(new Uint8Array(new Float64Array([re]).buffer), 0)
                .map(function (fe) {
                  return String.fromCharCode(fe);
                })
                .reverse()
                .join("");
            }
            var ge = new J(
              Y.map(function (re) {
                var fe = K(Ee(atob(re.image.slice(23))));
                return (fe.duration = re.duration), fe;
              })
            );
            postMessage(ge);
          }
          return (
            (M.prototype.compile = function (Y) {
              var J = I(F);
              (J.onmessage = function (X) {
                if (X.data.error) {
                  console.error(X.data.error);
                  return;
                }
                Y(X.data);
              }),
                J.postMessage(this.frames);
            }),
            { Video: M }
          );
        })();
        typeof e < "u" && (e.Whammy = z);
        /**
         * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.
         * @summary Writing blobs into IndexedDB.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @example
         * DiskStorage.Store({
         *     audioBlob: yourAudioBlob,
         *     videoBlob: yourVideoBlob,
         *     gifBlob  : yourGifBlob
         * });
         * DiskStorage.Fetch(function(dataURL, type) {
         *     if(type === 'audioBlob') { }
         *     if(type === 'videoBlob') { }
         *     if(type === 'gifBlob')   { }
         * });
         * // DiskStorage.dataStoreName = 'recordRTC';
         * // DiskStorage.onError = function(error) { };
         * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
         * @property {function} Fetch - This method fetches stored blobs from IndexedDB.
         * @property {function} Store - This method stores blobs in IndexedDB.
         * @property {function} onError - This function is invoked for any known/unknown error.
         * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         */ var B = {
          init: function () {
            var M = this;
            if (typeof indexedDB > "u" || typeof indexedDB.open > "u") {
              console.error("IndexedDB API are not available in this browser.");
              return;
            }
            var I = 1,
              F =
                this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ""),
              Y,
              J = indexedDB.open(F, I);
            function X(te) {
              te.createObjectStore(M.dataStoreName);
            }
            function Z() {
              var te = Y.transaction([M.dataStoreName], "readwrite");
              M.videoBlob &&
                te.objectStore(M.dataStoreName).put(M.videoBlob, "videoBlob"),
                M.gifBlob &&
                  te.objectStore(M.dataStoreName).put(M.gifBlob, "gifBlob"),
                M.audioBlob &&
                  te.objectStore(M.dataStoreName).put(M.audioBlob, "audioBlob");
              function ce(pe) {
                te.objectStore(M.dataStoreName).get(pe).onsuccess = function (
                  se
                ) {
                  M.callback && M.callback(se.target.result, pe);
                };
              }
              ce("audioBlob"), ce("videoBlob"), ce("gifBlob");
            }
            (J.onerror = M.onError),
              (J.onsuccess = function () {
                if (((Y = J.result), (Y.onerror = M.onError), Y.setVersion))
                  if (Y.version !== I) {
                    var te = Y.setVersion(I);
                    te.onsuccess = function () {
                      X(Y), Z();
                    };
                  } else Z();
                else Z();
              }),
              (J.onupgradeneeded = function (te) {
                X(te.target.result);
              });
          },
          Fetch: function (M) {
            return (this.callback = M), this.init(), this;
          },
          Store: function (M) {
            return (
              (this.audioBlob = M.audioBlob),
              (this.videoBlob = M.videoBlob),
              (this.gifBlob = M.gifBlob),
              this.init(),
              this
            );
          },
          onError: function (M) {
            console.error(JSON.stringify(M, null, "	"));
          },
          dataStoreName: "recordRTC",
          dbName: null,
        };
        typeof e < "u" && (e.DiskStorage = B);
        /**
         * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef GifRecorder
         * @class
         * @example
         * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });
         * recorder.record();
         * recorder.stop(function(blob) {
         *     img.src = URL.createObjectURL(blob);
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.
         * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}
         */ function q(M, I) {
          if (typeof GIFEncoder > "u") {
            var F = document.createElement("script");
            (F.src = "https://www.webrtc-experiment.com/gif-recorder.js"),
              (document.body || document.documentElement).appendChild(F);
          }
          I = I || {};
          var Y =
            M instanceof CanvasRenderingContext2D ||
            M instanceof HTMLCanvasElement;
          (this.record = function () {
            if (typeof GIFEncoder > "u") {
              setTimeout(ve.record, 1e3);
              return;
            }
            if (!ce) {
              setTimeout(ve.record, 1e3);
              return;
            }
            Y ||
              (I.width || (I.width = pe.offsetWidth || 320),
              I.height || (I.height = pe.offsetHeight || 240),
              I.video || (I.video = { width: I.width, height: I.height }),
              I.canvas || (I.canvas = { width: I.width, height: I.height }),
              (Z.width = I.canvas.width || 320),
              (Z.height = I.canvas.height || 240),
              (pe.width = I.video.width || 320),
              (pe.height = I.video.height || 240)),
              (K = new GIFEncoder()),
              K.setRepeat(0),
              K.setDelay(I.frameRate || 200),
              K.setQuality(I.quality || 10),
              K.start(),
              typeof I.onGifRecordingStarted == "function" &&
                I.onGifRecordingStarted();
            function Ee(De) {
              if (ve.clearedRecordedData !== !0) {
                if (J)
                  return setTimeout(function () {
                    Ee(De);
                  }, 100);
                (se = a(Ee)),
                  typeof be === void 0 && (be = De),
                  !(De - be < 90) &&
                    (!Y && pe.paused && pe.play(),
                    Y || te.drawImage(pe, 0, 0, Z.width, Z.height),
                    I.onGifPreview && I.onGifPreview(Z.toDataURL("image/png")),
                    K.addFrame(te),
                    (be = De));
              }
            }
            (se = a(Ee)), I.initCallback && I.initCallback();
          }),
            (this.stop = function (Ee) {
              (Ee = Ee || function () {}),
                se && l(se),
                (this.blob = new Blob([new Uint8Array(K.stream().bin)], {
                  type: "image/gif",
                })),
                Ee(this.blob),
                (K.stream().bin = []);
            });
          var J = !1;
          (this.pause = function () {
            J = !0;
          }),
            (this.resume = function () {
              J = !1;
            }),
            (this.clearRecordedData = function () {
              (ve.clearedRecordedData = !0), X();
            });
          function X() {
            K && (K.stream().bin = []);
          }
          (this.name = "GifRecorder"),
            (this.toString = function () {
              return this.name;
            });
          var Z = document.createElement("canvas"),
            te = Z.getContext("2d");
          Y &&
            (M instanceof CanvasRenderingContext2D
              ? ((te = M), (Z = te.canvas))
              : M instanceof HTMLCanvasElement &&
                ((te = M.getContext("2d")), (Z = M)));
          var ce = !0;
          if (!Y) {
            var pe = document.createElement("video");
            (pe.muted = !0),
              (pe.autoplay = !0),
              (pe.playsInline = !0),
              (ce = !1),
              (pe.onloadedmetadata = function () {
                ce = !0;
              }),
              C(M, pe),
              pe.play();
          }
          var se = null,
            be,
            K,
            ve = this;
        }
        typeof e < "u" && (e.GifRecorder = q);
        function O(M, I) {
          var F =
            "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
          (function (ne) {
            typeof e < "u" ||
              (ne &&
                (typeof window < "u" ||
                  typeof Yn > "u" ||
                  ((Yn.navigator = {
                    userAgent: F,
                    getUserMedia: function () {},
                  }),
                  Yn.console || (Yn.console = {}),
                  (typeof Yn.console.log > "u" ||
                    typeof Yn.console.error > "u") &&
                    (Yn.console.error = Yn.console.log =
                      Yn.console.log || function () {}),
                  typeof document > "u" &&
                    ((ne.document = {
                      documentElement: {
                        appendChild: function () {
                          return "";
                        },
                      },
                    }),
                    (document.createElement =
                      document.captureStream =
                      document.mozCaptureStream =
                        function () {
                          var ie = {
                            getContext: function () {
                              return ie;
                            },
                            play: function () {},
                            pause: function () {},
                            drawImage: function () {},
                            toDataURL: function () {
                              return "";
                            },
                            style: {},
                          };
                          return ie;
                        }),
                    (ne.HTMLVideoElement = function () {})),
                  typeof location > "u" &&
                    (ne.location = { protocol: "file:", href: "", hash: "" }),
                  typeof screen > "u" && (ne.screen = { width: 0, height: 0 }),
                  typeof pe > "u" &&
                    (ne.URL = {
                      createObjectURL: function () {
                        return "";
                      },
                      revokeObjectURL: function () {
                        return "";
                      },
                    }),
                  (ne.window = Yn))));
          })(typeof Yn < "u" ? Yn : null),
            (I = I || "multi-streams-mixer");
          var Y = [],
            J = !1,
            X = document.createElement("canvas"),
            Z = X.getContext("2d");
          (X.style.opacity = 0),
            (X.style.position = "absolute"),
            (X.style.zIndex = -1),
            (X.style.top = "-1000em"),
            (X.style.left = "-1000em"),
            (X.className = I),
            (document.body || document.documentElement).appendChild(X),
            (this.disableLogs = !1),
            (this.frameInterval = 10),
            (this.width = 360),
            (this.height = 240),
            (this.useGainNode = !0);
          var te = this,
            ce = window.AudioContext;
          typeof ce > "u" &&
            (typeof webkitAudioContext < "u" && (ce = webkitAudioContext),
            typeof mozAudioContext < "u" && (ce = mozAudioContext));
          var pe = window.URL;
          typeof pe > "u" && typeof webkitURL < "u" && (pe = webkitURL),
            typeof navigator < "u" &&
              typeof navigator.getUserMedia > "u" &&
              (typeof navigator.webkitGetUserMedia < "u" &&
                (navigator.getUserMedia = navigator.webkitGetUserMedia),
              typeof navigator.mozGetUserMedia < "u" &&
                (navigator.getUserMedia = navigator.mozGetUserMedia));
          var se = window.MediaStream;
          typeof se > "u" &&
            typeof webkitMediaStream < "u" &&
            (se = webkitMediaStream),
            typeof se < "u" &&
              typeof se.prototype.stop > "u" &&
              (se.prototype.stop = function () {
                this.getTracks().forEach(function (ne) {
                  ne.stop();
                });
              });
          var be = {};
          typeof ce < "u"
            ? (be.AudioContext = ce)
            : typeof webkitAudioContext < "u" &&
              (be.AudioContext = webkitAudioContext);
          function K(ne, ie) {
            "srcObject" in ie
              ? (ie.srcObject = ne)
              : "mozSrcObject" in ie
              ? (ie.mozSrcObject = ne)
              : (ie.srcObject = ne);
          }
          this.startDrawingFrames = function () {
            ve();
          };
          function ve() {
            if (!J) {
              var ne = Y.length,
                ie = !1,
                Ne = [];
              if (
                (Y.forEach(function (ot) {
                  ot.stream || (ot.stream = {}),
                    ot.stream.fullcanvas ? (ie = ot) : Ne.push(ot);
                }),
                ie)
              )
                (X.width = ie.stream.width), (X.height = ie.stream.height);
              else if (Ne.length) {
                X.width = ne > 1 ? Ne[0].width * 2 : Ne[0].width;
                var $e = 1;
                (ne === 3 || ne === 4) && ($e = 2),
                  (ne === 5 || ne === 6) && ($e = 3),
                  (ne === 7 || ne === 8) && ($e = 4),
                  (ne === 9 || ne === 10) && ($e = 5),
                  (X.height = Ne[0].height * $e);
              } else (X.width = te.width || 360), (X.height = te.height || 240);
              ie && ie instanceof HTMLVideoElement && Ee(ie),
                Ne.forEach(function (ot, st) {
                  Ee(ot, st);
                }),
                setTimeout(ve, te.frameInterval);
            }
          }
          function Ee(ne, ie) {
            if (!J) {
              var Ne = 0,
                $e = 0,
                ot = ne.width,
                st = ne.height;
              ie === 1 && (Ne = ne.width),
                ie === 2 && ($e = ne.height),
                ie === 3 && ((Ne = ne.width), ($e = ne.height)),
                ie === 4 && ($e = ne.height * 2),
                ie === 5 && ((Ne = ne.width), ($e = ne.height * 2)),
                ie === 6 && ($e = ne.height * 3),
                ie === 7 && ((Ne = ne.width), ($e = ne.height * 3)),
                typeof ne.stream.left < "u" && (Ne = ne.stream.left),
                typeof ne.stream.top < "u" && ($e = ne.stream.top),
                typeof ne.stream.width < "u" && (ot = ne.stream.width),
                typeof ne.stream.height < "u" && (st = ne.stream.height),
                Z.drawImage(ne, Ne, $e, ot, st),
                typeof ne.stream.onRender == "function" &&
                  ne.stream.onRender(Z, Ne, $e, ot, st, ie);
            }
          }
          function De() {
            J = !1;
            var ne = ge(),
              ie = re();
            return (
              ie &&
                ie
                  .getTracks()
                  .filter(function (Ne) {
                    return Ne.kind === "audio";
                  })
                  .forEach(function (Ne) {
                    ne.addTrack(Ne);
                  }),
              M.forEach(function (Ne) {
                Ne.fullcanvas;
              }),
              ne
            );
          }
          function ge() {
            ke();
            var ne;
            "captureStream" in X
              ? (ne = X.captureStream())
              : "mozCaptureStream" in X
              ? (ne = X.mozCaptureStream())
              : te.disableLogs ||
                console.error(
                  "Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features"
                );
            var ie = new se();
            return (
              ne
                .getTracks()
                .filter(function (Ne) {
                  return Ne.kind === "video";
                })
                .forEach(function (Ne) {
                  ie.addTrack(Ne);
                }),
              (X.stream = ie),
              ie
            );
          }
          function re() {
            be.AudioContextConstructor ||
              (be.AudioContextConstructor = new be.AudioContext()),
              (te.audioContext = be.AudioContextConstructor),
              (te.audioSources = []),
              te.useGainNode === !0 &&
                ((te.gainNode = te.audioContext.createGain()),
                te.gainNode.connect(te.audioContext.destination),
                (te.gainNode.gain.value = 0));
            var ne = 0;
            if (
              (M.forEach(function (ie) {
                if (
                  ie.getTracks().filter(function ($e) {
                    return $e.kind === "audio";
                  }).length
                ) {
                  ne++;
                  var Ne = te.audioContext.createMediaStreamSource(ie);
                  te.useGainNode === !0 && Ne.connect(te.gainNode),
                    te.audioSources.push(Ne);
                }
              }),
              !!ne)
            )
              return (
                (te.audioDestination =
                  te.audioContext.createMediaStreamDestination()),
                te.audioSources.forEach(function (ie) {
                  ie.connect(te.audioDestination);
                }),
                te.audioDestination.stream
              );
          }
          function fe(ne) {
            var ie = document.createElement("video");
            return (
              K(ne, ie),
              (ie.className = I),
              (ie.muted = !0),
              (ie.volume = 0),
              (ie.width = ne.width || te.width || 360),
              (ie.height = ne.height || te.height || 240),
              ie.play(),
              ie
            );
          }
          (this.appendStreams = function (ne) {
            if (!ne) throw "First parameter is required.";
            ne instanceof Array || (ne = [ne]),
              ne.forEach(function (ie) {
                var Ne = new se();
                if (
                  ie.getTracks().filter(function (st) {
                    return st.kind === "video";
                  }).length
                ) {
                  var $e = fe(ie);
                  ($e.stream = ie),
                    Y.push($e),
                    Ne.addTrack(
                      ie.getTracks().filter(function (st) {
                        return st.kind === "video";
                      })[0]
                    );
                }
                if (
                  ie.getTracks().filter(function (st) {
                    return st.kind === "audio";
                  }).length
                ) {
                  var ot = te.audioContext.createMediaStreamSource(ie);
                  (te.audioDestination =
                    te.audioContext.createMediaStreamDestination()),
                    ot.connect(te.audioDestination),
                    Ne.addTrack(
                      te.audioDestination.stream
                        .getTracks()
                        .filter(function (st) {
                          return st.kind === "audio";
                        })[0]
                    );
                }
                M.push(Ne);
              });
          }),
            (this.releaseStreams = function () {
              (Y = []),
                (J = !0),
                te.gainNode && (te.gainNode.disconnect(), (te.gainNode = null)),
                te.audioSources.length &&
                  (te.audioSources.forEach(function (ne) {
                    ne.disconnect();
                  }),
                  (te.audioSources = [])),
                te.audioDestination &&
                  (te.audioDestination.disconnect(),
                  (te.audioDestination = null)),
                te.audioContext && te.audioContext.close(),
                (te.audioContext = null),
                Z.clearRect(0, 0, X.width, X.height),
                X.stream && (X.stream.stop(), (X.stream = null));
            }),
            (this.resetVideoStreams = function (ne) {
              ne && !(ne instanceof Array) && (ne = [ne]), ke(ne);
            });
          function ke(ne) {
            (Y = []),
              (ne = ne || M),
              ne.forEach(function (ie) {
                if (
                  ie.getTracks().filter(function ($e) {
                    return $e.kind === "video";
                  }).length
                ) {
                  var Ne = fe(ie);
                  (Ne.stream = ie), Y.push(Ne);
                }
              });
          }
          (this.name = "MultiStreamsMixer"),
            (this.toString = function () {
              return this.name;
            }),
            (this.getMixedStream = De);
        }
        typeof e > "u" && (n.exports = O);
        /**
         * MultiStreamRecorder can record multiple videos in single container.
         * @summary Multi-videos recorder.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef MultiStreamRecorder
         * @class
         * @example
         * var options = {
         *     mimeType: 'video/webm'
         * }
         * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         *
         *     // or
         *     var blob = recorder.blob;
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStreams} mediaStreams - Array of MediaStreams.
         * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: "video/webm"}
         */ function U(M, I) {
          M = M || [];
          var F = this,
            Y,
            J;
          (I = I || {
            elementClass: "multi-streams-mixer",
            mimeType: "video/webm",
            video: { width: 360, height: 240 },
          }),
            I.frameInterval || (I.frameInterval = 10),
            I.video || (I.video = {}),
            I.video.width || (I.video.width = 360),
            I.video.height || (I.video.height = 240),
            (this.record = function () {
              (Y = new O(M, I.elementClass || "multi-streams-mixer")),
                X().length &&
                  ((Y.frameInterval = I.frameInterval || 10),
                  (Y.width = I.video.width || 360),
                  (Y.height = I.video.height || 240),
                  Y.startDrawingFrames()),
                I.previewStream &&
                  typeof I.previewStream == "function" &&
                  I.previewStream(Y.getMixedStream()),
                (J = new V(Y.getMixedStream(), I)),
                J.record();
            });
          function X() {
            var Z = [];
            return (
              M.forEach(function (te) {
                R(te, "video").forEach(function (ce) {
                  Z.push(ce);
                });
              }),
              Z
            );
          }
          (this.stop = function (Z) {
            J &&
              J.stop(function (te) {
                (F.blob = te), Z(te), F.clearRecordedData();
              });
          }),
            (this.pause = function () {
              J && J.pause();
            }),
            (this.resume = function () {
              J && J.resume();
            }),
            (this.clearRecordedData = function () {
              J && (J.clearRecordedData(), (J = null)),
                Y && (Y.releaseStreams(), (Y = null));
            }),
            (this.addStreams = function (Z) {
              if (!Z) throw "First parameter is required.";
              Z instanceof Array || (Z = [Z]),
                M.concat(Z),
                !(!J || !Y) &&
                  (Y.appendStreams(Z),
                  I.previewStream &&
                    typeof I.previewStream == "function" &&
                    I.previewStream(Y.getMixedStream()));
            }),
            (this.resetVideoStreams = function (Z) {
              Y &&
                (Z && !(Z instanceof Array) && (Z = [Z]),
                Y.resetVideoStreams(Z));
            }),
            (this.getMixer = function () {
              return Y;
            }),
            (this.name = "MultiStreamRecorder"),
            (this.toString = function () {
              return this.name;
            });
        }
        typeof e < "u" && (e.MultiStreamRecorder = U);
        /**
         * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}
         * @summary Promises for {@link RecordRTC}
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef RecordRTCPromisesHandler
         * @class
         * @example
         * var recorder = new RecordRTCPromisesHandler(mediaStream, options);
         * recorder.startRecording()
         *         .then(successCB)
         *         .catch(errorCB);
         * // Note: You can access all RecordRTC API using "recorder.recordRTC" e.g.
         * recorder.recordRTC.onStateChanged = function(state) {};
         * recorder.recordRTC.setRecordingDuration(5000);
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
         * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
         * @throws Will throw an error if "new" keyword is not used to initiate "RecordRTCPromisesHandler". Also throws error if first argument "MediaStream" is missing.
         * @requires {@link RecordRTC}
         */ function j(M, I) {
          if (!this) throw 'Use "new RecordRTCPromisesHandler()"';
          if (typeof M > "u") throw 'First argument "MediaStream" is required.';
          var F = this;
          (F.recordRTC = new e(M, I)),
            (this.startRecording = function () {
              return new Promise(function (Y, J) {
                try {
                  F.recordRTC.startRecording(), Y();
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.stopRecording = function () {
              return new Promise(function (Y, J) {
                try {
                  F.recordRTC.stopRecording(function (X) {
                    if (
                      ((F.blob = F.recordRTC.getBlob()),
                      !F.blob || !F.blob.size)
                    ) {
                      J("Empty blob.", F.blob);
                      return;
                    }
                    Y(X);
                  });
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.pauseRecording = function () {
              return new Promise(function (Y, J) {
                try {
                  F.recordRTC.pauseRecording(), Y();
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.resumeRecording = function () {
              return new Promise(function (Y, J) {
                try {
                  F.recordRTC.resumeRecording(), Y();
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.getDataURL = function (Y) {
              return new Promise(function (J, X) {
                try {
                  F.recordRTC.getDataURL(function (Z) {
                    J(Z);
                  });
                } catch (Z) {
                  X(Z);
                }
              });
            }),
            (this.getBlob = function () {
              return new Promise(function (Y, J) {
                try {
                  Y(F.recordRTC.getBlob());
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.getInternalRecorder = function () {
              return new Promise(function (Y, J) {
                try {
                  Y(F.recordRTC.getInternalRecorder());
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.reset = function () {
              return new Promise(function (Y, J) {
                try {
                  Y(F.recordRTC.reset());
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.destroy = function () {
              return new Promise(function (Y, J) {
                try {
                  Y(F.recordRTC.destroy());
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.getState = function () {
              return new Promise(function (Y, J) {
                try {
                  Y(F.recordRTC.getState());
                } catch (X) {
                  J(X);
                }
              });
            }),
            (this.blob = null),
            (this.version = "5.6.2");
        }
        typeof e < "u" && (e.RecordRTCPromisesHandler = j);
        /**
         * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.
         * @summary Video recording feature in Chrome, Firefox and maybe Edge.
         * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
         * @author {@link https://MuazKhan.com|Muaz Khan}
         * @typedef WebAssemblyRecorder
         * @class
         * @example
         * var recorder = new WebAssemblyRecorder(mediaStream);
         * recorder.record();
         * recorder.stop(function(blob) {
         *     video.src = URL.createObjectURL(blob);
         * });
         * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
         * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
         * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}
         */ function Q(M, I) {
          (typeof ReadableStream > "u" || typeof WritableStream > "u") &&
            console.error(
              "Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js"
            ),
            (I = I || {}),
            (I.width = I.width || 640),
            (I.height = I.height || 480),
            (I.frameRate = I.frameRate || 30),
            (I.bitrate = I.bitrate || 1200),
            (I.realtime = I.realtime || !0);
          var F;
          function Y() {
            return new ReadableStream({
              start: function (pe) {
                var se = document.createElement("canvas"),
                  be = document.createElement("video"),
                  K = !0;
                (be.srcObject = M),
                  (be.muted = !0),
                  (be.height = I.height),
                  (be.width = I.width),
                  (be.volume = 0),
                  (be.onplaying = function () {
                    (se.width = I.width), (se.height = I.height);
                    var ve = se.getContext("2d"),
                      Ee = 1e3 / I.frameRate,
                      De = setInterval(function () {
                        if (
                          (F && (clearInterval(De), pe.close()),
                          K &&
                            ((K = !1),
                            I.onVideoProcessStarted &&
                              I.onVideoProcessStarted()),
                          ve.drawImage(be, 0, 0),
                          pe._controlledReadableStream.state !== "closed")
                        )
                          try {
                            pe.enqueue(
                              ve.getImageData(0, 0, I.width, I.height)
                            );
                          } catch {}
                      }, Ee);
                  }),
                  be.play();
              },
            });
          }
          var J;
          function X(pe, se) {
            if (!I.workerPath && !se) {
              (F = !1),
                fetch(
                  "https://unpkg.com/webm-wasm@latest/dist/webm-worker.js"
                ).then(function (K) {
                  K.arrayBuffer().then(function (ve) {
                    X(pe, ve);
                  });
                });
              return;
            }
            if (!I.workerPath && se instanceof ArrayBuffer) {
              var be = new Blob([se], { type: "text/javascript" });
              I.workerPath = h.createObjectURL(be);
            }
            I.workerPath || console.error("workerPath parameter is missing."),
              (J = new Worker(I.workerPath)),
              J.postMessage(
                I.webAssemblyPath ||
                  "https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm"
              ),
              J.addEventListener("message", function (K) {
                K.data === "READY"
                  ? (J.postMessage({
                      width: I.width,
                      height: I.height,
                      bitrate: I.bitrate || 1200,
                      timebaseDen: I.frameRate || 30,
                      realtime: I.realtime,
                    }),
                    Y().pipeTo(
                      new WritableStream({
                        write: function (ve) {
                          if (F) {
                            console.error(
                              "Got image, but recorder is finished!"
                            );
                            return;
                          }
                          J.postMessage(ve.data.buffer, [ve.data.buffer]);
                        },
                      })
                    ))
                  : K.data && (Z || ce.push(K.data));
              });
          }
          this.record = function () {
            (ce = []),
              (Z = !1),
              (this.blob = null),
              X(M),
              typeof I.initCallback == "function" && I.initCallback();
          };
          var Z;
          (this.pause = function () {
            Z = !0;
          }),
            (this.resume = function () {
              Z = !1;
            });
          function te(pe) {
            if (!J) {
              pe && pe();
              return;
            }
            J.addEventListener("message", function (se) {
              se.data === null && (J.terminate(), (J = null), pe && pe());
            }),
              J.postMessage(null);
          }
          var ce = [];
          (this.stop = function (pe) {
            F = !0;
            var se = this;
            te(function () {
              (se.blob = new Blob(ce, { type: "video/webm" })), pe(se.blob);
            });
          }),
            (this.name = "WebAssemblyRecorder"),
            (this.toString = function () {
              return this.name;
            }),
            (this.clearRecordedData = function () {
              (ce = []), (Z = !1), (this.blob = null);
            }),
            (this.blob = null);
        }
        typeof e < "u" && (e.WebAssemblyRecorder = Q);
      })(U1)),
    U1.exports
  );
}
var Pk = q0e();
const l$ = ad(Pk);
class C7 {
  recordRTC = null;
  audioRecordRTC = null;
  stream;
  options;
  chunks = [];
  audioChunks = [];
  _state = "inactive";
  dataAvailableInterval = null;
  timeSliceMs = 100;
  enableParallelAudioRecording = !0;
  ondataavailable = null;
  onstop = null;
  onstart = null;
  onerror = null;
  onpause = null;
  onresume = null;
  constructor(e, t = {}) {
    (this.stream = e), (this.options = t);
  }
  get state() {
    return this._state;
  }
  get mimeType() {
    return this.options.mimeType || 'video/webm;codecs="vp8,opus"';
  }
  start(e) {
    if (this._state !== "inactive") {
      console.warn(
        "[RecordRTCWrapper] Cannot start recording - already recording or paused"
      );
      return;
    }
    e && (this.timeSliceMs = e);
    try {
      const t = this.getRecordRTCOptions();
      (this.recordRTC = new l$(this.stream, t)),
        (this.chunks = []),
        (this.audioChunks = []),
        (this._state = "recording"),
        this.recordRTC.startRecording();
      const s = this.stream.getAudioTracks();
      if (this.enableParallelAudioRecording && s.length > 0) {
        const r = new MediaStream(s),
          i = {
            type: "audio",
            mimeType: "audio/webm",
            recorderType: Pk.MediaStreamRecorder,
            audioBitsPerSecond: 64e3,
            disableLogs: !0,
          };
        (this.audioRecordRTC = new l$(r, i)),
          this.audioRecordRTC.startRecording();
      }
      e && this.ondataavailable && this.setupPeriodicDataEvents(),
        this.onstart && this.onstart();
    } catch (t) {
      console.error("[RecordRTCWrapper] Failed to start recording:", t),
        (this._state = "inactive"),
        this.onerror && this.onerror(new Event("error"));
    }
  }
  stop() {
    if (this._state === "inactive") {
      console.warn("[RecordRTCWrapper] Cannot stop recording - not recording");
      return;
    }
    if (!this.recordRTC) {
      console.error("[RecordRTCWrapper] RecordRTC instance not found");
      return;
    }
    try {
      this.dataAvailableInterval &&
        (clearInterval(this.dataAvailableInterval),
        (this.dataAvailableInterval = null)),
        this.audioRecordRTC &&
          this.audioRecordRTC.stopRecording(() => {
            if (this.audioRecordRTC) {
              const e = this.audioRecordRTC.getBlob();
              this.audioChunks.push(e), e.size;
            }
          }),
        this.recordRTC.stopRecording(() => {
          if (!this.recordRTC) return;
          const e = this.recordRTC.getBlob();
          if ((this.chunks.push(e), this.ondataavailable)) {
            const t = new Mk("dataavailable", { data: e });
            this.ondataavailable(t);
          }
          (this._state = "inactive"), this.onstop && this.onstop(), e.size;
        });
    } catch (e) {
      console.error("[RecordRTCWrapper] Failed to stop recording:", e),
        (this._state = "inactive"),
        this.onerror && this.onerror(new Event("error"));
    }
  }
  pause() {
    if (this._state !== "recording") {
      console.warn("[RecordRTCWrapper] Cannot pause - not recording");
      return;
    }
    if (!this.recordRTC) {
      console.error("[RecordRTCWrapper] RecordRTC instance not found");
      return;
    }
    try {
      this.recordRTC.pauseRecording(),
        (this._state = "paused"),
        this.dataAvailableInterval &&
          (clearInterval(this.dataAvailableInterval),
          (this.dataAvailableInterval = null)),
        this.onpause && this.onpause();
    } catch (e) {
      console.error("[RecordRTCWrapper] Failed to pause recording:", e),
        this.onerror && this.onerror(new Event("error"));
    }
  }
  resume() {
    if (this._state !== "paused") {
      console.warn("[RecordRTCWrapper] Cannot resume - not paused");
      return;
    }
    if (!this.recordRTC) {
      console.error("[RecordRTCWrapper] RecordRTC instance not found");
      return;
    }
    try {
      this.recordRTC.resumeRecording(),
        (this._state = "recording"),
        this.timeSliceMs &&
          this.ondataavailable &&
          this.setupPeriodicDataEvents(),
        this.onresume && this.onresume();
    } catch (e) {
      console.error("[RecordRTCWrapper] Failed to resume recording:", e),
        this.onerror && this.onerror(new Event("error"));
    }
  }
  requestData() {
    if (this._state !== "recording") {
      console.warn("[RecordRTCWrapper] Cannot request data - not recording");
      return;
    }
  }
  getAudioBlob() {
    if (this.audioChunks.length > 0) {
      const e = new Blob(this.audioChunks, { type: "audio/webm;codecs=opus" });
      return `${e.size}`, e;
    }
    return null;
  }
  destroy() {
    if (
      (this.dataAvailableInterval &&
        (clearInterval(this.dataAvailableInterval),
        (this.dataAvailableInterval = null)),
      this.audioRecordRTC)
    ) {
      try {
        this._state === "recording" || this._state === "paused"
          ? this.audioRecordRTC.stopRecording(() => {
              this.audioRecordRTC && this.audioRecordRTC.destroy();
            })
          : this.audioRecordRTC.destroy();
      } catch (e) {
        console.warn("[RecordRTCWrapper] Error during audio cleanup:", e);
      }
      this.audioRecordRTC = null;
    }
    if (this.recordRTC) {
      try {
        this._state === "recording" || this._state === "paused"
          ? this.recordRTC.stopRecording(() => {
              this.recordRTC && this.recordRTC.destroy();
            })
          : this.recordRTC.destroy();
      } catch (e) {
        console.warn("[RecordRTCWrapper] Error during cleanup:", e);
      }
      this.recordRTC = null;
    }
    (this._state = "inactive"), (this.chunks = []), (this.audioChunks = []);
  }
  getRecordRTCOptions() {
    const e = this.options.mimeType || 'video/webm;codecs="vp8,opus"';
    let t = "video/webm";
    return (
      e.includes("mp4") && (t = "video/mp4"),
      e.includes("vp9") || e.includes("h264"),
      e.includes("aac"),
      {
        type: "video",
        mimeType: t,
        recorderType: Pk.MediaStreamRecorder,
        video: {
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 },
        },
        bitsPerSecond: this.options.videoBitsPerSecond || 25e5,
        videoBitsPerSecond: this.options.videoBitsPerSecond || 25e5,
        audioBitsPerSecond: this.options.audioBitsPerSecond || 128e3,
        quality: 0.8,
        disableLogs: !0,
        checkForInactiveTracks: !0,
        pauseRecordingOnOtherTabs: !1,
      }
    );
  }
  setupPeriodicDataEvents() {
    this.dataAvailableInterval && clearInterval(this.dataAvailableInterval),
      (this.dataAvailableInterval = setInterval(() => {
        if (this._state === "recording" && this.ondataavailable) {
          const e = new Blob([], { type: this.mimeType }),
            t = new Mk("dataavailable", { data: e });
          this.ondataavailable(t);
        }
      }, this.timeSliceMs));
  }
}
class Mk extends Event {
  data;
  constructor(e, t) {
    super(e), (this.data = t.data);
  }
}
typeof window < "u" && !window.BlobEvent && (window.BlobEvent = Mk);
const on = Di()(
    Vne(
      ha((n, e) => ({
        elements: {},
        isRecording: !1,
        recordingStream: null,
        recordingMediaRecorder: null,
        recordingChunks: [],
        recordingType: null,
        recordingStartTime: null,
        globalState: "idle",
        activeRecordingElementId: null,
        pendingRecordingType: null,
        isPermissionModalVisible: !1,
        hasRequestedPermission: !1,
        showPermissionConfirmation: !1,
        permissions: { camera: "prompt", microphone: "prompt" },
        settings: {
          availableCameras: [],
          availableMicrophones: [],
          selectedCameraId: null,
          selectedMicrophoneId: null,
        },
        isSettingsPopoverOpen: !1,
        startToolbarRecording: async (t, s) => {
          try {
            const r = e();
            if (r.isRecording)
              return (
                console.warn(
                  "[RecordingStore] Already recording - current state:",
                  {
                    isRecording: r.isRecording,
                    globalState: r.globalState,
                    recordingType: r.recordingType,
                    hasMediaRecorder: !!r.recordingMediaRecorder,
                    hasStream: !!r.recordingStream,
                  }
                ),
                !1
              );
            `${t}`;
            const i = 'video/webm;codecs="vp8,opus"',
              a = new C7(s, {
                mimeType: i,
                videoBitsPerSecond: t === "screen" ? 4e6 : 25e5,
              });
            (a.ondataavailable = (l) => {
              l.data &&
                l.data.size > 0 &&
                n((c) => {
                  c.recordingChunks.push(l.data);
                });
            }),
              a.start(100),
              n((l) => {
                (l.isRecording = !0),
                  (l.recordingStream = s),
                  (l.recordingMediaRecorder = a),
                  (l.recordingChunks = []),
                  (l.recordingType = t),
                  (l.recordingStartTime = Date.now());
              });
            const o = Ce.getState();
            return (
              Tb("started", {
                recording_type: t,
                flask_id: o.flaskId,
                method: "toolbar",
              }),
              !0
            );
          } catch (r) {
            return (
              console.error("[RecordingStore] Failed to start recording:", r),
              !1
            );
          }
        },
        stopToolbarRecording: async () =>
          new Promise((t) => {
            const { recordingMediaRecorder: s, recordingStream: r } = e();
            if (!s) {
              console.warn("[RecordingStore] No recording to stop"), t(null);
              return;
            }
            (s.onstop = () => {
              const i = e().recordingChunks;
              if (
                (`${i.length}`,
                i.reduce((a, o) => a + o.size, 0),
                r && r.getTracks().forEach((a) => a.stop()),
                i.length > 0)
              ) {
                const a = s.mimeType || "video/webm",
                  o = new Blob(i, { type: a });
                `${o.size}`;
                const l = s.getAudioBlob ? s.getAudioBlob() : null;
                l && `${l.size}`;
                const { recordingType: c, recordingStartTime: h } = e(),
                  m = Ce.getState(),
                  p = h ? (Date.now() - h) / 1e3 : 0;
                Tb("completed", {
                  recording_type: c,
                  duration_seconds: Math.round(p),
                  file_size_bytes: o.size,
                  has_audio: c === "thoughts" || c === "screen",
                  flask_id: m.flaskId,
                }),
                  n((g) => {
                    (g.isRecording = !1),
                      (g.recordingStream = null),
                      (g.recordingMediaRecorder = null),
                      (g.recordingChunks = []),
                      (g.recordingType = null),
                      (g.recordingStartTime = null);
                  }),
                  t({ videoBlob: o, audioBlob: l });
              } else
                console.warn("[RecordingStore] No chunks collected"),
                  n((a) => {
                    (a.isRecording = !1),
                      (a.recordingStream = null),
                      (a.recordingMediaRecorder = null),
                      (a.recordingChunks = []),
                      (a.recordingType = null),
                      (a.recordingStartTime = null);
                  }),
                  t(null);
            }),
              s.state === "recording"
                ? s.stop()
                : (console.warn(
                    `[RecordingStore] MediaRecorder not recording: ${s.state}`
                  ),
                  t(null));
          }),
        cancelToolbarRecording: async () => {
          const { recordingMediaRecorder: t, recordingStream: s } = e();
          if (t)
            try {
              t.state === "recording" && ((t.onstop = () => {}), t.stop());
            } catch (r) {
              console.error(
                "[RecordingStore] Error stopping media recorder:",
                r
              );
            }
          if (s)
            try {
              s.getTracks().forEach((r) => {
                r.stop(), `${r.kind}`;
              });
            } catch (r) {
              console.error("[RecordingStore] Error stopping tracks:", r);
            }
          n((r) => {
            (r.isRecording = !1),
              (r.recordingStream = null),
              (r.recordingMediaRecorder = null),
              (r.recordingChunks = []),
              (r.recordingType = null),
              (r.globalState = "idle"),
              (r.activeRecordingElementId = null);
          });
        },
        processRecordingBlob: async (
          t,
          s,
          r,
          i,
          a = "timeline",
          o = null,
          l = [],
          c = null,
          h,
          m
        ) => {
          `${t.size}`, m && `${m.size}`;
          const p = Ce.getState().flaskId;
          if (!p) throw new Error("No flask ID available");
          let g = null;
          try {
            const y = Ce.getState().createElement;
            let b;
            if (a === "element" && o) {
              const { useCanvasStore: q } = await Lt(async () => {
                  const { useCanvasStore: U } = await Promise.resolve().then(
                    () => R7
                  );
                  return { useCanvasStore: U };
                }, void 0),
                O = q.getState().findRootElementInThread(o);
              O
                ? ((b = [{ type: "element", targetElementId: O }]), `${O}${o}`)
                : (console.warn(
                    "[RecordingStore] Could not find root element, linking to original target"
                  ),
                  (b = [{ type: "element", targetElementId: o }]));
            } else
              c
                ? c.start === c.end
                  ? (b = [{ type: "timeline", timestamp: c.start }])
                  : (b = [
                      {
                        type: "timeline",
                        timeRange: { start: c.start, end: c.end },
                      },
                    ])
                : (b = [{ type: "timeline", timestamp: i }]);
            if (
              ((g = await y(
                "recording",
                {
                  position: r,
                  title:
                    s === "screen" ? "Screen Recording" : "Thoughts Recording",
                  recordingType: s,
                  links: b,
                  tagIds: l,
                },
                void 0,
                void 0
              )),
              !g)
            )
              throw new Error("Failed to create element");
            `${g}`;
            const w = URL.createObjectURL(t);
            n((q) => {
              q.elements[g] = {
                id: g,
                state: "preparing",
                type: s,
                uploadProgress: 0,
                localBlobUrl: w,
                recordingDurationSeconds: h,
                preparingStartTime: Date.now(),
              };
            }),
              setTimeout(() => {
                n((q) => {
                  q.elements[g]?.state === "preparing" &&
                    (q.elements[g].state = "uploading");
                });
              }, 5e3);
            const S = await Ut("/api/recordings/create", {
              method: "POST",
              body: JSON.stringify({ flaskId: p, recordingType: s }),
            });
            if (!S.ok) {
              const q = await S.text();
              throw (
                (console.error("[RecordingStore] Failed to create upload:", q),
                await Ce.getState().deleteElementsDirectly([g]),
                new Error("Failed to create recording upload"))
              );
            }
            const {
              uploadUrl: A,
              uploadId: _,
              recordingId: R,
            } = await S.json();
            await Ce.getState().updateElement(g, { recordingId: R }),
              Bt.capture("recording_saved", {
                recording_id: R,
                recording_type: s,
                element_id: g,
                flask_id: p,
                linking_mode: a,
                has_tags: l.length > 0,
              });
            try {
              await Ut(`/api/recordings/${R}/update`, {
                method: "PATCH",
                body: JSON.stringify({ elementId: g }),
              });
            } catch (q) {
              console.warn(
                "[RecordingStore] Failed to update recording with element_id:",
                q
              );
            }
            n((q) => {
              q.elements[g] &&
                ((q.elements[g].muxUploadId = _),
                (q.elements[g].recordingId = R));
            });
            try {
              const { useAIStore: q } = await Lt(async () => {
                  const { useAIStore: U } = await Promise.resolve().then(
                    () => Q0e
                  );
                  return { useAIStore: U };
                }, void 0),
                O = m || t;
              `${O.size}`, await q.getState().startProcessing(g, R, O);
            } catch (q) {
              console.error("[RecordingStore] AI processing failed:", q),
                await Ce.getState().updateElement(g, {
                  aiStatus: "failed",
                  aiError:
                    q instanceof Error ? q.message : "AI processing failed",
                  aiSummary: "Something went wrong in getting insights",
                });
            }
            const C = Date.now(),
              { useElementPersistence: D } = await Lt(async () => {
                const { useElementPersistence: q } =
                  await Promise.resolve().then(() => t$);
                return { useElementPersistence: q };
              }, void 0);
            D.getState().startUpload(),
              n((q) => {
                q.elements[g] && (q.elements[g].state = "uploading");
              }),
              await new Promise((q, O) => {
                const U = new XMLHttpRequest();
                U.upload.addEventListener("progress", (j) => {
                  if (j.lengthComputable) {
                    const Q = Math.round((j.loaded / j.total) * 100);
                    `${Q}`,
                      e().updateElementState(g, { uploadProgress: Q }),
                      Ce.getState().updateElement(g, { uploadProgress: Q });
                  }
                }),
                  U.addEventListener("load", () => {
                    `${U.status}`,
                      U.status === 200 || U.status === 201
                        ? q()
                        : (console.error(
                            `[RecordingStore] Upload failed: ${U.status}`,
                            U.responseText
                          ),
                          O(new Error(`Upload failed: ${U.status}`)));
                  }),
                  U.addEventListener("error", () => {
                    console.error("[RecordingStore] Upload error"),
                      O(new Error("Upload failed"));
                  }),
                  U.open("PUT", A),
                  U.setRequestHeader("Content-Type", t.type),
                  U.send(t);
              }),
              D.getState().endUpload();
            const L = Date.now(),
              P = C ? L - C : 0;
            Tb("uploaded", {
              recording_id: R,
              flask_id: p,
              upload_duration_ms: P,
              mux_asset_id: _,
              upload_method: "xhr",
            });
            const N = Ce.getState().boardState.elements[g],
              W = e().elements[g],
              H = await Ut("/api/recordings/complete", {
                method: "POST",
                body: JSON.stringify({ recordingId: R, uploadId: _ }),
              });
            if (!H.ok) {
              const q = await H.text();
              throw (
                (console.error(
                  "[RecordingStore] Failed to complete upload:",
                  q
                ),
                new Error("Failed to complete recording"))
              );
            }
            const z = await H.json(),
              { assetId: B } = z;
            e().updateElementState(g, {
              state: "processing",
              uploadProgress: 100,
              muxAssetId: B,
              muxProcessingStartTime: Date.now(),
            }),
              await Ce.getState().updateElement(g, {
                recordingState: "processing",
                muxAssetId: B,
              }),
              setTimeout(() => e().pollRecordingStatus(g), 3e3);
          } catch (y) {
            console.error("[RecordingStore] Failed to process recording:", y);
            const { useElementPersistence: b } = await Lt(async () => {
              const { useElementPersistence: w } = await Promise.resolve().then(
                () => t$
              );
              return { useElementPersistence: w };
            }, void 0);
            throw (b.getState().endUpload(), y);
          }
        },
        pollRecordingStatus: async (t) => {
          const s = e().getElementState(t);
          if (!s) {
            console.warn(`[RecordingStore] No element state for ${t}`);
            return;
          }
          if (s.state === "processing")
            try {
              `${t}`;
              const r = await Ut(`/api/recordings/${s.recordingId}/status`, {
                method: "POST",
              });
              if (!r.ok) {
                const a = await r.text();
                console.error("[RecordingStore] Status check failed:", a),
                  setTimeout(() => e().pollRecordingStatus(t), 1e4);
                return;
              }
              const i = await r.json();
              if (i.status === "ready" && i.hlsUrl) {
                i.hlsUrl, i.thumbnailUrl, i.aiStatus;
                const a = e().elements[t];
                a?.localBlobUrl && URL.revokeObjectURL(a.localBlobUrl),
                  e().updateElementState(t, {
                    state: "completed",
                    videoUrl: i.hlsUrl,
                    thumbnailUrl: i.thumbnailUrl,
                    duration: i.duration,
                    aiStatus: i.aiStatus,
                    aiInsights: i.aiInsights,
                    aiError: i.aiError,
                    localBlobUrl: void 0,
                  }),
                  await Ce.getState().updateElement(t, {
                    videoUrl: i.hlsUrl,
                    thumbnailUrl: i.thumbnailUrl,
                    duration: i.duration,
                    recordingState: "completed",
                    aiStatus: i.aiStatus,
                    aiInsights: i.aiInsights,
                    aiError: i.aiError,
                  });
              } else if (i.status === "error") {
                console.error("[RecordingStore] Recording processing failed");
                const a = e().elements[t];
                a?.localBlobUrl && URL.revokeObjectURL(a.localBlobUrl),
                  e().updateElementState(t, {
                    state: "error",
                    errorMessage: i.error || "Processing failed",
                    localBlobUrl: void 0,
                  }),
                  await Ce.getState().updateElement(t, {
                    recordingState: "error",
                    errorMessage: i.error,
                  });
              } else setTimeout(() => e().pollRecordingStatus(t), 5e3);
            } catch (r) {
              console.error("[RecordingStore] Error polling status:", r),
                setTimeout(() => e().pollRecordingStatus(t), 1e4);
            }
        },
        updateElementState: (t, s) => {
          n((r) => {
            r.elements[t] && Object.assign(r.elements[t], s);
          });
        },
        getElementState: (t) => e().elements[t],
        setMuxProcessingStartTime: (t) => {
          n((s) => {
            s.elements[t] &&
              (s.elements[t].muxProcessingStartTime = Date.now());
          });
        },
        checkPermissions: async () => {
          try {
            const t = await navigator.permissions.query({ name: "camera" }),
              s = await navigator.permissions.query({ name: "microphone" });
            n((r) => {
              (r.permissions.camera = t.state),
                (r.permissions.microphone = s.state);
            });
          } catch (t) {
            console.warn("Permission check failed:", t);
          }
        },
        requestPermissions: async (t) => {
          try {
            const s = {};
            return (
              (t === "camera" || t === "both") && (s.video = !0),
              (t === "microphone" || t === "both") && (s.audio = !0),
              (await navigator.mediaDevices.getUserMedia(s))
                .getTracks()
                .forEach((i) => i.stop()),
              await e().checkPermissions(),
              !0
            );
          } catch (s) {
            return console.error("Permission request failed:", s), !1;
          }
        },
        enumerateDevices: async () => {
          try {
            const t = await navigator.mediaDevices.enumerateDevices(),
              s = t.filter((i) => i.kind === "videoinput"),
              r = t.filter((i) => i.kind === "audioinput");
            n((i) => {
              (i.settings.availableCameras = s),
                (i.settings.availableMicrophones = r),
                !i.settings.selectedCameraId &&
                  s.length > 0 &&
                  (i.settings.selectedCameraId = s[0].deviceId),
                !i.settings.selectedMicrophoneId &&
                  r.length > 0 &&
                  (i.settings.selectedMicrophoneId = r[0].deviceId);
            });
          } catch (t) {
            console.error("Device enumeration failed:", t);
          }
        },
        setSelectedCamera: (t) => {
          n((s) => {
            s.settings.selectedCameraId = t;
          });
        },
        setSelectedMicrophone: (t) => {
          n((s) => {
            s.settings.selectedMicrophoneId = t;
          });
        },
        openSettingsPopover: () => {
          n((t) => {
            t.isSettingsPopoverOpen = !0;
          });
        },
        closeSettingsPopover: () => {
          n((t) => {
            t.isSettingsPopoverOpen = !1;
          });
        },
        debugSimulateNoPermissions: () => {
          n((t) => {
            (t.permissions.camera = "prompt"),
              (t.permissions.microphone = "prompt");
          });
        },
        setPendingRecordingType: (t) => {
          n((s) => {
            s.pendingRecordingType = t;
          });
        },
        showPermissionModal: () => {
          n((t) => {
            t.isPermissionModalVisible = !0;
          });
        },
        hidePermissionModal: () => {
          n((t) => {
            t.isPermissionModalVisible = !1;
          });
        },
        setHasRequestedPermission: (t) => {
          n((s) => {
            s.hasRequestedPermission = t;
          });
        },
        setShowPermissionConfirmation: (t) => {
          n((s) => {
            s.showPermissionConfirmation = t;
          });
        },
        prepareRecording: async (t) => {
          try {
            return (
              n((s) => {
                (s.globalState = "preparing"), (s.activeRecordingElementId = t);
              }),
              !0
            );
          } catch (s) {
            return (
              console.error("[RecordingStore] Failed to prepare recording:", s),
              !1
            );
          }
        },
        startRecording: async (t) => {
          try {
            return (
              n((s) => {
                (s.globalState = "recording"), (s.activeRecordingElementId = t);
              }),
              !0
            );
          } catch (s) {
            return (
              console.error("[RecordingStore] Failed to start recording:", s),
              !1
            );
          }
        },
        stopRecording: async () => {
          try {
            n((t) => {
              (t.globalState = "idle"), (t.activeRecordingElementId = null);
            });
          } catch (t) {
            console.error("[RecordingStore] Failed to stop recording:", t);
          }
        },
        cancelRecording: async () => {
          try {
            n((t) => {
              (t.globalState = "idle"), (t.activeRecordingElementId = null);
            });
          } catch (t) {
            console.error("[RecordingStore] Failed to cancel recording:", t);
          }
        },
        retryRecording: async (t) => {
          const s = e().getElementState(t);
          if (!s || s.state !== "error")
            return (
              console.warn(
                `[RecordingStore] Cannot retry recording for ${t}: not in error state`
              ),
              !1
            );
          try {
            return (
              n((r) => {
                r.elements[t] = {
                  ...r.elements[t],
                  state: "uploading",
                  uploadProgress: 0,
                  errorMessage: null,
                };
              }),
              `${t}`,
              !0
            );
          } catch (r) {
            return (
              console.error("[RecordingStore] Failed to retry recording:", r),
              !1
            );
          }
        },
        canStartRecording: () => {
          const t = e();
          return t.globalState === "idle" && !t.isRecording;
        },
        reset: () => {
          const { recordingStream: t, recordingMediaRecorder: s } = e();
          if ((s && s.state !== "inactive" && s.stop(), s))
            try {
              s.destroy();
            } catch (r) {
              console.warn("[RecordingStore] Error cleaning up RecordRTC:", r);
            }
          t && t.getTracks().forEach((r) => r.stop()),
            n((r) => {
              (r.elements = {}),
                (r.isRecording = !1),
                (r.recordingStream = null),
                (r.recordingMediaRecorder = null),
                (r.recordingChunks = []),
                (r.recordingType = null),
                (r.globalState = "idle"),
                (r.activeRecordingElementId = null),
                (r.pendingRecordingType = null),
                (r.isPermissionModalVisible = !1),
                (r.hasRequestedPermission = !1),
                (r.showPermissionConfirmation = !1);
            });
        },
        forceResetRecordingState: () => {
          const { recordingStream: t, recordingMediaRecorder: s } = e();
          if (s)
            try {
              s.state !== "inactive" && s.stop(), s.destroy();
            } catch (r) {
              console.warn(
                "[RecordingStore] Error stopping media recorder during force reset:",
                r
              );
            }
          if (t)
            try {
              t.getTracks().forEach((r) => {
                try {
                  r.stop();
                } catch (i) {
                  console.warn(
                    "[RecordingStore] Error stopping track during force reset:",
                    i
                  );
                }
              });
            } catch (r) {
              console.warn(
                "[RecordingStore] Error stopping tracks during force reset:",
                r
              );
            }
          n((r) => {
            (r.isRecording = !1),
              (r.recordingStream = null),
              (r.recordingMediaRecorder = null),
              (r.recordingChunks = []),
              (r.recordingType = null),
              (r.globalState = "idle"),
              (r.activeRecordingElementId = null),
              (r.pendingRecordingType = null),
              (r.isPermissionModalVisible = !1),
              (r.hasRequestedPermission = !1),
              (r.showPermissionConfirmation = !1);
          });
        },
      })),
      {
        name: "recording-store",
        partialize: (n) => ({ elements: n.elements, settings: n.settings }),
      }
    )
  ),
  $1 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, useRecordingStore: on },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  W0e = () => {
    const n = _H(),
      t = vt((i) => i.state) === "recording",
      s = on((i) => i.isRecording),
      r = $n((i) => i.saveStatus);
    E.useEffect(() => {
      if (!n) return;
      const i = () => !!(s || t || r === "error"),
        a = (o) => {
          if (i()) {
            const l =
              "Are you sure you want to leave? There might be unsaved changes.";
            return o.preventDefault(), (o.returnValue = l), l;
          }
        };
      return (
        window.addEventListener("beforeunload", a),
        () => {
          window.removeEventListener("beforeunload", a);
        }
      );
    }, [n, t, s, r]);
  },
  c$ = ({
    width: n = 48,
    height: e = 49,
    className: t = "",
    color: s = "currentColor",
  }) =>
    u.jsxs("svg", {
      width: n,
      height: e,
      viewBox: "0 0 48 49",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: t,
      children: [
        u.jsx("path", {
          d: "M38 8.5H10C7.79086 8.5 6 10.2909 6 12.5V28.5C6 30.7091 7.79086 32.5 10 32.5H38C40.2091 32.5 42 30.7091 42 28.5V12.5C42 10.2909 40.2091 8.5 38 8.5Z",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M4 40.5H44",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    }),
  K0e = ({
    width: n = 48,
    height: e = 49,
    className: t = "",
    color: s = "currentColor",
  }) =>
    u.jsxs("svg", {
      width: n,
      height: e,
      viewBox: "0 0 48 49",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: t,
      children: [
        u.jsx("path", {
          d: "M4 20.5V26.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M12 12.5V34.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M20 6.5V42.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M28 16.5V30.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M36 10.5V36.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
        u.jsx("path", {
          d: "M44 20.5V26.5",
          stroke: s,
          strokeWidth: "4",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        }),
      ],
    }),
  I7 = (n = {}) => {
    const {
        enabled: e = !0,
        onZoom: t,
        onPan: s,
        method: r = "event-delegation",
        transformWrapperRef: i = null,
      } = n,
      a = E.useRef(null),
      o = E.useCallback(
        (l) => {
          const c = l.ctrlKey || l.metaKey,
            h = !l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
          if (c || h) {
            l.preventDefault(), l.stopPropagation();
            const m = { x: l.clientX, y: l.clientY };
            if (c) {
              const p = l.deltaY > 0 ? 1 : -1;
              if (t) t(p, m);
              else if (i?.current) {
                const y = i.current.instance.wrapperComponent;
                if (y) {
                  const b = new WheelEvent("wheel", {
                    clientX: l.clientX,
                    clientY: l.clientY,
                    deltaY: l.deltaY,
                    deltaX: l.deltaX,
                    deltaZ: l.deltaZ,
                    ctrlKey: l.ctrlKey,
                    metaKey: l.metaKey,
                    altKey: l.altKey,
                    shiftKey: l.shiftKey,
                    bubbles: !0,
                    cancelable: !0,
                  });
                  y.dispatchEvent(b);
                }
              }
            } else if (h) {
              const p = l.deltaX,
                g = l.deltaY;
              if (s) s(p, g, m);
              else if (i?.current) {
                const b = i.current.instance.wrapperComponent;
                if (b) {
                  const w = new WheelEvent("wheel", {
                    clientX: l.clientX,
                    clientY: l.clientY,
                    deltaY: l.deltaY,
                    deltaX: l.deltaX,
                    deltaZ: l.deltaZ,
                    ctrlKey: l.ctrlKey,
                    metaKey: l.metaKey,
                    altKey: l.altKey,
                    shiftKey: l.shiftKey,
                    bubbles: !0,
                    cancelable: !0,
                  });
                  b.dispatchEvent(w);
                }
              }
            }
          }
        },
        [t, s, i]
      );
    return (
      E.useEffect(() => {
        const l = a.current;
        if (!(!e || !l)) {
          if (r === "event-delegation")
            return (
              l.addEventListener("wheel", o, { passive: !1 }),
              () => {
                l.removeEventListener("wheel", o);
              }
            );
          if (r === "css-override") {
            const c = {
              touchAction: l.style.touchAction,
              userSelect: l.style.userSelect,
            };
            (l.style.touchAction = "none"), (l.style.userSelect = "none");
            const h = (m) => {
              if (l.contains(m.target)) {
                const p = m.ctrlKey || m.metaKey,
                  g = !m.ctrlKey && !m.metaKey && !m.shiftKey && !m.altKey;
                (p || g) && o(m);
              }
            };
            return (
              document.addEventListener("wheel", h, { passive: !1 }),
              () => {
                (l.style.touchAction = c.touchAction),
                  (l.style.userSelect = c.userSelect),
                  document.removeEventListener("wheel", h);
              }
            );
          }
        }
      }, [e, o, r]),
      a
    );
  },
  cD = I7;
ese();
const Y0e = 200;
let va = null;
const fl = Di()(
    $a(
      ha((n, e) => ({
        pressedKeys: new Set(),
        isSpacePressed: !1,
        isSpaceHeld: !1,
        modifiers: { ctrl: !1, alt: !1, shift: !1, meta: !1 },
        isPanning: !1,
        isInInputElement: !1,
        isInFullscreen: !1,
        shortcuts: { enabled: !0, preventDefaults: !0 },
        setKeyPressed: (t, s) =>
          n((r) => {
            const i = new Set(r.pressedKeys);
            return (
              s ? i.add(t.toLowerCase()) : i.delete(t.toLowerCase()),
              { pressedKeys: i }
            );
          }),
        setSpacePressed: (t) => {
          va && (clearTimeout(va), (va = null)),
            n((s) => {
              (s.isSpacePressed = t), (s.isSpaceHeld = !1), (s.isPanning = !1);
            }),
            t &&
              (va = setTimeout(() => {
                e().isSpacePressed &&
                  n((r) => {
                    (r.isSpaceHeld = !0), (r.isPanning = !0);
                  }),
                  (va = null);
              }, Y0e));
        },
        setSpaceHeld: (t) =>
          n((s) => {
            (s.isSpaceHeld = t), t || (s.isPanning = !1);
          }),
        setModifier: (t, s) =>
          n((r) => {
            r.modifiers[t] !== s && (r.modifiers[t] = s);
          }),
        setPanning: (t) =>
          n((s) => {
            s.isPanning !== t && (s.isPanning = t);
          }),
        setInInputElement: (t) =>
          n((s) => {
            s.isInInputElement !== t && (s.isInInputElement = t);
          }),
        setInFullscreen: (t) =>
          n((s) => {
            s.isInFullscreen !== t && (s.isInFullscreen = t);
          }),
        setShortcutsEnabled: (t) =>
          n((s) => {
            s.shortcuts.enabled !== t && (s.shortcuts.enabled = t);
          }),
        isKeyPressed: (t) => {
          const { pressedKeys: s } = e();
          return s.has(t.toLowerCase());
        },
        isKeyCombo: (t, s = {}) => {
          const r = e(),
            i = t.every((o) => r.pressedKeys.has(o.toLowerCase())),
            a = Object.entries(s).every(([o, l]) => r.modifiers[o] === l);
          return i && a;
        },
        reset: () => {
          va && (clearTimeout(va), (va = null)),
            n((t) => {
              t.pressedKeys.clear(),
                (t.isSpacePressed = !1),
                (t.isSpaceHeld = !1),
                (t.modifiers = { ctrl: !1, alt: !1, shift: !1, meta: !1 }),
                (t.isPanning = !1),
                (t.isInInputElement = !1),
                (t.isInFullscreen = !1);
            });
        },
        safeReset: () => {
          const t = e();
          va && (clearTimeout(va), (va = null)),
            (t.pressedKeys.size > 0 ||
              t.isSpacePressed ||
              t.isSpaceHeld ||
              t.isPanning ||
              t.isInInputElement ||
              t.isInFullscreen ||
              Object.values(t.modifiers).some(Boolean)) &&
              n((r) => {
                r.pressedKeys.clear(),
                  (r.isSpacePressed = !1),
                  (r.isSpaceHeld = !1),
                  (r.modifiers = { ctrl: !1, alt: !1, shift: !1, meta: !1 }),
                  (r.isPanning = !1),
                  (r.isInInputElement = !1),
                  (r.isInFullscreen = !1);
              });
        },
        clearAllKeys: () =>
          n((t) => {
            t.pressedKeys.clear(),
              (t.modifiers = { ctrl: !1, alt: !1, shift: !1, meta: !1 });
          }),
      }))
    )
  ),
  _b = Di()(
    $a(
      ha((n, e) => ({
        currentTeam: null,
        isLoading: !1,
        error: null,
        userTeams: [],
        isLoadingUserTeams: !1,
        fetchCurrentTeam: async (t) => {
          if (t) {
            n((s) => {
              (s.isLoading = !0), (s.error = null);
            });
            try {
              const s = ka(),
                { data: r, error: i } = await s
                  .from("user_teams")
                  .select("*, teams(*)")
                  .eq("user_id", t)
                  .eq("active", !0)
                  .single();
              if (i) {
                console.error("Error fetching user team:", i),
                  n((c) => {
                    (c.error = "Failed to fetch team"), (c.isLoading = !1);
                  });
                return;
              }
              if (!r?.teams) {
                n((c) => {
                  (c.currentTeam = null), (c.isLoading = !1);
                });
                return;
              }
              const a = r.teams,
                o = await Ut(`/api/teams/${a.id}`);
              if (!o.ok) throw new Error("Failed to fetch team details");
              const l = await o.json();
              n((c) => {
                (c.currentTeam = l.team), (c.isLoading = !1);
              });
            } catch (s) {
              console.error("Error in fetchCurrentTeam:", s),
                n((r) => {
                  (r.error =
                    s instanceof Error ? s.message : "Failed to fetch team"),
                    (r.isLoading = !1);
                });
            }
          }
        },
        fetchUserTeams: async (t) => {
          if (t) {
            n((s) => {
              s.isLoadingUserTeams = !0;
            });
            try {
              const s = ka(),
                { data: r, error: i } = await s
                  .from("user_teams")
                  .select("*, teams(*)")
                  .eq("user_id", t)
                  .order("joined_at", { ascending: !1 });
              if (i) {
                console.error("Error fetching user teams:", i);
                return;
              }
              const a = r?.map((o) => o.teams).filter(Boolean);
              n((o) => {
                (o.userTeams = a || []), (o.isLoadingUserTeams = !1);
              });
            } catch (s) {
              console.error("Error in fetchUserTeams:", s),
                n((r) => {
                  r.isLoadingUserTeams = !1;
                });
            }
          }
        },
        switchTeam: async (t) => {
          const s = ka();
          try {
            const { user: r } = hn.getState();
            if (!r) throw new Error("Not authenticated");
            await s
              .from("user_teams")
              .update({ active: !1 })
              .eq("user_id", r.id);
            const { error: i } = await s
              .from("user_teams")
              .update({ active: !0 })
              .eq("user_id", r.id)
              .eq("team_id", t);
            if (i) throw i;
            await e().fetchCurrentTeam(r.id),
              Ms({ title: "Team switched successfully" });
          } catch (r) {
            console.error("Error switching team:", r),
              Ms({ title: "Failed to switch team", variant: "destructive" });
          }
        },
        updateTeamName: async (t, s) => {
          try {
            const r = await Ut(`/api/teams/${t}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name: s }),
            });
            if (!r.ok) throw new Error("Failed to update team name");
            const i = await r.json();
            n((a) => {
              a.currentTeam &&
                a.currentTeam.id === t &&
                (a.currentTeam.name = s);
              const o = a.userTeams.findIndex((l) => l.id === t);
              o !== -1 && (a.userTeams[o].name = s);
            }),
              Ms({ title: "Team name updated" });
          } catch (r) {
            throw (
              (console.error("Error updating team name:", r),
              Ms({
                title: "Failed to update team name",
                variant: "destructive",
              }),
              r)
            );
          }
        },
        updateInviteEnabled: async (t, s) => {
          try {
            if (
              !(
                await Ut(`/api/teams/${t}`, {
                  method: "PATCH",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ invite_enabled: s }),
                })
              ).ok
            )
              throw new Error("Failed to update invite settings");
            n((i) => {
              i.currentTeam &&
                i.currentTeam.id === t &&
                (i.currentTeam.invite_enabled = s);
            }),
              Ms({ title: s ? "Invites enabled" : "Invites disabled" });
          } catch (r) {
            throw (
              (console.error("Error updating invite settings:", r),
              Ms({
                title: "Failed to update invite settings",
                variant: "destructive",
              }),
              r)
            );
          }
        },
        removeMember: async (t, s) => {
          try {
            const r = await Ut(`/api/teams/${t}/members/${s}`, {
              method: "DELETE",
            });
            if (!r.ok) {
              const i = await r.json();
              throw new Error(i.error || "Failed to remove member");
            }
            await e().refreshTeam(), Ms({ title: "Member removed" });
          } catch (r) {
            throw (
              (console.error("Error removing member:", r),
              Ms({
                title:
                  r instanceof Error ? r.message : "Failed to remove member",
                variant: "destructive",
              }),
              r)
            );
          }
        },
        refreshTeam: async () => {
          const t = e().currentTeam;
          if (t)
            try {
              const s = await Ut(`/api/teams/${t.id}`);
              if (!s.ok) throw new Error("Failed to refresh team");
              const r = await s.json();
              n((i) => {
                i.currentTeam = r.team;
              });
            } catch (s) {
              console.error("Error refreshing team:", s);
            }
        },
        isProTeam: () => e().currentTeam?.team_type === "pro_team",
        isFreeTeam: () => e().currentTeam?.team_type === "free_team",
        hasActiveSubscription: () => {
          const t = e().currentTeam;
          return (
            t?.team_type === "pro_team" && t?.subscription_status === "active"
          );
        },
        isTeamAdmin: (t) => {
          const s = e().currentTeam;
          return s
            ? s.members.find((i) => i.user_id === t)?.role === "admin"
            : !1;
        },
        isOnTrial: () => e().currentTeam?.subscription_status === "trialing",
        getTrialDaysRemaining: () => {
          const t = e().currentTeam;
          if (t?.subscription_status !== "trialing" || !t?.current_period_end)
            return null;
          const s = new Date(t.current_period_end),
            r = new Date(),
            i = Math.ceil((s.getTime() - r.getTime()) / (1e3 * 60 * 60 * 24));
          return Math.max(0, i);
        },
        getTrialEndDate: () => {
          const t = e().currentTeam;
          return t?.subscription_status !== "trialing" || !t?.current_period_end
            ? null
            : new Date(t.current_period_end);
        },
        reset: () => {
          n((t) => {
            (t.currentTeam = null),
              (t.isLoading = !1),
              (t.error = null),
              (t.userTeams = []),
              (t.isLoadingUserTeams = !1);
          });
        },
      }))
    )
  ),
  X0e = (n) => {
    const e = _b((r) => r.fetchCurrentTeam),
      t = _b((r) => r.fetchUserTeams),
      s = _b((r) => r.reset);
    de.useEffect(() => {
      n ? (e(n), t(n)) : s();
    }, [n, e, t, s]);
  };
Di()(
  $a(
    ha((n, e) => ({
      selectedFrames: [],
      selectedChildrenIds: [],
      selectedElementId: void 0,
      setSelectedFrames: (t) =>
        n((s) => {
          s.selectedFrames = t;
        }),
      setSelectedChildrenIds: (t) =>
        n((s) => {
          s.selectedChildrenIds = t;
        }),
      setSelectedElementId: (t) =>
        n((s) => {
          s.selectedElementId = t;
        }),
      selectElement: (t, s, r = () => !0, i = () => {}) => {
        if (!r(t)) return;
        const { addToSelection: o = !0, clearOthers: l = !1 } = s || {},
          c = e(),
          { selectedFrames: h, selectedChildrenIds: m } = c;
        l
          ? (n((p) => {
              (p.selectedFrames = [t]), (p.selectedChildrenIds = []);
            }),
            i(t))
          : o
          ? n((p) => {
              (p.selectedFrames = [...h, t]),
                (p.selectedChildrenIds = [...m, t]);
            })
          : (n((p) => {
              (p.selectedFrames = [t]), (p.selectedChildrenIds = [t]);
            }),
            i(t));
      },
      toggleElementSelection: (t, s = () => !0) => {
        if (!s(t)) return;
        const i = e(),
          { selectedFrames: a, selectedChildrenIds: o } = i;
        a.includes(t)
          ? n((l) => {
              (l.selectedFrames = a.filter((c) => c !== t)),
                (l.selectedChildrenIds = o.filter((c) => c !== t));
            })
          : n((l) => {
              (l.selectedFrames = [...a, t]),
                (l.selectedChildrenIds = [...o, t]);
            });
      },
      clearSelection: () => {
        n((t) => {
          (t.selectedFrames = []), (t.selectedChildrenIds = []);
        });
      },
      selectElementWithModifiers: (t, s, r = () => !0, i = () => {}) => {
        const a = e(),
          { selectedFrames: o } = a;
        r(t) &&
          (s
            ? o.includes(t)
              ? n((c) => {
                  (c.selectedFrames = o.filter((h) => h !== t)),
                    (c.selectedChildrenIds = c.selectedChildrenIds.filter(
                      (h) => h !== t
                    ));
                })
              : n((c) => {
                  (c.selectedFrames = [...o, t]),
                    (c.selectedChildrenIds = [...c.selectedChildrenIds, t]);
                })
            : (n((c) => {
                (c.selectedFrames = [t]), (c.selectedChildrenIds = [t]);
              }),
              i(t)));
      },
      isElementSelected: (t) => e().selectedFrames.includes(t),
      getSelectedCount: () => e().selectedFrames.length,
      hasSelection: () => e().selectedFrames.length > 0,
    }))
  )
);
const Au = new Map(),
  lf = Di()(
    ha((n, e) => ({
      activeJobs: {},
      startProcessing: async (t, s, r) => {
        try {
          `${t}`,
            Au.set(t, r),
            `${t}${r.size}`,
            n((l) => {
              l.activeJobs[t] = {
                elementId: t,
                recordingId: s,
                status: "uploading",
                progress: 0,
                retryCount: 0,
                maxRetries: 3,
              };
            });
          const i = new FormData();
          i.append("video", r),
            n((l) => {
              l.activeJobs[t] &&
                ((l.activeJobs[t].status = "processing"),
                (l.activeJobs[t].progress = 50));
            });
          const a = await Ut(`/api/recordings/${s}/ai`, {
            method: "POST",
            body: i,
          });
          if (!a.ok) {
            const l = await a.text();
            throw new Error(l || "AI processing failed");
          }
          const o = await a.json();
          if (
            (o.insights,
            o.insights?.transcript,
            o.insights?.transcript?.length,
            o.insights?.summary,
            o.success)
          )
            n((c) => {
              c.activeJobs[t] &&
                ((c.activeJobs[t].status = o.isEmpty ? "empty" : "completed"),
                (c.activeJobs[t].progress = 100),
                (c.activeJobs[t].insights = o.insights),
                (c.activeJobs[t].isEmpty = o.isEmpty),
                (c.activeJobs[t].retryCount = o.retryCount || 0));
            }),
              o.insights,
              await Ce.getState().updateElement(t, {
                aiStatus: "completed",
                aiInsights: o.insights,
                aiSummary: o.insights?.summary || "No insights detected",
                hasAIInsights: !0,
              }),
              `${t}`,
              Au.delete(t),
              `${t}`,
              setTimeout(() => {
                lf.getState().clearJob(t);
              }, 2e3);
          else throw new Error(o.error || "AI processing failed");
        } catch (i) {
          console.error("[AIStore] Processing failed:", i);
          const a = Au.has(t);
          n((o) => {
            o.activeJobs[t] &&
              ((o.activeJobs[t].status = "failed"),
              (o.activeJobs[t].error =
                i instanceof Error ? i.message : "Processing failed"),
              (o.activeJobs[t].retryable = a));
          }),
            await Ce.getState().updateElement(t, {
              aiStatus: "failed",
              aiError: i instanceof Error ? i.message : "Processing failed",
              aiSummary: "Something went wrong in getting insights",
            }),
            a ||
              setTimeout(() => {
                lf.getState().clearJob(t);
              }, 5e3);
        }
      },
      retryProcessing: async (t) => {
        const s = e().activeJobs[t],
          r = Au.get(t);
        if (!s || !r) {
          console.error("[AIStore] Cannot retry: no job or blob found");
          return;
        }
        n((i) => {
          i.activeJobs[t] &&
            ((i.activeJobs[t].status = "uploading"),
            (i.activeJobs[t].progress = 0),
            (i.activeJobs[t].error = void 0),
            (i.activeJobs[t].retryCount =
              (i.activeJobs[t].retryCount || 0) + 1));
        }),
          await e().startProcessing(t, s.recordingId, r);
      },
      updateJobStatus: (t, s) => {
        n((r) => {
          r.activeJobs[t] && Object.assign(r.activeJobs[t], s);
        });
      },
      clearJob: (t) => {
        Au.delete(t),
          n((s) => {
            delete s.activeJobs[t];
          });
      },
      getJobState: (t) => e().activeJobs[t],
      isProcessing: (t) => {
        const s = e().activeJobs[t];
        return (
          s !== void 0 &&
          (s.status === "uploading" || s.status === "processing")
        );
      },
      hasRetainedBlob: (t) => Au.has(t),
    }))
  );
typeof window < "u" &&
  window.addEventListener("beforeunload", () => {
    Au.clear();
  });
const Q0e = Object.freeze(
  Object.defineProperty(
    { __proto__: null, useAIStore: lf },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function Z0e() {
  const [n, e] = de.useState(!1);
  return {
    initialize: async (i, a = !1, o = 0) => {
      await Ce.getState().initializeCanvas(i, a, o),
        vn.getState().initializeFromUrl(),
        e(!0);
    },
    cleanup: () => {
      Ce.getState().clearSelection(), Be.getState().reset(), e(!1);
    },
    reset: () => {
      Ce.getState().reset(), Be.getState().reset(), e(!1);
    },
    isInitialized: n,
    forceSave: async () => !0,
  };
}
function Qx(n, [e, t]) {
  return Math.min(t, Math.max(e, n));
}
function GE(n) {
  const e = E.useRef({ value: n, previous: n });
  return E.useMemo(
    () => (
      e.current.value !== n &&
        ((e.current.previous = e.current.value), (e.current.value = n)),
      e.current.previous
    ),
    [n]
  );
}
var J0e = [" ", "Enter", "ArrowUp", "ArrowDown"],
  eye = [" ", "Enter"],
  nd = "Select",
  [qE, WE, tye] = Tv(nd),
  [Wf, JMe] = Pr(nd, [tye, Gc]),
  KE = Gc(),
  [nye, Wc] = Wf(nd),
  [sye, rye] = Wf(nd),
  L7 = (n) => {
    const {
        __scopeSelect: e,
        children: t,
        open: s,
        defaultOpen: r,
        onOpenChange: i,
        value: a,
        defaultValue: o,
        onValueChange: l,
        dir: c,
        name: h,
        autoComplete: m,
        disabled: p,
        required: g,
        form: y,
      } = n,
      b = KE(e),
      [w, S] = E.useState(null),
      [A, _] = E.useState(null),
      [R, C] = E.useState(!1),
      D = _v(c),
      [L, P] = ci({ prop: s, defaultProp: r ?? !1, onChange: i, caller: nd }),
      [V, N] = ci({ prop: a, defaultProp: o, onChange: l, caller: nd }),
      W = E.useRef(null),
      H = w ? y || !!w.closest("form") : !0,
      [z, B] = E.useState(new Set()),
      q = Array.from(z)
        .map((O) => O.props.value)
        .join(";");
    return u.jsx(Cv, {
      ...b,
      children: u.jsxs(nye, {
        required: g,
        scope: e,
        trigger: w,
        onTriggerChange: S,
        valueNode: A,
        onValueNodeChange: _,
        valueNodeHasChildren: R,
        onValueNodeHasChildrenChange: C,
        contentId: $r(),
        value: V,
        onValueChange: N,
        open: L,
        onOpenChange: P,
        dir: D,
        triggerPointerDownPosRef: W,
        disabled: p,
        children: [
          u.jsx(qE.Provider, {
            scope: e,
            children: u.jsx(sye, {
              scope: n.__scopeSelect,
              onNativeOptionAdd: E.useCallback((O) => {
                B((U) => new Set(U).add(O));
              }, []),
              onNativeOptionRemove: E.useCallback((O) => {
                B((U) => {
                  const j = new Set(U);
                  return j.delete(O), j;
                });
              }, []),
              children: t,
            }),
          }),
          H
            ? u.jsxs(
                tq,
                {
                  "aria-hidden": !0,
                  required: g,
                  tabIndex: -1,
                  name: h,
                  autoComplete: m,
                  value: V,
                  onChange: (O) => N(O.target.value),
                  disabled: p,
                  form: y,
                  children: [
                    V === void 0 ? u.jsx("option", { value: "" }) : null,
                    Array.from(z),
                  ],
                },
                q
              )
            : null,
        ],
      }),
    });
  };
L7.displayName = nd;
var D7 = "SelectTrigger",
  P7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, disabled: s = !1, ...r } = n,
      i = KE(t),
      a = Wc(D7, t),
      o = a.disabled || s,
      l = Nt(e, a.onTriggerChange),
      c = WE(t),
      h = E.useRef("touch"),
      [m, p, g] = sq((b) => {
        const w = c().filter((_) => !_.disabled),
          S = w.find((_) => _.value === a.value),
          A = rq(w, b, S);
        A !== void 0 && a.onValueChange(A.value);
      }),
      y = (b) => {
        o || (a.onOpenChange(!0), g()),
          b &&
            (a.triggerPointerDownPosRef.current = {
              x: Math.round(b.pageX),
              y: Math.round(b.pageY),
            });
      };
    return u.jsx(Iv, {
      asChild: !0,
      ...i,
      children: u.jsx(Et.button, {
        type: "button",
        role: "combobox",
        "aria-controls": a.contentId,
        "aria-expanded": a.open,
        "aria-required": a.required,
        "aria-autocomplete": "none",
        dir: a.dir,
        "data-state": a.open ? "open" : "closed",
        disabled: o,
        "data-disabled": o ? "" : void 0,
        "data-placeholder": nq(a.value) ? "" : void 0,
        ...r,
        ref: l,
        onClick: qe(r.onClick, (b) => {
          b.currentTarget.focus(), h.current !== "mouse" && y(b);
        }),
        onPointerDown: qe(r.onPointerDown, (b) => {
          h.current = b.pointerType;
          const w = b.target;
          w.hasPointerCapture(b.pointerId) &&
            w.releasePointerCapture(b.pointerId),
            b.button === 0 &&
              b.ctrlKey === !1 &&
              b.pointerType === "mouse" &&
              (y(b), b.preventDefault());
        }),
        onKeyDown: qe(r.onKeyDown, (b) => {
          const w = m.current !== "";
          !(b.ctrlKey || b.altKey || b.metaKey) &&
            b.key.length === 1 &&
            p(b.key),
            !(w && b.key === " ") &&
              J0e.includes(b.key) &&
              (y(), b.preventDefault());
        }),
      }),
    });
  });
P7.displayName = D7;
var M7 = "SelectValue",
  N7 = E.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        className: s,
        style: r,
        children: i,
        placeholder: a = "",
        ...o
      } = n,
      l = Wc(M7, t),
      { onValueNodeHasChildrenChange: c } = l,
      h = i !== void 0,
      m = Nt(e, l.onValueNodeChange);
    return (
      ys(() => {
        c(h);
      }, [c, h]),
      u.jsx(Et.span, {
        ...o,
        ref: m,
        style: { pointerEvents: "none" },
        children: nq(l.value) ? u.jsx(u.Fragment, { children: a }) : i,
      })
    );
  });
N7.displayName = M7;
var iye = "SelectIcon",
  O7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, children: s, ...r } = n;
    return u.jsx(Et.span, {
      "aria-hidden": !0,
      ...r,
      ref: e,
      children: s || "",
    });
  });
O7.displayName = iye;
var aye = "SelectPortal",
  j7 = (n) => u.jsx(Hf, { asChild: !0, ...n });
j7.displayName = aye;
var sd = "SelectContent",
  F7 = E.forwardRef((n, e) => {
    const t = Wc(sd, n.__scopeSelect),
      [s, r] = E.useState();
    if (
      (ys(() => {
        r(new DocumentFragment());
      }, []),
      !t.open)
    ) {
      const i = s;
      return i
        ? ri.createPortal(
            u.jsx(U7, {
              scope: n.__scopeSelect,
              children: u.jsx(qE.Slot, {
                scope: n.__scopeSelect,
                children: u.jsx("div", { children: n.children }),
              }),
            }),
            i
          )
        : null;
    }
    return u.jsx($7, { ...n, ref: e });
  });
F7.displayName = sd;
var ba = 10,
  [U7, Kc] = Wf(sd),
  oye = "SelectContentImpl",
  lye = Mc("SelectContent.RemoveScroll"),
  $7 = E.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        position: s = "item-aligned",
        onCloseAutoFocus: r,
        onEscapeKeyDown: i,
        onPointerDownOutside: a,
        side: o,
        sideOffset: l,
        align: c,
        alignOffset: h,
        arrowPadding: m,
        collisionBoundary: p,
        collisionPadding: g,
        sticky: y,
        hideWhenDetached: b,
        avoidCollisions: w,
        ...S
      } = n,
      A = Wc(sd, t),
      [_, R] = E.useState(null),
      [C, D] = E.useState(null),
      L = Nt(e, (te) => R(te)),
      [P, V] = E.useState(null),
      [N, W] = E.useState(null),
      H = WE(t),
      [z, B] = E.useState(!1),
      q = E.useRef(!1);
    E.useEffect(() => {
      if (_) return _E(_);
    }, [_]),
      SE();
    const O = E.useCallback(
        (te) => {
          const [ce, ...pe] = H().map((K) => K.ref.current),
            [se] = pe.slice(-1),
            be = document.activeElement;
          for (const K of te)
            if (
              K === be ||
              (K?.scrollIntoView({ block: "nearest" }),
              K === ce && C && (C.scrollTop = 0),
              K === se && C && (C.scrollTop = C.scrollHeight),
              K?.focus(),
              document.activeElement !== be)
            )
              return;
        },
        [H, C]
      ),
      U = E.useCallback(() => O([P, _]), [O, P, _]);
    E.useEffect(() => {
      z && U();
    }, [z, U]);
    const { onOpenChange: j, triggerPointerDownPosRef: Q } = A;
    E.useEffect(() => {
      if (_) {
        let te = { x: 0, y: 0 };
        const ce = (se) => {
            te = {
              x: Math.abs(Math.round(se.pageX) - (Q.current?.x ?? 0)),
              y: Math.abs(Math.round(se.pageY) - (Q.current?.y ?? 0)),
            };
          },
          pe = (se) => {
            te.x <= 10 && te.y <= 10
              ? se.preventDefault()
              : _.contains(se.target) || j(!1),
              document.removeEventListener("pointermove", ce),
              (Q.current = null);
          };
        return (
          Q.current !== null &&
            (document.addEventListener("pointermove", ce),
            document.addEventListener("pointerup", pe, {
              capture: !0,
              once: !0,
            })),
          () => {
            document.removeEventListener("pointermove", ce),
              document.removeEventListener("pointerup", pe, { capture: !0 });
          }
        );
      }
    }, [_, j, Q]),
      E.useEffect(() => {
        const te = () => j(!1);
        return (
          window.addEventListener("blur", te),
          window.addEventListener("resize", te),
          () => {
            window.removeEventListener("blur", te),
              window.removeEventListener("resize", te);
          }
        );
      }, [j]);
    const [M, I] = sq((te) => {
        const ce = H().filter((be) => !be.disabled),
          pe = ce.find((be) => be.ref.current === document.activeElement),
          se = rq(ce, te, pe);
        se && setTimeout(() => se.ref.current.focus());
      }),
      F = E.useCallback(
        (te, ce, pe) => {
          const se = !q.current && !pe;
          ((A.value !== void 0 && A.value === ce) || se) &&
            (V(te), se && (q.current = !0));
        },
        [A.value]
      ),
      Y = E.useCallback(() => _?.focus(), [_]),
      J = E.useCallback(
        (te, ce, pe) => {
          const se = !q.current && !pe;
          ((A.value !== void 0 && A.value === ce) || se) && W(te);
        },
        [A.value]
      ),
      X = s === "popper" ? Nk : B7,
      Z =
        X === Nk
          ? {
              side: o,
              sideOffset: l,
              align: c,
              alignOffset: h,
              arrowPadding: m,
              collisionBoundary: p,
              collisionPadding: g,
              sticky: y,
              hideWhenDetached: b,
              avoidCollisions: w,
            }
          : {};
    return u.jsx(U7, {
      scope: t,
      content: _,
      viewport: C,
      onViewportChange: D,
      itemRefCallback: F,
      selectedItem: P,
      onItemLeave: Y,
      itemTextRefCallback: J,
      focusSelectedItem: U,
      selectedItemText: N,
      position: s,
      isPositioned: z,
      searchRef: M,
      children: u.jsx(Rv, {
        as: lye,
        allowPinchZoom: !0,
        children: u.jsx(Av, {
          asChild: !0,
          trapped: A.open,
          onMountAutoFocus: (te) => {
            te.preventDefault();
          },
          onUnmountAutoFocus: qe(r, (te) => {
            A.trigger?.focus({ preventScroll: !0 }), te.preventDefault();
          }),
          children: u.jsx(Bf, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: i,
            onPointerDownOutside: a,
            onFocusOutside: (te) => te.preventDefault(),
            onDismiss: () => A.onOpenChange(!1),
            children: u.jsx(X, {
              role: "listbox",
              id: A.contentId,
              "data-state": A.open ? "open" : "closed",
              dir: A.dir,
              onContextMenu: (te) => te.preventDefault(),
              ...S,
              ...Z,
              onPlaced: () => B(!0),
              ref: L,
              style: {
                display: "flex",
                flexDirection: "column",
                outline: "none",
                ...S.style,
              },
              onKeyDown: qe(S.onKeyDown, (te) => {
                const ce = te.ctrlKey || te.altKey || te.metaKey;
                if (
                  (te.key === "Tab" && te.preventDefault(),
                  !ce && te.key.length === 1 && I(te.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(te.key))
                ) {
                  let se = H()
                    .filter((be) => !be.disabled)
                    .map((be) => be.ref.current);
                  if (
                    (["ArrowUp", "End"].includes(te.key) &&
                      (se = se.slice().reverse()),
                    ["ArrowUp", "ArrowDown"].includes(te.key))
                  ) {
                    const be = te.target,
                      K = se.indexOf(be);
                    se = se.slice(K + 1);
                  }
                  setTimeout(() => O(se)), te.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
$7.displayName = oye;
var cye = "SelectItemAlignedPosition",
  B7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, onPlaced: s, ...r } = n,
      i = Wc(sd, t),
      a = Kc(sd, t),
      [o, l] = E.useState(null),
      [c, h] = E.useState(null),
      m = Nt(e, (L) => h(L)),
      p = WE(t),
      g = E.useRef(!1),
      y = E.useRef(!0),
      {
        viewport: b,
        selectedItem: w,
        selectedItemText: S,
        focusSelectedItem: A,
      } = a,
      _ = E.useCallback(() => {
        if (i.trigger && i.valueNode && o && c && b && w && S) {
          const L = i.trigger.getBoundingClientRect(),
            P = c.getBoundingClientRect(),
            V = i.valueNode.getBoundingClientRect(),
            N = S.getBoundingClientRect();
          if (i.dir !== "rtl") {
            const be = N.left - P.left,
              K = V.left - be,
              ve = L.left - K,
              Ee = L.width + ve,
              De = Math.max(Ee, P.width),
              ge = window.innerWidth - ba,
              re = Qx(K, [ba, Math.max(ba, ge - De)]);
            (o.style.minWidth = Ee + "px"), (o.style.left = re + "px");
          } else {
            const be = P.right - N.right,
              K = window.innerWidth - V.right - be,
              ve = window.innerWidth - L.right - K,
              Ee = L.width + ve,
              De = Math.max(Ee, P.width),
              ge = window.innerWidth - ba,
              re = Qx(K, [ba, Math.max(ba, ge - De)]);
            (o.style.minWidth = Ee + "px"), (o.style.right = re + "px");
          }
          const W = p(),
            H = window.innerHeight - ba * 2,
            z = b.scrollHeight,
            B = window.getComputedStyle(c),
            q = parseInt(B.borderTopWidth, 10),
            O = parseInt(B.paddingTop, 10),
            U = parseInt(B.borderBottomWidth, 10),
            j = parseInt(B.paddingBottom, 10),
            Q = q + O + z + j + U,
            M = Math.min(w.offsetHeight * 5, Q),
            I = window.getComputedStyle(b),
            F = parseInt(I.paddingTop, 10),
            Y = parseInt(I.paddingBottom, 10),
            J = L.top + L.height / 2 - ba,
            X = H - J,
            Z = w.offsetHeight / 2,
            te = w.offsetTop + Z,
            ce = q + O + te,
            pe = Q - ce;
          if (ce <= J) {
            const be = W.length > 0 && w === W[W.length - 1].ref.current;
            o.style.bottom = "0px";
            const K = c.clientHeight - b.offsetTop - b.offsetHeight,
              ve = Math.max(X, Z + (be ? Y : 0) + K + U),
              Ee = ce + ve;
            o.style.height = Ee + "px";
          } else {
            const be = W.length > 0 && w === W[0].ref.current;
            o.style.top = "0px";
            const ve = Math.max(J, q + b.offsetTop + (be ? F : 0) + Z) + pe;
            (o.style.height = ve + "px"), (b.scrollTop = ce - J + b.offsetTop);
          }
          (o.style.margin = `${ba}px 0`),
            (o.style.minHeight = M + "px"),
            (o.style.maxHeight = H + "px"),
            s?.(),
            requestAnimationFrame(() => (g.current = !0));
        }
      }, [p, i.trigger, i.valueNode, o, c, b, w, S, i.dir, s]);
    ys(() => _(), [_]);
    const [R, C] = E.useState();
    ys(() => {
      c && C(window.getComputedStyle(c).zIndex);
    }, [c]);
    const D = E.useCallback(
      (L) => {
        L && y.current === !0 && (_(), A?.(), (y.current = !1));
      },
      [_, A]
    );
    return u.jsx(dye, {
      scope: t,
      contentWrapper: o,
      shouldExpandOnScrollRef: g,
      onScrollButtonChange: D,
      children: u.jsx("div", {
        ref: l,
        style: {
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: R,
        },
        children: u.jsx(Et.div, {
          ...r,
          ref: m,
          style: { boxSizing: "border-box", maxHeight: "100%", ...r.style },
        }),
      }),
    });
  });
B7.displayName = cye;
var uye = "SelectPopperPosition",
  Nk = E.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        align: s = "start",
        collisionPadding: r = ba,
        ...i
      } = n,
      a = KE(t);
    return u.jsx(LE, {
      ...a,
      ...i,
      ref: e,
      align: s,
      collisionPadding: r,
      style: {
        boxSizing: "border-box",
        ...i.style,
        "--radix-select-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-select-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
Nk.displayName = uye;
var [dye, uD] = Wf(sd, {}),
  Ok = "SelectViewport",
  H7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, nonce: s, ...r } = n,
      i = Kc(Ok, t),
      a = uD(Ok, t),
      o = Nt(e, i.onViewportChange),
      l = E.useRef(0);
    return u.jsxs(u.Fragment, {
      children: [
        u.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: s,
        }),
        u.jsx(qE.Slot, {
          scope: t,
          children: u.jsx(Et.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...r,
            ref: o,
            style: {
              position: "relative",
              flex: 1,
              overflow: "hidden auto",
              ...r.style,
            },
            onScroll: qe(r.onScroll, (c) => {
              const h = c.currentTarget,
                { contentWrapper: m, shouldExpandOnScrollRef: p } = a;
              if (p?.current && m) {
                const g = Math.abs(l.current - h.scrollTop);
                if (g > 0) {
                  const y = window.innerHeight - ba * 2,
                    b = parseFloat(m.style.minHeight),
                    w = parseFloat(m.style.height),
                    S = Math.max(b, w);
                  if (S < y) {
                    const A = S + g,
                      _ = Math.min(y, A),
                      R = A - _;
                    (m.style.height = _ + "px"),
                      m.style.bottom === "0px" &&
                        ((h.scrollTop = R > 0 ? R : 0),
                        (m.style.justifyContent = "flex-end"));
                  }
                }
              }
              l.current = h.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
H7.displayName = Ok;
var V7 = "SelectGroup",
  [hye, fye] = Wf(V7),
  mye = E.forwardRef((n, e) => {
    const { __scopeSelect: t, ...s } = n,
      r = $r();
    return u.jsx(hye, {
      scope: t,
      id: r,
      children: u.jsx(Et.div, {
        role: "group",
        "aria-labelledby": r,
        ...s,
        ref: e,
      }),
    });
  });
mye.displayName = V7;
var z7 = "SelectLabel",
  G7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, ...s } = n,
      r = fye(z7, t);
    return u.jsx(Et.div, { id: r.id, ...s, ref: e });
  });
G7.displayName = z7;
var Zx = "SelectItem",
  [pye, q7] = Wf(Zx),
  W7 = E.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        value: s,
        disabled: r = !1,
        textValue: i,
        ...a
      } = n,
      o = Wc(Zx, t),
      l = Kc(Zx, t),
      c = o.value === s,
      [h, m] = E.useState(i ?? ""),
      [p, g] = E.useState(!1),
      y = Nt(e, (A) => l.itemRefCallback?.(A, s, r)),
      b = $r(),
      w = E.useRef("touch"),
      S = () => {
        r || (o.onValueChange(s), o.onOpenChange(!1));
      };
    if (s === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return u.jsx(pye, {
      scope: t,
      value: s,
      disabled: r,
      textId: b,
      isSelected: c,
      onItemTextChange: E.useCallback((A) => {
        m((_) => _ || (A?.textContent ?? "").trim());
      }, []),
      children: u.jsx(qE.ItemSlot, {
        scope: t,
        value: s,
        disabled: r,
        textValue: h,
        children: u.jsx(Et.div, {
          role: "option",
          "aria-labelledby": b,
          "data-highlighted": p ? "" : void 0,
          "aria-selected": c && p,
          "data-state": c ? "checked" : "unchecked",
          "aria-disabled": r || void 0,
          "data-disabled": r ? "" : void 0,
          tabIndex: r ? void 0 : -1,
          ...a,
          ref: y,
          onFocus: qe(a.onFocus, () => g(!0)),
          onBlur: qe(a.onBlur, () => g(!1)),
          onClick: qe(a.onClick, () => {
            w.current !== "mouse" && S();
          }),
          onPointerUp: qe(a.onPointerUp, () => {
            w.current === "mouse" && S();
          }),
          onPointerDown: qe(a.onPointerDown, (A) => {
            w.current = A.pointerType;
          }),
          onPointerMove: qe(a.onPointerMove, (A) => {
            (w.current = A.pointerType),
              r
                ? l.onItemLeave?.()
                : w.current === "mouse" &&
                  A.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: qe(a.onPointerLeave, (A) => {
            A.currentTarget === document.activeElement && l.onItemLeave?.();
          }),
          onKeyDown: qe(a.onKeyDown, (A) => {
            (l.searchRef?.current !== "" && A.key === " ") ||
              (eye.includes(A.key) && S(), A.key === " " && A.preventDefault());
          }),
        }),
      }),
    });
  });
W7.displayName = Zx;
var kp = "SelectItemText",
  K7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, className: s, style: r, ...i } = n,
      a = Wc(kp, t),
      o = Kc(kp, t),
      l = q7(kp, t),
      c = rye(kp, t),
      [h, m] = E.useState(null),
      p = Nt(
        e,
        (S) => m(S),
        l.onItemTextChange,
        (S) => o.itemTextRefCallback?.(S, l.value, l.disabled)
      ),
      g = h?.textContent,
      y = E.useMemo(
        () =>
          u.jsx(
            "option",
            { value: l.value, disabled: l.disabled, children: g },
            l.value
          ),
        [l.disabled, l.value, g]
      ),
      { onNativeOptionAdd: b, onNativeOptionRemove: w } = c;
    return (
      ys(() => (b(y), () => w(y)), [b, w, y]),
      u.jsxs(u.Fragment, {
        children: [
          u.jsx(Et.span, { id: l.textId, ...i, ref: p }),
          l.isSelected && a.valueNode && !a.valueNodeHasChildren
            ? ri.createPortal(i.children, a.valueNode)
            : null,
        ],
      })
    );
  });
K7.displayName = kp;
var Y7 = "SelectItemIndicator",
  X7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, ...s } = n;
    return q7(Y7, t).isSelected
      ? u.jsx(Et.span, { "aria-hidden": !0, ...s, ref: e })
      : null;
  });
X7.displayName = Y7;
var jk = "SelectScrollUpButton",
  Q7 = E.forwardRef((n, e) => {
    const t = Kc(jk, n.__scopeSelect),
      s = uD(jk, n.__scopeSelect),
      [r, i] = E.useState(!1),
      a = Nt(e, s.onScrollButtonChange);
    return (
      ys(() => {
        if (t.viewport && t.isPositioned) {
          let o = function () {
            const c = l.scrollTop > 0;
            i(c);
          };
          const l = t.viewport;
          return (
            o(),
            l.addEventListener("scroll", o),
            () => l.removeEventListener("scroll", o)
          );
        }
      }, [t.viewport, t.isPositioned]),
      r
        ? u.jsx(J7, {
            ...n,
            ref: a,
            onAutoScroll: () => {
              const { viewport: o, selectedItem: l } = t;
              o && l && (o.scrollTop = o.scrollTop - l.offsetHeight);
            },
          })
        : null
    );
  });
Q7.displayName = jk;
var Fk = "SelectScrollDownButton",
  Z7 = E.forwardRef((n, e) => {
    const t = Kc(Fk, n.__scopeSelect),
      s = uD(Fk, n.__scopeSelect),
      [r, i] = E.useState(!1),
      a = Nt(e, s.onScrollButtonChange);
    return (
      ys(() => {
        if (t.viewport && t.isPositioned) {
          let o = function () {
            const c = l.scrollHeight - l.clientHeight,
              h = Math.ceil(l.scrollTop) < c;
            i(h);
          };
          const l = t.viewport;
          return (
            o(),
            l.addEventListener("scroll", o),
            () => l.removeEventListener("scroll", o)
          );
        }
      }, [t.viewport, t.isPositioned]),
      r
        ? u.jsx(J7, {
            ...n,
            ref: a,
            onAutoScroll: () => {
              const { viewport: o, selectedItem: l } = t;
              o && l && (o.scrollTop = o.scrollTop + l.offsetHeight);
            },
          })
        : null
    );
  });
Z7.displayName = Fk;
var J7 = E.forwardRef((n, e) => {
    const { __scopeSelect: t, onAutoScroll: s, ...r } = n,
      i = Kc("SelectScrollButton", t),
      a = E.useRef(null),
      o = WE(t),
      l = E.useCallback(() => {
        a.current !== null &&
          (window.clearInterval(a.current), (a.current = null));
      }, []);
    return (
      E.useEffect(() => () => l(), [l]),
      ys(() => {
        o()
          .find((h) => h.ref.current === document.activeElement)
          ?.ref.current?.scrollIntoView({ block: "nearest" });
      }, [o]),
      u.jsx(Et.div, {
        "aria-hidden": !0,
        ...r,
        ref: e,
        style: { flexShrink: 0, ...r.style },
        onPointerDown: qe(r.onPointerDown, () => {
          a.current === null && (a.current = window.setInterval(s, 50));
        }),
        onPointerMove: qe(r.onPointerMove, () => {
          i.onItemLeave?.(),
            a.current === null && (a.current = window.setInterval(s, 50));
        }),
        onPointerLeave: qe(r.onPointerLeave, () => {
          l();
        }),
      })
    );
  }),
  gye = "SelectSeparator",
  eq = E.forwardRef((n, e) => {
    const { __scopeSelect: t, ...s } = n;
    return u.jsx(Et.div, { "aria-hidden": !0, ...s, ref: e });
  });
eq.displayName = gye;
var Uk = "SelectArrow",
  vye = E.forwardRef((n, e) => {
    const { __scopeSelect: t, ...s } = n,
      r = KE(t),
      i = Wc(Uk, t),
      a = Kc(Uk, t);
    return i.open && a.position === "popper"
      ? u.jsx(DE, { ...r, ...s, ref: e })
      : null;
  });
vye.displayName = Uk;
var yye = "SelectBubbleInput",
  tq = E.forwardRef(({ __scopeSelect: n, value: e, ...t }, s) => {
    const r = E.useRef(null),
      i = Nt(s, r),
      a = GE(e);
    return (
      E.useEffect(() => {
        const o = r.current;
        if (!o) return;
        const l = window.HTMLSelectElement.prototype,
          h = Object.getOwnPropertyDescriptor(l, "value").set;
        if (a !== e && h) {
          const m = new Event("change", { bubbles: !0 });
          h.call(o, e), o.dispatchEvent(m);
        }
      }, [a, e]),
      u.jsx(Et.select, {
        ...t,
        style: { ..._z, ...t.style },
        ref: i,
        defaultValue: e,
      })
    );
  });
tq.displayName = yye;
function nq(n) {
  return n === "" || n === void 0;
}
function sq(n) {
  const e = ua(n),
    t = E.useRef(""),
    s = E.useRef(0),
    r = E.useCallback(
      (a) => {
        const o = t.current + a;
        e(o),
          (function l(c) {
            (t.current = c),
              window.clearTimeout(s.current),
              c !== "" && (s.current = window.setTimeout(() => l(""), 1e3));
          })(o);
      },
      [e]
    ),
    i = E.useCallback(() => {
      (t.current = ""), window.clearTimeout(s.current);
    }, []);
  return E.useEffect(() => () => window.clearTimeout(s.current), []), [t, r, i];
}
function rq(n, e, t) {
  const r = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e,
    i = t ? n.indexOf(t) : -1;
  let a = bye(n, Math.max(i, 0));
  r.length === 1 && (a = a.filter((c) => c !== t));
  const l = a.find((c) =>
    c.textValue.toLowerCase().startsWith(r.toLowerCase())
  );
  return l !== t ? l : void 0;
}
function bye(n, e) {
  return n.map((t, s) => n[(e + s) % n.length]);
}
var xye = L7,
  iq = P7,
  wye = N7,
  Eye = O7,
  Sye = j7,
  aq = F7,
  Tye = H7,
  oq = G7,
  lq = W7,
  _ye = K7,
  Aye = X7,
  cq = Q7,
  uq = Z7,
  dq = eq;
const u$ = xye,
  d$ = wye,
  $k = E.forwardRef(({ className: n, children: e, ...t }, s) =>
    u.jsxs(iq, {
      ref: s,
      className: Le(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        n
      ),
      ...t,
      children: [
        e,
        u.jsx(Eye, {
          asChild: !0,
          children: u.jsx(cd, { className: "h-4 w-4 opacity-50" }),
        }),
      ],
    })
  );
$k.displayName = iq.displayName;
const hq = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(cq, {
    ref: t,
    className: Le("flex cursor-default items-center justify-center py-1", n),
    ...e,
    children: u.jsx(lL, { className: "h-4 w-4" }),
  })
);
hq.displayName = cq.displayName;
const fq = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(uq, {
    ref: t,
    className: Le("flex cursor-default items-center justify-center py-1", n),
    ...e,
    children: u.jsx(cd, { className: "h-4 w-4" }),
  })
);
fq.displayName = uq.displayName;
const Bk = E.forwardRef(
  ({ className: n, children: e, position: t = "popper", ...s }, r) =>
    u.jsx(Sye, {
      children: u.jsxs(aq, {
        ref: r,
        className: Le(
          "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          t === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          n
        ),
        position: t,
        ...s,
        children: [
          u.jsx(hq, {}),
          u.jsx(Tye, {
            className: Le(
              "p-1",
              t === "popper" &&
                "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children: e,
          }),
          u.jsx(fq, {}),
        ],
      }),
    })
);
Bk.displayName = aq.displayName;
const Rye = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(oq, {
    ref: t,
    className: Le("py-1.5 pl-8 pr-2 text-sm font-semibold", n),
    ...e,
  })
);
Rye.displayName = oq.displayName;
const Hk = E.forwardRef(({ className: n, children: e, ...t }, s) =>
  u.jsxs(lq, {
    ref: s,
    className: Le(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      n
    ),
    ...t,
    children: [
      u.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: u.jsx(Aye, { children: u.jsx(zs, { className: "h-4 w-4" }) }),
      }),
      u.jsx(_ye, { children: e }),
    ],
  })
);
Hk.displayName = lq.displayName;
const kye = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(dq, { ref: t, className: Le("-mx-1 my-1 h-px bg-muted", n), ...e })
);
kye.displayName = dq.displayName;
const Cye = ({
    isOpen: n,
    onClose: e,
    hasEditingPermissions: t = !0,
    isMobile: s = !1,
    pendingRecordingType: r = null,
  }) => {
    const {
      permissions: i,
      settings: a,
      setSelectedMicrophone: o,
      setSelectedCamera: l,
      requestPermissions: c,
      checkPermissions: h,
      enumerateDevices: m,
    } = on();
    E.useEffect(() => {
      n && (h(), m());
    }, [n, h, m]),
      E.useEffect(() => {
        if (!n || !r) return;
        const L = !(r === "thoughts") || i.camera === "granted",
          P = i.microphone === "granted";
        if (L && P) {
          e();
          const V = new CustomEvent("startPendingRecording", {
            detail: { type: r },
          });
          window.dispatchEvent(V);
        }
      }, [n, r, i.camera, i.microphone, e]);
    const p = async () => {
        (await c("microphone"))
          ? (Bt.capture("recording_permission_granted", {
              recording_type: r || "unknown",
              permission_type: "microphone",
            }),
            await h(),
            await m())
          : Bt.capture("recording_permission_denied", {
              recording_type: r || "unknown",
              permission_type: "microphone",
            });
      },
      g = async () => {
        (await c("camera"))
          ? (Bt.capture("recording_permission_granted", {
              recording_type: r || "unknown",
              permission_type: "camera",
            }),
            await h(),
            await m())
          : Bt.capture("recording_permission_denied", {
              recording_type: r || "unknown",
              permission_type: "camera",
            });
      },
      [y, b] = E.useState(0),
      [w, S] = E.useState(null),
      A = async () => {
        if ((b((L) => L + 1), !w)) {
          const L = setTimeout(() => {
            b(0), S(null);
          }, 5e3);
          S(L);
        }
        y >= 2 && (R(!0), b(0), w && (clearTimeout(w), S(null))),
          (await c("both"))
            ? Bt.capture("recording_permission_granted", {
                recording_type: r || "unknown",
                permission_type: "both",
              })
            : Bt.capture("recording_permission_denied", {
                recording_type: r || "unknown",
                permission_type: "both",
              }),
          await h(),
          await m();
      },
      [_, R] = E.useState(!1),
      C = i.camera !== "granted" || i.microphone !== "granted";
    return (
      E.useEffect(
        () => () => {
          w && clearTimeout(w);
        },
        [w]
      ),
      u.jsx(os, {
        open: n,
        onOpenChange: e,
        children: u.jsxs(Jn, {
          className: "sm:max-w-[425px]",
          children: [
            u.jsx(bs, {
              children: u.jsx(xs, { children: "Recording Options" }),
            }),
            u.jsxs("div", {
              className: "space-y-5 mt-4",
              children: [
                u.jsxs("div", {
                  className: "flex items-start gap-4",
                  children: [
                    u.jsx("div", {
                      className: Le(
                        "w-10 h-10 rounded-lg flex items-center justify-center flex-shrink-0 mt-1",
                        i.microphone === "granted"
                          ? "bg-text-primary/10 text-text-primary"
                          : "bg-orange-500/10 text-orange-400"
                      ),
                      children: u.jsx(yle, { className: "w-5 h-5" }),
                    }),
                    u.jsxs("div", {
                      className: "flex-1 space-y-2",
                      children: [
                        u.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [
                            u.jsx("span", {
                              className: "text-sm font-medium text-white",
                              children: "Microphone",
                            }),
                            i.microphone === "granted"
                              ? u.jsx(zs, {
                                  className: "w-3.5 h-3.5 text-green-400",
                                })
                              : u.jsx(Lx, {
                                  className: "w-3.5 h-3.5 text-orange-400",
                                }),
                          ],
                        }),
                        i.microphone === "granted"
                          ? u.jsx(u.Fragment, {
                              children:
                                !s && a.availableMicrophones.length > 0
                                  ? u.jsxs(u$, {
                                      value: a.selectedMicrophoneId || "",
                                      onValueChange: o,
                                      children: [
                                        u.jsx($k, {
                                          className:
                                            "w-full h-9 text-sm bg-background/50 border-border/50 text-white hover:bg-background/70 transition-colors",
                                          children: u.jsx(d$, {
                                            placeholder: "Select microphone",
                                          }),
                                        }),
                                        u.jsx(Bk, {
                                          side: "top",
                                          sideOffset: 4,
                                          className:
                                            "bg-background border-border z-[10003]",
                                          children: a.availableMicrophones
                                            .filter(
                                              (D) =>
                                                D.deviceId &&
                                                D.deviceId.trim() !== ""
                                            )
                                            .map((D) =>
                                              u.jsx(
                                                Hk,
                                                {
                                                  value: D.deviceId,
                                                  className:
                                                    "text-white hover:bg-white/10 text-sm",
                                                  children: D.label,
                                                },
                                                D.deviceId
                                              )
                                            ),
                                        }),
                                      ],
                                    })
                                  : s
                                  ? u.jsx("p", {
                                      className: "text-sm text-green-400 py-2",
                                      children: "Permission granted",
                                    })
                                  : u.jsx("p", {
                                      className: "text-sm text-orange-400 py-2",
                                      children:
                                        "No microphone devices detected",
                                    }),
                            })
                          : u.jsx(et, {
                              onClick: p,
                              variant: "outline",
                              className: Le(
                                "w-full h-9 text-sm",
                                "bg-orange-500/10 border-orange-500/40",
                                "text-orange-400 hover:bg-orange-500/20 hover:border-orange-500/60"
                              ),
                              children: "Permission not granted",
                            }),
                      ],
                    }),
                  ],
                }),
                u.jsxs("div", {
                  className: "flex items-start gap-4",
                  children: [
                    u.jsx("div", {
                      className: Le(
                        "w-10 h-10 rounded-lg flex items-center justify-center flex-shrink-0 mt-1",
                        i.camera === "granted"
                          ? "bg-text-primary/10 text-text-primary"
                          : "bg-orange-500/10 text-orange-400"
                      ),
                      children: u.jsx(CH, { className: "w-5 h-5" }),
                    }),
                    u.jsxs("div", {
                      className: "flex-1 space-y-2",
                      children: [
                        u.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [
                            u.jsx("span", {
                              className: "text-sm font-medium text-white",
                              children: "Camera",
                            }),
                            i.camera === "granted"
                              ? u.jsx(zs, {
                                  className: "w-3.5 h-3.5 text-green-400",
                                })
                              : u.jsx(Lx, {
                                  className: "w-3.5 h-3.5 text-orange-400",
                                }),
                          ],
                        }),
                        i.camera === "granted"
                          ? u.jsx(u.Fragment, {
                              children:
                                !s && a.availableCameras.length > 0
                                  ? u.jsxs(u$, {
                                      value: a.selectedCameraId || "",
                                      onValueChange: l,
                                      children: [
                                        u.jsx($k, {
                                          className:
                                            "w-full h-9 text-sm bg-background/50 border-border/50 text-white hover:bg-background/70 transition-colors",
                                          children: u.jsx(d$, {
                                            placeholder: "Select camera",
                                          }),
                                        }),
                                        u.jsx(Bk, {
                                          side: "top",
                                          sideOffset: 4,
                                          className:
                                            "bg-background border-border z-[10003]",
                                          children: a.availableCameras
                                            .filter(
                                              (D) =>
                                                D.deviceId &&
                                                D.deviceId.trim() !== ""
                                            )
                                            .map((D) =>
                                              u.jsx(
                                                Hk,
                                                {
                                                  value: D.deviceId,
                                                  className:
                                                    "text-white hover:bg-white/10 text-sm",
                                                  children: D.label,
                                                },
                                                D.deviceId
                                              )
                                            ),
                                        }),
                                      ],
                                    })
                                  : s
                                  ? u.jsx("p", {
                                      className: "text-sm text-green-400 py-2",
                                      children: "Permission granted",
                                    })
                                  : u.jsx("p", {
                                      className: "text-sm text-orange-400 py-2",
                                      children: "No camera devices detected",
                                    }),
                            })
                          : u.jsx(et, {
                              onClick: g,
                              variant: "outline",
                              className: Le(
                                "w-full h-9 text-sm",
                                "bg-orange-500/10 border-orange-500/40",
                                "text-orange-400 hover:bg-orange-500/20 hover:border-orange-500/60"
                              ),
                              children: "Permission not granted",
                            }),
                      ],
                    }),
                  ],
                }),
                C &&
                  u.jsxs("div", {
                    className: "space-y-2",
                    children: [
                      u.jsxs("button", {
                        onClick: () => R(!_),
                        className:
                          "text-xs text-text-secondary hover:text-text-primary transition-colors flex items-center gap-1",
                        children: [
                          "Permission prompt not appearing?",
                          u.jsx(DH, { className: "w-3 h-3" }),
                        ],
                      }),
                      _ &&
                        u.jsxs("div", {
                          className:
                            "text-xs text-text-secondary space-y-2 bg-background/50 p-3 rounded-lg border border-border/50",
                          children: [
                            u.jsxs("div", {
                              children: [
                                u.jsx("p", {
                                  className: "font-semibold text-white mb-1",
                                  children: "Chrome:",
                                }),
                                u.jsx("p", {
                                  children:
                                    "Click the lock icon in the address bar  Site settings  Reset permissions",
                                }),
                              ],
                            }),
                            u.jsxs("div", {
                              children: [
                                u.jsx("p", {
                                  className: "font-semibold text-white mb-1",
                                  children: "Safari:",
                                }),
                                u.jsx("p", {
                                  children:
                                    "Safari menu  Settings  Websites  Camera/Microphone  Allow for this site",
                                }),
                              ],
                            }),
                          ],
                        }),
                    ],
                  }),
              ],
            }),
            u.jsx(xr, {
              children: C
                ? u.jsx(et, {
                    className: "button-primary rounded-full",
                    onClick: A,
                    children: "Grant Permissions",
                  })
                : u.jsx(et, {
                    variant: "ghost",
                    className: "rounded-full",
                    onClick: e,
                    children: "Close",
                  }),
            }),
          ],
        }),
      })
    );
  },
  mn = ({ children: n, className: e, animate: t = !1 }) => {
    const [s, r] = E.useState(!1),
      i = () => {
        r(!0);
      },
      a = () => {
        r(!1);
      };
    return u.jsxs(u.Fragment, {
      children: [
        u.jsx("div", {
          className: Le(
            "z-30 flex h-7 select-none items-center justify-center rounded-sm border border-text-secondary/50 bg-card-background font-semibold text-[10px] text-text-primary shadow-[inset_0_-1px_0_0_rgba(161,161,170,0.5)] translate-y-[1px] -mt-0.5 -mr-1.5 px-1.5 min-w-[28px]",
            t && "animate-keyboardTooltipPress",
            s && "animate-keyboardTooltipUnpress",
            e
          ),
          onMouseEnter: i,
          onAnimationEnd: a,
          children: u.jsx("span", {
            className: "mt-[-1px]",
            children: u.jsx("span", { className: "pt-2", children: n }),
          }),
        }),
        u.jsx("style", {
          children: `
        @keyframes keyboardTooltipPress {
          0% {
            transform: translateY(0);
            box-shadow: inset 0 -2px 0 0 rgba(0, 0, 0, 0.2), 0 1px 2px 0 rgba(0, 0, 0, 0.4);
          }
          50% {
            transform: translateY(1px);
            box-shadow: inset 0 -1px rgba(161, 161, 170, 0.5);
          }
          to {
            transform: translateY(0);
            box-shadow: inset 0 -2px 0 0 rgba(0, 0, 0, 0.2), 0 1px 2px 0 rgba(0, 0, 0, 0.4);
          }
        }

        @keyframes keyboardTooltipUnpress {
          0% {
            transform: translateY(1px);
            box-shadow: inset 0 -1px rgba(161, 161, 170, 0.5);
          }
          50% {
            transform: translateY(0);
            box-shadow: inset 0 -2px 0 0 rgba(0, 0, 0, 0.2), 0 1px 2px 0 rgba(0, 0, 0, 0.4);
          }
          to {
            transform: translateY(1px);
            box-shadow: inset 0 -1px rgba(161, 161, 170, 0.5);
          }
        }

        .animate-keyboardTooltipPress {
          animation: 0.4s ease-in-out 2 keyboardTooltipPress 0.2s;
        }

        .animate-keyboardTooltipUnpress {
          animation: 0.4s ease-in-out 1 keyboardTooltipUnpress;
        }
      `,
        }),
      ],
    });
  },
  mq = E.createContext(void 0),
  Iye = ({
    children: n,
    flask: e,
    flaskId: t,
    hasEditingPermissions: s,
    isCreator: r,
    accessLevel: i = null,
    currentAssetIndex: a = 0,
    onUpdateFlaskName: o,
    onUpdateFlaskAccessLevel: l,
    onUpdateFlaskThumbnail: c,
    onAssetChange: h,
  }) => {
    const m = {
      flask: e,
      flaskId: t,
      hasEditingPermissions: s,
      isCreator: r,
      accessLevel: i,
      currentAssetIndex: a,
      onUpdateFlaskName: o,
      onUpdateFlaskAccessLevel: l,
      onUpdateFlaskThumbnail: c,
      onAssetChange: h,
    };
    return u.jsx(mq.Provider, { value: m, children: n });
  },
  dd = () => {
    const n = E.useContext(mq);
    if (n === void 0)
      throw new Error("useFlaskContext must be used within a FlaskProvider");
    return n;
  },
  B1 = ({
    title: n,
    keycapLetter: e,
    description: t,
    icon: s,
    hideKeycap: r = !1,
  }) =>
    u.jsx(Pn, {
      className: "p-4 rounded-3xl  border-text-secondary/50 border z-[100]",
      children: u.jsxs("div", {
        className: "flex flex-col gap-2",
        children: [
          u.jsxs("div", {
            className:
              "flex justify-between font-semibold items-center gap-3 whitespace-nowrap",
            children: [
              u.jsxs("div", {
                className: "flex items-center gap-2",
                children: [s, u.jsx("span", { children: n })],
              }),
              !r && u.jsx(mn, { animate: !0, children: e }),
            ],
          }),
          t &&
            u.jsx("div", {
              className: "flex justify-center items-center mt-1",
              children: u.jsx("div", {
                className:
                  "bg-green-500/20 text-green-400 text-xs font-medium px-3 py-1 text-center rounded-full border border-green-500/30",
                children: t,
              }),
            }),
        ],
      }),
    }),
  hh = ({
    children: n,
    content: e,
    isMobile: t,
    delayDuration: s = 300,
    open: r,
  }) =>
    t
      ? u.jsx(u.Fragment, { children: n })
      : u.jsxs(Xn, {
          delayDuration: s,
          ...(r !== void 0 ? { open: r } : {}),
          children: [u.jsx(Qn, { asChild: !0, children: n }), e],
        }),
  pq = ({ hasEditingPermissions: n, variant: e = "timeline", threadId: t }) => {
    const { accessLevel: s, isCreator: r } = dd(),
      i = s === "viewonly" && !r,
      [a, o] = E.useState(!1),
      { signInWithGoogle: l } = ks(),
      c = e === "reply",
      h = vt((le) => (c ? le.replyToolbar.state : le.state)),
      m = vt((le) => (c ? le.replyToolbar.textContent : le.textContent)),
      p = vt((le) => (c ? le.replyToolbar.recordingType : le.recordingType)),
      g = vt(c ? (le) => le.setReplyTextContent : (le) => le.setTextContent),
      y = vt((le) =>
        c ? le.replyToolbar.recordingDuration : le.recordingDuration
      ),
      b = vt((le) => (c ? le.replyToolbar.previewStream : le.previewStream)),
      w = vt(c ? (le) => le.startReplyRecording : (le) => le.startRecording),
      S = vt(c ? (le) => le.stopReplyRecording : (le) => le.stopRecording),
      A = vt(
        c ? (le) => le.setReplyPreviewStream : (le) => le.setPreviewStream
      ),
      _ = c
        ? E.useCallback(() => {
            t && vt.getState().enterReplyFocusedState(t);
          }, [t])
        : vt((le) => le.enterFocusedState),
      R = vt(c ? (le) => le.exitReplyToIdle : (le) => le.exitToIdle),
      C = c ? null : vt((le) => le.editingElementId),
      D = c ? () => {} : vt((le) => le.clearEditMode),
      L = c ? "element" : vt((le) => le.linkingMode),
      P = c ? t || null : vt((le) => le.targetElementId),
      V = c ? null : vt((le) => le.pendingTimelineLink);
    vt((le) => le.isToolbarHovered);
    const N = vt((le) => le.setToolbarHovered),
      W = vt((le) => le.pendingRecordingCancelCallback),
      H = vt((le) => le.setPendingRecordingCancelCallback),
      z = vt((le) =>
        c ? le.replyToolbar.pendingDiscardCallback : le.pendingDiscardCallback
      ),
      B = vt(
        c
          ? (le) => le.setReplyPendingDiscardCallback
          : (le) => le.setPendingDiscardCallback
      ),
      q = c ? () => {} : vt((le) => le.savePendingLoginText),
      O = c ? () => {} : vt((le) => le.restorePendingLoginText),
      j = vt((le) => le.replyToolbar.threadId) !== null,
      Q = Ce((le) => le.createElement),
      M = Ce((le) => le.updateElement),
      I = Be((le) => le.currentTime),
      F = Be((le) => le.pause),
      Y = hn((le) => le.user),
      J = hn((le) => le.profile);
    pt((le) => le.timelineScale),
      pt((le) => le.timelineOffset),
      pt((le) => le.playbarWidth),
      pt((le) => le.visibleTimeStart),
      pt((le) => le.visibleTimeEnd),
      pt((le) => le.duration);
    const X = 0;
    Y && J && (Y.id, J.full_name, J.avatar_url, Y.email),
      ((le) => (le ? le.split(" ")[0] : null))(J?.full_name) ||
        Y?.email?.split("@")[0];
    const ce = cD(),
      pe = E.useRef(null),
      se = E.useRef(null),
      be = E.useRef(null),
      K = E.useRef(null),
      ve = E.useRef(null),
      Ee = E.useRef(null),
      De = E.useRef(null),
      ge = E.useRef(!1),
      re = E.useRef(!1),
      fe = E.useRef(null),
      ke = E.useRef(null),
      ne = E.useRef(null),
      ie = E.useRef(null),
      [Ne, $e] = E.useState(!1),
      [ot, st] = E.useState(null),
      [ht, xt] = E.useState([0, 0, 0, 0]),
      [_e, Ue] = E.useState(null),
      [He, Ve] = E.useState(null),
      [Ze, ct] = E.useState(() => window.innerWidth < 768),
      [ft, Ye] = E.useState(!1),
      $t = (() => {
        const le = {
          width: 1e3,
          height: 300,
          intensity: 1,
          falloff: 0.7,
          steps: 11,
          easingCurve: [
            0.8, 0.7, 0.55, 0.4, 0.25, 0.15, 0.08, 0.04, 0.02, 0.01,
          ],
        };
        return h === "recording"
          ? { ...le, color: "#FF4444", width: 1500, height: 500, opacity: 0.6 }
          : ["focused", "preparing"].includes(h)
          ? L === "element"
            ? { ...le, color: "#BCD8FF", opacity: 0 }
            : { ...le, color: "#BCD8FF", opacity: 0.4 }
          : { ...le, color: "#000000", opacity: 1 };
      })(),
      wn = (le) => {
        const { color: je, intensity: Ke, steps: ut, easingCurve: St } = le,
          kt = [],
          Kt = St.map((jt, _n) => {
            const ws = (_n / (ut - 2)) * 100;
            return Math.min(ws, 92);
          });
        return (
          St.forEach((jt, _n) => {
            const ws = Math.round(Ke * jt * 255)
                .toString(16)
                .padStart(2, "0"),
              Es = Kt[_n];
            kt.push(`${je}${ws} ${Es}%`);
          }),
          kt.push("transparent 100%"),
          `radial-gradient(ellipse ${le.width / 2}px ${
            le.height / 2
          }px at center, ${kt.join(", ")})`
        );
      },
      Bn = () => {
        se.current &&
          ((se.current.style.height = "auto"),
          (se.current.style.height = `${se.current.scrollHeight}px`));
      },
      Ws = (le) => {
        const je = le.target.value;
        g(je);
      },
      ts = async () => {
        if (m.trim()) {
          if (!Y || !n) {
            q(), o(!0);
            return;
          }
          F();
          try {
            if (C) await M(C, { content: m }), D();
            else {
              const je = Xx(I, null, 1200, 320, 30);
              let Ke;
              if (c && t) {
                const ut = Ce.getState().findRootElementInThread(t);
                ut
                  ? ((Ke = [{ type: "element", targetElementId: ut }]), `${ut}`)
                  : (console.warn(
                      "[ToolbarV2] Could not find root element, linking to thread ID directly"
                    ),
                    (Ke = [{ type: "element", targetElementId: t }]));
              } else if (L === "element" && P) {
                const ut = Ce.getState().findRootElementInThread(P);
                ut
                  ? ((Ke = [{ type: "element", targetElementId: ut }]),
                    `${ut}${P}`)
                  : (console.warn(
                      "[ToolbarV2] Could not find root element, linking to original target"
                    ),
                    (Ke = [{ type: "element", targetElementId: P }]));
              } else Ke = [{ type: "timeline", timestamp: I }];
              c ? vt.getState().exitReplyToIdle() : vt.getState().exitToIdle(),
                !c && j && vt.getState().exitReplyToIdle(),
                se.current && se.current.blur(),
                await Q(
                  "text",
                  { position: je, content: m, title: "Text", links: Ke },
                  void 0,
                  void 0
                );
            }
          } catch {
            Xe.error("Failed to save text");
          }
        }
      },
      Vt = async (le) => {
        if (vt.getState().isAnyToolbarRecording()) return;
        if (
          (Bt.capture("recording_clicked", {
            recording_type: le,
            button_location: "toolbar",
            is_authenticated: !!Y,
            has_editing_permissions: n,
          }),
          !Y)
        ) {
          _(), o(!0);
          return;
        }
        if (!n) return;
        await on.getState().checkPermissions();
        const je = on.getState().permissions,
          ut = le === "thoughts" && je.camera !== "granted",
          St = je.microphone !== "granted";
        if (ut || St) {
          st(le), Ye(!0);
          return;
        }
        if ((st(null), m.trim() && !C)) {
          vt.getState().setPendingDiscardCallback(async () => {
            c ? vt.getState().clearReplyText() : vt.getState().clearText(!0),
              await Je(le);
          });
          return;
        }
        await Je(le);
      },
      Zt = () => {
        De.current && (clearInterval(De.current), (De.current = null)),
          (ge.current = !1),
          (re.current = !1),
          Ue(3),
          Ve(null);
        let le = 3;
        ie.current &&
          ((ie.current.currentTime = 0),
          (ie.current.volume = 0.4),
          ie.current.play().catch(() => {})),
          (De.current = setInterval(() => {
            (le -= 1),
              le > 0
                ? (Ve(le + 1),
                  setTimeout(() => {
                    Ue(le), Ve(null);
                  }, 50),
                  ie.current &&
                    ((ie.current.currentTime = 0),
                    (ie.current.volume = 0.4),
                    ie.current.play().catch(() => {})))
                : (Ve(1),
                  setTimeout(() => {
                    Ue(0), Ve(null);
                  }, 50),
                  (ge.current = !0),
                  De.current &&
                    (clearInterval(De.current), (De.current = null)),
                  setTimeout(() => {
                    ln();
                  }, 100));
          }, 1e3));
      },
      ln = () => {
        if ((ge.current, re.current, ge.current && re.current)) {
          const le = fe.current,
            je = ke.current,
            Ke = ne.current;
          if (!le || !je || !Ke) {
            console.error(
              "[ToolbarV2] Missing pending stream, type, or recorder"
            );
            return;
          }
          if (
            ((fe.current = null),
            (ke.current = null),
            (ne.current = null),
            Ue(null),
            on.getState().isRecording)
          ) {
            console.warn("[ToolbarV2] Already recording, skipping start");
            return;
          }
          try {
            Ke.start(100),
              on.setState({
                isRecording: !0,
                recordingStream: le,
                recordingMediaRecorder: Ke,
                recordingChunks: [],
                recordingType: je,
                recordingStartTime: Date.now(),
              }),
              Bt.capture("recording_started", {
                recording_type: je,
                has_audio: le.getAudioTracks().length > 0,
                has_video: le.getVideoTracks().length > 0,
              });
          } catch (jt) {
            console.error("[ToolbarV2] Failed to start RecordRTC:", jt),
              Xe.error("Failed to start recording"),
              S();
            return;
          }
          c
            ? vt.getState().setReplyToolbarState("recording")
            : vt.getState().setState("recording");
          const St = Date.now(),
            kt = 300;
          let Kt = !1;
          K.current = setInterval(() => {
            const jt = Math.floor((Date.now() - St) / 1e3);
            if (
              (!Kt &&
                jt >= 270 &&
                ((Kt = !0),
                Xe.warning(
                  "Recording will automatically stop in 30 seconds (5 minute limit)"
                )),
              jt >= kt)
            ) {
              Xe.info("Recording stopped - 5 minute limit reached"), zt();
              return;
            }
            const _n = Math.floor(jt / 60)
                .toString()
                .padStart(2, "0"),
              ws = (jt % 60).toString().padStart(2, "0");
            c
              ? vt.getState().setReplyRecordingDuration(`${_n}:${ws}`)
              : vt.getState().setRecordingDuration(`${_n}:${ws}`);
          }, 100);
        }
      },
      Je = async (le) => {
        F(), c || pt.getState().ensurePlayheadVisible();
        try {
          let je = null;
          if (le === "screen") {
            let St = null;
            try {
              (St = await navigator.mediaDevices.getDisplayMedia({
                video: !0,
                audio: !1,
              })),
                w(le),
                Zt();
              const kt = on.getState().settings;
              let Kt = null;
              try {
                Kt = await navigator.mediaDevices.getUserMedia({
                  video: !1,
                  audio: kt?.selectedMicrophoneId
                    ? { deviceId: { exact: kt.selectedMicrophoneId } }
                    : !0,
                });
              } catch (jt) {
                console.warn(
                  "[ToolbarV2] Microphone access failed, using screen only:",
                  jt
                );
              }
              (je = new MediaStream([
                ...St.getVideoTracks(),
                ...(Kt ? Kt.getAudioTracks() : []),
              ])),
                (St.getVideoTracks()[0].onended = () => {
                  zt();
                });
            } catch (kt) {
              St && St.getTracks().forEach((Kt) => Kt.stop()),
                De.current && (clearInterval(De.current), (De.current = null)),
                Ue(null),
                (ge.current = !1),
                (re.current = !1),
                St && (await on.getState().cancelToolbarRecording(), S());
              return;
            }
          } else {
            await on.getState().checkPermissions();
            const St = on.getState().permissions,
              kt = St.camera !== "granted",
              Kt = St.microphone !== "granted";
            if (kt || Kt) {
              on.getState().setPendingRecordingType(le),
                on.getState().openSettingsPopover();
              return;
            }
            await on.getState().enumerateDevices();
            const jt = on.getState().settings,
              _n = jt.availableCameras.length > 0,
              ws = jt.availableMicrophones.length > 0;
            if (!_n || !ws) {
              on.getState().setPendingRecordingType(le),
                on.getState().openSettingsPopover();
              return;
            }
            const Es =
                jt.selectedCameraId &&
                jt.availableCameras.some(
                  (js) => js.deviceId === jt.selectedCameraId
                ),
              ur =
                jt.selectedMicrophoneId &&
                jt.availableMicrophones.some(
                  (js) => js.deviceId === jt.selectedMicrophoneId
                );
            if (!Es || !ur) {
              !Es &&
                _n &&
                on
                  .getState()
                  .setSelectedCamera(jt.availableCameras[0].deviceId),
                !ur &&
                  ws &&
                  on
                    .getState()
                    .setSelectedMicrophone(jt.availableMicrophones[0].deviceId),
                on.getState().setPendingRecordingType(le),
                on.getState().openSettingsPopover();
              return;
            }
            w(le), Zt();
            try {
              const js = on.getState().settings,
                Fs = {
                  video: js?.selectedCameraId
                    ? { deviceId: { exact: js.selectedCameraId } }
                    : !0,
                  audio: js?.selectedMicrophoneId
                    ? { deviceId: { exact: js.selectedMicrophoneId } }
                    : !0,
                };
              je = await navigator.mediaDevices.getUserMedia(Fs);
            } catch {
              Xe.error("Camera or microphone access was denied"), S();
              return;
            }
          }
          if (je) {
            A(je),
              be.current &&
                ((be.current.srcObject = je),
                be.current.play().catch(() => {}));
            try {
              const St = new (window.AudioContext ||
                window.webkitAudioContext)();
              Ee.current = St;
              const kt = je.getAudioTracks();
              if ((kt.length, kt.length > 0)) {
                const Kt = St.createMediaStreamSource(je),
                  jt = St.createAnalyser();
                (jt.fftSize = 256),
                  (jt.smoothingTimeConstant = 0.3),
                  Kt.connect(jt),
                  (ve.current = jt);
                let _n;
                const ws = () => {
                  if (!ve.current) return;
                  const Es = new Uint8Array(ve.current.frequencyBinCount);
                  ve.current.getByteTimeDomainData(Es);
                  let ur = 0;
                  for (let hd = 0; hd < Es.length; hd++) {
                    const em = (Es[hd] - 128) / 128;
                    ur += em * em;
                  }
                  const js = Math.sqrt(ur / Es.length),
                    Fs = Math.min(js * 10, 1),
                    ls = [
                      Fs > 0.1 ? Math.min(0.3 + Fs * 0.7, 1) : 0,
                      Fs > 0.25 ? Math.min(0.3 + Fs * 0.7, 1) : 0,
                      Fs > 0.45 ? Math.min(0.3 + Fs * 0.7, 1) : 0,
                      Fs > 0.65 ? Math.min(0.3 + Fs * 0.7, 1) : 0,
                    ];
                  xt(ls), (_n = requestAnimationFrame(ws));
                };
                ws(), (Ee.current.animationFrameId = _n);
              }
            } catch (St) {
              console.warn("Could not set up audio analysis:", St);
            }
          }
          (fe.current = je), (ke.current = le);
          const Ke = 'video/webm;codecs="vp8,opus"',
            ut = new C7(je, {
              mimeType: Ke,
              videoBitsPerSecond: le === "screen" ? 4e6 : 25e5,
            });
          (ut.ondataavailable = (St) => {
            if (St.data && St.data.size > 0) {
              const kt = on.getState().recordingChunks;
              on.setState({ recordingChunks: [...kt, St.data] });
            }
          }),
            (ne.current = ut),
            (re.current = !0),
            ln();
        } catch {
          Xe.error("Recording failed"),
            fe.current &&
              (fe.current.getTracks().forEach((je) => je.stop()),
              (fe.current = null)),
            (ke.current = null),
            (ne.current = null),
            (re.current = !1),
            S();
        }
      },
      Ge = () => {
        if (h === "preparing") {
          mt();
          return;
        }
        H(async () => {
          await mt();
        });
      },
      mt = async () => {
        K.current && (clearInterval(K.current), (K.current = null)),
          De.current && (clearInterval(De.current), (De.current = null)),
          Ue(null),
          Ve(null),
          (ge.current = !1),
          (re.current = !1),
          fe.current &&
            (fe.current.getTracks().forEach((le) => le.stop()),
            (fe.current = null)),
          (ke.current = null),
          (ne.current = null),
          Ee.current &&
            (Ee.current.animationFrameId &&
              cancelAnimationFrame(Ee.current.animationFrameId),
            Ee.current.close(),
            (Ee.current = null)),
          (ve.current = null),
          xt([0, 0, 0, 0]),
          b && (b.getTracks().forEach((le) => le.stop()), A(null)),
          await on.getState().cancelToolbarRecording(),
          S();
      },
      zt = async () => {
        const le = L,
          je = P,
          Ke = V,
          ut = y;
        K.current && (clearInterval(K.current), (K.current = null)),
          De.current && (clearInterval(De.current), (De.current = null)),
          Ue(null),
          Ve(null),
          (ge.current = !1),
          (re.current = !1),
          fe.current &&
            (fe.current.getTracks().forEach((kt) => kt.stop()),
            (fe.current = null)),
          (ke.current = null),
          (ne.current = null),
          Ee.current &&
            (Ee.current.animationFrameId &&
              cancelAnimationFrame(Ee.current.animationFrameId),
            Ee.current.close(),
            (Ee.current = null)),
          (ve.current = null),
          xt([0, 0, 0, 0]);
        const St = await on.getState().stopToolbarRecording();
        if (
          (b && (b.getTracks().forEach((kt) => kt.stop()), A(null)), S(), St)
        ) {
          const { videoBlob: kt, audioBlob: Kt } = St;
          kt.size, Kt?.size;
          const _n = Xx(I, null, 1200, 320, 30),
            ws = p || "thoughts";
          try {
            let Es;
            if (ut) {
              const [Fs, ls] = ut.split(":").map(Number);
              Es = Fs * 60 + ls;
            }
            const ur = c ? "element" : le,
              js = c ? t : je;
            await on
              .getState()
              .processRecordingBlob(
                kt,
                ws,
                _n,
                I,
                ur,
                js,
                [],
                c ? null : Ke,
                Es,
                Kt
              ),
              c || (le === "element" && vt.getState().exitElementLinking());
          } catch {
            Xe.error("Failed to process recording");
          }
        }
      },
      an = (le) => {
        le.key === "Enter" && !le.shiftKey && (le.preventDefault(), ts());
      };
    return (
      E.useEffect(() => {
        if (be.current && b)
          try {
            (be.current.srcObject = b), be.current.play().catch(() => {});
          } catch {}
      }, [b]),
      E.useEffect(
        () => () => {
          b && b.getTracks().forEach((le) => le.stop());
        },
        [b]
      ),
      E.useEffect(
        () => () => {
          K.current && clearInterval(K.current),
            De.current && clearInterval(De.current);
        },
        []
      ),
      E.useEffect(
        () => (
          typeof window < "u" &&
            ((ie.current = new Audio("/click.wav")),
            (ie.current.preload = "auto")),
          () => {
            ie.current && (ie.current = null);
          }
        ),
        []
      ),
      E.useEffect(() => {
        const le = () => ct(window.innerWidth < 768);
        return (
          window.addEventListener("resize", le),
          () => window.removeEventListener("resize", le)
        );
      }, []),
      E.useEffect(() => {
        Y && a && o(!1);
      }, [Y, a]),
      E.useEffect(() => {
        h === "idle" && a && o(!1);
      }, [h, a]),
      E.useEffect(() => {
        Y && O();
      }, [Y, O]),
      E.useEffect(() => {
        Bn();
      }, [m]),
      E.useEffect(() => {
        const le = (je) => {
          const { type: Ke } = je.detail;
          Ke === "thoughts" && Vt("thoughts");
        };
        return (
          window.addEventListener("startPendingRecording", le),
          () => {
            window.removeEventListener("startPendingRecording", le);
          }
        );
      }, []),
      E.useEffect(() => {
        const le = (je) => {
          je.key === "Escape" &&
            (h === "recording" || h === "preparing"
              ? (je.preventDefault(), je.stopPropagation(), Ge())
              : h === "focused" && m.trim() && !C
              ? (je.preventDefault(),
                je.stopPropagation(),
                B(() => {
                  c
                    ? vt.getState().clearReplyText()
                    : vt.getState().clearText(),
                    R(),
                    se.current && se.current.blur();
                }))
              : h === "focused" &&
                !m.trim() &&
                (je.preventDefault(),
                je.stopPropagation(),
                R(),
                se.current && se.current.blur()));
        };
        return (
          window.addEventListener("keydown", le, !0),
          () => {
            window.removeEventListener("keydown", le, !0);
          }
        );
      }, [h, m, C, c, B, R]),
      E.useEffect(() => {
        L === "timeline" &&
          (h === "focused" || h === "preparing" || h === "recording") &&
          setTimeout(() => {
            pt.getState().ensurePlayheadVisible();
          }, 50);
      }, [h, L]),
      E.useEffect(() => {
        h === "idle" && N(!1);
      }, [h, N]),
      E.useEffect(() => {
        const le = () => {
          Ge();
        };
        return (
          window.addEventListener("toolbarV2CancelRecording", le),
          () => {
            window.removeEventListener("toolbarV2CancelRecording", le);
          }
        );
      }, []),
      i
        ? null
        : u.jsxs(Br, {
            delayDuration: 300,
            children: [
              u.jsx("div", {
                className:
                  "absolute bottom-0 left-1/2 -translate-x-1/2 pointer-events-none z-[39]",
                children: u.jsxs("div", {
                  className: "relative",
                  style: {
                    width: `${$t.width}px`,
                    height: `${$t.height}px`,
                    transform: "translateY(50%)",
                  },
                  children: [
                    u.jsx("div", {
                      className:
                        "absolute inset-0 w-full h-full transition-opacity duration-100",
                      style: {
                        opacity: h === "idle" ? $t.opacity : 0,
                        background: wn({ ...$t, color: "#000000" }),
                      },
                    }),
                    u.jsx("div", {
                      className:
                        "absolute inset-0 w-full h-full transition-opacity duration-100",
                      style: {
                        opacity:
                          h === "recording" || h === "idle" ? 0 : $t.opacity,
                        background: wn({ ...$t, color: "#BCD8FF" }),
                      },
                    }),
                    u.jsx("div", {
                      className:
                        "absolute inset-0 w-full h-full transition-opacity duration-100",
                      style: {
                        opacity: h === "recording" ? $t.opacity : 0,
                        background: wn({
                          ...$t,
                          color: "#FF4444",
                          width: 1500,
                          height: 500,
                        }),
                      },
                    }),
                  ],
                }),
              }),
              !c && X < 0,
              u.jsx("div", {
                className: Le(
                  c ? "w-full" : "fixed bottom-2 left-1/2",
                  "transition-transform duration-200 ease-out",
                  "flex flex-col-reverse items-center",
                  "z-[60] pointer-events-auto"
                ),
                style: {
                  transformOrigin: "bottom center",
                  transform: c ? void 0 : "translateX(-50%)",
                },
                children: u.jsxs("div", {
                  className: Le("relative", c && "w-full"),
                  onMouseEnter: () => {
                    c || N(!0);
                  },
                  onMouseLeave: () => {
                    c || N(!1);
                  },
                  children: [
                    !c &&
                      u.jsx("div", {
                        className: "absolute inset-0 pointer-events-auto",
                        style: {
                          top: "-10px",
                          bottom: "-100px",
                          left: "-10px",
                          right: "-50px",
                        },
                      }),
                    u.jsx("div", {
                      className: Le(
                        c ? "display-none" : "rounded-[22px]",
                        c
                          ? "border border-transparent"
                          : "border-[0.5px] border-text-primary/10",
                        "transition-all duration-200 ease-out",
                        c && "w-full"
                      ),
                      children: u.jsxs("div", {
                        ref: (le) => {
                          ce && "current" in ce && (ce.current = le),
                            (pe.current = le);
                        },
                        className: Le(
                          "relative flex items-stretch",
                          "z-[41] overflow-visible",
                          c ? "border-0" : "bg-element-background",
                          c ? "-mt-2" : "border-t border-white/10",
                          h === "idle" && "",
                          "transition-all duration-200 ease-out",
                          c
                            ? "border-t border-border shadow-none"
                            : "rounded-[22px] shadow-lg shadow-black/30",
                          c
                            ? "w-full h-auto flex-col"
                            : h === "preparing" || h === "recording"
                            ? "w-[350px] md:w-[400px] h-auto flex-col"
                            : "w-[300px] h-auto"
                        ),
                        style: { backgroundImage: c ? void 0 : "" },
                        onMouseDown: (le) => {
                          le.stopPropagation();
                        },
                        children: [
                          (h === "preparing" || h === "recording") &&
                            u.jsxs("div", {
                              className: "w-full",
                              children: [
                                u.jsx("div", {
                                  className: "w-full p-3 ",
                                  children: u.jsxs("div", {
                                    className:
                                      "w-full aspect-video rounded-2xl overflow-hidden bg-black border border-text-secondary/20 relative",
                                    children: [
                                      b &&
                                        u.jsx("video", {
                                          ref: be,
                                          autoPlay: !0,
                                          muted: !0,
                                          playsInline: !0,
                                          className:
                                            "w-full h-full object-cover transition-opacity duration-300 opacity-100",
                                        }),
                                      h === "preparing" &&
                                        u.jsx("div", {
                                          className: Le(
                                            "absolute inset-0 rounded-2xl bg-black/60 backdrop-blur-sm",
                                            "flex items-center justify-center",
                                            "transition-opacity duration-300",
                                            _e === 0
                                              ? "opacity-0"
                                              : "opacity-100"
                                          ),
                                          children: u.jsxs("div", {
                                            className: "relative",
                                            children: [
                                              He !== null &&
                                                u.jsx(
                                                  "span",
                                                  {
                                                    className:
                                                      "absolute inset-0 flex items-center justify-center text-4xl font-bold text-white drop-shadow-lg animate-out slide-out-to-top-4 fade-out-0 duration-300",
                                                    children: He,
                                                  },
                                                  `out-${He}`
                                                ),
                                              _e !== null && _e > 0
                                                ? u.jsx(
                                                    "span",
                                                    {
                                                      className:
                                                        "text-4xl font-bold text-white drop-shadow-lg animate-in slide-in-from-bottom-4 fade-in-0 duration-300",
                                                      children: _e,
                                                    },
                                                    _e
                                                  )
                                                : _e === null
                                                ? u.jsx("span", {
                                                    className:
                                                      "text-sm font-mono text-white/80",
                                                    children: "Get ready..",
                                                  })
                                                : null,
                                            ],
                                          }),
                                        }),
                                    ],
                                  }),
                                }),
                                u.jsx("div", {
                                  className:
                                    "relative flex items-center justify-between px-3 mb-4 h-10",
                                  children:
                                    (h === "preparing" || h === "recording") &&
                                    u.jsxs(u.Fragment, {
                                      children: [
                                        u.jsx(hh, {
                                          isMobile: Ze,
                                          delayDuration: 300,
                                          content: u.jsx(Pn, {
                                            side: "top",
                                            className: "z-[100]",
                                            children: u.jsxs("div", {
                                              className:
                                                "flex items-center gap-2",
                                              children: [
                                                u.jsx("span", {
                                                  children: "Cancel recording",
                                                }),
                                                !c &&
                                                  u.jsx(mn, {
                                                    animate: !1,
                                                    className: "text-xs",
                                                    children: "ESC",
                                                  }),
                                              ],
                                            }),
                                          }),
                                          children: u.jsx("button", {
                                            className:
                                              "flex items-center justify-center w-8 h-8 ml-1 rounded-full bg-card-background hover:bg-element-background/80 transition-all duration-200 cursor-pointer",
                                            onClick: Ge,
                                            ...(c
                                              ? {
                                                  "data-peek-toolbar-cancel-btn":
                                                    !0,
                                                }
                                              : {
                                                  "data-toolbar-cancel-btn": !0,
                                                }),
                                            children: u.jsx(Pa, {
                                              className:
                                                "w-5 h-5 text-text-secondary/50",
                                            }),
                                          }),
                                        }),
                                        u.jsx("div", {
                                          className:
                                            "absolute left-1/2 -translate-x-1/2 flex items-center gap-1 animate-in fade-in-0 duration-300",
                                          children: ht.map((le, je) => {
                                            const Ke = [
                                                "#CFDEF6",
                                                "#CFDEF6",
                                                "#CFDEF6",
                                                "#CFDEF6",
                                              ],
                                              ut =
                                                (h === "preparing" ||
                                                  h === "recording") &&
                                                le > 0;
                                            return u.jsx(
                                              "div",
                                              {
                                                className: Le(
                                                  "w-1 h-2 rounded-full transition-all duration-75",
                                                  !ut && "bg-gray-700"
                                                ),
                                                style: {
                                                  ...(ut && {
                                                    backgroundColor: Ke[je],
                                                    opacity: le,
                                                  }),
                                                },
                                              },
                                              je
                                            );
                                          }),
                                        }),
                                        u.jsx(hh, {
                                          isMobile: Ze,
                                          delayDuration: 300,
                                          content: u.jsx(Pn, {
                                            side: "top",
                                            className: "z-[100]",
                                            children: u.jsxs("div", {
                                              className:
                                                "flex items-center gap-2",
                                              children: [
                                                u.jsx("span", {
                                                  children: "Stop",
                                                }),
                                                !c &&
                                                  u.jsx(mn, {
                                                    animate: !1,
                                                    className: "text-xs",
                                                    children: "",
                                                  }),
                                              ],
                                            }),
                                          }),
                                          children: u.jsxs("button", {
                                            ...(c
                                              ? {
                                                  "data-peek-toolbar-stop-btn":
                                                    !0,
                                                }
                                              : {
                                                  "data-toolbar-stop-btn": !0,
                                                }),
                                            onClick: zt,
                                            disabled: h === "preparing",
                                            className: Le(
                                              "flex items-center gap-2 px-4 h-10 rounded-full transition-all duration-200 animate-in slide-in-from-top-2 fade-in-0",
                                              h === "recording"
                                                ? "bg-red-500 hover:bg-red-500/80 cursor-pointer"
                                                : "bg-card-background cursor-not-allowed"
                                            ),
                                            children: [
                                              u.jsx("div", {
                                                className: Le(
                                                  "w-3 h-3 rounded-[2px]",
                                                  h === "recording"
                                                    ? "bg-white"
                                                    : "bg-text-secondary/50"
                                                ),
                                              }),
                                              u.jsx("span", {
                                                className: Le(
                                                  "text-sm font-mono font-semibold",
                                                  h === "recording"
                                                    ? "text-white"
                                                    : "text-text-secondary"
                                                ),
                                                children:
                                                  h === "recording"
                                                    ? u.jsxs(u.Fragment, {
                                                        children: [
                                                          y,
                                                          y >= "04:30" &&
                                                            " (max 5:00)",
                                                        ],
                                                      })
                                                    : "00:00",
                                              }),
                                            ],
                                          }),
                                        }),
                                      ],
                                    }),
                                }),
                              ],
                            }),
                          !(h === "preparing" || h === "recording") &&
                            u.jsxs("div", {
                              className: "relative w-full p-3 flex flex-col",
                              children: [
                                a &&
                                  u.jsx("div", {
                                    className: "w-full p-3 mb-3",
                                    children: u.jsx("div", {
                                      className:
                                        "w-full bg-card-background py-3 px-3 rounded-3xl border-t border-white/30 text-white shadow-md shadow-black/50",
                                      children: u.jsxs("div", {
                                        className:
                                          "flex flex-col items-center space-y-2",
                                        children: [
                                          u.jsx("div", {
                                            className: "text-center space-y-1",
                                            children: u.jsx("h2", {
                                              className: "text-md font-bold",
                                              children: "Almost there",
                                            }),
                                          }),
                                          u.jsxs("button", {
                                            onClick: async () => {
                                              try {
                                                const le =
                                                  window.location.pathname +
                                                  window.location.search;
                                                await l(le);
                                              } catch (le) {
                                                console.error(
                                                  "Error signing in with Google:",
                                                  le
                                                );
                                              }
                                            },
                                            className:
                                              "w-full bg-white text-black hover:bg-white/90 px-4 py-2.5 rounded-xl font-medium flex items-center justify-center transition-colors text-sm",
                                            children: [
                                              u.jsxs("svg", {
                                                className: "w-4 h-4 mr-2",
                                                viewBox: "0 0 24 24",
                                                fill: "none",
                                                xmlns:
                                                  "http://www.w3.org/2000/svg",
                                                children: [
                                                  u.jsx("path", {
                                                    d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z",
                                                    fill: "#4285F4",
                                                  }),
                                                  u.jsx("path", {
                                                    d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z",
                                                    fill: "#34A853",
                                                  }),
                                                  u.jsx("path", {
                                                    d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z",
                                                    fill: "#FBBC05",
                                                  }),
                                                  u.jsx("path", {
                                                    d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z",
                                                    fill: "#EA4335",
                                                  }),
                                                ],
                                              }),
                                              "Continue with Google",
                                            ],
                                          }),
                                          u.jsx("p", {
                                            className:
                                              "text-xs text-text-primary pt-0",
                                            children:
                                              "Your comment will be saved",
                                          }),
                                          u.jsxs("p", {
                                            className:
                                              "text-xs text-text-secondary text-center opacity-50 pt-4",
                                            children: [
                                              "By continuing, you agree to the ",
                                              u.jsx("a", {
                                                href: "/terms-of-service",
                                                className:
                                                  "text-text-primary hover:underline",
                                                children: "Terms of Service",
                                              }),
                                              " and ",
                                              u.jsx("a", {
                                                href: "/privacy-policy",
                                                className:
                                                  "text-text-primary hover:underline",
                                                children: "Privacy Policy",
                                              }),
                                              ".",
                                            ],
                                          }),
                                        ],
                                      }),
                                    }),
                                  }),
                                u.jsx("div", {
                                  className: "cursor-text",
                                  onClick: (le) => {
                                    const je = le.target;
                                    !je.closest("button") &&
                                      !je.closest(
                                        "[data-toolbar-thoughts-btn]"
                                      ) &&
                                      !je.closest(
                                        "[data-toolbar-screen-btn]"
                                      ) &&
                                      !je.closest(
                                        "[data-toolbar-submit-btn]"
                                      ) &&
                                      !je.closest(
                                        "[data-toolbar-settings-btn]"
                                      ) &&
                                      je !== se.current &&
                                      se.current?.focus();
                                  },
                                  children: u.jsx("textarea", {
                                    ref: se,
                                    ...(c
                                      ? { "data-peek-toolbar-textbox": !0 }
                                      : { "data-toolbar-textbox": !0 }),
                                    value: m,
                                    onChange: Ws,
                                    onKeyDown: an,
                                    onFocus: () => {
                                      $e(!0), !m && h === "idle" && _();
                                    },
                                    onBlur: (le) => {
                                      const je = le.relatedTarget;
                                      (je &&
                                        (je.closest("[data-tag-picker]") ||
                                          je.closest("[role='dialog']") ||
                                          je.closest(".link-dots") ||
                                          je.closest(
                                            "[data-toolbar-thoughts-btn]"
                                          ) ||
                                          je.closest(
                                            "[data-toolbar-screen-btn]"
                                          ) ||
                                          je.closest(
                                            "[data-toolbar-submit-btn]"
                                          ))) ||
                                        $e(!1);
                                    },
                                    placeholder:
                                      c || L === "element"
                                        ? "Add your reply.."
                                        : "Leave your comment..",
                                    className: Le(
                                      "w-full bg-transparent border-none outline-none resize-none",
                                      "text-text-primary placeholder:text-text-primary/80",
                                      "text-sm",
                                      "transition-all duration-300 px-1 mt-0.5",
                                      h !== "idle" && "opacity-90"
                                    ),
                                    style: {
                                      height: "auto",
                                      lineHeight: "1.5",
                                      minHeight: "28px",
                                    },
                                    rows: 1,
                                    onInput: Bn,
                                  }),
                                }),
                                u.jsxs("div", {
                                  className:
                                    "relative flex items-center justify-between -mb-1.5 -mx-1.5 ",
                                  children: [
                                    u.jsxs("div", {
                                      className:
                                        "flex items-center gap-1 pointer-events-auto",
                                      children: [
                                        u.jsx(hh, {
                                          isMobile: Ze,
                                          delayDuration: 300,
                                          content: u.jsx(B1, {
                                            title: "Record Thoughts",
                                            keycapLetter: "R",
                                            description:
                                              "2.7x faster than typing",
                                            icon: u.jsx(K0e, {
                                              className: "w-4 h-4",
                                            }),
                                            hideKeycap: c,
                                          }),
                                          children: u.jsxs("div", {
                                            className:
                                              "h-8 px-4 pl-3 rounded-full flex items-center gap-2 cursor-pointer  transition-all duration-0 button-secondary !bg-text-primary/5",
                                            "data-toolbar-thoughts-btn": !0,
                                            onClick: () => {
                                              Vt("thoughts");
                                            },
                                            tabIndex: 0,
                                            children: [
                                              u.jsx("div", {
                                                className:
                                                  "w-2 h-2 rounded-full bg-red-500 mb-0.5",
                                              }),
                                              u.jsx("span", {
                                                className:
                                                  " text-text-primary mb-0.5 text-sm",
                                                children: "Record",
                                              }),
                                            ],
                                          }),
                                        }),
                                        u.jsx("div", {
                                          className: "hidden md:block",
                                          children: u.jsx(hh, {
                                            isMobile: Ze,
                                            delayDuration: 300,
                                            content: u.jsx(B1, {
                                              title: "Record Screen",
                                              keycapLetter: "S",
                                              description:
                                                "Show anything on screen",
                                              icon: u.jsx(c$, {
                                                className: "w-4 h-4",
                                              }),
                                              hideKeycap: c,
                                            }),
                                            children: u.jsx("div", {
                                              className:
                                                "h-8 w-8 rounded-full flex items-center justify-center cursor-pointer transition-all duration-0 button-secondary !bg-text-primary/5",
                                              "data-toolbar-screen-btn": !0,
                                              onClick: () => {
                                                Vt("screen");
                                              },
                                              tabIndex: 0,
                                              children: u.jsx(c$, {
                                                className:
                                                  "w-4 h-4 text-text-primary",
                                              }),
                                            }),
                                          }),
                                        }),
                                        u.jsx(hh, {
                                          isMobile: Ze,
                                          delayDuration: 300,
                                          content: u.jsx(Pn, {
                                            side: "top",
                                            className: "z-[100]",
                                            children: "Recording options",
                                          }),
                                          children: u.jsx("div", {
                                            className:
                                              "px-1 h-6 w-6 flex items-center justify-center cursor-pointer text-text-secondary hover:text-text-primary  transition-colors rounded-full",
                                            "data-toolbar-settings-btn": !0,
                                            onClick: () => Ye(!0),
                                            children: u.jsx(lL, {
                                              className: "w-3 h-3",
                                            }),
                                          }),
                                        }),
                                      ],
                                    }),
                                    u.jsx(hh, {
                                      isMobile: Ze,
                                      delayDuration: 0,
                                      open: m.trim() ? void 0 : !1,
                                      content: u.jsx(B1, {
                                        title: "Submit",
                                        keycapLetter: "",
                                        hideKeycap: c,
                                      }),
                                      children: u.jsx("button", {
                                        "data-toolbar-submit-btn": !0,
                                        disabled: !m.trim(),
                                        onClick: ts,
                                        className: Le(
                                          "h-8 w-8 rounded-full flex items-center justify-center transition-all duration-200",
                                          m.trim()
                                            ? "button-primary cursor-pointer"
                                            : "bg-card-background/50 text-border"
                                        ),
                                        children: u.jsx(OH, {
                                          className: "w-4 h-4 mt-0.5 mr-0.5",
                                        }),
                                      }),
                                    }),
                                  ],
                                }),
                              ],
                            }),
                        ],
                      }),
                    }),
                  ],
                }),
              }),
              u.jsx(os, {
                open: !!z,
                onOpenChange: (le) => !le && B(null),
                children: u.jsxs(Jn, {
                  className: "sm:max-w-[425px]",
                  children: [
                    u.jsx(bs, {
                      children: u.jsx(xs, {
                        children: "Discard unsaved changes?",
                      }),
                    }),
                    u.jsx("div", {
                      className: "text-sm text-muted-foreground",
                      children:
                        "You have unsaved text. Do you want to discard it?",
                    }),
                    u.jsxs(xr, {
                      className: "gap-2",
                      children: [
                        u.jsx(et, {
                          variant: "ghost",
                          onClick: () => B(null),
                          children: "Keep Editing",
                        }),
                        u.jsx("button", {
                          className:
                            "button-primary flex items-center rounded-xl justify-center px-6 py-3 cursor-pointer text-sm font-medium",
                          onClick: () => {
                            if (z) {
                              const le = z;
                              B(null), le();
                            }
                          },
                          autoFocus: !0,
                          children: u.jsx("span", { children: "Discard" }),
                        }),
                      ],
                    }),
                  ],
                }),
              }),
              u.jsx(Cye, {
                isOpen: ft,
                onClose: () => {
                  Ye(!1), st(null);
                },
                hasEditingPermissions: n,
                isMobile: Ze,
                pendingRecordingType: ot,
              }),
              u.jsx(os, {
                open: !!W,
                onOpenChange: (le) => !le && H(null),
                children: u.jsxs(Jn, {
                  className: "sm:max-w-[425px]",
                  children: [
                    u.jsx(bs, {
                      children: u.jsx(xs, { children: "Cancel recording?" }),
                    }),
                    u.jsx("div", {
                      className: "text-sm text-muted-foreground",
                      children:
                        "Are you sure you want to cancel this recording? This action cannot be undone.",
                    }),
                    u.jsxs(xr, {
                      className: "gap-2",
                      children: [
                        u.jsx(et, {
                          variant: "ghost",
                          onClick: () => H(null),
                          children: "Keep Recording",
                        }),
                        u.jsx("button", {
                          className:
                            "button-primary flex items-center rounded-xl justify-center px-6 py-3 cursor-pointer text-sm font-medium",
                          onClick: async () => {
                            if (W) {
                              const le = W;
                              H(null), await le();
                            }
                          },
                          autoFocus: !0,
                          children: "Cancel Recording",
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          })
    );
  },
  Lye = ({ offsetX: n = 0, offsetY: e = 0 }) =>
    u.jsx("div", {
      className:
        "absolute inset-0 w-full h-full bg-card-background pointer-events-none",
      style: {
        backgroundImage:
          "radial-gradient(circle, #7C7C7C 1px, transparent 1px)",
        backgroundSize: `${pF}px ${pF}px`,
        backgroundPosition: `${n}px ${e}px`,
        opacity: 0.35,
      },
    }),
  Dye = 12,
  up = {
    "accent-purple": "#a78bfa",
    "accent-blue": "#60a5fa",
    "accent-teal": "#5eead4",
    "accent-green": "#4ade80",
    "accent-lime": "#bef264",
    "accent-orange": "#fdba74",
    "accent-red": "#f87171",
    "accent-gray": "#a1a1aa",
  },
  rc = (n, e) => {
    const t = parseInt(n.slice(1, 3), 16),
      s = parseInt(n.slice(3, 5), 16),
      r = parseInt(n.slice(5, 7), 16);
    return `rgba(${t}, ${s}, ${r}, ${e})`;
  },
  Pye = ({ duration: n, getTimeFromPosition: e, hasEditingPermissions: t }) => {
    const [s, r] = E.useState(null),
      [i, a] = E.useState(null),
      [o, l] = E.useState(null),
      c = E.useRef(null),
      h = Ce((H) => H.boardState.elements);
    vn((H) => H.activeFilterIds), vn((H) => H.filterMode);
    const m = vn((H) => H.isElementVisible),
      p = Ce((H) => H.isCurrentUserElementOwner),
      g = Ce((H) => H.checkElementOwnership),
      y = Ce((H) => H.updateElementLinkVisual),
      b = Ce((H) => H.commitElementLinkUpdate),
      w = Ce((H) => H.startPillOperation),
      S = Ce((H) => H.updatePillOperation),
      A = Ce((H) => H.endPillOperation),
      _ = Be((H) => H.requestPreview),
      R = Be((H) => H.exitPreview),
      C = Ce((H) => H.selectedFrames),
      D = Ce((H) => H.selectElementWithModifiers),
      L = Ce((H) => H.getElementTags),
      P = E.useMemo(() => {
        const H = [];
        return (
          Object.entries(h).forEach(([z, B]) => {
            B &&
              B.links &&
              B.links.forEach((q, O) => {
                q.type === "timeline" &&
                  H.push({ elementId: z, element: B, linkIndex: O, link: q });
              });
          }),
          H
        );
      }, [h]),
      V = E.useCallback(
        (H, z, B, q, O) => {
          if (
            (H.stopPropagation(),
            H.preventDefault(),
            !g(z, "link modification"))
          )
            return;
          const U = q.timeRange?.start ?? q.timestamp ?? 0,
            j = q.timeRange?.end ?? q.timestamp ?? 0,
            Q = e(H.clientX);
          l({
            elementId: z,
            linkIndex: B,
            type: O,
            initialMouseX: H.clientX,
            initialStartTime: U,
            initialEndTime: j,
            currentStartTime: U,
            currentEndTime: j,
            initialTimeAtMouse: Q,
            isDragging: !1,
          });
        },
        [g, e]
      ),
      N = E.useCallback(
        (H) => {
          if (!o || !c.current) return;
          const z = 5,
            B = Math.abs(H.clientX - o.initialMouseX),
            {
              elementId: q,
              linkIndex: O,
              type: U,
              initialStartTime: j,
              initialEndTime: Q,
              initialTimeAtMouse: M,
            } = o,
            I = Q - j;
          if (!o.isDragging) {
            if (B < z) return;
            const Z = U === "resize-start" ? j : U === "resize-end" ? Q : j;
            w(U === "move" ? "move" : "resize", q, O, Z, { start: j, end: Q }),
              _(Z, "linkdots"),
              l((te) => (te ? { ...te, isDragging: !0 } : null));
            return;
          }
          const F = e(H.clientX);
          let Y = j,
            J = Q;
          if (U === "move") {
            const Z = F - M;
            (Y = j + Z),
              (J = Q + Z),
              Y < 0 && ((Y = 0), (J = I)),
              J > n && ((J = n), (Y = n - I));
          } else
            U === "resize-start"
              ? ((Y = F), (J = Q), Y > J && ([Y, J] = [J, Y]))
              : U === "resize-end" &&
                ((Y = j), (J = F), J < Y && ([Y, J] = [J, Y]));
          (Y = Math.max(0, Math.min(Y, n))),
            (J = Math.max(0, Math.min(J, n))),
            l((Z) =>
              Z ? { ...Z, currentStartTime: Y, currentEndTime: J } : null
            ),
            y(q, O, {
              timestamp: Y === J ? Y : void 0,
              timeRange: Y !== J ? { start: Y, end: J } : void 0,
            });
          const X = U === "resize-start" ? Y : U === "resize-end" ? J : Y;
          S(X, { start: Y, end: J }), _(X, "linkdots");
        },
        [o, n, e, y, S, _, w]
      ),
      W = E.useCallback(async () => {
        if (!o) return;
        const {
          elementId: H,
          linkIndex: z,
          currentStartTime: B,
          currentEndTime: q,
          isDragging: O,
        } = o;
        O &&
          (y(H, z, {
            timestamp: B === q ? B : void 0,
            timeRange: B !== q ? { start: B, end: q } : void 0,
          }),
          await b(H, z),
          A(),
          R()),
          l(null);
      }, [o, y, b, A, R]);
    return (
      E.useEffect(() => {
        if (o) {
          const H = (B) => N(B),
            z = () => W();
          return (
            window.addEventListener("mousemove", H),
            window.addEventListener("mouseup", z),
            o.isDragging &&
              (document.body.style.cursor =
                o.type === "move" ? "grabbing" : "ew-resize"),
            () => {
              window.removeEventListener("mousemove", H),
                window.removeEventListener("mouseup", z),
                (document.body.style.cursor = "");
            }
          );
        }
      }, [o, N, W]),
      !P.length || n <= 0
        ? null
        : u.jsx("div", {
            ref: c,
            className:
              "link-dots relative w-full h-full flex items-center pointer-events-none top-[22px] overflow-visible",
            children: P.map(
              ({ elementId: H, element: z, linkIndex: B, link: q }) => {
                const O = C.includes(H),
                  U = o?.elementId === H && o?.linkIndex === B,
                  Q = (s === H && !o) || U;
                if (!m(z)) return null;
                const I = t && p(H);
                let F, Y;
                U && o
                  ? ((F = o.currentStartTime), (Y = o.currentEndTime))
                  : ((F = q.timeRange?.start ?? q.timestamp ?? 0),
                    (Y = q.timeRange?.end ?? q.timestamp ?? 0));
                const J = Math.max(0, Math.min(F, n)),
                  X = Math.max(0, Math.min(Y, n)),
                  Z = (J / n) * 100,
                  te = (X / n) * 100,
                  ce = Math.max(0, te - Z),
                  pe = Math.abs(X - J) < 0.01,
                  se = L(H),
                  be = se.length > 0 ? se[0].color : void 0,
                  K = rc((be && up[be]) || "#FAFAFA", 0.5),
                  Ee = (() => {
                    if (se.length === 0)
                      return { backgroundColor: rc("#E2E8F0", O ? 0.8 : 0.4) };
                    if (se.length === 1) {
                      const ie = up[se[0].color] || "#E2E8F0";
                      return { backgroundColor: rc(ie, O ? 1 : 0.7) };
                    }
                    const ke = se.map((ie) => up[ie.color] || "#E2E8F0");
                    return {
                      background: `linear-gradient(90deg, ${ke
                        .map((ie, Ne) => {
                          const $e = (Ne / (ke.length - 1)) * 100;
                          return `${rc(ie, O ? 1 : 0.7)} ${$e}%`;
                        })
                        .join(", ")})`,
                    };
                  })(),
                  De = pe ? `calc(${Z}% - 34px)` : `${Z}%`,
                  ge = X - J,
                  re = pe
                    ? 100
                    : Math.max(
                        10,
                        100 - Math.floor(Math.log10(ge * 1e3 + 1) * 10)
                      ),
                  fe = () => {
                    if (!Q) return {};
                    if (se.length === 0)
                      return {
                        backgroundColor: rc("#E2E8F0", O ? 0.95 : 0.65),
                      };
                    if (se.length === 1) {
                      const ie = up[se[0].color] || "#E2E8F0";
                      return { backgroundColor: rc(ie, O ? 1 : 0.9) };
                    }
                    const ke = se.map((ie) => up[ie.color] || "#E2E8F0");
                    return {
                      background: `linear-gradient(90deg, ${ke
                        .map((ie, Ne) => {
                          const $e = (Ne / (ke.length - 1)) * 100;
                          return `${rc(ie, O ? 1 : 0.9)} ${$e}%`;
                        })
                        .join(", ")})`,
                    };
                  };
                return u.jsxs(
                  "div",
                  {
                    className: Le(
                      "absolute top-2 h-full group overflow-visible",
                      pe ? "pointer-events-none" : "pointer-events-auto"
                    ),
                    style: {
                      left: De,
                      width: pe ? "68px" : `${ce}%`,
                      minWidth: pe ? "68px" : `${Dye}px`,
                      zIndex: re,
                    },
                    onMouseEnter: () => !o && !pe && r(H),
                    onMouseLeave: () => !o && !pe && r(null),
                    children: [
                      u.jsx("div", {
                        className: Le(
                          "absolute transform backdrop-blur-md rounded-[8px] pointer-events-auto",
                          pe ? "w-4 left-1/2 -translate-x-1/2" : "w-full",
                          !U && "cursor-pointer"
                        ),
                        style: {
                          ...(Q ? fe() : Ee),
                          borderTop: `1px solid ${K}`,
                          boxShadow:
                            "inset 0 0 10px rgba(255, 255, 255, 0.4), 0 4px 12px rgba(0, 0, 0, 0.5), 0 2px 6px rgba(0, 0, 0, 0.3)",
                          position: "relative",
                          height: Q ? "28px" : "16px",
                          top: Q ? "-30px" : "-24px",
                          transition: "all 200ms",
                        },
                        onClick: (ke) => {
                          (o && o.isDragging) || (ke.stopPropagation(), D(H));
                        },
                        onMouseDown: (ke) => {
                          I && V(ke, H, B, q, "move");
                        },
                        onMouseEnter: () => !o && pe && r(H),
                        onMouseLeave: () => !o && pe && r(null),
                      }),
                      I &&
                        u.jsxs(u.Fragment, {
                          children: [
                            u.jsx("div", {
                              className:
                                "absolute cursor-ew-resize pointer-events-auto",
                              style: {
                                left: pe ? "21px" : "-4px",
                                top: "-16px",
                                transform: "translateY(-50%)",
                                width: "16px",
                                zIndex: 12,
                              },
                              onMouseEnter: () => {
                                a({ elementId: H, linkIndex: B, side: "left" }),
                                  r(H);
                              },
                              onMouseLeave: () => {
                                a(null), r(null);
                              },
                              onMouseDown: (ke) => {
                                ke.preventDefault(),
                                  ke.stopPropagation(),
                                  V(ke, H, B, q, "resize-start");
                              },
                              children: u.jsx("div", {
                                className:
                                  "absolute rounded-full  bg-text-primary",
                                style: {
                                  left: "4px",
                                  transform: "translateY(-50%)",
                                  width: "3px",
                                  height: "20px",
                                  boxShadow: "0 2px 4px rgba(0, 0, 0, 0.2)",
                                  opacity:
                                    (i?.elementId === H &&
                                      i?.linkIndex === B &&
                                      i?.side === "left") ||
                                    (U && o?.type === "resize-start")
                                      ? 1
                                      : 0,
                                },
                              }),
                            }),
                            u.jsx("div", {
                              className:
                                "absolute cursor-ew-resize pointer-events-auto",
                              style: {
                                right: pe ? "21px" : "-4px",
                                top: "-16px",
                                transform: "translateY(-50%)",
                                width: "16px",
                                zIndex: 12,
                              },
                              onMouseEnter: () => {
                                a({
                                  elementId: H,
                                  linkIndex: B,
                                  side: "right",
                                }),
                                  r(H);
                              },
                              onMouseLeave: () => {
                                a(null), r(null);
                              },
                              onMouseDown: (ke) => {
                                ke.preventDefault(),
                                  ke.stopPropagation(),
                                  V(ke, H, B, q, "resize-end");
                              },
                              children: u.jsx("div", {
                                className:
                                  "absolute rounded-full bg-text-primary",
                                style: {
                                  right: "4px",
                                  top: "50%",
                                  transform: "translateY(-50%)",
                                  width: "3px",
                                  height: "20px",
                                  boxShadow: "0 2px 4px rgba(0, 0, 0, 0.2)",
                                  opacity:
                                    (i?.elementId === H &&
                                      i?.linkIndex === B &&
                                      i?.side === "right") ||
                                    (U && o?.type === "resize-end")
                                      ? 1
                                      : 0,
                                },
                              }),
                            }),
                          ],
                        }),
                    ],
                  },
                  `${H}-${B}`
                );
              }
            ),
          })
    );
  },
  Mye = ({ playbarWidth: n, isDragging: e, hoverTime: t }) => {
    const s = Be((o) => o.duration);
    if (t === null) return null;
    const i = (s > 0 ? t / s : 0) * n,
      a = zg(t);
    return u.jsx("div", {
      className:
        "absolute pointer-events-none z-50 flex items-center justify-center text-xs px-3 py-1 rounded-full transform -translate-x-1/2 font-mono border bg-border text-primary border-border",
      style: { left: `${i}px`, top: "-30px" },
      children: a,
    });
  },
  Nye = {
    second: [1, 2, 5, 10, 15, 30],
    minute: [1, 2, 5, 10, 15, 30],
    hour: [1, 2, 3, 4, 6, 12],
    day: [1, 2, 3, 7, 14],
  },
  Oye = 120;
function jye(n, e) {
  const t = ["second", "minute", "hour", "day"];
  for (const s of t) {
    const r = Nye[s];
    for (const i of r) {
      let a;
      switch (s) {
        case "second":
          a = i;
          break;
        case "minute":
          a = i * 60;
          break;
        case "hour":
          a = i * 3600;
          break;
        case "day":
          a = i * 86400;
          break;
        default:
          a = 1;
      }
      const o = n / a;
      if (e / o >= Oye) return { unit: s, step: i };
    }
  }
  return { unit: "second", step: 1 };
}
function Fye(n, e = !1) {
  const t = Math.floor(n),
    s = Math.floor(t / 3600),
    r = Math.floor((t % 3600) / 60),
    i = t % 60,
    a = [],
    o = e ? "hour" : "h",
    l = e ? "min" : "m",
    c = e ? "sec" : "s";
  return (
    s > 0 &&
      a.push(
        u.jsxs(
          de.Fragment,
          {
            children: [
              s,
              u.jsx("span", {
                style: { opacity: 0.6, verticalAlign: "baseline" },
                children: o,
              }),
            ],
          },
          "h"
        )
      ),
    (r > 0 || s > 0) &&
      (a.length > 0 && a.push(u.jsx(de.Fragment, { children: ":" }, "h-sep")),
      a.push(
        u.jsxs(
          de.Fragment,
          {
            children: [
              r.toString().padStart(2, "0"),
              u.jsx("span", {
                style: { opacity: 0.6, verticalAlign: "baseline" },
                children: l,
              }),
            ],
          },
          "m"
        )
      )),
    ((s === 0 && r === 0) || i > 0) &&
      (a.length > 0 && a.push(u.jsx(de.Fragment, { children: ":" }, "m-sep")),
      a.push(
        u.jsxs(
          de.Fragment,
          {
            children: [
              i.toString().padStart(2, "0"),
              u.jsx("span", {
                style: { opacity: 0.6, verticalAlign: "baseline" },
                children: c,
              }),
            ],
          },
          "s"
        )
      )),
    u.jsx(u.Fragment, { children: a })
  );
}
function Uye(n, e, t, s, r) {
  let i;
  switch (t) {
    case "second":
      i = s;
      break;
    case "minute":
      i = s * 60;
      break;
    case "hour":
      i = s * 3600;
      break;
    case "day":
      i = s * 86400;
      break;
    default:
      i = 1;
  }
  const a = Math.ceil(n / i) * i;
  for (
    let o = a;
    (o < e || Math.abs(o - e) < 0.001) && !(o > e + 0.001);
    o += i
  )
    r(o);
}
const $ye = ({ duration: n, playbarWidth: e, isFullscreen: t = !1 }) => {
    const s = pt((p) => p.visibleDuration),
      r = pt((p) => p.visibleTimeStart),
      i = pt((p) => p.visibleTimeEnd),
      a = pt((p) => p.timelineScale),
      o = t ? 1 : a,
      l = s > 0 ? s : n,
      {
        majorTicks: c,
        minorTicks: h,
        useVerboseLabels: m,
      } = E.useMemo(() => {
        const p = typeof window < "u" ? window.innerWidth - 80 : 1840,
          g = n / o,
          { unit: y, step: b } = jye(g, p),
          w = [],
          S = 500;
        Uye(0, n, y, b, (P) => {
          P > 0 && P < n + 0.001 && w.length < S && w.push(P);
        });
        const A = [];
        let _ = b;
        y === "minute"
          ? (_ *= 60)
          : y === "hour"
          ? (_ *= 3600)
          : y === "day" && (_ *= 86400);
        let R = 0;
        _ >= 10 || _ >= 5
          ? (R = _ / 5)
          : _ >= 2
          ? (R = _ / 2)
          : _ >= 0.9 && _ <= 1.1 && (R = 0.2);
        const C = p / g,
          D = R * C;
        if (R > 0 && D > 2)
          for (let P = R; P < n; P += R) {
            const V = R < 1 ? 0.05 : R * 0.1;
            !w.some((W) => Math.abs(W - P) < V) && A.length < S && A.push(P);
          }
        let L = !1;
        if (w.length > 0) {
          const P = w.some((W) => Math.floor(W / 3600) > 0),
            V = w.some((W) => Math.floor((W % 3600) / 60) > 0),
            N = w.some((W) => W % 60 > 0);
          ((V && !N && !P) ||
            (N && !V && !P) ||
            (P && w.every((W) => W % 3600 === 0))) &&
            (L = !0);
        }
        return {
          majorTicks: w,
          minorTicks: A,
          unit: y,
          step: b,
          useVerboseLabels: L,
        };
      }, [n, e, l, r, i, o]);
    return !n || n <= 0 || e <= 0
      ? null
      : u.jsxs("div", {
          style: {
            position: "absolute",
            left: 0,
            width: `${e}px`,
            top: 0,
            height: "100%",
            opacity: 1,
            zIndex: 5,
            pointerEvents: "none",
          },
          children: [
            c.map((p) => {
              const g = (p / n) * 100;
              return u.jsxs(
                de.Fragment,
                {
                  children: [
                    u.jsx("div", {
                      className: "text-text-secondary/70",
                      style: {
                        position: "absolute",
                        left: `${g}%`,
                        top: "-23px",
                        transform: "translateX(-50%)",
                        fontSize: 12,
                        fontFamily: "monospace, sans-serif",
                        fontWeight: 500,
                        lineHeight: 1,
                        textAlign: "center",
                        pointerEvents: "none",
                        userSelect: "none",
                        whiteSpace: "nowrap",
                      },
                      children: Fye(p, m),
                    }),
                    u.jsx("div", {
                      className: "bg-text-primary/70 rounded-full",
                      style: {
                        position: "absolute",
                        left: `${g}%`,
                        top: -10,
                        width: 1,
                        opacity: 0.7,
                        height: "10px",
                      },
                    }),
                    u.jsx("div", {
                      style: {
                        background:
                          "linear-gradient(to bottom, rgba(0,0,0,0.50) 0%, rgba(0,0,0,0) 100%)",
                        position: "absolute",
                        left: `${g}%`,
                        top: 0,
                        width: 1,
                        height: "100%",
                      },
                    }),
                  ],
                },
                `major-${p}`
              );
            }),
            h.map((p) => {
              const g = (p / n) * 100;
              return u.jsxs(
                de.Fragment,
                {
                  children: [
                    u.jsx("div", {
                      className: "bg-text-primary",
                      style: {
                        position: "absolute",
                        left: `${g}%`,
                        top: -5,
                        width: 1,
                        height: "5px",
                        opacity: 0.4,
                      },
                    }),
                    u.jsx("div", {
                      style: {
                        position: "absolute",
                        left: `${g}%`,
                        top: 0,
                        width: 1,
                        height: "100%",
                        background:
                          "linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 80%)",
                        pointerEvents: "none",
                      },
                    }),
                  ],
                },
                `minor-${p}`
              );
            }),
          ],
        });
  },
  Bye = ({ isOpen: n, onClose: e }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        children: [
          u.jsxs(bs, {
            children: [
              u.jsx(xs, { children: "Active Recording Detected" }),
              u.jsx(Cl, {
                children:
                  "You are currently recording. End the active recording before starting another one.",
              }),
            ],
          }),
          u.jsx(xr, {
            children: u.jsx(et, { onClick: e, autoFocus: !0, children: "OK" }),
          }),
        ],
      }),
    }),
  Hye = ({ isDragging: n = !1, toolbarProps: e, isFullscreen: t = !1 }) => {
    const s = E.useRef(null),
      [r, i] = E.useState(!1),
      { accessLevel: a, isCreator: o } = dd(),
      l = a === "viewonly" && !o;
    AH(),
      Ce((S) => S.boardState),
      Ce((S) => S.createElement),
      Ce((S) => S.setSelectedFrames);
    const c = E.useRef(0),
      h = Be((S) => S.duration),
      m = Be((S) => S.currentTime),
      p = h > 0 ? (m / h) * 100 : 0,
      g = vt((S) => S.setPlayheadHovered),
      y = Be((S) => S.setPlayheadHover);
    E.useEffect(() => {
      c.current = Date.now();
    }, [p]);
    const w = cD({ transformWrapperRef: null });
    return (
      E.useEffect(() => {
        const S = s.current;
        if (!S) return;
        const A = (_) => {
          let R = S.parentElement;
          for (; R; ) {
            if (R.classList.contains("overflow-hidden")) {
              const C = new WheelEvent("wheel", {
                deltaX: _.deltaX,
                deltaY: _.deltaY,
                deltaZ: _.deltaZ,
                deltaMode: _.deltaMode,
                clientX: _.clientX,
                clientY: _.clientY,
                screenX: _.screenX,
                screenY: _.screenY,
                ctrlKey: _.ctrlKey,
                shiftKey: _.shiftKey,
                altKey: _.altKey,
                metaKey: _.metaKey,
                button: _.button,
                buttons: _.buttons,
                relatedTarget: _.relatedTarget,
                view: _.view,
                bubbles: !0,
                cancelable: !0,
              });
              R.dispatchEvent(C), _.preventDefault(), _.stopPropagation();
              break;
            }
            R = R.parentElement;
          }
        };
        return (
          S.addEventListener("wheel", A, { passive: !1 }),
          () => {
            S.removeEventListener("wheel", A);
          }
        );
      }, []),
      u.jsxs(u.Fragment, {
        children: [
          u.jsx(Bye, { isOpen: r, onClose: () => i(!1) }),
          u.jsx("div", {
            ref: (S) => {
              (s.current = S), (w.current = S);
            },
            className:
              "absolute z-[25] handle-current flex items-center justify-center overflow-hidden transition-all duration-300 ease-out backdrop-blur-sm drop-shadow-lg cursor-pointer",
            style: {
              left: `${p}%`,
              top: "12px",
              transform: "translate(-50%, -50%)",
              pointerEvents: "auto",
              width: "16px",
              height: "32px",
              borderRadius: "8px",
              backgroundColor: "rgba(226, 232, 240, 0.4)",
              borderTop: "1px solid #FAFAFA",
              boxShadow:
                "inset 0 0 10px rgba(255, 255, 255, 0.4), 0 0px 18px -1px rgba(0, 0, 0, 0.4)",
            },
            onMouseEnter: () => {
              !n && !l && !t && (g(!0), y(!0));
            },
            onMouseLeave: () => {
              t || (g(!1), y(!1));
            },
          }),
        ],
      })
    );
  },
  gq = ({
    currentTime: n,
    duration: e,
    isPlaying: t,
    playbarWidth: s,
    hasEditingPermissions: r,
    youtubeUrl: i,
    nativeAsset: a,
    onCreateLinkedFrame: o,
    onCreateElementInFrame: l,
    preventSeekOnLinkClick: c = !0,
    onPlayheadHoverChange: h,
    timelineScale: m = 1,
    isFullscreen: p = !1,
  }) => {
    const g = E.useRef(null),
      [y, b] = E.useState(!1),
      [w, S] = E.useState(null),
      [A, _] = E.useState(!1);
    E.useRef(null),
      Ce((X) => X.boardState),
      Ce((X) => X.selectedFrames),
      Ce((X) => X.setSelectedFrames);
    const R = Ce((X) => X.recordPlayheadInteraction);
    Be((X) => X.togglePlayPause);
    const C = Be((X) => X.seek);
    Be((X) => X.isCountingDown), Be((X) => X.countdownProgress);
    const D = Be((X) => X.setPlaybarHover),
      L = Be((X) => X.setPlayheadHover);
    Be((X) => X.requestPreview), Be((X) => X.exitPreview);
    const P = Be((X) => X.exitPreviewWithoutRestoration),
      V = Be((X) => X.setupDefensiveCleanup),
      N = n,
      W = !!(i || a?.hls_url);
    E.useMemo(() => (i ? Sf(i) : null), [i]);
    const H = E.useCallback(
        (X) => {
          if (!g.current || e <= 0) return 0;
          const Z = g.current.getBoundingClientRect();
          return Z.width === 0
            ? 0
            : Math.max(0, Math.min(1, (X - Z.left) / Z.width)) * e;
        },
        [e]
      ),
      z = E.useCallback(
        (X) => {
          if (!g.current || e <= 0) return !1;
          const Z = g.current.getBoundingClientRect();
          if (Z.width === 0) return !1;
          const te = Z.left + (n / e) * Z.width;
          return Math.abs(X - te) <= 20;
        },
        [n, e]
      ),
      B = E.useCallback(
        (X) => {
          if (!y && g.current) {
            const Z = g.current.getBoundingClientRect();
            if (
              X.clientY >= Z.top &&
              X.clientY <= Z.bottom &&
              X.clientX >= Z.left &&
              X.clientX <= Z.right
            ) {
              const ce = H(X.clientX),
                pe = z(X.clientX);
              S(ce), L(pe), D(!0, ce);
            } else S(null), L(!1), D(!1);
          }
        },
        [H, z, D, L, y]
      ),
      q = E.useCallback(() => {
        y || (S(null), D(!1), L(!1), _(!1));
      }, [y, D, L]),
      O = Be((X) => X.previewTimestamp),
      U = Be((X) => X.previewSource),
      j = Be((X) => X.setPreviewMode),
      Q = Be((X) => X.isPreviewMode),
      M = Be((X) => X.seekPreviewOnly),
      I = Be((X) => X.pauseForPreview),
      F = Be((X) => X.exitPreviewWithRestoration);
    E.useEffect(() => {
      O !== null && U
        ? Q
          ? M(O)
          : (j(!0, O),
            I(),
            setTimeout(() => {
              M(O);
            }, 50))
        : O === null && Q && U === null && F();
    }, [O, U, Q, j, M, I, F]),
      E.useEffect(() => V(), [V]),
      E.useEffect(() => {
        y && Q && U !== "linkdots" && P();
      }, [y, Q, U, P]);
    const Y = E.useCallback(
      (X) => {
        if (!g.current || e <= 0) return;
        X.preventDefault();
        const Z = Be.getState().wasPlayingBeforePreview;
        P(), S(null);
        const te = H(X.clientX);
        b(!0), C(te);
        let ce = null;
        const pe = (be) => {
            be.preventDefault(),
              ce && cancelAnimationFrame(ce),
              (ce = requestAnimationFrame(() => {
                const K = H(be.clientX);
                C(K);
              }));
          },
          se = (be) => {
            ce && (cancelAnimationFrame(ce), (ce = null)),
              document.removeEventListener("mousemove", pe),
              document.removeEventListener("mouseup", se);
            const K = H(be.clientX);
            R(K),
              b(!1),
              S(null),
              Z &&
                setTimeout(() => {
                  const { play: ve } = Be.getState();
                  ve();
                }, 50);
          };
        document.addEventListener("mousemove", pe),
          document.addEventListener("mouseup", se);
      },
      [e, H, C, P, z, L, D]
    );
    E.useCallback(
      (X) => {
        _(X), X && L(!0);
      },
      [L]
    );
    const J = Le(
      "video-playbar relative flex h-full items-center justify-center  rounded-full text-white",
      { "select-none": y }
    );
    return u.jsxs("div", {
      className: J,
      style: { position: "relative", zIndex: 10 },
      children: [
        !p &&
          u.jsx("div", {
            className:
              "absolute left-1/2 -translate-x-1/2 pointer-events-none w-[1000000px] -z-[2] bg-card-background",
            style: { top: "-100px", height: "134px" },
          }),
        u.jsxs("div", {
          className:
            "relative rounded-sm flex-grow bg-transparent overflow-visible",
          children: [
            u.jsxs("div", {
              ref: g,
              className: Le(
                "h-6 rounded-full relative element-border overflow-visible   bg-gradient-to-b from-grey-400 to-slate-400/20 bg-text-secondary/20",
                W
                  ? y
                    ? "cursor-grabbing"
                    : "cursor-pointer"
                  : "cursor-not-allowed"
              ),
              style: { width: `${s}px` },
              onMouseMove:
                !W || y
                  ? void 0
                  : (X) => {
                      X.stopPropagation(), B(X);
                    },
              onMouseDown: W
                ? (X) => {
                    X.stopPropagation(), Y(X);
                  }
                : void 0,
              onMouseLeave: q,
              children: [
                u.jsx("div", {
                  className:
                    "absolute inset-0 overflow-hidden rounded-sm pointer-events-none",
                  children: u.jsxs("div", {
                    className:
                      "absolute top-0 left-0 h-6 rounded-l-full rounded-r-2xl pointer-events-none overflow-hidden transition-none border-0",
                    style: {
                      width: `${!W || e <= 0 ? 0 : (N / e) * 100}%`,
                      backgroundColor: "#CFDFF6",
                    },
                    children: [
                      u.jsx("div", {
                        className: "absolute inset-0",
                        style: {
                          backgroundImage: "url('/svgs/playbargradient.svg')",
                          backgroundRepeat: "no-repeat",
                          backgroundPosition: "right center",
                          backgroundSize: "auto 100%",
                        },
                      }),
                      u.jsx("div", {
                        className:
                          "absolute inset-0 shadow-inner shadow-cyan-100/70",
                      }),
                    ],
                  }),
                }),
                w !== null &&
                  !y &&
                  u.jsx("div", {
                    className:
                      "absolute top-0 bottom-0 w-0.5 pointer-events-none bg-white",
                    style: {
                      left: `${e > 0 ? (w / e) * 100 : 0}%`,
                      transform: "translateX(0)",
                    },
                  }),
                u.jsx($ye, {
                  duration: e,
                  playbarWidth: s,
                  timelineScale: m,
                  isFullscreen: p,
                }),
              ],
            }),
            W &&
              e > 1 &&
              !p &&
              u.jsx("div", {
                style: {
                  position: "absolute",
                  left: 0,
                  width: "100%",
                  top: "100%",
                  zIndex: 5,
                },
                children: u.jsx(Pye, {
                  duration: e,
                  getTimeFromPosition: H,
                  hasEditingPermissions: r,
                }),
              }),
            W &&
              e > 0 &&
              !y &&
              u.jsx(Mye, { playbarWidth: s, isDragging: y, hoverTime: w }),
          ],
        }),
        u.jsx(Hye, {
          isDragging: y,
          isFullscreen: p,
          toolbarProps: {
            flaskId: void 0,
            hasEditingPermissions: r,
            currentTime: n,
            duration: e,
            flask: void 0,
            isCreator: !1,
            onAccessLevelChange: void 0,
          },
        }),
      ],
    });
  },
  Wg = E.createContext({});
function dD(n) {
  const e = E.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const hD = typeof window < "u",
  fD = hD ? E.useLayoutEffect : E.useEffect,
  YE = E.createContext(null);
function mD(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function pD(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
const Rl = (n, e, t) => (t > e ? e : t < n ? n : t);
let gD = () => {};
const kl = {},
  vq = (n) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);
function yq(n) {
  return typeof n == "object" && n !== null;
}
const bq = (n) => /^0[^.\s]+$/u.test(n);
function vD(n) {
  let e;
  return () => (e === void 0 && (e = n()), e);
}
const oa = (n) => n,
  Vye = (n, e) => (t) => e(n(t)),
  $v = (...n) => n.reduce(Vye),
  Kg = (n, e, t) => {
    const s = e - n;
    return s === 0 ? 1 : (t - n) / s;
  };
class yD {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return mD(this.subscriptions, e), () => pD(this.subscriptions, e);
  }
  notify(e, t, s) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, s);
      else
        for (let i = 0; i < r; i++) {
          const a = this.subscriptions[i];
          a && a(e, t, s);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Co = (n) => n * 1e3,
  Io = (n) => n / 1e3;
function xq(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const wq = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  zye = 1e-7,
  Gye = 12;
function qye(n, e, t, s, r) {
  let i,
    a,
    o = 0;
  do (a = e + (t - e) / 2), (i = wq(a, s, r) - n), i > 0 ? (t = a) : (e = a);
  while (Math.abs(i) > zye && ++o < Gye);
  return a;
}
function Bv(n, e, t, s) {
  if (n === e && t === s) return oa;
  const r = (i) => qye(i, 0, 1, n, t);
  return (i) => (i === 0 || i === 1 ? i : wq(r(i), e, s));
}
const Eq = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  Sq = (n) => (e) => 1 - n(1 - e),
  Tq = Bv(0.33, 1.53, 0.69, 0.99),
  bD = Sq(Tq),
  _q = Eq(bD),
  Aq = (n) =>
    (n *= 2) < 1 ? 0.5 * bD(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  xD = (n) => 1 - Math.sin(Math.acos(n)),
  Rq = Sq(xD),
  kq = Eq(xD),
  Wye = Bv(0.42, 0, 1, 1),
  Kye = Bv(0, 0, 0.58, 1),
  Cq = Bv(0.42, 0, 0.58, 1),
  Yye = (n) => Array.isArray(n) && typeof n[0] != "number",
  Iq = (n) => Array.isArray(n) && typeof n[0] == "number",
  Xye = {
    linear: oa,
    easeIn: Wye,
    easeInOut: Cq,
    easeOut: Kye,
    circIn: xD,
    circInOut: kq,
    circOut: Rq,
    backIn: bD,
    backInOut: _q,
    backOut: Tq,
    anticipate: Aq,
  },
  Qye = (n) => typeof n == "string",
  h$ = (n) => {
    if (Iq(n)) {
      gD(n.length === 4);
      const [e, t, s, r] = n;
      return Bv(e, t, s, r);
    } else if (Qye(n)) return Xye[n];
    return n;
  },
  Dy = [
    "setup",
    "read",
    "resolveKeyframes",
    "preUpdate",
    "update",
    "preRender",
    "render",
    "postRender",
  ];
function Zye(n, e) {
  let t = new Set(),
    s = new Set(),
    r = !1,
    i = !1;
  const a = new WeakSet();
  let o = { delta: 0, timestamp: 0, isProcessing: !1 };
  function l(h) {
    a.has(h) && (c.schedule(h), n()), h(o);
  }
  const c = {
    schedule: (h, m = !1, p = !1) => {
      const y = p && r ? t : s;
      return m && a.add(h), y.has(h) || y.add(h), h;
    },
    cancel: (h) => {
      s.delete(h), a.delete(h);
    },
    process: (h) => {
      if (((o = h), r)) {
        i = !0;
        return;
      }
      (r = !0),
        ([t, s] = [s, t]),
        t.forEach(l),
        t.clear(),
        (r = !1),
        i && ((i = !1), c.process(h));
    },
  };
  return c;
}
const Jye = 40;
function Lq(n, e) {
  let t = !1,
    s = !0;
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    i = () => (t = !0),
    a = Dy.reduce((_, R) => ((_[R] = Zye(i)), _), {}),
    {
      setup: o,
      read: l,
      resolveKeyframes: c,
      preUpdate: h,
      update: m,
      preRender: p,
      render: g,
      postRender: y,
    } = a,
    b = () => {
      const _ = kl.useManualTiming ? r.timestamp : performance.now();
      (t = !1),
        kl.useManualTiming ||
          (r.delta = s
            ? 1e3 / 60
            : Math.max(Math.min(_ - r.timestamp, Jye), 1)),
        (r.timestamp = _),
        (r.isProcessing = !0),
        o.process(r),
        l.process(r),
        c.process(r),
        h.process(r),
        m.process(r),
        p.process(r),
        g.process(r),
        y.process(r),
        (r.isProcessing = !1),
        t && e && ((s = !1), n(b));
    },
    w = () => {
      (t = !0), (s = !0), r.isProcessing || n(b);
    };
  return {
    schedule: Dy.reduce((_, R) => {
      const C = a[R];
      return (_[R] = (D, L = !1, P = !1) => (t || w(), C.schedule(D, L, P))), _;
    }, {}),
    cancel: (_) => {
      for (let R = 0; R < Dy.length; R++) a[Dy[R]].cancel(_);
    },
    state: r,
    steps: a,
  };
}
const {
  schedule: qn,
  cancel: Uc,
  state: gr,
  steps: H1,
} = Lq(typeof requestAnimationFrame < "u" ? requestAnimationFrame : oa, !0);
let Ab;
function ebe() {
  Ab = void 0;
}
const oi = {
    now: () => (
      Ab === void 0 &&
        oi.set(
          gr.isProcessing || kl.useManualTiming
            ? gr.timestamp
            : performance.now()
        ),
      Ab
    ),
    set: (n) => {
      (Ab = n), queueMicrotask(ebe);
    },
  },
  Dq = (n) => (e) => typeof e == "string" && e.startsWith(n),
  wD = Dq("--"),
  tbe = Dq("var(--"),
  ED = (n) => (tbe(n) ? nbe.test(n.split("/*")[0].trim()) : !1),
  nbe =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Kf = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  Yg = { ...Kf, transform: (n) => Rl(0, 1, n) },
  Py = { ...Kf, default: 1 },
  Jp = (n) => Math.round(n * 1e5) / 1e5,
  SD = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function sbe(n) {
  return n == null;
}
const rbe =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  TD = (n, e) => (t) =>
    !!(
      (typeof t == "string" && rbe.test(t) && t.startsWith(n)) ||
      (e && !sbe(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  Pq = (n, e, t) => (s) => {
    if (typeof s != "string") return s;
    const [r, i, a, o] = s.match(SD);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(i),
      [t]: parseFloat(a),
      alpha: o !== void 0 ? parseFloat(o) : 1,
    };
  },
  ibe = (n) => Rl(0, 255, n),
  V1 = { ...Kf, transform: (n) => Math.round(ibe(n)) },
  Ou = {
    test: TD("rgb", "red"),
    parse: Pq("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: s = 1 }) =>
      "rgba(" +
      V1.transform(n) +
      ", " +
      V1.transform(e) +
      ", " +
      V1.transform(t) +
      ", " +
      Jp(Yg.transform(s)) +
      ")",
  };
function abe(n) {
  let e = "",
    t = "",
    s = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (s = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (s = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (s += s),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(s, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const Vk = { test: TD("#"), parse: abe, transform: Ou.transform },
  Hv = (n) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  mc = Hv("deg"),
  Lo = Hv("%"),
  It = Hv("px"),
  obe = Hv("vh"),
  lbe = Hv("vw"),
  f$ = {
    ...Lo,
    parse: (n) => Lo.parse(n) / 100,
    transform: (n) => Lo.transform(n * 100),
  },
  zh = {
    test: TD("hsl", "hue"),
    parse: Pq("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: s = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      Lo.transform(Jp(e)) +
      ", " +
      Lo.transform(Jp(t)) +
      ", " +
      Jp(Yg.transform(s)) +
      ")",
  },
  Ps = {
    test: (n) => Ou.test(n) || Vk.test(n) || zh.test(n),
    parse: (n) =>
      Ou.test(n) ? Ou.parse(n) : zh.test(n) ? zh.parse(n) : Vk.parse(n),
    transform: (n) =>
      typeof n == "string"
        ? n
        : n.hasOwnProperty("red")
        ? Ou.transform(n)
        : zh.transform(n),
    getAnimatableNone: (n) => {
      const e = Ps.parse(n);
      return (e.alpha = 0), Ps.transform(e);
    },
  },
  cbe =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function ube(n) {
  return (
    isNaN(n) &&
    typeof n == "string" &&
    (n.match(SD)?.length || 0) + (n.match(cbe)?.length || 0) > 0
  );
}
const Mq = "number",
  Nq = "color",
  dbe = "var",
  hbe = "var(",
  m$ = "${}",
  fbe =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Xg(n) {
  const e = n.toString(),
    t = [],
    s = { color: [], number: [], var: [] },
    r = [];
  let i = 0;
  const o = e
    .replace(
      fbe,
      (l) => (
        Ps.test(l)
          ? (s.color.push(i), r.push(Nq), t.push(Ps.parse(l)))
          : l.startsWith(hbe)
          ? (s.var.push(i), r.push(dbe), t.push(l))
          : (s.number.push(i), r.push(Mq), t.push(parseFloat(l))),
        ++i,
        m$
      )
    )
    .split(m$);
  return { values: t, split: o, indexes: s, types: r };
}
function Oq(n) {
  return Xg(n).values;
}
function jq(n) {
  const { split: e, types: t } = Xg(n),
    s = e.length;
  return (r) => {
    let i = "";
    for (let a = 0; a < s; a++)
      if (((i += e[a]), r[a] !== void 0)) {
        const o = t[a];
        o === Mq
          ? (i += Jp(r[a]))
          : o === Nq
          ? (i += Ps.transform(r[a]))
          : (i += r[a]);
      }
    return i;
  };
}
const mbe = (n) =>
  typeof n == "number" ? 0 : Ps.test(n) ? Ps.getAnimatableNone(n) : n;
function pbe(n) {
  const e = Oq(n);
  return jq(n)(e.map(mbe));
}
const $c = {
  test: ube,
  parse: Oq,
  createTransformer: jq,
  getAnimatableNone: pbe,
};
function z1(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function gbe({ hue: n, saturation: e, lightness: t, alpha: s }) {
  (n /= 360), (e /= 100), (t /= 100);
  let r = 0,
    i = 0,
    a = 0;
  if (!e) r = i = a = t;
  else {
    const o = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - o;
    (r = z1(l, o, n + 1 / 3)), (i = z1(l, o, n)), (a = z1(l, o, n - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(i * 255),
    blue: Math.round(a * 255),
    alpha: s,
  };
}
function Jx(n, e) {
  return (t) => (t > 0 ? e : n);
}
const as = (n, e, t) => n + (e - n) * t,
  G1 = (n, e, t) => {
    const s = n * n,
      r = t * (e * e - s) + s;
    return r < 0 ? 0 : Math.sqrt(r);
  },
  vbe = [Vk, Ou, zh],
  ybe = (n) => vbe.find((e) => e.test(n));
function p$(n) {
  const e = ybe(n);
  if (!e) return !1;
  let t = e.parse(n);
  return e === zh && (t = gbe(t)), t;
}
const g$ = (n, e) => {
    const t = p$(n),
      s = p$(e);
    if (!t || !s) return Jx(n, e);
    const r = { ...t };
    return (i) => (
      (r.red = G1(t.red, s.red, i)),
      (r.green = G1(t.green, s.green, i)),
      (r.blue = G1(t.blue, s.blue, i)),
      (r.alpha = as(t.alpha, s.alpha, i)),
      Ou.transform(r)
    );
  },
  zk = new Set(["none", "hidden"]);
function bbe(n, e) {
  return zk.has(n) ? (t) => (t <= 0 ? n : e) : (t) => (t >= 1 ? e : n);
}
function xbe(n, e) {
  return (t) => as(n, e, t);
}
function _D(n) {
  return typeof n == "number"
    ? xbe
    : typeof n == "string"
    ? ED(n)
      ? Jx
      : Ps.test(n)
      ? g$
      : Sbe
    : Array.isArray(n)
    ? Fq
    : typeof n == "object"
    ? Ps.test(n)
      ? g$
      : wbe
    : Jx;
}
function Fq(n, e) {
  const t = [...n],
    s = t.length,
    r = n.map((i, a) => _D(i)(i, e[a]));
  return (i) => {
    for (let a = 0; a < s; a++) t[a] = r[a](i);
    return t;
  };
}
function wbe(n, e) {
  const t = { ...n, ...e },
    s = {};
  for (const r in t)
    n[r] !== void 0 && e[r] !== void 0 && (s[r] = _D(n[r])(n[r], e[r]));
  return (r) => {
    for (const i in s) t[i] = s[i](r);
    return t;
  };
}
function Ebe(n, e) {
  const t = [],
    s = { color: 0, var: 0, number: 0 };
  for (let r = 0; r < e.values.length; r++) {
    const i = e.types[r],
      a = n.indexes[i][s[i]],
      o = n.values[a] ?? 0;
    (t[r] = o), s[i]++;
  }
  return t;
}
const Sbe = (n, e) => {
  const t = $c.createTransformer(e),
    s = Xg(n),
    r = Xg(e);
  return s.indexes.var.length === r.indexes.var.length &&
    s.indexes.color.length === r.indexes.color.length &&
    s.indexes.number.length >= r.indexes.number.length
    ? (zk.has(n) && !r.values.length) || (zk.has(e) && !s.values.length)
      ? bbe(n, e)
      : $v(Fq(Ebe(s, r), r.values), t)
    : Jx(n, e);
};
function Uq(n, e, t) {
  return typeof n == "number" && typeof e == "number" && typeof t == "number"
    ? as(n, e, t)
    : _D(n)(n, e);
}
const Tbe = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: (t = !0) => qn.update(e, t),
      stop: () => Uc(e),
      now: () => (gr.isProcessing ? gr.timestamp : oi.now()),
    };
  },
  $q = (n, e, t = 10) => {
    let s = "";
    const r = Math.max(Math.round(e / t), 2);
    for (let i = 0; i < r; i++)
      s += Math.round(n(i / (r - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${s.substring(0, s.length - 2)})`;
  },
  ew = 2e4;
function AD(n) {
  let e = 0;
  const t = 50;
  let s = n.next(e);
  for (; !s.done && e < ew; ) (e += t), (s = n.next(e));
  return e >= ew ? 1 / 0 : e;
}
function _be(n, e = 100, t) {
  const s = t({ ...n, keyframes: [0, e] }),
    r = Math.min(AD(s), ew);
  return {
    type: "keyframes",
    ease: (i) => s.next(r * i).value / e,
    duration: Io(r),
  };
}
const Abe = 5;
function Bq(n, e, t) {
  const s = Math.max(e - Abe, 0);
  return xq(t - n(s), e - s);
}
const hs = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  q1 = 0.001;
function Rbe({
  duration: n = hs.duration,
  bounce: e = hs.bounce,
  velocity: t = hs.velocity,
  mass: s = hs.mass,
}) {
  let r,
    i,
    a = 1 - e;
  (a = Rl(hs.minDamping, hs.maxDamping, a)),
    (n = Rl(hs.minDuration, hs.maxDuration, Io(n))),
    a < 1
      ? ((r = (c) => {
          const h = c * a,
            m = h * n,
            p = h - t,
            g = Gk(c, a),
            y = Math.exp(-m);
          return q1 - (p / g) * y;
        }),
        (i = (c) => {
          const m = c * a * n,
            p = m * t + t,
            g = Math.pow(a, 2) * Math.pow(c, 2) * n,
            y = Math.exp(-m),
            b = Gk(Math.pow(c, 2), a);
          return ((-r(c) + q1 > 0 ? -1 : 1) * ((p - g) * y)) / b;
        }))
      : ((r = (c) => {
          const h = Math.exp(-c * n),
            m = (c - t) * n + 1;
          return -q1 + h * m;
        }),
        (i = (c) => {
          const h = Math.exp(-c * n),
            m = (t - c) * (n * n);
          return h * m;
        }));
  const o = 5 / n,
    l = Cbe(r, i, o);
  if (((n = Co(n)), isNaN(l)))
    return { stiffness: hs.stiffness, damping: hs.damping, duration: n };
  {
    const c = Math.pow(l, 2) * s;
    return { stiffness: c, damping: a * 2 * Math.sqrt(s * c), duration: n };
  }
}
const kbe = 12;
function Cbe(n, e, t) {
  let s = t;
  for (let r = 1; r < kbe; r++) s = s - n(s) / e(s);
  return s;
}
function Gk(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const Ibe = ["duration", "bounce"],
  Lbe = ["stiffness", "damping", "mass"];
function v$(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function Dbe(n) {
  let e = {
    velocity: hs.velocity,
    stiffness: hs.stiffness,
    damping: hs.damping,
    mass: hs.mass,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!v$(n, Lbe) && v$(n, Ibe))
    if (n.visualDuration) {
      const t = n.visualDuration,
        s = (2 * Math.PI) / (t * 1.2),
        r = s * s,
        i = 2 * Rl(0.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(r);
      e = { ...e, mass: hs.mass, stiffness: r, damping: i };
    } else {
      const t = Rbe(n);
      (e = { ...e, ...t, mass: hs.mass }), (e.isResolvedFromDuration = !0);
    }
  return e;
}
function tw(n = hs.visualDuration, e = hs.bounce) {
  const t =
    typeof n != "object"
      ? { visualDuration: n, keyframes: [0, 1], bounce: e }
      : n;
  let { restSpeed: s, restDelta: r } = t;
  const i = t.keyframes[0],
    a = t.keyframes[t.keyframes.length - 1],
    o = { done: !1, value: i },
    {
      stiffness: l,
      damping: c,
      mass: h,
      duration: m,
      velocity: p,
      isResolvedFromDuration: g,
    } = Dbe({ ...t, velocity: -Io(t.velocity || 0) }),
    y = p || 0,
    b = c / (2 * Math.sqrt(l * h)),
    w = a - i,
    S = Io(Math.sqrt(l / h)),
    A = Math.abs(w) < 5;
  s || (s = A ? hs.restSpeed.granular : hs.restSpeed.default),
    r || (r = A ? hs.restDelta.granular : hs.restDelta.default);
  let _;
  if (b < 1) {
    const C = Gk(S, b);
    _ = (D) => {
      const L = Math.exp(-b * S * D);
      return (
        a - L * (((y + b * S * w) / C) * Math.sin(C * D) + w * Math.cos(C * D))
      );
    };
  } else if (b === 1) _ = (C) => a - Math.exp(-S * C) * (w + (y + S * w) * C);
  else {
    const C = S * Math.sqrt(b * b - 1);
    _ = (D) => {
      const L = Math.exp(-b * S * D),
        P = Math.min(C * D, 300);
      return (
        a - (L * ((y + b * S * w) * Math.sinh(P) + C * w * Math.cosh(P))) / C
      );
    };
  }
  const R = {
    calculatedDuration: (g && m) || null,
    next: (C) => {
      const D = _(C);
      if (g) o.done = C >= m;
      else {
        let L = C === 0 ? y : 0;
        b < 1 && (L = C === 0 ? Co(y) : Bq(_, C, D));
        const P = Math.abs(L) <= s,
          V = Math.abs(a - D) <= r;
        o.done = P && V;
      }
      return (o.value = o.done ? a : D), o;
    },
    toString: () => {
      const C = Math.min(AD(R), ew),
        D = $q((L) => R.next(C * L).value, C, 30);
      return C + "ms " + D;
    },
    toTransition: () => {},
  };
  return R;
}
tw.applyToOptions = (n) => {
  const e = _be(n, 100, tw);
  return (
    (n.ease = e.ease), (n.duration = Co(e.duration)), (n.type = "keyframes"), n
  );
};
function qk({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: s = 325,
  bounceDamping: r = 10,
  bounceStiffness: i = 500,
  modifyTarget: a,
  min: o,
  max: l,
  restDelta: c = 0.5,
  restSpeed: h,
}) {
  const m = n[0],
    p = { done: !1, value: m },
    g = (P) => (o !== void 0 && P < o) || (l !== void 0 && P > l),
    y = (P) =>
      o === void 0
        ? l
        : l === void 0 || Math.abs(o - P) < Math.abs(l - P)
        ? o
        : l;
  let b = t * e;
  const w = m + b,
    S = a === void 0 ? w : a(w);
  S !== w && (b = S - m);
  const A = (P) => -b * Math.exp(-P / s),
    _ = (P) => S + A(P),
    R = (P) => {
      const V = A(P),
        N = _(P);
      (p.done = Math.abs(V) <= c), (p.value = p.done ? S : N);
    };
  let C, D;
  const L = (P) => {
    g(p.value) &&
      ((C = P),
      (D = tw({
        keyframes: [p.value, y(p.value)],
        velocity: Bq(_, P, p.value),
        damping: r,
        stiffness: i,
        restDelta: c,
        restSpeed: h,
      })));
  };
  return (
    L(0),
    {
      calculatedDuration: null,
      next: (P) => {
        let V = !1;
        return (
          !D && C === void 0 && ((V = !0), R(P), L(P)),
          C !== void 0 && P >= C ? D.next(P - C) : (!V && R(P), p)
        );
      },
    }
  );
}
function Pbe(n, e, t) {
  const s = [],
    r = t || kl.mix || Uq,
    i = n.length - 1;
  for (let a = 0; a < i; a++) {
    let o = r(n[a], n[a + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[a] || oa : e;
      o = $v(l, o);
    }
    s.push(o);
  }
  return s;
}
function Mbe(n, e, { clamp: t = !0, ease: s, mixer: r } = {}) {
  const i = n.length;
  if ((gD(i === e.length), i === 1)) return () => e[0];
  if (i === 2 && e[0] === e[1]) return () => e[1];
  const a = n[0] === n[1];
  n[0] > n[i - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = Pbe(e, s, r),
    l = o.length,
    c = (h) => {
      if (a && h < n[0]) return e[0];
      let m = 0;
      if (l > 1) for (; m < n.length - 2 && !(h < n[m + 1]); m++);
      const p = Kg(n[m], n[m + 1], h);
      return o[m](p);
    };
  return t ? (h) => c(Rl(n[0], n[i - 1], h)) : c;
}
function Nbe(n, e) {
  const t = n[n.length - 1];
  for (let s = 1; s <= e; s++) {
    const r = Kg(0, e, s);
    n.push(as(t, 1, r));
  }
}
function Obe(n) {
  const e = [0];
  return Nbe(e, n.length - 1), e;
}
function jbe(n, e) {
  return n.map((t) => t * e);
}
function Fbe(n, e) {
  return n.map(() => e || Cq).splice(0, n.length - 1);
}
function eg({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: s = "easeInOut",
}) {
  const r = Yye(s) ? s.map(h$) : h$(s),
    i = { done: !1, value: e[0] },
    a = jbe(t && t.length === e.length ? t : Obe(e), n),
    o = Mbe(a, e, { ease: Array.isArray(r) ? r : Fbe(e, r) });
  return {
    calculatedDuration: n,
    next: (l) => ((i.value = o(l)), (i.done = l >= n), i),
  };
}
const Ube = (n) => n !== null;
function RD(n, { repeat: e, repeatType: t = "loop" }, s, r = 1) {
  const i = n.filter(Ube),
    o = r < 0 || (e && t !== "loop" && e % 2 === 1) ? 0 : i.length - 1;
  return !o || s === void 0 ? i[o] : s;
}
const $be = { decay: qk, inertia: qk, tween: eg, keyframes: eg, spring: tw };
function Hq(n) {
  typeof n.type == "string" && (n.type = $be[n.type]);
}
class kD {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((e) => {
      this.resolve = e;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
}
const Bbe = (n) => n / 100;
class CD extends kD {
  constructor(e) {
    super(),
      (this.state = "idle"),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        const { motionValue: t } = this.options;
        t && t.updatedAt !== oi.now() && this.tick(oi.now()),
          (this.isStopped = !0),
          this.state !== "idle" && (this.teardown(), this.options.onStop?.());
      }),
      (this.options = e),
      this.initAnimation(),
      this.play(),
      e.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: e } = this;
    Hq(e);
    const {
      type: t = eg,
      repeat: s = 0,
      repeatDelay: r = 0,
      repeatType: i,
      velocity: a = 0,
    } = e;
    let { keyframes: o } = e;
    const l = t || eg;
    l !== eg &&
      typeof o[0] != "number" &&
      ((this.mixKeyframes = $v(Bbe, Uq(o[0], o[1]))), (o = [0, 100]));
    const c = l({ ...e, keyframes: o });
    i === "mirror" &&
      (this.mirroredGenerator = l({
        ...e,
        keyframes: [...o].reverse(),
        velocity: -a,
      })),
      c.calculatedDuration === null && (c.calculatedDuration = AD(c));
    const { calculatedDuration: h } = c;
    (this.calculatedDuration = h),
      (this.resolvedDuration = h + r),
      (this.totalDuration = this.resolvedDuration * (s + 1) - r),
      (this.generator = c);
  }
  updateTime(e) {
    const t = Math.round(e - this.startTime) * this.playbackSpeed;
    this.holdTime !== null
      ? (this.currentTime = this.holdTime)
      : (this.currentTime = t);
  }
  tick(e, t = !1) {
    const {
      generator: s,
      totalDuration: r,
      mixKeyframes: i,
      mirroredGenerator: a,
      resolvedDuration: o,
      calculatedDuration: l,
    } = this;
    if (this.startTime === null) return s.next(0);
    const {
      delay: c = 0,
      keyframes: h,
      repeat: m,
      repeatType: p,
      repeatDelay: g,
      type: y,
      onUpdate: b,
      finalKeyframe: w,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - r / this.speed, this.startTime)),
      t ? (this.currentTime = e) : this.updateTime(e);
    const S = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
      A = this.playbackSpeed >= 0 ? S < 0 : S > r;
    (this.currentTime = Math.max(S, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = r);
    let _ = this.currentTime,
      R = s;
    if (m) {
      const P = Math.min(this.currentTime, r) / o;
      let V = Math.floor(P),
        N = P % 1;
      !N && P >= 1 && (N = 1),
        N === 1 && V--,
        (V = Math.min(V, m + 1)),
        !!(V % 2) &&
          (p === "reverse"
            ? ((N = 1 - N), g && (N -= g / o))
            : p === "mirror" && (R = a)),
        (_ = Rl(0, 1, N) * o);
    }
    const C = A ? { done: !1, value: h[0] } : R.next(_);
    i && (C.value = i(C.value));
    let { done: D } = C;
    !A &&
      l !== null &&
      (D =
        this.playbackSpeed >= 0
          ? this.currentTime >= r
          : this.currentTime <= 0);
    const L =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && D));
    return (
      L && y !== qk && (C.value = RD(h, this.options, w, this.speed)),
      b && b(C.value),
      L && this.finish(),
      C
    );
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
  get duration() {
    return Io(this.calculatedDuration);
  }
  get time() {
    return Io(this.currentTime);
  }
  set time(e) {
    (e = Co(e)),
      (this.currentTime = e),
      this.startTime === null ||
      this.holdTime !== null ||
      this.playbackSpeed === 0
        ? (this.holdTime = e)
        : this.driver &&
          (this.startTime = this.driver.now() - e / this.playbackSpeed),
      this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    this.updateTime(oi.now());
    const t = this.playbackSpeed !== e;
    (this.playbackSpeed = e), t && (this.time = Io(this.currentTime));
  }
  play() {
    if (this.isStopped) return;
    const { driver: e = Tbe, startTime: t } = this.options;
    this.driver || (this.driver = e((r) => this.tick(r))),
      this.options.onPlay?.();
    const s = this.driver.now();
    this.state === "finished"
      ? (this.updateFinished(), (this.startTime = s))
      : this.holdTime !== null
      ? (this.startTime = s - this.holdTime)
      : this.startTime || (this.startTime = t ?? s),
      this.state === "finished" &&
        this.speed < 0 &&
        (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    (this.state = "paused"),
      this.updateTime(oi.now()),
      (this.holdTime = this.currentTime);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    this.notifyFinished(),
      this.teardown(),
      (this.state = "finished"),
      this.options.onComplete?.();
  }
  cancel() {
    (this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      this.options.onCancel?.();
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      (this.startTime = this.holdTime = null);
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0);
  }
  attachTimeline(e) {
    return (
      this.options.allowFlatten &&
        ((this.options.type = "keyframes"),
        (this.options.ease = "linear"),
        this.initAnimation()),
      this.driver?.stop(),
      e.observe(this)
    );
  }
}
function Hbe(n) {
  for (let e = 1; e < n.length; e++) n[e] ?? (n[e] = n[e - 1]);
}
const ju = (n) => (n * 180) / Math.PI,
  Wk = (n) => {
    const e = ju(Math.atan2(n[1], n[0]));
    return Kk(e);
  },
  Vbe = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (n) => (Math.abs(n[0]) + Math.abs(n[3])) / 2,
    rotate: Wk,
    rotateZ: Wk,
    skewX: (n) => ju(Math.atan(n[1])),
    skewY: (n) => ju(Math.atan(n[2])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[2])) / 2,
  },
  Kk = (n) => ((n = n % 360), n < 0 && (n += 360), n),
  y$ = Wk,
  b$ = (n) => Math.sqrt(n[0] * n[0] + n[1] * n[1]),
  x$ = (n) => Math.sqrt(n[4] * n[4] + n[5] * n[5]),
  zbe = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: b$,
    scaleY: x$,
    scale: (n) => (b$(n) + x$(n)) / 2,
    rotateX: (n) => Kk(ju(Math.atan2(n[6], n[5]))),
    rotateY: (n) => Kk(ju(Math.atan2(-n[2], n[0]))),
    rotateZ: y$,
    rotate: y$,
    skewX: (n) => ju(Math.atan(n[4])),
    skewY: (n) => ju(Math.atan(n[1])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[4])) / 2,
  };
function Yk(n) {
  return n.includes("scale") ? 1 : 0;
}
function Xk(n, e) {
  if (!n || n === "none") return Yk(e);
  const t = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let s, r;
  if (t) (s = zbe), (r = t);
  else {
    const o = n.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    (s = Vbe), (r = o);
  }
  if (!r) return Yk(e);
  const i = s[e],
    a = r[1].split(",").map(qbe);
  return typeof i == "function" ? i(a) : a[i];
}
const Gbe = (n, e) => {
  const { transform: t = "none" } = getComputedStyle(n);
  return Xk(t, e);
};
function qbe(n) {
  return parseFloat(n.trim());
}
const Yf = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Xf = new Set(Yf),
  w$ = (n) => n === Kf || n === It,
  Wbe = new Set(["x", "y", "z"]),
  Kbe = Yf.filter((n) => !Wbe.has(n));
function Ybe(n) {
  const e = [];
  return (
    Kbe.forEach((t) => {
      const s = n.getValue(t);
      s !== void 0 &&
        (e.push([t, s.get()]), s.set(t.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const Hu = {
  width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: (n, { transform: e }) => Xk(e, "x"),
  y: (n, { transform: e }) => Xk(e, "y"),
};
Hu.translateX = Hu.x;
Hu.translateY = Hu.y;
const Vu = new Set();
let Qk = !1,
  Zk = !1,
  Jk = !1;
function Vq() {
  if (Zk) {
    const n = Array.from(Vu).filter((s) => s.needsMeasurement),
      e = new Set(n.map((s) => s.element)),
      t = new Map();
    e.forEach((s) => {
      const r = Ybe(s);
      r.length && (t.set(s, r), s.render());
    }),
      n.forEach((s) => s.measureInitialState()),
      e.forEach((s) => {
        s.render();
        const r = t.get(s);
        r &&
          r.forEach(([i, a]) => {
            s.getValue(i)?.set(a);
          });
      }),
      n.forEach((s) => s.measureEndState()),
      n.forEach((s) => {
        s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY);
      });
  }
  (Zk = !1), (Qk = !1), Vu.forEach((n) => n.complete(Jk)), Vu.clear();
}
function zq() {
  Vu.forEach((n) => {
    n.readKeyframes(), n.needsMeasurement && (Zk = !0);
  });
}
function Xbe() {
  (Jk = !0), zq(), Vq(), (Jk = !1);
}
class ID {
  constructor(e, t, s, r, i, a = !1) {
    (this.state = "pending"),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = s),
      (this.motionValue = r),
      (this.element = i),
      (this.isAsync = a);
  }
  scheduleResolve() {
    (this.state = "scheduled"),
      this.isAsync
        ? (Vu.add(this),
          Qk || ((Qk = !0), qn.read(zq), qn.resolveKeyframes(Vq)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: t,
      element: s,
      motionValue: r,
    } = this;
    if (e[0] === null) {
      const i = r?.get(),
        a = e[e.length - 1];
      if (i !== void 0) e[0] = i;
      else if (s && t) {
        const o = s.readValue(t, a);
        o != null && (e[0] = o);
      }
      e[0] === void 0 && (e[0] = a), r && i === void 0 && r.set(e[0]);
    }
    Hbe(e);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(e = !1) {
    (this.state = "complete"),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
      Vu.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Vu.delete(this), (this.state = "pending"));
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const Qbe = (n) => n.startsWith("--");
function Zbe(n, e, t) {
  Qbe(e) ? n.style.setProperty(e, t) : (n.style[e] = t);
}
const Jbe = vD(() => window.ScrollTimeline !== void 0),
  exe = {};
function txe(n, e) {
  const t = vD(n);
  return () => exe[e] ?? t();
}
const Gq = txe(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  Cp = ([n, e, t, s]) => `cubic-bezier(${n}, ${e}, ${t}, ${s})`,
  E$ = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Cp([0, 0.65, 0.55, 1]),
    circOut: Cp([0.55, 0, 1, 0.45]),
    backIn: Cp([0.31, 0.01, 0.66, -0.59]),
    backOut: Cp([0.33, 1.53, 0.69, 0.99]),
  };
function qq(n, e) {
  if (n)
    return typeof n == "function"
      ? Gq()
        ? $q(n, e)
        : "ease-out"
      : Iq(n)
      ? Cp(n)
      : Array.isArray(n)
      ? n.map((t) => qq(t, e) || E$.easeOut)
      : E$[n];
}
function nxe(
  n,
  e,
  t,
  {
    delay: s = 0,
    duration: r = 300,
    repeat: i = 0,
    repeatType: a = "loop",
    ease: o = "easeOut",
    times: l,
  } = {},
  c = void 0
) {
  const h = { [e]: t };
  l && (h.offset = l);
  const m = qq(o, r);
  Array.isArray(m) && (h.easing = m);
  const p = {
    delay: s,
    duration: r,
    easing: Array.isArray(m) ? "linear" : m,
    fill: "both",
    iterations: i + 1,
    direction: a === "reverse" ? "alternate" : "normal",
  };
  return c && (p.pseudoElement = c), n.animate(h, p);
}
function Wq(n) {
  return typeof n == "function" && "applyToOptions" in n;
}
function sxe({ type: n, ...e }) {
  return Wq(n) && Gq()
    ? n.applyToOptions(e)
    : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e);
}
class rxe extends kD {
  constructor(e) {
    if ((super(), (this.finishedTime = null), (this.isStopped = !1), !e))
      return;
    const {
      element: t,
      name: s,
      keyframes: r,
      pseudoElement: i,
      allowFlatten: a = !1,
      finalKeyframe: o,
      onComplete: l,
    } = e;
    (this.isPseudoElement = !!i),
      (this.allowFlatten = a),
      (this.options = e),
      gD(typeof e.type != "string");
    const c = sxe(e);
    (this.animation = nxe(t, s, r, c, i)),
      c.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !i)) {
          const h = RD(r, this.options, o, this.speed);
          this.updateMotionValue ? this.updateMotionValue(h) : Zbe(t, s, h),
            this.animation.cancel();
        }
        l?.(), this.notifyFinished();
      });
  }
  play() {
    this.isStopped ||
      (this.animation.play(),
      this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: e } = this;
    e === "idle" ||
      e === "finished" ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const e = this.animation.effect?.getComputedTiming?.().duration || 0;
    return Io(Number(e));
  }
  get time() {
    return Io(Number(this.animation.currentTime) || 0);
  }
  set time(e) {
    (this.finishedTime = null), (this.animation.currentTime = Co(e));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(e) {
    e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e);
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(e) {
    this.animation.startTime = e;
  }
  attachTimeline({ timeline: e, observe: t }) {
    return (
      this.allowFlatten &&
        this.animation.effect?.updateTiming({ easing: "linear" }),
      (this.animation.onfinish = null),
      e && Jbe() ? ((this.animation.timeline = e), oa) : t(this)
    );
  }
}
const Kq = { anticipate: Aq, backInOut: _q, circInOut: kq };
function ixe(n) {
  return n in Kq;
}
function axe(n) {
  typeof n.ease == "string" && ixe(n.ease) && (n.ease = Kq[n.ease]);
}
const S$ = 10;
class oxe extends rxe {
  constructor(e) {
    axe(e),
      Hq(e),
      super(e),
      e.startTime && (this.startTime = e.startTime),
      (this.options = e);
  }
  updateMotionValue(e) {
    const {
      motionValue: t,
      onUpdate: s,
      onComplete: r,
      element: i,
      ...a
    } = this.options;
    if (!t) return;
    if (e !== void 0) {
      t.set(e);
      return;
    }
    const o = new CD({ ...a, autoplay: !1 }),
      l = Co(this.finishedTime ?? this.time);
    t.setWithVelocity(o.sample(l - S$).value, o.sample(l).value, S$), o.stop();
  }
}
const T$ = (n, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof n == "number" ||
        Array.isArray(n) ||
        (typeof n == "string" &&
          ($c.test(n) || n === "0") &&
          !n.startsWith("url("))
      );
function lxe(n) {
  const e = n[0];
  if (n.length === 1) return !0;
  for (let t = 0; t < n.length; t++) if (n[t] !== e) return !0;
}
function cxe(n, e, t, s) {
  const r = n[0];
  if (r === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const i = n[n.length - 1],
    a = T$(r, e),
    o = T$(i, e);
  return !a || !o ? !1 : lxe(n) || ((t === "spring" || Wq(t)) && s);
}
function eC(n) {
  (n.duration = 0), n.type;
}
const uxe = new Set(["opacity", "clipPath", "filter", "transform"]),
  dxe = vD(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function hxe(n) {
  const {
    motionValue: e,
    name: t,
    repeatDelay: s,
    repeatType: r,
    damping: i,
    type: a,
  } = n;
  if (!(e?.owner?.current instanceof HTMLElement)) return !1;
  const { onUpdate: l, transformTemplate: c } = e.owner.getProps();
  return (
    dxe() &&
    t &&
    uxe.has(t) &&
    (t !== "transform" || !c) &&
    !l &&
    !s &&
    r !== "mirror" &&
    i !== 0 &&
    a !== "inertia"
  );
}
const fxe = 40;
class mxe extends kD {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: s = "keyframes",
    repeat: r = 0,
    repeatDelay: i = 0,
    repeatType: a = "loop",
    keyframes: o,
    name: l,
    motionValue: c,
    element: h,
    ...m
  }) {
    super(),
      (this.stop = () => {
        this._animation && (this._animation.stop(), this.stopTimeline?.()),
          this.keyframeResolver?.cancel();
      }),
      (this.createdAt = oi.now());
    const p = {
        autoplay: e,
        delay: t,
        type: s,
        repeat: r,
        repeatDelay: i,
        repeatType: a,
        name: l,
        motionValue: c,
        element: h,
        ...m,
      },
      g = h?.KeyframeResolver || ID;
    (this.keyframeResolver = new g(
      o,
      (y, b, w) => this.onKeyframesResolved(y, b, p, !w),
      l,
      c,
      h
    )),
      this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(e, t, s, r) {
    this.keyframeResolver = void 0;
    const {
      name: i,
      type: a,
      velocity: o,
      delay: l,
      isHandoff: c,
      onUpdate: h,
    } = s;
    (this.resolvedAt = oi.now()),
      cxe(e, i, a, o) ||
        ((kl.instantAnimations || !l) && h?.(RD(e, s, t)),
        (e[0] = e[e.length - 1]),
        eC(s),
        (s.repeat = 0));
    const p = {
        startTime: r
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > fxe
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: t,
        ...s,
        keyframes: e,
      },
      g =
        !c && hxe(p)
          ? new oxe({ ...p, element: p.motionValue.owner.current })
          : new CD(p);
    g.finished.then(() => this.notifyFinished()).catch(oa),
      this.pendingTimeline &&
        ((this.stopTimeline = g.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = g);
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(e, t) {
    return this.finished.finally(e).then(() => {});
  }
  get animation() {
    return (
      this._animation || (this.keyframeResolver?.resume(), Xbe()),
      this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(e) {
    this.animation.time = e;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(e) {
    this.animation.speed = e;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(e) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(e))
        : (this.pendingTimeline = e),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
const pxe = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function gxe(n) {
  const e = pxe.exec(n);
  if (!e) return [,];
  const [, t, s, r] = e;
  return [`--${t ?? s}`, r];
}
function Yq(n, e, t = 1) {
  const [s, r] = gxe(n);
  if (!s) return;
  const i = window.getComputedStyle(e).getPropertyValue(s);
  if (i) {
    const a = i.trim();
    return vq(a) ? parseFloat(a) : a;
  }
  return ED(r) ? Yq(r, e, t + 1) : r;
}
function LD(n, e) {
  return n?.[e] ?? n?.default ?? n;
}
const Xq = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...Yf,
  ]),
  vxe = { test: (n) => n === "auto", parse: (n) => n },
  Qq = (n) => (e) => e.test(n),
  Zq = [Kf, It, Lo, mc, lbe, obe, vxe],
  _$ = (n) => Zq.find(Qq(n));
function yxe(n) {
  return typeof n == "number"
    ? n === 0
    : n !== null
    ? n === "none" || n === "0" || bq(n)
    : !0;
}
const bxe = new Set(["brightness", "contrast", "saturate", "opacity"]);
function xxe(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [s] = t.match(SD) || [];
  if (!s) return n;
  const r = t.replace(s, "");
  let i = bxe.has(e) ? 1 : 0;
  return s !== t && (i *= 100), e + "(" + i + r + ")";
}
const wxe = /\b([a-z-]*)\(.*?\)/gu,
  tC = {
    ...$c,
    getAnimatableNone: (n) => {
      const e = n.match(wxe);
      return e ? e.map(xxe).join(" ") : n;
    },
  },
  A$ = { ...Kf, transform: Math.round },
  Exe = {
    rotate: mc,
    rotateX: mc,
    rotateY: mc,
    rotateZ: mc,
    scale: Py,
    scaleX: Py,
    scaleY: Py,
    scaleZ: Py,
    skew: mc,
    skewX: mc,
    skewY: mc,
    distance: It,
    translateX: It,
    translateY: It,
    translateZ: It,
    x: It,
    y: It,
    z: It,
    perspective: It,
    transformPerspective: It,
    opacity: Yg,
    originX: f$,
    originY: f$,
    originZ: It,
  },
  DD = {
    borderWidth: It,
    borderTopWidth: It,
    borderRightWidth: It,
    borderBottomWidth: It,
    borderLeftWidth: It,
    borderRadius: It,
    radius: It,
    borderTopLeftRadius: It,
    borderTopRightRadius: It,
    borderBottomRightRadius: It,
    borderBottomLeftRadius: It,
    width: It,
    maxWidth: It,
    height: It,
    maxHeight: It,
    top: It,
    right: It,
    bottom: It,
    left: It,
    padding: It,
    paddingTop: It,
    paddingRight: It,
    paddingBottom: It,
    paddingLeft: It,
    margin: It,
    marginTop: It,
    marginRight: It,
    marginBottom: It,
    marginLeft: It,
    backgroundPositionX: It,
    backgroundPositionY: It,
    ...Exe,
    zIndex: A$,
    fillOpacity: Yg,
    strokeOpacity: Yg,
    numOctaves: A$,
  },
  Sxe = {
    ...DD,
    color: Ps,
    backgroundColor: Ps,
    outlineColor: Ps,
    fill: Ps,
    stroke: Ps,
    borderColor: Ps,
    borderTopColor: Ps,
    borderRightColor: Ps,
    borderBottomColor: Ps,
    borderLeftColor: Ps,
    filter: tC,
    WebkitFilter: tC,
  },
  Jq = (n) => Sxe[n];
function e9(n, e) {
  let t = Jq(n);
  return (
    t !== tC && (t = $c), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const Txe = new Set(["auto", "none", "0"]);
function _xe(n, e, t) {
  let s = 0,
    r;
  for (; s < n.length && !r; ) {
    const i = n[s];
    typeof i == "string" && !Txe.has(i) && Xg(i).values.length && (r = n[s]),
      s++;
  }
  if (r && t) for (const i of e) n[i] = e9(t, r);
}
class Axe extends ID {
  constructor(e, t, s, r, i) {
    super(e, t, s, r, i, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: s } = this;
    if (!t || !t.current) return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == "string" && ((c = c.trim()), ED(c))) {
        const h = Yq(c, t.current);
        h !== void 0 && (e[l] = h),
          l === e.length - 1 && (this.finalKeyframe = c);
      }
    }
    if ((this.resolveNoneKeyframes(), !Xq.has(s) || e.length !== 2)) return;
    const [r, i] = e,
      a = _$(r),
      o = _$(i);
    if (a !== o)
      if (w$(a) && w$(o))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == "string" && (e[l] = parseFloat(c));
        }
      else Hu[s] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      s = [];
    for (let r = 0; r < e.length; r++)
      (e[r] === null || yxe(e[r])) && s.push(r);
    s.length && _xe(e, s, t);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: s } = this;
    if (!e || !e.current) return;
    s === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Hu[s](
        e.measureViewportBox(),
        window.getComputedStyle(e.current)
      )),
      (t[0] = this.measuredOrigin);
    const r = t[t.length - 1];
    r !== void 0 && e.getValue(s, r).jump(r, !1);
  }
  measureEndState() {
    const { element: e, name: t, unresolvedKeyframes: s } = this;
    if (!e || !e.current) return;
    const r = e.getValue(t);
    r && r.jump(this.measuredOrigin, !1);
    const i = s.length - 1,
      a = s[i];
    (s[i] = Hu[t](e.measureViewportBox(), window.getComputedStyle(e.current))),
      a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
      this.removedTransforms?.length &&
        this.removedTransforms.forEach(([o, l]) => {
          e.getValue(o).set(l);
        }),
      this.resolveNoneKeyframes();
  }
}
function Rxe(n, e, t) {
  if (n instanceof EventTarget) return [n];
  if (typeof n == "string") {
    let s = document;
    const r = t?.[n] ?? s.querySelectorAll(n);
    return r ? Array.from(r) : [];
  }
  return Array.from(n);
}
const t9 = (n, e) => (e && typeof n == "number" ? e.transform(n) : n);
function n9(n) {
  return yq(n) && "offsetHeight" in n;
}
const R$ = 30,
  kxe = (n) => !isNaN(parseFloat(n));
class Cxe {
  constructor(e, t = {}) {
    (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (s) => {
        const r = oi.now();
        if (
          (this.updatedAt !== r && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(s),
          this.current !== this.prev &&
            (this.events.change?.notify(this.current), this.dependents))
        )
          for (const i of this.dependents) i.dirty();
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner);
  }
  setCurrent(e) {
    (this.current = e),
      (this.updatedAt = oi.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = kxe(this.current));
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new yD());
    const s = this.events[e].add(t);
    return e === "change"
      ? () => {
          s(),
            qn.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : s;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e) {
    this.passiveEffect
      ? this.passiveEffect(e, this.updateAndNotify)
      : this.updateAndNotify(e);
  }
  setWithVelocity(e, t, s) {
    this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - s);
  }
  jump(e, t = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(e) {
    this.dependents || (this.dependents = new Set()), this.dependents.add(e);
  }
  removeDependent(e) {
    this.dependents && this.dependents.delete(e);
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = oi.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > R$
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, R$);
    return xq(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.dependents?.clear(),
      this.events.destroy?.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Rf(n, e) {
  return new Cxe(n, e);
}
const { schedule: PD } = Lq(queueMicrotask, !1),
  xa = { x: !1, y: !1 };
function s9() {
  return xa.x || xa.y;
}
function Ixe(n) {
  return n === "x" || n === "y"
    ? xa[n]
      ? null
      : ((xa[n] = !0),
        () => {
          xa[n] = !1;
        })
    : xa.x || xa.y
    ? null
    : ((xa.x = xa.y = !0),
      () => {
        xa.x = xa.y = !1;
      });
}
function r9(n, e) {
  const t = Rxe(n),
    s = new AbortController(),
    r = { passive: !0, ...e, signal: s.signal };
  return [t, r, () => s.abort()];
}
function k$(n) {
  return !(n.pointerType === "touch" || s9());
}
function Lxe(n, e, t = {}) {
  const [s, r, i] = r9(n, t),
    a = (o) => {
      if (!k$(o)) return;
      const { target: l } = o,
        c = e(l, o);
      if (typeof c != "function" || !l) return;
      const h = (m) => {
        k$(m) && (c(m), l.removeEventListener("pointerleave", h));
      };
      l.addEventListener("pointerleave", h, r);
    };
  return (
    s.forEach((o) => {
      o.addEventListener("pointerenter", a, r);
    }),
    i
  );
}
const i9 = (n, e) => (e ? (n === e ? !0 : i9(n, e.parentElement)) : !1),
  MD = (n) =>
    n.pointerType === "mouse"
      ? typeof n.button != "number" || n.button <= 0
      : n.isPrimary !== !1,
  Dxe = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function Pxe(n) {
  return Dxe.has(n.tagName) || n.tabIndex !== -1;
}
const Rb = new WeakSet();
function C$(n) {
  return (e) => {
    e.key === "Enter" && n(e);
  };
}
function W1(n, e) {
  n.dispatchEvent(
    new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })
  );
}
const Mxe = (n, e) => {
  const t = n.currentTarget;
  if (!t) return;
  const s = C$(() => {
    if (Rb.has(t)) return;
    W1(t, "down");
    const r = C$(() => {
        W1(t, "up");
      }),
      i = () => W1(t, "cancel");
    t.addEventListener("keyup", r, e), t.addEventListener("blur", i, e);
  });
  t.addEventListener("keydown", s, e),
    t.addEventListener("blur", () => t.removeEventListener("keydown", s), e);
};
function I$(n) {
  return MD(n) && !s9();
}
function Nxe(n, e, t = {}) {
  const [s, r, i] = r9(n, t),
    a = (o) => {
      const l = o.currentTarget;
      if (!I$(o)) return;
      Rb.add(l);
      const c = e(l, o),
        h = (g, y) => {
          window.removeEventListener("pointerup", m),
            window.removeEventListener("pointercancel", p),
            Rb.has(l) && Rb.delete(l),
            I$(g) && typeof c == "function" && c(g, { success: y });
        },
        m = (g) => {
          h(
            g,
            l === window ||
              l === document ||
              t.useGlobalTarget ||
              i9(l, g.target)
          );
        },
        p = (g) => {
          h(g, !1);
        };
      window.addEventListener("pointerup", m, r),
        window.addEventListener("pointercancel", p, r);
    };
  return (
    s.forEach((o) => {
      (t.useGlobalTarget ? window : o).addEventListener("pointerdown", a, r),
        n9(o) &&
          (o.addEventListener("focus", (c) => Mxe(c, r)),
          !Pxe(o) && !o.hasAttribute("tabindex") && (o.tabIndex = 0));
    }),
    i
  );
}
function a9(n) {
  return yq(n) && "ownerSVGElement" in n;
}
function Oxe(n) {
  return a9(n) && n.tagName === "svg";
}
const Ir = (n) => !!(n && n.getVelocity),
  jxe = [...Zq, Ps, $c],
  Fxe = (n) => jxe.find(Qq(n)),
  ND = E.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  });
class Uxe extends E.Component {
  getSnapshotBeforeUpdate(e) {
    const t = this.props.childRef.current;
    if (t && e.isPresent && !this.props.isPresent) {
      const s = t.offsetParent,
        r = (n9(s) && s.offsetWidth) || 0,
        i = this.props.sizeRef.current;
      (i.height = t.offsetHeight || 0),
        (i.width = t.offsetWidth || 0),
        (i.top = t.offsetTop),
        (i.left = t.offsetLeft),
        (i.right = r - i.width - i.left);
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function $xe({ children: n, isPresent: e, anchorX: t, root: s }) {
  const r = E.useId(),
    i = E.useRef(null),
    a = E.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }),
    { nonce: o } = E.useContext(ND);
  return (
    E.useInsertionEffect(() => {
      const { width: l, height: c, top: h, left: m, right: p } = a.current;
      if (e || !i.current || !l || !c) return;
      const g = t === "left" ? `left: ${m}` : `right: ${p}`;
      i.current.dataset.motionPopId = r;
      const y = document.createElement("style");
      o && (y.nonce = o);
      const b = s ?? document.head;
      return (
        b.appendChild(y),
        y.sheet &&
          y.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${c}px !important;
            ${g}px !important;
            top: ${h}px !important;
          }
        `),
        () => {
          b.contains(y) && b.removeChild(y);
        }
      );
    }, [e]),
    u.jsx(Uxe, {
      isPresent: e,
      childRef: i,
      sizeRef: a,
      children: E.cloneElement(n, { ref: i }),
    })
  );
}
const Bxe = ({
  children: n,
  initial: e,
  isPresent: t,
  onExitComplete: s,
  custom: r,
  presenceAffectsLayout: i,
  mode: a,
  anchorX: o,
  root: l,
}) => {
  const c = dD(Hxe),
    h = E.useId();
  let m = !0,
    p = E.useMemo(
      () => (
        (m = !1),
        {
          id: h,
          initial: e,
          isPresent: t,
          custom: r,
          onExitComplete: (g) => {
            c.set(g, !0);
            for (const y of c.values()) if (!y) return;
            s && s();
          },
          register: (g) => (c.set(g, !1), () => c.delete(g)),
        }
      ),
      [t, c, s]
    );
  return (
    i && m && (p = { ...p }),
    E.useMemo(() => {
      c.forEach((g, y) => c.set(y, !1));
    }, [t]),
    E.useEffect(() => {
      !t && !c.size && s && s();
    }, [t]),
    a === "popLayout" &&
      (n = u.jsx($xe, { isPresent: t, anchorX: o, root: l, children: n })),
    u.jsx(YE.Provider, { value: p, children: n })
  );
};
function Hxe() {
  return new Map();
}
function o9(n = !0) {
  const e = E.useContext(YE);
  if (e === null) return [!0, null];
  const { isPresent: t, onExitComplete: s, register: r } = e,
    i = E.useId();
  E.useEffect(() => {
    if (n) return r(i);
  }, [n]);
  const a = E.useCallback(() => n && s && s(i), [i, s, n]);
  return !t && s ? [!1, a] : [!0];
}
const My = (n) => n.key || "";
function L$(n) {
  const e = [];
  return (
    E.Children.forEach(n, (t) => {
      E.isValidElement(t) && e.push(t);
    }),
    e
  );
}
const Qg = ({
    children: n,
    custom: e,
    initial: t = !0,
    onExitComplete: s,
    presenceAffectsLayout: r = !0,
    mode: i = "sync",
    propagate: a = !1,
    anchorX: o = "left",
    root: l,
  }) => {
    const [c, h] = o9(a),
      m = E.useMemo(() => L$(n), [n]),
      p = a && !c ? [] : m.map(My),
      g = E.useRef(!0),
      y = E.useRef(m),
      b = dD(() => new Map()),
      [w, S] = E.useState(m),
      [A, _] = E.useState(m);
    fD(() => {
      (g.current = !1), (y.current = m);
      for (let D = 0; D < A.length; D++) {
        const L = My(A[D]);
        p.includes(L) ? b.delete(L) : b.get(L) !== !0 && b.set(L, !1);
      }
    }, [A, p.length, p.join("-")]);
    const R = [];
    if (m !== w) {
      let D = [...m];
      for (let L = 0; L < A.length; L++) {
        const P = A[L],
          V = My(P);
        p.includes(V) || (D.splice(L, 0, P), R.push(P));
      }
      return i === "wait" && R.length && (D = R), _(L$(D)), S(m), null;
    }
    const { forceRender: C } = E.useContext(Wg);
    return u.jsx(u.Fragment, {
      children: A.map((D) => {
        const L = My(D),
          P = a && !c ? !1 : m === A || p.includes(L),
          V = () => {
            if (b.has(L)) b.set(L, !0);
            else return;
            let N = !0;
            b.forEach((W) => {
              W || (N = !1);
            }),
              N && (C?.(), _(y.current), a && h?.(), s && s());
          };
        return u.jsx(
          Bxe,
          {
            isPresent: P,
            initial: !g.current || t ? void 0 : !1,
            custom: e,
            presenceAffectsLayout: r,
            mode: i,
            root: l,
            onExitComplete: P ? void 0 : V,
            anchorX: o,
            children: D,
          },
          L
        );
      }),
    });
  },
  Vxe = E.createContext(null);
function zxe() {
  const n = E.useRef(!1);
  return (
    fD(
      () => (
        (n.current = !0),
        () => {
          n.current = !1;
        }
      ),
      []
    ),
    n
  );
}
function Gxe() {
  const n = zxe(),
    [e, t] = E.useState(0),
    s = E.useCallback(() => {
      n.current && t(e + 1);
    }, [e]);
  return [E.useCallback(() => qn.postRender(s), [s]), e];
}
const qxe = (n) => !n.isLayoutDirty && n.willUpdate(!1);
function D$() {
  const n = new Set(),
    e = new WeakMap(),
    t = () => n.forEach(qxe);
  return {
    add: (s) => {
      n.add(s), e.set(s, s.addEventListener("willUpdate", t));
    },
    remove: (s) => {
      n.delete(s);
      const r = e.get(s);
      r && (r(), e.delete(s)), t();
    },
    dirty: t,
  };
}
const l9 = (n) => n === !0,
  Wxe = (n) => l9(n === !0) || n === "id",
  Kxe = ({ children: n, id: e, inherit: t = !0 }) => {
    const s = E.useContext(Wg),
      r = E.useContext(Vxe),
      [i, a] = Gxe(),
      o = E.useRef(null),
      l = s.id || r;
    o.current === null &&
      (Wxe(t) && l && (e = e ? l + "-" + e : l),
      (o.current = { id: e, group: (l9(t) && s.group) || D$() }));
    const c = E.useMemo(() => ({ ...o.current, forceRender: i }), [a]);
    return u.jsx(Wg.Provider, { value: c, children: n });
  },
  c9 = E.createContext({ strict: !1 }),
  P$ = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  kf = {};
for (const n in P$) kf[n] = { isEnabled: (e) => P$[n].some((t) => !!e[t]) };
function Yxe(n) {
  for (const e in n) kf[e] = { ...kf[e], ...n[e] };
}
const Xxe = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function nw(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    n.startsWith("onLayout") ||
    Xxe.has(n)
  );
}
let u9 = (n) => !nw(n);
function Qxe(n) {
  typeof n == "function" && (u9 = (e) => (e.startsWith("on") ? !nw(e) : n(e)));
}
try {
  Qxe(require("@emotion/is-prop-valid").default);
} catch {}
function Zxe(n, e, t) {
  const s = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((u9(r) ||
        (t === !0 && nw(r)) ||
        (!e && !nw(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (s[r] = n[r]));
  return s;
}
const XE = E.createContext({});
function QE(n) {
  return n !== null && typeof n == "object" && typeof n.start == "function";
}
function Zg(n) {
  return typeof n == "string" || Array.isArray(n);
}
const OD = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  jD = ["initial", ...OD];
function ZE(n) {
  return QE(n.animate) || jD.some((e) => Zg(n[e]));
}
function d9(n) {
  return !!(ZE(n) || n.variants);
}
function Jxe(n, e) {
  if (ZE(n)) {
    const { initial: t, animate: s } = n;
    return {
      initial: t === !1 || Zg(t) ? t : void 0,
      animate: Zg(s) ? s : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function ewe(n) {
  const { initial: e, animate: t } = Jxe(n, E.useContext(XE));
  return E.useMemo(() => ({ initial: e, animate: t }), [M$(e), M$(t)]);
}
function M$(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const Jg = {};
function twe(n) {
  for (const e in n) (Jg[e] = n[e]), wD(e) && (Jg[e].isCSSVariable = !0);
}
function h9(n, { layout: e, layoutId: t }) {
  return (
    Xf.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!Jg[n] || n === "opacity"))
  );
}
const nwe = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  swe = Yf.length;
function rwe(n, e, t) {
  let s = "",
    r = !0;
  for (let i = 0; i < swe; i++) {
    const a = Yf[i],
      o = n[a];
    if (o === void 0) continue;
    let l = !0;
    if (
      (typeof o == "number"
        ? (l = o === (a.startsWith("scale") ? 1 : 0))
        : (l = parseFloat(o) === 0),
      !l || t)
    ) {
      const c = t9(o, DD[a]);
      if (!l) {
        r = !1;
        const h = nwe[a] || a;
        s += `${h}(${c}) `;
      }
      t && (e[a] = c);
    }
  }
  return (s = s.trim()), t ? (s = t(e, r ? "" : s)) : r && (s = "none"), s;
}
function FD(n, e, t) {
  const { style: s, vars: r, transformOrigin: i } = n;
  let a = !1,
    o = !1;
  for (const l in e) {
    const c = e[l];
    if (Xf.has(l)) {
      a = !0;
      continue;
    } else if (wD(l)) {
      r[l] = c;
      continue;
    } else {
      const h = t9(c, DD[l]);
      l.startsWith("origin") ? ((o = !0), (i[l] = h)) : (s[l] = h);
    }
  }
  if (
    (e.transform ||
      (a || t
        ? (s.transform = rwe(e, n.transform, t))
        : s.transform && (s.transform = "none")),
    o)
  ) {
    const { originX: l = "50%", originY: c = "50%", originZ: h = 0 } = i;
    s.transformOrigin = `${l} ${c} ${h}`;
  }
}
const UD = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function f9(n, e, t) {
  for (const s in e) !Ir(e[s]) && !h9(s, t) && (n[s] = e[s]);
}
function iwe({ transformTemplate: n }, e) {
  return E.useMemo(() => {
    const t = UD();
    return FD(t, e, n), Object.assign({}, t.vars, t.style);
  }, [e]);
}
function awe(n, e) {
  const t = n.style || {},
    s = {};
  return f9(s, t, n), Object.assign(s, iwe(n, e)), s;
}
function owe(n, e) {
  const t = {},
    s = awe(n, e);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((t.draggable = !1),
      (s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none"),
      (s.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (t.tabIndex = 0),
    (t.style = s),
    t
  );
}
const lwe = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  cwe = { offset: "strokeDashoffset", array: "strokeDasharray" };
function uwe(n, e, t = 1, s = 0, r = !0) {
  n.pathLength = 1;
  const i = r ? lwe : cwe;
  n[i.offset] = It.transform(-s);
  const a = It.transform(e),
    o = It.transform(t);
  n[i.array] = `${a} ${o}`;
}
function m9(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: s,
    pathLength: r,
    pathSpacing: i = 1,
    pathOffset: a = 0,
    ...o
  },
  l,
  c,
  h
) {
  if ((FD(n, o, c), l)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: m, style: p } = n;
  m.transform && ((p.transform = m.transform), delete m.transform),
    (p.transform || m.transformOrigin) &&
      ((p.transformOrigin = m.transformOrigin ?? "50% 50%"),
      delete m.transformOrigin),
    p.transform &&
      ((p.transformBox = h?.transformBox ?? "fill-box"), delete m.transformBox),
    e !== void 0 && (m.x = e),
    t !== void 0 && (m.y = t),
    s !== void 0 && (m.scale = s),
    r !== void 0 && uwe(m, r, i, a, !1);
}
const p9 = () => ({ ...UD(), attrs: {} }),
  g9 = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function dwe(n, e, t, s) {
  const r = E.useMemo(() => {
    const i = p9();
    return (
      m9(i, e, g9(s), n.transformTemplate, n.style),
      { ...i.attrs, style: { ...i.style } }
    );
  }, [e]);
  if (n.style) {
    const i = {};
    f9(i, n.style, n), (r.style = { ...i, ...r.style });
  }
  return r;
}
const hwe = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function $D(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(hwe.indexOf(n) > -1 || /[A-Z]/u.test(n));
}
function fwe(n, e, t, { latestValues: s }, r, i = !1) {
  const o = ($D(n) ? dwe : owe)(e, s, r, n),
    l = Zxe(e, typeof n == "string", i),
    c = n !== E.Fragment ? { ...l, ...o, ref: t } : {},
    { children: h } = e,
    m = E.useMemo(() => (Ir(h) ? h.get() : h), [h]);
  return E.createElement(n, { ...c, children: m });
}
function N$(n) {
  const e = [{}, {}];
  return (
    n?.values.forEach((t, s) => {
      (e[0][s] = t.get()), (e[1][s] = t.getVelocity());
    }),
    e
  );
}
function BD(n, e, t, s) {
  if (typeof e == "function") {
    const [r, i] = N$(s);
    e = e(t !== void 0 ? t : n.custom, r, i);
  }
  if (
    (typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function")
  ) {
    const [r, i] = N$(s);
    e = e(t !== void 0 ? t : n.custom, r, i);
  }
  return e;
}
function kb(n) {
  return Ir(n) ? n.get() : n;
}
function mwe(
  { scrapeMotionValuesFromProps: n, createRenderState: e },
  t,
  s,
  r
) {
  return { latestValues: pwe(t, s, r, n), renderState: e() };
}
function pwe(n, e, t, s) {
  const r = {},
    i = s(n, {});
  for (const p in i) r[p] = kb(i[p]);
  let { initial: a, animate: o } = n;
  const l = ZE(n),
    c = d9(n);
  e &&
    c &&
    !l &&
    n.inherit !== !1 &&
    (a === void 0 && (a = e.initial), o === void 0 && (o = e.animate));
  let h = t ? t.initial === !1 : !1;
  h = h || a === !1;
  const m = h ? o : a;
  if (m && typeof m != "boolean" && !QE(m)) {
    const p = Array.isArray(m) ? m : [m];
    for (let g = 0; g < p.length; g++) {
      const y = BD(n, p[g]);
      if (y) {
        const { transitionEnd: b, transition: w, ...S } = y;
        for (const A in S) {
          let _ = S[A];
          if (Array.isArray(_)) {
            const R = h ? _.length - 1 : 0;
            _ = _[R];
          }
          _ !== null && (r[A] = _);
        }
        for (const A in b) r[A] = b[A];
      }
    }
  }
  return r;
}
const v9 = (n) => (e, t) => {
  const s = E.useContext(XE),
    r = E.useContext(YE),
    i = () => mwe(n, e, s, r);
  return t ? i() : dD(i);
};
function HD(n, e, t) {
  const { style: s } = n,
    r = {};
  for (const i in s)
    (Ir(s[i]) ||
      (e.style && Ir(e.style[i])) ||
      h9(i, n) ||
      t?.getValue(i)?.liveStyle !== void 0) &&
      (r[i] = s[i]);
  return r;
}
const gwe = v9({ scrapeMotionValuesFromProps: HD, createRenderState: UD });
function y9(n, e, t) {
  const s = HD(n, e, t);
  for (const r in n)
    if (Ir(n[r]) || Ir(e[r])) {
      const i =
        Yf.indexOf(r) !== -1
          ? "attr" + r.charAt(0).toUpperCase() + r.substring(1)
          : r;
      s[i] = n[r];
    }
  return s;
}
const vwe = v9({ scrapeMotionValuesFromProps: y9, createRenderState: p9 }),
  ywe = Symbol.for("motionComponentSymbol");
function Gh(n) {
  return (
    n &&
    typeof n == "object" &&
    Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function bwe(n, e, t) {
  return E.useCallback(
    (s) => {
      s && n.onMount && n.onMount(s),
        e && (s ? e.mount(s) : e.unmount()),
        t && (typeof t == "function" ? t(s) : Gh(t) && (t.current = s));
    },
    [e]
  );
}
const VD = (n) => n.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  xwe = "framerAppearId",
  b9 = "data-" + VD(xwe),
  x9 = E.createContext({});
function wwe(n, e, t, s, r) {
  const { visualElement: i } = E.useContext(XE),
    a = E.useContext(c9),
    o = E.useContext(YE),
    l = E.useContext(ND).reducedMotion,
    c = E.useRef(null);
  (s = s || a.renderer),
    !c.current &&
      s &&
      (c.current = s(n, {
        visualState: e,
        parent: i,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: l,
      }));
  const h = c.current,
    m = E.useContext(x9);
  h &&
    !h.projection &&
    r &&
    (h.type === "html" || h.type === "svg") &&
    Ewe(c.current, t, r, m);
  const p = E.useRef(!1);
  E.useInsertionEffect(() => {
    h && p.current && h.update(t, o);
  });
  const g = t[b9],
    y = E.useRef(
      !!g &&
        !window.MotionHandoffIsComplete?.(g) &&
        window.MotionHasOptimisedAnimation?.(g)
    );
  return (
    fD(() => {
      h &&
        ((p.current = !0),
        (window.MotionIsMounted = !0),
        h.updateFeatures(),
        h.scheduleRenderMicrotask(),
        y.current && h.animationState && h.animationState.animateChanges());
    }),
    E.useEffect(() => {
      h &&
        (!y.current && h.animationState && h.animationState.animateChanges(),
        y.current &&
          (queueMicrotask(() => {
            window.MotionHandoffMarkAsComplete?.(g);
          }),
          (y.current = !1)),
        (h.enteringChildren = void 0));
    }),
    h
  );
}
function Ewe(n, e, t, s) {
  const {
    layoutId: r,
    layout: i,
    drag: a,
    dragConstraints: o,
    layoutScroll: l,
    layoutRoot: c,
    layoutCrossfade: h,
  } = e;
  (n.projection = new t(
    n.latestValues,
    e["data-framer-portal-id"] ? void 0 : w9(n.parent)
  )),
    n.projection.setOptions({
      layoutId: r,
      layout: i,
      alwaysMeasureLayout: !!a || (o && Gh(o)),
      visualElement: n,
      animationType: typeof i == "string" ? i : "both",
      initialPromotionConfig: s,
      crossfade: h,
      layoutScroll: l,
      layoutRoot: c,
    });
}
function w9(n) {
  if (n) return n.options.allowProjection !== !1 ? n.projection : w9(n.parent);
}
function K1(n, { forwardMotionProps: e = !1 } = {}, t, s) {
  t && Yxe(t);
  const r = $D(n) ? vwe : gwe;
  function i(o, l) {
    let c;
    const h = { ...E.useContext(ND), ...o, layoutId: Swe(o) },
      { isStatic: m } = h,
      p = ewe(o),
      g = r(o, m);
    if (!m && hD) {
      Twe();
      const y = _we(h);
      (c = y.MeasureLayout),
        (p.visualElement = wwe(n, g, h, s, y.ProjectionNode));
    }
    return u.jsxs(XE.Provider, {
      value: p,
      children: [
        c && p.visualElement
          ? u.jsx(c, { visualElement: p.visualElement, ...h })
          : null,
        fwe(n, o, bwe(g, p.visualElement, l), g, m, e),
      ],
    });
  }
  i.displayName = `motion.${
    typeof n == "string" ? n : `create(${n.displayName ?? n.name ?? ""})`
  }`;
  const a = E.forwardRef(i);
  return (a[ywe] = n), a;
}
function Swe({ layoutId: n }) {
  const e = E.useContext(Wg).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function Twe(n, e) {
  E.useContext(c9).strict;
}
function _we(n) {
  const { drag: e, layout: t } = kf;
  if (!e && !t) return {};
  const s = { ...e, ...t };
  return {
    MeasureLayout:
      e?.isEnabled(n) || t?.isEnabled(n) ? s.MeasureLayout : void 0,
    ProjectionNode: s.ProjectionNode,
  };
}
function Awe(n, e) {
  if (typeof Proxy > "u") return K1;
  const t = new Map(),
    s = (i, a) => K1(i, a, n, e),
    r = (i, a) => s(i, a);
  return new Proxy(r, {
    get: (i, a) =>
      a === "create"
        ? s
        : (t.has(a) || t.set(a, K1(a, void 0, n, e)), t.get(a)),
  });
}
function E9({ top: n, left: e, right: t, bottom: s }) {
  return { x: { min: e, max: t }, y: { min: n, max: s } };
}
function Rwe({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function kwe(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    s = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: s.y, right: s.x };
}
function Y1(n) {
  return n === void 0 || n === 1;
}
function nC({ scale: n, scaleX: e, scaleY: t }) {
  return !Y1(n) || !Y1(e) || !Y1(t);
}
function Ru(n) {
  return (
    nC(n) ||
    S9(n) ||
    n.z ||
    n.rotate ||
    n.rotateX ||
    n.rotateY ||
    n.skewX ||
    n.skewY
  );
}
function S9(n) {
  return O$(n.x) || O$(n.y);
}
function O$(n) {
  return n && n !== "0%";
}
function sw(n, e, t) {
  const s = n - t,
    r = e * s;
  return t + r;
}
function j$(n, e, t, s, r) {
  return r !== void 0 && (n = sw(n, r, s)), sw(n, t, s) + e;
}
function sC(n, e = 0, t = 1, s, r) {
  (n.min = j$(n.min, e, t, s, r)), (n.max = j$(n.max, e, t, s, r));
}
function T9(n, { x: e, y: t }) {
  sC(n.x, e.translate, e.scale, e.originPoint),
    sC(n.y, t.translate, t.scale, t.originPoint);
}
const F$ = 0.999999999999,
  U$ = 1.0000000000001;
function Cwe(n, e, t, s = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let i, a;
  for (let o = 0; o < r; o++) {
    (i = t[o]), (a = i.projectionDelta);
    const { visualElement: l } = i.options;
    (l && l.props.style && l.props.style.display === "contents") ||
      (s &&
        i.options.layoutScroll &&
        i.scroll &&
        i !== i.root &&
        Wh(n, { x: -i.scroll.offset.x, y: -i.scroll.offset.y }),
      a && ((e.x *= a.x.scale), (e.y *= a.y.scale), T9(n, a)),
      s && Ru(i.latestValues) && Wh(n, i.latestValues));
  }
  e.x < U$ && e.x > F$ && (e.x = 1), e.y < U$ && e.y > F$ && (e.y = 1);
}
function qh(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function $$(n, e, t, s, r = 0.5) {
  const i = as(n.min, n.max, r);
  sC(n, e, t, i, s);
}
function Wh(n, e) {
  $$(n.x, e.x, e.scaleX, e.scale, e.originX),
    $$(n.y, e.y, e.scaleY, e.scale, e.originY);
}
function _9(n, e) {
  return E9(kwe(n.getBoundingClientRect(), e));
}
function Iwe(n, e, t) {
  const s = _9(n, t),
    { scroll: r } = e;
  return r && (qh(s.x, r.offset.x), qh(s.y, r.offset.y)), s;
}
const B$ = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Kh = () => ({ x: B$(), y: B$() }),
  H$ = () => ({ min: 0, max: 0 }),
  _s = () => ({ x: H$(), y: H$() }),
  rC = { current: null },
  A9 = { current: !1 };
function Lwe() {
  if (((A9.current = !0), !!hD))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (rC.current = n.matches);
      n.addEventListener("change", e), e();
    } else rC.current = !1;
}
const Dwe = new WeakMap();
function Pwe(n, e, t) {
  for (const s in e) {
    const r = e[s],
      i = t[s];
    if (Ir(r)) n.addValue(s, r);
    else if (Ir(i)) n.addValue(s, Rf(r, { owner: n }));
    else if (i !== r)
      if (n.hasValue(s)) {
        const a = n.getValue(s);
        a.liveStyle === !0 ? a.jump(r) : a.hasAnimated || a.set(r);
      } else {
        const a = n.getStaticValue(s);
        n.addValue(s, Rf(a !== void 0 ? a : r, { owner: n }));
      }
  }
  for (const s in t) e[s] === void 0 && n.removeValue(s);
  return e;
}
const V$ = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
class Mwe {
  scrapeMotionValuesFromProps(e, t, s) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: s,
      reducedMotionConfig: r,
      blockInitialAnimation: i,
      visualState: a,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = ID),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const p = oi.now();
        this.renderScheduledAt < p &&
          ((this.renderScheduledAt = p), qn.render(this.render, !1, !0));
      });
    const { latestValues: l, renderState: c } = a;
    (this.latestValues = l),
      (this.baseTarget = { ...l }),
      (this.initialValues = t.initial ? { ...l } : {}),
      (this.renderState = c),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = s),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.blockInitialAnimation = !!i),
      (this.isControllingVariants = ZE(t)),
      (this.isVariantNode = d9(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this
    );
    for (const p in m) {
      const g = m[p];
      l[p] !== void 0 && Ir(g) && g.set(l[p]);
    }
  }
  mount(e) {
    (this.current = e),
      Dwe.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, s) => this.bindToMotionValue(s, t)),
      A9.current || Lwe(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : rC.current),
      this.parent?.addChild(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(),
      Uc(this.notifyUpdate),
      Uc(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent?.removeChild(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const t = this.features[e];
      t && (t.unmount(), (t.isMounted = !1));
    }
    this.current = null;
  }
  addChild(e) {
    this.children.add(e),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(e);
  }
  removeChild(e) {
    this.children.delete(e),
      this.enteringChildren && this.enteringChildren.delete(e);
  }
  bindToMotionValue(e, t) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const s = Xf.has(e);
    s && this.onBindTransform && this.onBindTransform();
    const r = t.on("change", (a) => {
      (this.latestValues[e] = a),
        this.props.onUpdate && qn.preRender(this.notifyUpdate),
        s && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender();
    });
    let i;
    window.MotionCheckAppearSync &&
      (i = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        r(), i && i(), t.owner && t.stop();
      });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in kf) {
      const t = kf[e];
      if (!t) continue;
      const { isEnabled: s, Feature: r } = t;
      if (
        (!this.features[e] &&
          r &&
          s(this.props) &&
          (this.features[e] = new r(this)),
        this.features[e])
      ) {
        const i = this.features[e];
        i.isMounted ? i.update() : (i.mount(), (i.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : _s();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let s = 0; s < V$.length; s++) {
      const r = V$[s];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const i = "on" + r,
        a = e[i];
      a && (this.propEventSubscriptions[r] = this.on(r, a));
    }
    (this.prevMotionValues = Pwe(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    const s = this.values.get(e);
    t !== s &&
      (s && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let s = this.values.get(e);
    return (
      s === void 0 &&
        t !== void 0 &&
        ((s = Rf(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, s)),
      s
    );
  }
  readValue(e, t) {
    let s =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : this.getBaseTargetFromProps(this.props, e) ??
          this.readValueFromInstance(this.current, e, this.options);
    return (
      s != null &&
        (typeof s == "string" && (vq(s) || bq(s))
          ? (s = parseFloat(s))
          : !Fxe(s) && $c.test(t) && (s = e9(e, t)),
        this.setBaseTarget(e, Ir(s) ? s.get() : s)),
      Ir(s) ? s.get() : s
    );
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    const { initial: t } = this.props;
    let s;
    if (typeof t == "string" || typeof t == "object") {
      const i = BD(this.props, t, this.presenceContext?.custom);
      i && (s = i[e]);
    }
    if (t && s !== void 0) return s;
    const r = this.getBaseTargetFromProps(this.props, e);
    return r !== void 0 && !Ir(r)
      ? r
      : this.initialValues[e] !== void 0 && s === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new yD()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
  scheduleRenderMicrotask() {
    PD.render(this.render);
  }
}
class R9 extends Mwe {
  constructor() {
    super(...arguments), (this.KeyframeResolver = Axe);
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: s }) {
    delete t[e], delete s[e];
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Ir(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
}
function k9(n, { style: e, vars: t }, s, r) {
  const i = n.style;
  let a;
  for (a in e) i[a] = e[a];
  r?.applyProjectionStyles(i, s);
  for (a in t) i.setProperty(a, t[a]);
}
function Nwe(n) {
  return window.getComputedStyle(n);
}
class Owe extends R9 {
  constructor() {
    super(...arguments), (this.type = "html"), (this.renderInstance = k9);
  }
  readValueFromInstance(e, t) {
    if (Xf.has(t)) return this.projection?.isProjecting ? Yk(t) : Gbe(e, t);
    {
      const s = Nwe(e),
        r = (wD(t) ? s.getPropertyValue(t) : s[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return _9(e, t);
  }
  build(e, t, s) {
    FD(e, t, s.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t, s) {
    return HD(e, t, s);
  }
}
const C9 = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function jwe(n, e, t, s) {
  k9(n, e, void 0, s);
  for (const r in e.attrs) n.setAttribute(C9.has(r) ? r : VD(r), e.attrs[r]);
}
class Fwe extends R9 {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = _s);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Xf.has(t)) {
      const s = Jq(t);
      return (s && s.default) || 0;
    }
    return (t = C9.has(t) ? t : VD(t)), e.getAttribute(t);
  }
  scrapeMotionValuesFromProps(e, t, s) {
    return y9(e, t, s);
  }
  build(e, t, s) {
    m9(e, t, this.isSVGTag, s.transformTemplate, s.style);
  }
  renderInstance(e, t, s, r) {
    jwe(e, t, s, r);
  }
  mount(e) {
    (this.isSVGTag = g9(e.tagName)), super.mount(e);
  }
}
const Uwe = (n, e) =>
  $D(n) ? new Fwe(e) : new Owe(e, { allowProjection: n !== E.Fragment });
function cf(n, e, t) {
  const s = n.getProps();
  return BD(s, e, t !== void 0 ? t : s.custom, n);
}
const iC = (n) => Array.isArray(n);
function $we(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Rf(t));
}
function Bwe(n) {
  return iC(n) ? n[n.length - 1] || 0 : n;
}
function Hwe(n, e) {
  const t = cf(n, e);
  let { transitionEnd: s = {}, transition: r = {}, ...i } = t || {};
  i = { ...i, ...s };
  for (const a in i) {
    const o = Bwe(i[a]);
    $we(n, a, o);
  }
}
function Vwe(n) {
  return !!(Ir(n) && n.add);
}
function aC(n, e) {
  const t = n.getValue("willChange");
  if (Vwe(t)) return t.add(e);
  if (!t && kl.WillChange) {
    const s = new kl.WillChange("auto");
    n.addValue("willChange", s), s.add(e);
  }
}
function I9(n) {
  return n.props[b9];
}
const zwe = (n) => n !== null;
function Gwe(n, { repeat: e, repeatType: t = "loop" }, s) {
  const r = n.filter(zwe),
    i = e && t !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
  return r[i];
}
const qwe = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  Wwe = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  Kwe = { type: "keyframes", duration: 0.8 },
  Ywe = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  Xwe = (n, { keyframes: e }) =>
    e.length > 2
      ? Kwe
      : Xf.has(n)
      ? n.startsWith("scale")
        ? Wwe(e[1])
        : qwe
      : Ywe;
function Qwe({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: s,
  staggerDirection: r,
  repeat: i,
  repeatType: a,
  repeatDelay: o,
  from: l,
  elapsed: c,
  ...h
}) {
  return !!Object.keys(h).length;
}
const zD =
  (n, e, t, s = {}, r, i) =>
  (a) => {
    const o = LD(s, n) || {},
      l = o.delay || s.delay || 0;
    let { elapsed: c = 0 } = s;
    c = c - Co(l);
    const h = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...o,
      delay: -c,
      onUpdate: (p) => {
        e.set(p), o.onUpdate && o.onUpdate(p);
      },
      onComplete: () => {
        a(), o.onComplete && o.onComplete();
      },
      name: n,
      motionValue: e,
      element: i ? void 0 : r,
    };
    Qwe(o) || Object.assign(h, Xwe(n, h)),
      h.duration && (h.duration = Co(h.duration)),
      h.repeatDelay && (h.repeatDelay = Co(h.repeatDelay)),
      h.from !== void 0 && (h.keyframes[0] = h.from);
    let m = !1;
    if (
      ((h.type === !1 || (h.duration === 0 && !h.repeatDelay)) &&
        (eC(h), h.delay === 0 && (m = !0)),
      (kl.instantAnimations || kl.skipAnimations) &&
        ((m = !0), eC(h), (h.delay = 0)),
      (h.allowFlatten = !o.type && !o.ease),
      m && !i && e.get() !== void 0)
    ) {
      const p = Gwe(h.keyframes, o);
      if (p !== void 0) {
        qn.update(() => {
          h.onUpdate(p), h.onComplete();
        });
        return;
      }
    }
    return o.isSync ? new CD(h) : new mxe(h);
  };
function Zwe({ protectedKeys: n, needsAnimating: e }, t) {
  const s = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), s;
}
function L9(n, e, { delay: t = 0, transitionOverride: s, type: r } = {}) {
  let { transition: i = n.getDefaultTransition(), transitionEnd: a, ...o } = e;
  s && (i = s);
  const l = [],
    c = r && n.animationState && n.animationState.getState()[r];
  for (const h in o) {
    const m = n.getValue(h, n.latestValues[h] ?? null),
      p = o[h];
    if (p === void 0 || (c && Zwe(c, h))) continue;
    const g = { delay: t, ...LD(i || {}, h) },
      y = m.get();
    if (
      y !== void 0 &&
      !m.isAnimating &&
      !Array.isArray(p) &&
      p === y &&
      !g.velocity
    )
      continue;
    let b = !1;
    if (window.MotionHandoffAnimation) {
      const S = I9(n);
      if (S) {
        const A = window.MotionHandoffAnimation(S, h, qn);
        A !== null && ((g.startTime = A), (b = !0));
      }
    }
    aC(n, h),
      m.start(
        zD(h, m, p, n.shouldReduceMotion && Xq.has(h) ? { type: !1 } : g, n, b)
      );
    const w = m.animation;
    w && l.push(w);
  }
  return (
    a &&
      Promise.all(l).then(() => {
        qn.update(() => {
          a && Hwe(n, a);
        });
      }),
    l
  );
}
function D9(n, e, t, s = 0, r = 1) {
  const i = Array.from(n)
      .sort((c, h) => c.sortNodePosition(h))
      .indexOf(e),
    a = n.size,
    o = (a - 1) * s;
  return typeof t == "function" ? t(i, a) : r === 1 ? i * s : o - i * s;
}
function oC(n, e, t = {}) {
  const s = cf(n, e, t.type === "exit" ? n.presenceContext?.custom : void 0);
  let { transition: r = n.getDefaultTransition() || {} } = s || {};
  t.transitionOverride && (r = t.transitionOverride);
  const i = s ? () => Promise.all(L9(n, s, t)) : () => Promise.resolve(),
    a =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: c = 0,
              staggerChildren: h,
              staggerDirection: m,
            } = r;
            return Jwe(n, e, l, c, h, m, t);
          }
        : () => Promise.resolve(),
    { when: o } = r;
  if (o) {
    const [l, c] = o === "beforeChildren" ? [i, a] : [a, i];
    return l().then(() => c());
  } else return Promise.all([i(), a(t.delay)]);
}
function Jwe(n, e, t = 0, s = 0, r = 0, i = 1, a) {
  const o = [];
  for (const l of n.variantChildren)
    l.notify("AnimationStart", e),
      o.push(
        oC(l, e, {
          ...a,
          delay:
            t +
            (typeof s == "function" ? 0 : s) +
            D9(n.variantChildren, l, s, r, i),
        }).then(() => l.notify("AnimationComplete", e))
      );
  return Promise.all(o);
}
function eEe(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let s;
  if (Array.isArray(e)) {
    const r = e.map((i) => oC(n, i, t));
    s = Promise.all(r);
  } else if (typeof e == "string") s = oC(n, e, t);
  else {
    const r = typeof e == "function" ? cf(n, e, t.custom) : e;
    s = Promise.all(L9(n, r, t));
  }
  return s.then(() => {
    n.notify("AnimationComplete", e);
  });
}
function P9(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let s = 0; s < t; s++) if (e[s] !== n[s]) return !1;
  return !0;
}
const tEe = jD.length;
function M9(n) {
  if (!n) return;
  if (!n.isControllingVariants) {
    const t = n.parent ? M9(n.parent) || {} : {};
    return n.props.initial !== void 0 && (t.initial = n.props.initial), t;
  }
  const e = {};
  for (let t = 0; t < tEe; t++) {
    const s = jD[t],
      r = n.props[s];
    (Zg(r) || r === !1) && (e[s] = r);
  }
  return e;
}
const nEe = [...OD].reverse(),
  sEe = OD.length;
function rEe(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: s }) => eEe(n, t, s)));
}
function iEe(n) {
  let e = rEe(n),
    t = z$(),
    s = !0;
  const r = (l) => (c, h) => {
    const m = cf(n, h, l === "exit" ? n.presenceContext?.custom : void 0);
    if (m) {
      const { transition: p, transitionEnd: g, ...y } = m;
      c = { ...c, ...y, ...g };
    }
    return c;
  };
  function i(l) {
    e = l(n);
  }
  function a(l) {
    const { props: c } = n,
      h = M9(n.parent) || {},
      m = [],
      p = new Set();
    let g = {},
      y = 1 / 0;
    for (let w = 0; w < sEe; w++) {
      const S = nEe[w],
        A = t[S],
        _ = c[S] !== void 0 ? c[S] : h[S],
        R = Zg(_),
        C = S === l ? A.isActive : null;
      C === !1 && (y = w);
      let D = _ === h[S] && _ !== c[S] && R;
      if (
        (D && s && n.manuallyAnimateOnMount && (D = !1),
        (A.protectedKeys = { ...g }),
        (!A.isActive && C === null) ||
          (!_ && !A.prevProp) ||
          QE(_) ||
          typeof _ == "boolean")
      )
        continue;
      const L = aEe(A.prevProp, _);
      let P = L || (S === l && A.isActive && !D && R) || (w > y && R),
        V = !1;
      const N = Array.isArray(_) ? _ : [_];
      let W = N.reduce(r(S), {});
      C === !1 && (W = {});
      const { prevResolvedValues: H = {} } = A,
        z = { ...H, ...W },
        B = (U) => {
          (P = !0),
            p.has(U) && ((V = !0), p.delete(U)),
            (A.needsAnimating[U] = !0);
          const j = n.getValue(U);
          j && (j.liveStyle = !1);
        };
      for (const U in z) {
        const j = W[U],
          Q = H[U];
        if (g.hasOwnProperty(U)) continue;
        let M = !1;
        iC(j) && iC(Q) ? (M = !P9(j, Q)) : (M = j !== Q),
          M
            ? j != null
              ? B(U)
              : p.add(U)
            : j !== void 0 && p.has(U)
            ? B(U)
            : (A.protectedKeys[U] = !0);
      }
      (A.prevProp = _),
        (A.prevResolvedValues = W),
        A.isActive && (g = { ...g, ...W }),
        s && n.blockInitialAnimation && (P = !1);
      const q = D && L;
      P &&
        (!q || V) &&
        m.push(
          ...N.map((U) => {
            const j = { type: S };
            if (
              typeof U == "string" &&
              s &&
              !q &&
              n.manuallyAnimateOnMount &&
              n.parent
            ) {
              const { parent: Q } = n,
                M = cf(Q, U);
              if (Q.enteringChildren && M) {
                const { delayChildren: I } = M.transition || {};
                j.delay = D9(Q.enteringChildren, n, I);
              }
            }
            return { animation: U, options: j };
          })
        );
    }
    if (p.size) {
      const w = {};
      if (typeof c.initial != "boolean") {
        const S = cf(n, Array.isArray(c.initial) ? c.initial[0] : c.initial);
        S && S.transition && (w.transition = S.transition);
      }
      p.forEach((S) => {
        const A = n.getBaseTarget(S),
          _ = n.getValue(S);
        _ && (_.liveStyle = !0), (w[S] = A ?? null);
      }),
        m.push({ animation: w });
    }
    let b = !!m.length;
    return (
      s &&
        (c.initial === !1 || c.initial === c.animate) &&
        !n.manuallyAnimateOnMount &&
        (b = !1),
      (s = !1),
      b ? e(m) : Promise.resolve()
    );
  }
  function o(l, c) {
    if (t[l].isActive === c) return Promise.resolve();
    n.variantChildren?.forEach((m) => m.animationState?.setActive(l, c)),
      (t[l].isActive = c);
    const h = a(l);
    for (const m in t) t[m].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: a,
    setActive: o,
    setAnimateFunction: i,
    getState: () => t,
    reset: () => {
      (t = z$()), (s = !0);
    },
  };
}
function aEe(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !P9(e, n) : !1;
}
function wu(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function z$() {
  return {
    animate: wu(!0),
    whileInView: wu(),
    whileHover: wu(),
    whileTap: wu(),
    whileDrag: wu(),
    whileFocus: wu(),
    exit: wu(),
  };
}
class Yc {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
class oEe extends Yc {
  constructor(e) {
    super(e), e.animationState || (e.animationState = iEe(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    QE(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let lEe = 0;
class cEe extends Yc {
  constructor() {
    super(...arguments), (this.id = lEe++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: s } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === s) return;
    const r = this.node.animationState.setActive("exit", !e);
    t &&
      !e &&
      r.then(() => {
        t(this.id);
      });
  }
  mount() {
    const { register: e, onExitComplete: t } = this.node.presenceContext || {};
    t && t(this.id), e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const uEe = { animation: { Feature: oEe }, exit: { Feature: cEe } };
function ev(n, e, t, s = { passive: !0 }) {
  return n.addEventListener(e, t, s), () => n.removeEventListener(e, t);
}
function Vv(n) {
  return { point: { x: n.pageX, y: n.pageY } };
}
const dEe = (n) => (e) => MD(e) && n(e, Vv(e));
function tg(n, e, t, s) {
  return ev(n, e, dEe(t), s);
}
const N9 = 1e-4,
  hEe = 1 - N9,
  fEe = 1 + N9,
  O9 = 0.01,
  mEe = 0 - O9,
  pEe = 0 + O9;
function Ur(n) {
  return n.max - n.min;
}
function gEe(n, e, t) {
  return Math.abs(n - e) <= t;
}
function G$(n, e, t, s = 0.5) {
  (n.origin = s),
    (n.originPoint = as(e.min, e.max, n.origin)),
    (n.scale = Ur(t) / Ur(e)),
    (n.translate = as(t.min, t.max, n.origin) - n.originPoint),
    ((n.scale >= hEe && n.scale <= fEe) || isNaN(n.scale)) && (n.scale = 1),
    ((n.translate >= mEe && n.translate <= pEe) || isNaN(n.translate)) &&
      (n.translate = 0);
}
function ng(n, e, t, s) {
  G$(n.x, e.x, t.x, s ? s.originX : void 0),
    G$(n.y, e.y, t.y, s ? s.originY : void 0);
}
function q$(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + Ur(e));
}
function vEe(n, e, t) {
  q$(n.x, e.x, t.x), q$(n.y, e.y, t.y);
}
function W$(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + Ur(e));
}
function sg(n, e, t) {
  W$(n.x, e.x, t.x), W$(n.y, e.y, t.y);
}
function Wi(n) {
  return [n("x"), n("y")];
}
const j9 = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  K$ = (n, e) => Math.abs(n - e);
function yEe(n, e) {
  const t = K$(n.x, e.x),
    s = K$(n.y, e.y);
  return Math.sqrt(t ** 2 + s ** 2);
}
class F9 {
  constructor(
    e,
    t,
    {
      transformPagePoint: s,
      contextWindow: r = window,
      dragSnapToOrigin: i = !1,
      distanceThreshold: a = 3,
    } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const p = Q1(this.lastMoveEventInfo, this.history),
          g = this.startEvent !== null,
          y = yEe(p.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!g && !y) return;
        const { point: b } = p,
          { timestamp: w } = gr;
        this.history.push({ ...b, timestamp: w });
        const { onStart: S, onMove: A } = this.handlers;
        g ||
          (S && S(this.lastMoveEvent, p),
          (this.startEvent = this.lastMoveEvent)),
          A && A(this.lastMoveEvent, p);
      }),
      (this.handlePointerMove = (p, g) => {
        (this.lastMoveEvent = p),
          (this.lastMoveEventInfo = X1(g, this.transformPagePoint)),
          qn.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (p, g) => {
        this.end();
        const { onEnd: y, onSessionEnd: b, resumeAnimation: w } = this.handlers;
        if (
          (this.dragSnapToOrigin && w && w(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const S = Q1(
          p.type === "pointercancel"
            ? this.lastMoveEventInfo
            : X1(g, this.transformPagePoint),
          this.history
        );
        this.startEvent && y && y(p, S), b && b(p, S);
      }),
      !MD(e))
    )
      return;
    (this.dragSnapToOrigin = i),
      (this.handlers = t),
      (this.transformPagePoint = s),
      (this.distanceThreshold = a),
      (this.contextWindow = r || window);
    const o = Vv(e),
      l = X1(o, this.transformPagePoint),
      { point: c } = l,
      { timestamp: h } = gr;
    this.history = [{ ...c, timestamp: h }];
    const { onSessionStart: m } = t;
    m && m(e, Q1(l, this.history)),
      (this.removeListeners = $v(
        tg(this.contextWindow, "pointermove", this.handlePointerMove),
        tg(this.contextWindow, "pointerup", this.handlePointerUp),
        tg(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Uc(this.updatePoint);
  }
}
function X1(n, e) {
  return e ? { point: e(n.point) } : n;
}
function Y$(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function Q1({ point: n }, e) {
  return {
    point: n,
    delta: Y$(n, U9(e)),
    offset: Y$(n, bEe(e)),
    velocity: xEe(e, 0.1),
  };
}
function bEe(n) {
  return n[0];
}
function U9(n) {
  return n[n.length - 1];
}
function xEe(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    s = null;
  const r = U9(n);
  for (; t >= 0 && ((s = n[t]), !(r.timestamp - s.timestamp > Co(e))); ) t--;
  if (!s) return { x: 0, y: 0 };
  const i = Io(r.timestamp - s.timestamp);
  if (i === 0) return { x: 0, y: 0 };
  const a = { x: (r.x - s.x) / i, y: (r.y - s.y) / i };
  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;
}
function wEe(n, { min: e, max: t }, s) {
  return (
    e !== void 0 && n < e
      ? (n = s ? as(e, n, s.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = s ? as(t, n, s.max) : Math.min(n, t)),
    n
  );
}
function X$(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function EEe(n, { top: e, left: t, bottom: s, right: r }) {
  return { x: X$(n.x, t, r), y: X$(n.y, e, s) };
}
function Q$(n, e) {
  let t = e.min - n.min,
    s = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, s] = [s, t]), { min: t, max: s };
}
function SEe(n, e) {
  return { x: Q$(n.x, e.x), y: Q$(n.y, e.y) };
}
function TEe(n, e) {
  let t = 0.5;
  const s = Ur(n),
    r = Ur(e);
  return (
    r > s
      ? (t = Kg(e.min, e.max - s, n.min))
      : s > r && (t = Kg(n.min, n.max - r, e.min)),
    Rl(0, 1, t)
  );
}
function _Ee(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const lC = 0.35;
function AEe(n = lC) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = lC),
    { x: Z$(n, "left", "right"), y: Z$(n, "top", "bottom") }
  );
}
function Z$(n, e, t) {
  return { min: J$(n, e), max: J$(n, t) };
}
function J$(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const REe = new WeakMap();
class kEe {
  constructor(e) {
    (this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = _s()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1, distanceThreshold: s } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1) return;
    const i = (m) => {
        const { dragSnapToOrigin: p } = this.getProps();
        p ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Vv(m).point);
      },
      a = (m, p) => {
        const { drag: g, dragPropagation: y, onDragStart: b } = this.getProps();
        if (
          g &&
          !y &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = Ixe(g)),
          !this.openDragLock)
        )
          return;
        (this.latestPointerEvent = m),
          (this.latestPanInfo = p),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Wi((S) => {
            let A = this.getAxisMotionValue(S).get() || 0;
            if (Lo.test(A)) {
              const { projection: _ } = this.visualElement;
              if (_ && _.layout) {
                const R = _.layout.layoutBox[S];
                R && (A = Ur(R) * (parseFloat(A) / 100));
              }
            }
            this.originPoint[S] = A;
          }),
          b && qn.postRender(() => b(m, p)),
          aC(this.visualElement, "transform");
        const { animationState: w } = this.visualElement;
        w && w.setActive("whileDrag", !0);
      },
      o = (m, p) => {
        (this.latestPointerEvent = m), (this.latestPanInfo = p);
        const {
          dragPropagation: g,
          dragDirectionLock: y,
          onDirectionLock: b,
          onDrag: w,
        } = this.getProps();
        if (!g && !this.openDragLock) return;
        const { offset: S } = p;
        if (y && this.currentDirection === null) {
          (this.currentDirection = CEe(S)),
            this.currentDirection !== null && b && b(this.currentDirection);
          return;
        }
        this.updateAxis("x", p.point, S),
          this.updateAxis("y", p.point, S),
          this.visualElement.render(),
          w && w(m, p);
      },
      l = (m, p) => {
        (this.latestPointerEvent = m),
          (this.latestPanInfo = p),
          this.stop(m, p),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null);
      },
      c = () =>
        Wi(
          (m) =>
            this.getAnimationState(m) === "paused" &&
            this.getAxisMotionValue(m).animation?.play()
        ),
      { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new F9(
      e,
      {
        onSessionStart: i,
        onStart: a,
        onMove: o,
        onSessionEnd: l,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: h,
        distanceThreshold: s,
        contextWindow: j9(this.visualElement),
      }
    );
  }
  stop(e, t) {
    const s = e || this.latestPointerEvent,
      r = t || this.latestPanInfo,
      i = this.isDragging;
    if ((this.cancel(), !i || !r || !s)) return;
    const { velocity: a } = r;
    this.startAnimation(a);
    const { onDragEnd: o } = this.getProps();
    o && qn.postRender(() => o(s, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: s } = this.getProps();
    !s &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, s) {
    const { drag: r } = this.getProps();
    if (!s || !Ny(e, r, this.currentDirection)) return;
    const i = this.getAxisMotionValue(e);
    let a = this.originPoint[e] + s[e];
    this.constraints &&
      this.constraints[e] &&
      (a = wEe(a, this.constraints[e], this.elastic[e])),
      i.set(a);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      s =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : this.visualElement.projection?.layout,
      r = this.constraints;
    e && Gh(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && s
      ? (this.constraints = EEe(s.layoutBox, e))
      : (this.constraints = !1),
      (this.elastic = AEe(t)),
      r !== this.constraints &&
        s &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Wi((i) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(i) &&
            (this.constraints[i] = _Ee(s.layoutBox[i], this.constraints[i]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !Gh(e)) return !1;
    const s = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const i = Iwe(s, r.root, this.visualElement.getTransformPagePoint());
    let a = SEe(r.layout.layoutBox, i);
    if (t) {
      const o = t(Rwe(a));
      (this.hasMutatedConstraints = !!o), o && (a = E9(o));
    }
    return a;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: s,
        dragElastic: r,
        dragTransition: i,
        dragSnapToOrigin: a,
        onDragTransitionEnd: o,
      } = this.getProps(),
      l = this.constraints || {},
      c = Wi((h) => {
        if (!Ny(h, t, this.currentDirection)) return;
        let m = (l && l[h]) || {};
        a && (m = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          g = r ? 40 : 1e7,
          y = {
            type: "inertia",
            velocity: s ? e[h] : 0,
            bounceStiffness: p,
            bounceDamping: g,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...i,
            ...m,
          };
        return this.startAxisValueAnimation(h, y);
      });
    return Promise.all(c).then(o);
  }
  startAxisValueAnimation(e, t) {
    const s = this.getAxisMotionValue(e);
    return (
      aC(this.visualElement, e), s.start(zD(e, s, 0, t, this.visualElement, !1))
    );
  }
  stopAnimation() {
    Wi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Wi((e) => this.getAxisMotionValue(e).animation?.pause());
  }
  getAnimationState(e) {
    return this.getAxisMotionValue(e).animation?.state;
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      s = this.visualElement.getProps(),
      r = s[t];
    return (
      r ||
      this.visualElement.getValue(e, (s.initial ? s.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    Wi((t) => {
      const { drag: s } = this.getProps();
      if (!Ny(t, s, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        i = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: a, max: o } = r.layout.layoutBox[t];
        i.set(e[t] - as(a, o, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: s } = this.visualElement;
    if (!Gh(t) || !s || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    Wi((a) => {
      const o = this.getAxisMotionValue(a);
      if (o && this.constraints !== !1) {
        const l = o.get();
        r[a] = TEe({ min: l, max: l }, this.constraints[a]);
      }
    });
    const { transformTemplate: i } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = i ? i({}, "") : "none"),
      s.root && s.root.updateScroll(),
      s.updateLayout(),
      this.resolveConstraints(),
      Wi((a) => {
        if (!Ny(a, e, null)) return;
        const o = this.getAxisMotionValue(a),
          { min: l, max: c } = this.constraints[a];
        o.set(as(l, c, r[a]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    REe.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = tg(e, "pointerdown", (l) => {
        const { drag: c, dragListener: h = !0 } = this.getProps();
        c && h && this.start(l);
      }),
      s = () => {
        const { dragConstraints: l } = this.getProps();
        Gh(l) && l.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      i = r.addEventListener("measure", s);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      qn.read(s);
    const a = ev(window, "resize", () => this.scalePositionWithinConstraints()),
      o = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: c }) => {
          this.isDragging &&
            c &&
            (Wi((h) => {
              const m = this.getAxisMotionValue(h);
              m &&
                ((this.originPoint[h] += l[h].translate),
                m.set(m.get() + l[h].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      a(), t(), i(), o && o();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: s = !1,
        dragPropagation: r = !1,
        dragConstraints: i = !1,
        dragElastic: a = lC,
        dragMomentum: o = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: s,
      dragPropagation: r,
      dragConstraints: i,
      dragElastic: a,
      dragMomentum: o,
    };
  }
}
function Ny(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function CEe(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class IEe extends Yc {
  constructor(e) {
    super(e),
      (this.removeGroupControls = oa),
      (this.removeListeners = oa),
      (this.controls = new kEe(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || oa);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const e4 = (n) => (e, t) => {
  n && qn.postRender(() => n(e, t));
};
class LEe extends Yc {
  constructor() {
    super(...arguments), (this.removePointerDownListener = oa);
  }
  onPointerDown(e) {
    this.session = new F9(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: j9(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: s,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: e4(e),
      onStart: e4(t),
      onMove: s,
      onEnd: (i, a) => {
        delete this.session, r && qn.postRender(() => r(i, a));
      },
    };
  }
  mount() {
    this.removePointerDownListener = tg(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Cb = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function t4(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const dp = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (It.test(n)) n = parseFloat(n);
        else return n;
      const t = t4(n, e.target.x),
        s = t4(n, e.target.y);
      return `${t}% ${s}%`;
    },
  },
  DEe = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const s = n,
        r = $c.parse(n);
      if (r.length > 5) return s;
      const i = $c.createTransformer(n),
        a = typeof r[0] != "number" ? 1 : 0,
        o = t.x.scale * e.x,
        l = t.y.scale * e.y;
      (r[0 + a] /= o), (r[1 + a] /= l);
      const c = as(o, l, 0.5);
      return (
        typeof r[2 + a] == "number" && (r[2 + a] /= c),
        typeof r[3 + a] == "number" && (r[3 + a] /= c),
        i(r)
      );
    },
  };
let Z1 = !1;
class PEe extends E.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: s,
        layoutId: r,
      } = this.props,
      { projection: i } = e;
    twe(MEe),
      i &&
        (t.group && t.group.add(i),
        s && s.register && r && s.register(i),
        Z1 && i.root.didUpdate(),
        i.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        i.setOptions({
          ...i.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Cb.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: s,
        drag: r,
        isPresent: i,
      } = this.props,
      { projection: a } = s;
    return (
      a &&
        ((a.isPresent = i),
        (Z1 = !0),
        r || e.layoutDependency !== t || t === void 0 || e.isPresent !== i
          ? a.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== i &&
          (i
            ? a.promote()
            : a.relegate() ||
              qn.postRender(() => {
                const o = a.getStack();
                (!o || !o.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      PD.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: s,
      } = this.props,
      { projection: r } = e;
    (Z1 = !0),
      r &&
        (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        s && s.deregister && s.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function $9(n) {
  const [e, t] = o9(),
    s = E.useContext(Wg);
  return u.jsx(PEe, {
    ...n,
    layoutGroup: s,
    switchLayoutGroup: E.useContext(x9),
    isPresent: e,
    safeToRemove: t,
  });
}
const MEe = {
  borderRadius: {
    ...dp,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: dp,
  borderTopRightRadius: dp,
  borderBottomLeftRadius: dp,
  borderBottomRightRadius: dp,
  boxShadow: DEe,
};
function NEe(n, e, t) {
  const s = Ir(n) ? n : Rf(n);
  return s.start(zD("", s, e, t)), s.animation;
}
const OEe = (n, e) => n.depth - e.depth;
class jEe {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    mD(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    pD(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(OEe),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function FEe(n, e) {
  const t = oi.now(),
    s = ({ timestamp: r }) => {
      const i = r - t;
      i >= e && (Uc(s), n(i - e));
    };
  return qn.setup(s, !0), () => Uc(s);
}
const B9 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  UEe = B9.length,
  n4 = (n) => (typeof n == "string" ? parseFloat(n) : n),
  s4 = (n) => typeof n == "number" || It.test(n);
function $Ee(n, e, t, s, r, i) {
  r
    ? ((n.opacity = as(0, t.opacity ?? 1, BEe(s))),
      (n.opacityExit = as(e.opacity ?? 1, 0, HEe(s))))
    : i && (n.opacity = as(e.opacity ?? 1, t.opacity ?? 1, s));
  for (let a = 0; a < UEe; a++) {
    const o = `border${B9[a]}Radius`;
    let l = r4(e, o),
      c = r4(t, o);
    if (l === void 0 && c === void 0) continue;
    l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || s4(l) === s4(c)
        ? ((n[o] = Math.max(as(n4(l), n4(c), s), 0)),
          (Lo.test(c) || Lo.test(l)) && (n[o] += "%"))
        : (n[o] = c);
  }
  (e.rotate || t.rotate) && (n.rotate = as(e.rotate || 0, t.rotate || 0, s));
}
function r4(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const BEe = H9(0, 0.5, Rq),
  HEe = H9(0.5, 0.95, oa);
function H9(n, e, t) {
  return (s) => (s < n ? 0 : s > e ? 1 : t(Kg(n, e, s)));
}
function i4(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function Vi(n, e) {
  i4(n.x, e.x), i4(n.y, e.y);
}
function a4(n, e) {
  (n.translate = e.translate),
    (n.scale = e.scale),
    (n.originPoint = e.originPoint),
    (n.origin = e.origin);
}
function o4(n, e, t, s, r) {
  return (
    (n -= e), (n = sw(n, 1 / t, s)), r !== void 0 && (n = sw(n, 1 / r, s)), n
  );
}
function VEe(n, e = 0, t = 1, s = 0.5, r, i = n, a = n) {
  if (
    (Lo.test(e) &&
      ((e = parseFloat(e)), (e = as(a.min, a.max, e / 100) - a.min)),
    typeof e != "number")
  )
    return;
  let o = as(i.min, i.max, s);
  n === i && (o -= e),
    (n.min = o4(n.min, e, t, o, r)),
    (n.max = o4(n.max, e, t, o, r));
}
function l4(n, e, [t, s, r], i, a) {
  VEe(n, e[t], e[s], e[r], e.scale, i, a);
}
const zEe = ["x", "scaleX", "originX"],
  GEe = ["y", "scaleY", "originY"];
function c4(n, e, t, s) {
  l4(n.x, e, zEe, t ? t.x : void 0, s ? s.x : void 0),
    l4(n.y, e, GEe, t ? t.y : void 0, s ? s.y : void 0);
}
function u4(n) {
  return n.translate === 0 && n.scale === 1;
}
function V9(n) {
  return u4(n.x) && u4(n.y);
}
function d4(n, e) {
  return n.min === e.min && n.max === e.max;
}
function qEe(n, e) {
  return d4(n.x, e.x) && d4(n.y, e.y);
}
function h4(n, e) {
  return (
    Math.round(n.min) === Math.round(e.min) &&
    Math.round(n.max) === Math.round(e.max)
  );
}
function z9(n, e) {
  return h4(n.x, e.x) && h4(n.y, e.y);
}
function f4(n) {
  return Ur(n.x) / Ur(n.y);
}
function m4(n, e) {
  return (
    n.translate === e.translate &&
    n.scale === e.scale &&
    n.originPoint === e.originPoint
  );
}
class WEe {
  constructor() {
    this.members = [];
  }
  add(e) {
    mD(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (pD(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let s;
    for (let r = t; r >= 0; r--) {
      const i = this.members[r];
      if (i.isPresent !== !1) {
        s = i;
        break;
      }
    }
    return s ? (this.promote(s), !0) : !1;
  }
  promote(e, t) {
    const s = this.lead;
    if (e !== s && ((this.prevLead = s), (this.lead = e), e.show(), s)) {
      s.instance && s.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = s),
        t && (e.resumeFrom.preserveOpacity = !0),
        s.snapshot &&
          ((e.snapshot = s.snapshot),
          (e.snapshot.latestValues = s.animationValues || s.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && s.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: s } = e;
      t.onExitComplete && t.onExitComplete(),
        s && s.options.onExitComplete && s.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function KEe(n, e, t) {
  let s = "";
  const r = n.x.translate / e.x,
    i = n.y.translate / e.y,
    a = t?.z || 0;
  if (
    ((r || i || a) && (s = `translate3d(${r}px, ${i}px, ${a}px) `),
    (e.x !== 1 || e.y !== 1) && (s += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: c,
      rotate: h,
      rotateX: m,
      rotateY: p,
      skewX: g,
      skewY: y,
    } = t;
    c && (s = `perspective(${c}px) ${s}`),
      h && (s += `rotate(${h}deg) `),
      m && (s += `rotateX(${m}deg) `),
      p && (s += `rotateY(${p}deg) `),
      g && (s += `skewX(${g}deg) `),
      y && (s += `skewY(${y}deg) `);
  }
  const o = n.x.scale * e.x,
    l = n.y.scale * e.y;
  return (o !== 1 || l !== 1) && (s += `scale(${o}, ${l})`), s || "none";
}
const J1 = ["", "X", "Y", "Z"],
  YEe = 1e3;
let XEe = 0;
function eA(n, e, t, s) {
  const { latestValues: r } = e;
  r[n] && ((t[n] = r[n]), e.setStaticValue(n, 0), s && (s[n] = 0));
}
function G9(n) {
  if (((n.hasCheckedOptimisedAppear = !0), n.root === n)) return;
  const { visualElement: e } = n.options;
  if (!e) return;
  const t = I9(e);
  if (window.MotionHasOptimisedAnimation(t, "transform")) {
    const { layout: r, layoutId: i } = n.options;
    window.MotionCancelOptimisedAnimation(t, "transform", qn, !(r || i));
  }
  const { parent: s } = n;
  s && !s.hasCheckedOptimisedAppear && G9(s);
}
function q9({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: s,
  resetTransform: r,
}) {
  return class {
    constructor(a = {}, o = e?.()) {
      (this.id = XEe++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            this.nodes.forEach(JEe),
            this.nodes.forEach(sSe),
            this.nodes.forEach(rSe),
            this.nodes.forEach(eSe);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = a),
        (this.root = o ? o.root || o : this),
        (this.path = o ? [...o.path, o] : []),
        (this.parent = o),
        (this.depth = o ? o.depth + 1 : 0);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new jEe());
    }
    addEventListener(a, o) {
      return (
        this.eventHandlers.has(a) || this.eventHandlers.set(a, new yD()),
        this.eventHandlers.get(a).add(o)
      );
    }
    notifyListeners(a, ...o) {
      const l = this.eventHandlers.get(a);
      l && l.notify(...o);
    }
    hasListeners(a) {
      return this.eventHandlers.has(a);
    }
    mount(a) {
      if (this.instance) return;
      (this.isSVG = a9(a) && !Oxe(a)), (this.instance = a);
      const { layoutId: o, layout: l, visualElement: c } = this.options;
      if (
        (c && !c.current && c.mount(a),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (l || o) && (this.isLayoutDirty = !0),
        n)
      ) {
        let h,
          m = 0;
        const p = () => (this.root.updateBlockedByResize = !1);
        qn.read(() => {
          m = window.innerWidth;
        }),
          n(a, () => {
            const g = window.innerWidth;
            g !== m &&
              ((m = g),
              (this.root.updateBlockedByResize = !0),
              h && h(),
              (h = FEe(p, 250)),
              Cb.hasAnimatedSinceResize &&
                ((Cb.hasAnimatedSinceResize = !1), this.nodes.forEach(v4)));
          });
      }
      o && this.root.registerSharedNode(o, this),
        this.options.animate !== !1 &&
          c &&
          (o || l) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: h,
              hasLayoutChanged: m,
              hasRelativeLayoutChanged: p,
              layout: g,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const y =
                  this.options.transition || c.getDefaultTransition() || cSe,
                { onLayoutAnimationStart: b, onLayoutAnimationComplete: w } =
                  c.getProps(),
                S = !this.targetLayout || !z9(this.targetLayout, g),
                A = !m && p;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                A ||
                (m && (S || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const _ = { ...LD(y, "layout"), onPlay: b, onComplete: w };
                (c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((_.delay = 0), (_.type = !1)),
                  this.startAnimation(_),
                  this.setAnimationOrigin(h, A);
              } else
                m || v4(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = g;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const a = this.getStack();
      a && a.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        Uc(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(iSe),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: a } = this.options;
      return a && a.getProps().transformTemplate;
    }
    willUpdate(a = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          G9(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h];
        (m.shouldResetTransform = !0),
          m.updateScroll("snapshot"),
          m.options.layoutRoot && m.willUpdate(!1);
      }
      const { layoutId: o, layout: l } = this.options;
      if (o === void 0 && !l) return;
      const c = this.getTransformTemplate();
      (this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        a && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(p4);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(g4);
        return;
      }
      (this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(nSe),
            this.nodes.forEach(QEe),
            this.nodes.forEach(ZEe))
          : this.nodes.forEach(g4),
        this.clearAllSnapshots();
      const o = oi.now();
      (gr.delta = Rl(0, 1e3 / 60, o - gr.timestamp)),
        (gr.timestamp = o),
        (gr.isProcessing = !0),
        H1.update.process(gr),
        H1.preRender.process(gr),
        H1.render.process(gr),
        (gr.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), PD.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(tSe), this.sharedNodes.forEach(aSe);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        qn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      qn.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !Ur(this.snapshot.measuredBox.x) &&
          !Ur(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const a = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = _s()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: o } = this.options;
      o &&
        o.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          a ? a.layoutBox : void 0
        );
    }
    updateScroll(a = "measure") {
      let o = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === a &&
          (o = !1),
        o && this.instance)
      ) {
        const l = s(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: a,
          isRoot: l,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!r) return;
      const a =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        o = this.projectionDelta && !V9(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        h = c !== this.prevTransformTemplateValue;
      a &&
        this.instance &&
        (o || Ru(this.latestValues) || h) &&
        (r(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(a = !0) {
      const o = this.measurePageBox();
      let l = this.removeElementScroll(o);
      return (
        a && (l = this.removeTransform(l)),
        uSe(l),
        {
          animationId: this.root.animationId,
          measuredBox: o,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: a } = this.options;
      if (!a) return _s();
      const o = a.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(dSe))) {
        const { scroll: c } = this.root;
        c && (qh(o.x, c.offset.x), qh(o.y, c.offset.y));
      }
      return o;
    }
    removeElementScroll(a) {
      const o = _s();
      if ((Vi(o, a), this.scroll?.wasRoot)) return o;
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l],
          { scroll: h, options: m } = c;
        c !== this.root &&
          h &&
          m.layoutScroll &&
          (h.wasRoot && Vi(o, a), qh(o.x, h.offset.x), qh(o.y, h.offset.y));
      }
      return o;
    }
    applyTransform(a, o = !1) {
      const l = _s();
      Vi(l, a);
      for (let c = 0; c < this.path.length; c++) {
        const h = this.path[c];
        !o &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          Wh(l, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          Ru(h.latestValues) && Wh(l, h.latestValues);
      }
      return Ru(this.latestValues) && Wh(l, this.latestValues), l;
    }
    removeTransform(a) {
      const o = _s();
      Vi(o, a);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Ru(c.latestValues)) continue;
        nC(c.latestValues) && c.updateSnapshot();
        const h = _s(),
          m = c.measurePageBox();
        Vi(h, m),
          c4(o, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, h);
      }
      return Ru(this.latestValues) && c4(o, this.latestValues), o;
    }
    setTargetDelta(a) {
      (this.targetDelta = a),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(a) {
      this.options = {
        ...this.options,
        ...a,
        crossfade: a.crossfade !== void 0 ? a.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== gr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(a = !1) {
      const o = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = o.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = o.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = o.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== o;
      if (
        !(
          a ||
          (l && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: h, layoutId: m } = this.options;
      if (!(!this.layout || !(h || m))) {
        if (
          ((this.resolvedRelativeTargetAt = gr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const p = this.getClosestProjectingParent();
          p && p.layout && this.animationProgress !== 1
            ? ((this.relativeParent = p),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = _s()),
              (this.relativeTargetOrigin = _s()),
              sg(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                p.layout.layoutBox
              ),
              Vi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (
          !(!this.relativeTarget && !this.targetDelta) &&
          (this.target ||
            ((this.target = _s()), (this.targetWithTransforms = _s())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              vEe(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
            ? (this.resumingFrom
                ? (this.target = this.applyTransform(this.layout.layoutBox))
                : Vi(this.target, this.layout.layoutBox),
              T9(this.target, this.targetDelta))
            : Vi(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget)
        ) {
          this.attemptToResolveRelativeTarget = !1;
          const p = this.getClosestProjectingParent();
          p &&
          !!p.resumingFrom == !!this.resumingFrom &&
          !p.options.layoutScroll &&
          p.target &&
          this.animationProgress !== 1
            ? ((this.relativeParent = p),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = _s()),
              (this.relativeTargetOrigin = _s()),
              sg(this.relativeTargetOrigin, this.target, p.target),
              Vi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          nC(this.parent.latestValues) ||
          S9(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      const a = this.getLead(),
        o = !!this.resumingFrom || this !== a;
      let l = !0;
      if (
        ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (l = !1),
        o &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (l = !1),
        this.resolvedRelativeTargetAt === gr.timestamp && (l = !1),
        l)
      )
        return;
      const { layout: c, layoutId: h } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || h))
      )
        return;
      Vi(this.layoutCorrected, this.layout.layoutBox);
      const m = this.treeScale.x,
        p = this.treeScale.y;
      Cwe(this.layoutCorrected, this.treeScale, this.path, o),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((a.target = a.layout.layoutBox), (a.targetWithTransforms = _s()));
      const { target: g } = a;
      if (!g) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (a4(this.prevProjectionDelta.x, this.projectionDelta.x),
          a4(this.prevProjectionDelta.y, this.projectionDelta.y)),
        ng(this.projectionDelta, this.layoutCorrected, g, this.latestValues),
        (this.treeScale.x !== m ||
          this.treeScale.y !== p ||
          !m4(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !m4(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", g));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(a = !0) {
      if ((this.options.visualElement?.scheduleRender(), a)) {
        const o = this.getStack();
        o && o.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = Kh()),
        (this.projectionDelta = Kh()),
        (this.projectionDeltaWithTransform = Kh());
    }
    setAnimationOrigin(a, o = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        h = { ...this.latestValues },
        m = Kh();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !o);
      const p = _s(),
        g = l ? l.source : void 0,
        y = this.layout ? this.layout.source : void 0,
        b = g !== y,
        w = this.getStack(),
        S = !w || w.members.length <= 1,
        A = !!(
          b &&
          !S &&
          this.options.crossfade === !0 &&
          !this.path.some(lSe)
        );
      this.animationProgress = 0;
      let _;
      (this.mixTargetDelta = (R) => {
        const C = R / 1e3;
        y4(m.x, a.x, C),
          y4(m.y, a.y, C),
          this.setTargetDelta(m),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (sg(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            oSe(this.relativeTarget, this.relativeTargetOrigin, p, C),
            _ && qEe(this.relativeTarget, _) && (this.isProjectionDirty = !1),
            _ || (_ = _s()),
            Vi(_, this.relativeTarget)),
          b &&
            ((this.animationValues = h), $Ee(h, c, this.latestValues, C, A, S)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = C);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(a) {
      this.notifyListeners("animationStart"),
        this.currentAnimation?.stop(),
        this.resumingFrom?.currentAnimation?.stop(),
        this.pendingAnimation &&
          (Uc(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = qn.update(() => {
          (Cb.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = Rf(0)),
            (this.currentAnimation = NEe(this.motionValue, [0, 1e3], {
              ...a,
              velocity: 0,
              isSync: !0,
              onUpdate: (o) => {
                this.mixTargetDelta(o), a.onUpdate && a.onUpdate(o);
              },
              onStop: () => {},
              onComplete: () => {
                a.onComplete && a.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const a = this.getStack();
      a && a.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(YEe),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const a = this.getLead();
      let {
        targetWithTransforms: o,
        target: l,
        layout: c,
        latestValues: h,
      } = a;
      if (!(!o || !l || !c)) {
        if (
          this !== a &&
          this.layout &&
          c &&
          W9(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || _s();
          const m = Ur(this.layout.layoutBox.x);
          (l.x.min = a.target.x.min), (l.x.max = l.x.min + m);
          const p = Ur(this.layout.layoutBox.y);
          (l.y.min = a.target.y.min), (l.y.max = l.y.min + p);
        }
        Vi(o, l),
          Wh(o, h),
          ng(this.projectionDeltaWithTransform, this.layoutCorrected, o, h);
      }
    }
    registerSharedNode(a, o) {
      this.sharedNodes.has(a) || this.sharedNodes.set(a, new WEe()),
        this.sharedNodes.get(a).add(o);
      const c = o.options.initialPromotionConfig;
      o.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity
            ? c.shouldPreserveFollowOpacity(o)
            : void 0,
      });
    }
    isLead() {
      const a = this.getStack();
      return a ? a.lead === this : !0;
    }
    getLead() {
      const { layoutId: a } = this.options;
      return a ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: a } = this.options;
      return a ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: a } = this.options;
      if (a) return this.root.sharedNodes.get(a);
    }
    promote({ needsReset: a, transition: o, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l),
        a && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        o && this.setOptions({ transition: o });
    }
    relegate() {
      const a = this.getStack();
      return a ? a.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: a } = this.options;
      if (!a) return;
      let o = !1;
      const { latestValues: l } = a;
      if (
        ((l.z ||
          l.rotate ||
          l.rotateX ||
          l.rotateY ||
          l.rotateZ ||
          l.skewX ||
          l.skewY) &&
          (o = !0),
        !o)
      )
        return;
      const c = {};
      l.z && eA("z", a, c, this.animationValues);
      for (let h = 0; h < J1.length; h++)
        eA(`rotate${J1[h]}`, a, c, this.animationValues),
          eA(`skew${J1[h]}`, a, c, this.animationValues);
      a.render();
      for (const h in c)
        a.setStaticValue(h, c[h]),
          this.animationValues && (this.animationValues[h] = c[h]);
      a.scheduleRender();
    }
    applyProjectionStyles(a, o) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        a.visibility = "hidden";
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        (this.needsReset = !1),
          (a.visibility = ""),
          (a.opacity = ""),
          (a.pointerEvents = kb(o?.pointerEvents) || ""),
          (a.transform = l ? l(this.latestValues, "") : "none");
        return;
      }
      const c = this.getLead();
      if (!this.projectionDelta || !this.layout || !c.target) {
        this.options.layoutId &&
          ((a.opacity =
            this.latestValues.opacity !== void 0
              ? this.latestValues.opacity
              : 1),
          (a.pointerEvents = kb(o?.pointerEvents) || "")),
          this.hasProjected &&
            !Ru(this.latestValues) &&
            ((a.transform = l ? l({}, "") : "none"), (this.hasProjected = !1));
        return;
      }
      a.visibility = "";
      const h = c.animationValues || c.latestValues;
      this.applyTransformsToTarget();
      let m = KEe(this.projectionDeltaWithTransform, this.treeScale, h);
      l && (m = l(h, m)), (a.transform = m);
      const { x: p, y: g } = this.projectionDelta;
      (a.transformOrigin = `${p.origin * 100}% ${g.origin * 100}% 0`),
        c.animationValues
          ? (a.opacity =
              c === this
                ? h.opacity ?? this.latestValues.opacity ?? 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : h.opacityExit)
          : (a.opacity =
              c === this
                ? h.opacity !== void 0
                  ? h.opacity
                  : ""
                : h.opacityExit !== void 0
                ? h.opacityExit
                : 0);
      for (const y in Jg) {
        if (h[y] === void 0) continue;
        const { correct: b, applyTo: w, isCSSVariable: S } = Jg[y],
          A = m === "none" ? h[y] : b(h[y], c);
        if (w) {
          const _ = w.length;
          for (let R = 0; R < _; R++) a[w[R]] = A;
        } else
          S ? (this.options.visualElement.renderState.vars[y] = A) : (a[y] = A);
      }
      this.options.layoutId &&
        (a.pointerEvents = c === this ? kb(o?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((a) => a.currentAnimation?.stop()),
        this.root.nodes.forEach(p4),
        this.root.sharedNodes.clear();
    }
  };
}
function QEe(n) {
  n.updateLayout();
}
function ZEe(n) {
  const e = n.resumeFrom?.snapshot || n.snapshot;
  if (n.isLead() && n.layout && e && n.hasListeners("didUpdate")) {
    const { layoutBox: t, measuredBox: s } = n.layout,
      { animationType: r } = n.options,
      i = e.source !== n.layout.source;
    r === "size"
      ? Wi((h) => {
          const m = i ? e.measuredBox[h] : e.layoutBox[h],
            p = Ur(m);
          (m.min = t[h].min), (m.max = m.min + p);
        })
      : W9(r, e.layoutBox, t) &&
        Wi((h) => {
          const m = i ? e.measuredBox[h] : e.layoutBox[h],
            p = Ur(t[h]);
          (m.max = m.min + p),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[h].max = n.relativeTarget[h].min + p));
        });
    const a = Kh();
    ng(a, t, e.layoutBox);
    const o = Kh();
    i ? ng(o, n.applyTransform(s, !0), e.measuredBox) : ng(o, t, e.layoutBox);
    const l = !V9(a);
    let c = !1;
    if (!n.resumeFrom) {
      const h = n.getClosestProjectingParent();
      if (h && !h.resumeFrom) {
        const { snapshot: m, layout: p } = h;
        if (m && p) {
          const g = _s();
          sg(g, e.layoutBox, m.layoutBox);
          const y = _s();
          sg(y, t, p.layoutBox),
            z9(g, y) || (c = !0),
            h.options.layoutRoot &&
              ((n.relativeTarget = y),
              (n.relativeTargetOrigin = g),
              (n.relativeParent = h));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: t,
      snapshot: e,
      delta: o,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeLayoutChanged: c,
    });
  } else if (n.isLead()) {
    const { onExitComplete: t } = n.options;
    t && t();
  }
  n.options.transition = void 0;
}
function JEe(n) {
  n.parent &&
    (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
    n.isSharedProjectionDirty ||
      (n.isSharedProjectionDirty = !!(
        n.isProjectionDirty ||
        n.parent.isProjectionDirty ||
        n.parent.isSharedProjectionDirty
      )),
    n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function eSe(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function tSe(n) {
  n.clearSnapshot();
}
function p4(n) {
  n.clearMeasurements();
}
function g4(n) {
  n.isLayoutDirty = !1;
}
function nSe(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function v4(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0);
}
function sSe(n) {
  n.resolveTargetDelta();
}
function rSe(n) {
  n.calcProjection();
}
function iSe(n) {
  n.resetSkewAndRotation();
}
function aSe(n) {
  n.removeLeadSnapshot();
}
function y4(n, e, t) {
  (n.translate = as(e.translate, 0, t)),
    (n.scale = as(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function b4(n, e, t, s) {
  (n.min = as(e.min, t.min, s)), (n.max = as(e.max, t.max, s));
}
function oSe(n, e, t, s) {
  b4(n.x, e.x, t.x, s), b4(n.y, e.y, t.y, s);
}
function lSe(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const cSe = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  x4 = (n) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(n),
  w4 = x4("applewebkit/") && !x4("chrome/") ? Math.round : oa;
function E4(n) {
  (n.min = w4(n.min)), (n.max = w4(n.max));
}
function uSe(n) {
  E4(n.x), E4(n.y);
}
function W9(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !gEe(f4(e), f4(t), 0.2))
  );
}
function dSe(n) {
  return n !== n.root && n.scroll?.wasRoot;
}
const hSe = q9({
    attachResizeListener: (n, e) => ev(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  tA = { current: void 0 },
  K9 = q9({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!tA.current) {
        const n = new hSe({});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (tA.current = n);
      }
      return tA.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  fSe = {
    pan: { Feature: LEe },
    drag: { Feature: IEe, ProjectionNode: K9, MeasureLayout: $9 },
  };
function S4(n, e, t) {
  const { props: s } = n;
  n.animationState &&
    s.whileHover &&
    n.animationState.setActive("whileHover", t === "Start");
  const r = "onHover" + t,
    i = s[r];
  i && qn.postRender(() => i(e, Vv(e)));
}
class mSe extends Yc {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = Lxe(
        e,
        (t, s) => (S4(this.node, s, "Start"), (r) => S4(this.node, r, "End"))
      ));
  }
  unmount() {}
}
class pSe extends Yc {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = $v(
      ev(this.node.current, "focus", () => this.onFocus()),
      ev(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
function T4(n, e, t) {
  const { props: s } = n;
  if (n.current instanceof HTMLButtonElement && n.current.disabled) return;
  n.animationState &&
    s.whileTap &&
    n.animationState.setActive("whileTap", t === "Start");
  const r = "onTap" + (t === "End" ? "" : t),
    i = s[r];
  i && qn.postRender(() => i(e, Vv(e)));
}
class gSe extends Yc {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = Nxe(
        e,
        (t, s) => (
          T4(this.node, s, "Start"),
          (r, { success: i }) => T4(this.node, r, i ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ));
  }
  unmount() {}
}
const cC = new WeakMap(),
  nA = new WeakMap(),
  vSe = (n) => {
    const e = cC.get(n.target);
    e && e(n);
  },
  ySe = (n) => {
    n.forEach(vSe);
  };
function bSe({ root: n, ...e }) {
  const t = n || document;
  nA.has(t) || nA.set(t, {});
  const s = nA.get(t),
    r = JSON.stringify(e);
  return (
    s[r] || (s[r] = new IntersectionObserver(ySe, { root: n, ...e })), s[r]
  );
}
function xSe(n, e, t) {
  const s = bSe(e);
  return (
    cC.set(n, t),
    s.observe(n),
    () => {
      cC.delete(n), s.unobserve(n);
    }
  );
}
const wSe = { some: 0, all: 1 };
class ESe extends Yc {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: s, amount: r = "some", once: i } = e,
      a = {
        root: t ? t.current : void 0,
        rootMargin: s,
        threshold: typeof r == "number" ? r : wSe[r],
      },
      o = (l) => {
        const { isIntersecting: c } = l;
        if (
          this.isInView === c ||
          ((this.isInView = c), i && !c && this.hasEnteredView)
        )
          return;
        c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", c);
        const { onViewportEnter: h, onViewportLeave: m } = this.node.getProps(),
          p = c ? h : m;
        p && p(l);
      };
    return xSe(this.node.current, a, o);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(SSe(e, t)) && this.startObserver();
  }
  unmount() {}
}
function SSe({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const TSe = {
    inView: { Feature: ESe },
    tap: { Feature: gSe },
    focus: { Feature: pSe },
    hover: { Feature: mSe },
  },
  _Se = { layout: { ProjectionNode: K9, MeasureLayout: $9 } },
  ASe = { ...uEe, ...TSe, ...fSe, ..._Se },
  la = Awe(ASe, Uwe),
  RSe =
    "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
  kSe =
    "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
  uC = "numeric",
  dC = "ascii",
  hC = "alpha",
  rg = "asciinumeric",
  Ip = "alphanumeric",
  fC = "domain",
  Y9 = "emoji",
  CSe = "scheme",
  ISe = "slashscheme",
  sA = "whitespace";
function LSe(n, e) {
  return n in e || (e[n] = []), e[n];
}
function Fu(n, e, t) {
  e[uC] && ((e[rg] = !0), (e[Ip] = !0)),
    e[dC] && ((e[rg] = !0), (e[hC] = !0)),
    e[rg] && (e[Ip] = !0),
    e[hC] && (e[Ip] = !0),
    e[Ip] && (e[fC] = !0),
    e[Y9] && (e[fC] = !0);
  for (const s in e) {
    const r = LSe(s, t);
    r.indexOf(n) < 0 && r.push(n);
  }
}
function DSe(n, e) {
  const t = {};
  for (const s in e) e[s].indexOf(n) >= 0 && (t[s] = !0);
  return t;
}
function Ei(n = null) {
  (this.j = {}), (this.jr = []), (this.jd = null), (this.t = n);
}
Ei.groups = {};
Ei.prototype = {
  accepts() {
    return !!this.t;
  },
  go(n) {
    const e = this,
      t = e.j[n];
    if (t) return t;
    for (let s = 0; s < e.jr.length; s++) {
      const r = e.jr[s][0],
        i = e.jr[s][1];
      if (i && r.test(n)) return i;
    }
    return e.jd;
  },
  has(n, e = !1) {
    return e ? n in this.j : !!this.go(n);
  },
  ta(n, e, t, s) {
    for (let r = 0; r < n.length; r++) this.tt(n[r], e, t, s);
  },
  tr(n, e, t, s) {
    s = s || Ei.groups;
    let r;
    return (
      e && e.j ? (r = e) : ((r = new Ei(e)), t && s && Fu(e, t, s)),
      this.jr.push([n, r]),
      r
    );
  },
  ts(n, e, t, s) {
    let r = this;
    const i = n.length;
    if (!i) return r;
    for (let a = 0; a < i - 1; a++) r = r.tt(n[a]);
    return r.tt(n[i - 1], e, t, s);
  },
  tt(n, e, t, s) {
    s = s || Ei.groups;
    const r = this;
    if (e && e.j) return (r.j[n] = e), e;
    const i = e;
    let a,
      o = r.go(n);
    if (
      (o
        ? ((a = new Ei()),
          Object.assign(a.j, o.j),
          a.jr.push.apply(a.jr, o.jr),
          (a.jd = o.jd),
          (a.t = o.t))
        : (a = new Ei()),
      i)
    ) {
      if (s)
        if (a.t && typeof a.t == "string") {
          const l = Object.assign(DSe(a.t, s), t);
          Fu(i, l, s);
        } else t && Fu(i, t, s);
      a.t = i;
    }
    return (r.j[n] = a), a;
  },
};
const Wt = (n, e, t, s, r) => n.ta(e, t, s, r),
  ds = (n, e, t, s, r) => n.tr(e, t, s, r),
  _4 = (n, e, t, s, r) => n.ts(e, t, s, r),
  ze = (n, e, t, s, r) => n.tt(e, t, s, r),
  ol = "WORD",
  mC = "UWORD",
  X9 = "ASCIINUMERICAL",
  Q9 = "ALPHANUMERICAL",
  tv = "LOCALHOST",
  pC = "TLD",
  gC = "UTLD",
  Ib = "SCHEME",
  _h = "SLASH_SCHEME",
  GD = "NUM",
  vC = "WS",
  qD = "NL",
  ig = "OPENBRACE",
  ag = "CLOSEBRACE",
  rw = "OPENBRACKET",
  iw = "CLOSEBRACKET",
  aw = "OPENPAREN",
  ow = "CLOSEPAREN",
  lw = "OPENANGLEBRACKET",
  cw = "CLOSEANGLEBRACKET",
  uw = "FULLWIDTHLEFTPAREN",
  dw = "FULLWIDTHRIGHTPAREN",
  hw = "LEFTCORNERBRACKET",
  fw = "RIGHTCORNERBRACKET",
  mw = "LEFTWHITECORNERBRACKET",
  pw = "RIGHTWHITECORNERBRACKET",
  gw = "FULLWIDTHLESSTHAN",
  vw = "FULLWIDTHGREATERTHAN",
  yw = "AMPERSAND",
  bw = "APOSTROPHE",
  xw = "ASTERISK",
  bc = "AT",
  ww = "BACKSLASH",
  Ew = "BACKTICK",
  Sw = "CARET",
  Tc = "COLON",
  WD = "COMMA",
  Tw = "DOLLAR",
  co = "DOT",
  _w = "EQUALS",
  KD = "EXCLAMATION",
  Ki = "HYPHEN",
  og = "PERCENT",
  Aw = "PIPE",
  Rw = "PLUS",
  kw = "POUND",
  lg = "QUERY",
  YD = "QUOTE",
  Z9 = "FULLWIDTHMIDDLEDOT",
  XD = "SEMI",
  uo = "SLASH",
  cg = "TILDE",
  Cw = "UNDERSCORE",
  J9 = "EMOJI",
  Iw = "SYM";
var eW = Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Q9,
  AMPERSAND: yw,
  APOSTROPHE: bw,
  ASCIINUMERICAL: X9,
  ASTERISK: xw,
  AT: bc,
  BACKSLASH: ww,
  BACKTICK: Ew,
  CARET: Sw,
  CLOSEANGLEBRACKET: cw,
  CLOSEBRACE: ag,
  CLOSEBRACKET: iw,
  CLOSEPAREN: ow,
  COLON: Tc,
  COMMA: WD,
  DOLLAR: Tw,
  DOT: co,
  EMOJI: J9,
  EQUALS: _w,
  EXCLAMATION: KD,
  FULLWIDTHGREATERTHAN: vw,
  FULLWIDTHLEFTPAREN: uw,
  FULLWIDTHLESSTHAN: gw,
  FULLWIDTHMIDDLEDOT: Z9,
  FULLWIDTHRIGHTPAREN: dw,
  HYPHEN: Ki,
  LEFTCORNERBRACKET: hw,
  LEFTWHITECORNERBRACKET: mw,
  LOCALHOST: tv,
  NL: qD,
  NUM: GD,
  OPENANGLEBRACKET: lw,
  OPENBRACE: ig,
  OPENBRACKET: rw,
  OPENPAREN: aw,
  PERCENT: og,
  PIPE: Aw,
  PLUS: Rw,
  POUND: kw,
  QUERY: lg,
  QUOTE: YD,
  RIGHTCORNERBRACKET: fw,
  RIGHTWHITECORNERBRACKET: pw,
  SCHEME: Ib,
  SEMI: XD,
  SLASH: uo,
  SLASH_SCHEME: _h,
  SYM: Iw,
  TILDE: cg,
  TLD: pC,
  UNDERSCORE: Cw,
  UTLD: gC,
  UWORD: mC,
  WORD: ol,
  WS: vC,
});
const el = /[a-z]/,
  hp = new RegExp("\\p{L}", "u"),
  rA = new RegExp("\\p{Emoji}", "u"),
  tl = /\d/,
  iA = /\s/,
  A4 = "\r",
  aA = `
`,
  PSe = "",
  MSe = "",
  oA = "";
let Oy = null,
  jy = null;
function NSe(n = []) {
  const e = {};
  Ei.groups = e;
  const t = new Ei();
  Oy == null && (Oy = R4(RSe)),
    jy == null && (jy = R4(kSe)),
    ze(t, "'", bw),
    ze(t, "{", ig),
    ze(t, "}", ag),
    ze(t, "[", rw),
    ze(t, "]", iw),
    ze(t, "(", aw),
    ze(t, ")", ow),
    ze(t, "<", lw),
    ze(t, ">", cw),
    ze(t, "", uw),
    ze(t, "", dw),
    ze(t, "", hw),
    ze(t, "", fw),
    ze(t, "", mw),
    ze(t, "", pw),
    ze(t, "", gw),
    ze(t, "", vw),
    ze(t, "&", yw),
    ze(t, "*", xw),
    ze(t, "@", bc),
    ze(t, "`", Ew),
    ze(t, "^", Sw),
    ze(t, ":", Tc),
    ze(t, ",", WD),
    ze(t, "$", Tw),
    ze(t, ".", co),
    ze(t, "=", _w),
    ze(t, "!", KD),
    ze(t, "-", Ki),
    ze(t, "%", og),
    ze(t, "|", Aw),
    ze(t, "+", Rw),
    ze(t, "#", kw),
    ze(t, "?", lg),
    ze(t, '"', YD),
    ze(t, "/", uo),
    ze(t, ";", XD),
    ze(t, "~", cg),
    ze(t, "_", Cw),
    ze(t, "\\", ww),
    ze(t, "", Z9);
  const s = ds(t, tl, GD, { [uC]: !0 });
  ds(s, tl, s);
  const r = ds(s, el, X9, { [rg]: !0 }),
    i = ds(s, hp, Q9, { [Ip]: !0 }),
    a = ds(t, el, ol, { [dC]: !0 });
  ds(a, tl, r), ds(a, el, a), ds(r, tl, r), ds(r, el, r);
  const o = ds(t, hp, mC, { [hC]: !0 });
  ds(o, el), ds(o, tl, i), ds(o, hp, o), ds(i, tl, i), ds(i, el), ds(i, hp, i);
  const l = ze(t, aA, qD, { [sA]: !0 }),
    c = ze(t, A4, vC, { [sA]: !0 }),
    h = ds(t, iA, vC, { [sA]: !0 });
  ze(t, oA, h),
    ze(c, aA, l),
    ze(c, oA, h),
    ds(c, iA, h),
    ze(h, A4),
    ze(h, aA),
    ds(h, iA, h),
    ze(h, oA, h);
  const m = ds(t, rA, J9, { [Y9]: !0 });
  ze(m, "#"), ds(m, rA, m), ze(m, PSe, m);
  const p = ze(m, MSe);
  ze(p, "#"), ds(p, rA, m);
  const g = [
      [el, a],
      [tl, r],
    ],
    y = [
      [el, null],
      [hp, o],
      [tl, i],
    ];
  for (let b = 0; b < Oy.length; b++) ic(t, Oy[b], pC, ol, g);
  for (let b = 0; b < jy.length; b++) ic(t, jy[b], gC, mC, y);
  Fu(pC, { tld: !0, ascii: !0 }, e),
    Fu(gC, { utld: !0, alpha: !0 }, e),
    ic(t, "file", Ib, ol, g),
    ic(t, "mailto", Ib, ol, g),
    ic(t, "http", _h, ol, g),
    ic(t, "https", _h, ol, g),
    ic(t, "ftp", _h, ol, g),
    ic(t, "ftps", _h, ol, g),
    Fu(Ib, { scheme: !0, ascii: !0 }, e),
    Fu(_h, { slashscheme: !0, ascii: !0 }, e),
    (n = n.sort((b, w) => (b[0] > w[0] ? 1 : -1)));
  for (let b = 0; b < n.length; b++) {
    const w = n[b][0],
      A = n[b][1] ? { [CSe]: !0 } : { [ISe]: !0 };
    w.indexOf("-") >= 0
      ? (A[fC] = !0)
      : el.test(w)
      ? tl.test(w)
        ? (A[rg] = !0)
        : (A[dC] = !0)
      : (A[uC] = !0),
      _4(t, w, w, A);
  }
  return (
    _4(t, "localhost", tv, { ascii: !0 }),
    (t.jd = new Ei(Iw)),
    { start: t, tokens: Object.assign({ groups: e }, eW) }
  );
}
function tW(n, e) {
  const t = OSe(e.replace(/[A-Z]/g, (o) => o.toLowerCase())),
    s = t.length,
    r = [];
  let i = 0,
    a = 0;
  for (; a < s; ) {
    let o = n,
      l = null,
      c = 0,
      h = null,
      m = -1,
      p = -1;
    for (; a < s && (l = o.go(t[a])); )
      (o = l),
        o.accepts()
          ? ((m = 0), (p = 0), (h = o))
          : m >= 0 && ((m += t[a].length), p++),
        (c += t[a].length),
        (i += t[a].length),
        a++;
    (i -= m),
      (a -= p),
      (c -= m),
      r.push({ t: h.t, v: e.slice(i - c, i), s: i - c, e: i });
  }
  return r;
}
function OSe(n) {
  const e = [],
    t = n.length;
  let s = 0;
  for (; s < t; ) {
    let r = n.charCodeAt(s),
      i,
      a =
        r < 55296 ||
        r > 56319 ||
        s + 1 === t ||
        (i = n.charCodeAt(s + 1)) < 56320 ||
        i > 57343
          ? n[s]
          : n.slice(s, s + 2);
    e.push(a), (s += a.length);
  }
  return e;
}
function ic(n, e, t, s, r) {
  let i;
  const a = e.length;
  for (let o = 0; o < a - 1; o++) {
    const l = e[o];
    n.j[l] ? (i = n.j[l]) : ((i = new Ei(s)), (i.jr = r.slice()), (n.j[l] = i)),
      (n = i);
  }
  return (i = new Ei(t)), (i.jr = r.slice()), (n.j[e[a - 1]] = i), i;
}
function R4(n) {
  const e = [],
    t = [];
  let s = 0,
    r = "0123456789";
  for (; s < n.length; ) {
    let i = 0;
    for (; r.indexOf(n[s + i]) >= 0; ) i++;
    if (i > 0) {
      e.push(t.join(""));
      for (let a = parseInt(n.substring(s, s + i), 10); a > 0; a--) t.pop();
      s += i;
    } else t.push(n[s]), s++;
  }
  return e;
}
const nv = {
  defaultProtocol: "http",
  events: null,
  format: k4,
  formatHref: k4,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null,
};
function QD(n, e = null) {
  let t = Object.assign({}, nv);
  n && (t = Object.assign(t, n instanceof QD ? n.o : n));
  const s = t.ignoreTags,
    r = [];
  for (let i = 0; i < s.length; i++) r.push(s[i].toUpperCase());
  (this.o = t), e && (this.defaultRender = e), (this.ignoreTags = r);
}
QD.prototype = {
  o: nv,
  ignoreTags: [],
  defaultRender(n) {
    return n;
  },
  check(n) {
    return this.get("validate", n.toString(), n);
  },
  get(n, e, t) {
    const s = e != null;
    let r = this.o[n];
    return (
      r &&
      (typeof r == "object"
        ? ((r = t.t in r ? r[t.t] : nv[n]),
          typeof r == "function" && s && (r = r(e, t)))
        : typeof r == "function" && s && (r = r(e, t.t, t)),
      r)
    );
  },
  getObj(n, e, t) {
    let s = this.o[n];
    return typeof s == "function" && e != null && (s = s(e, t.t, t)), s;
  },
  render(n) {
    const e = n.render(this);
    return (this.get("render", null, n) || this.defaultRender)(e, n.t, n);
  },
};
function k4(n) {
  return n;
}
function nW(n, e) {
  (this.t = "token"), (this.v = n), (this.tk = e);
}
nW.prototype = {
  isLink: !1,
  toString() {
    return this.v;
  },
  toHref(n) {
    return this.toString();
  },
  toFormattedString(n) {
    const e = this.toString(),
      t = n.get("truncate", e, this),
      s = n.get("format", e, this);
    return t && s.length > t ? s.substring(0, t) + "" : s;
  },
  toFormattedHref(n) {
    return n.get("formatHref", this.toHref(n.get("defaultProtocol")), this);
  },
  startIndex() {
    return this.tk[0].s;
  },
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject(n = nv.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(n),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  toFormattedObject(n) {
    return {
      type: this.t,
      value: this.toFormattedString(n),
      isLink: this.isLink,
      href: this.toFormattedHref(n),
      start: this.startIndex(),
      end: this.endIndex(),
    };
  },
  validate(n) {
    return n.get("validate", this.toString(), this);
  },
  render(n) {
    const e = this,
      t = this.toHref(n.get("defaultProtocol")),
      s = n.get("formatHref", t, this),
      r = n.get("tagName", t, e),
      i = this.toFormattedString(n),
      a = {},
      o = n.get("className", t, e),
      l = n.get("target", t, e),
      c = n.get("rel", t, e),
      h = n.getObj("attributes", t, e),
      m = n.getObj("events", t, e);
    return (
      (a.href = s),
      o && (a.class = o),
      l && (a.target = l),
      c && (a.rel = c),
      h && Object.assign(a, h),
      { tagName: r, attributes: a, content: i, eventListeners: m }
    );
  },
};
function JE(n, e) {
  class t extends nW {
    constructor(r, i) {
      super(r, i), (this.t = n);
    }
  }
  for (const s in e) t.prototype[s] = e[s];
  return (t.t = n), t;
}
const C4 = JE("email", {
    isLink: !0,
    toHref() {
      return "mailto:" + this.toString();
    },
  }),
  I4 = JE("text"),
  jSe = JE("nl"),
  Fy = JE("url", {
    isLink: !0,
    toHref(n = nv.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${n}://${this.v}`;
    },
    hasProtocol() {
      const n = this.tk;
      return n.length >= 2 && n[0].t !== tv && n[1].t === Tc;
    },
  }),
  zi = (n) => new Ei(n);
function FSe({ groups: n }) {
  const e = n.domain.concat([
      yw,
      xw,
      bc,
      ww,
      Ew,
      Sw,
      Tw,
      _w,
      Ki,
      GD,
      og,
      Aw,
      Rw,
      kw,
      uo,
      Iw,
      cg,
      Cw,
    ]),
    t = [
      bw,
      Tc,
      WD,
      co,
      KD,
      og,
      lg,
      YD,
      XD,
      lw,
      cw,
      ig,
      ag,
      iw,
      rw,
      aw,
      ow,
      uw,
      dw,
      hw,
      fw,
      mw,
      pw,
      gw,
      vw,
    ],
    s = [
      yw,
      bw,
      xw,
      ww,
      Ew,
      Sw,
      Tw,
      _w,
      Ki,
      ig,
      ag,
      og,
      Aw,
      Rw,
      kw,
      lg,
      uo,
      Iw,
      cg,
      Cw,
    ],
    r = zi(),
    i = ze(r, cg);
  Wt(i, s, i), Wt(i, n.domain, i);
  const a = zi(),
    o = zi(),
    l = zi();
  Wt(r, n.domain, a),
    Wt(r, n.scheme, o),
    Wt(r, n.slashscheme, l),
    Wt(a, s, i),
    Wt(a, n.domain, a);
  const c = ze(a, bc);
  ze(i, bc, c), ze(o, bc, c), ze(l, bc, c);
  const h = ze(i, co);
  Wt(h, s, i), Wt(h, n.domain, i);
  const m = zi();
  Wt(c, n.domain, m), Wt(m, n.domain, m);
  const p = ze(m, co);
  Wt(p, n.domain, m);
  const g = zi(C4);
  Wt(p, n.tld, g), Wt(p, n.utld, g), ze(c, tv, g);
  const y = ze(m, Ki);
  ze(y, Ki, y),
    Wt(y, n.domain, m),
    Wt(g, n.domain, m),
    ze(g, co, p),
    ze(g, Ki, y);
  const b = ze(g, Tc);
  Wt(b, n.numeric, C4);
  const w = ze(a, Ki),
    S = ze(a, co);
  ze(w, Ki, w), Wt(w, n.domain, a), Wt(S, s, i), Wt(S, n.domain, a);
  const A = zi(Fy);
  Wt(S, n.tld, A),
    Wt(S, n.utld, A),
    Wt(A, n.domain, a),
    Wt(A, s, i),
    ze(A, co, S),
    ze(A, Ki, w),
    ze(A, bc, c);
  const _ = ze(A, Tc),
    R = zi(Fy);
  Wt(_, n.numeric, R);
  const C = zi(Fy),
    D = zi();
  Wt(C, e, C),
    Wt(C, t, D),
    Wt(D, e, C),
    Wt(D, t, D),
    ze(A, uo, C),
    ze(R, uo, C);
  const L = ze(o, Tc),
    P = ze(l, Tc),
    V = ze(P, uo),
    N = ze(V, uo);
  Wt(o, n.domain, a),
    ze(o, co, S),
    ze(o, Ki, w),
    Wt(l, n.domain, a),
    ze(l, co, S),
    ze(l, Ki, w),
    Wt(L, n.domain, C),
    ze(L, uo, C),
    ze(L, lg, C),
    Wt(N, n.domain, C),
    Wt(N, e, C),
    ze(N, uo, C);
  const W = [
    [ig, ag],
    [rw, iw],
    [aw, ow],
    [lw, cw],
    [uw, dw],
    [hw, fw],
    [mw, pw],
    [gw, vw],
  ];
  for (let H = 0; H < W.length; H++) {
    const [z, B] = W[H],
      q = ze(C, z);
    ze(D, z, q), ze(q, B, C);
    const O = zi(Fy);
    Wt(q, e, O);
    const U = zi();
    Wt(q, t),
      Wt(O, e, O),
      Wt(O, t, U),
      Wt(U, e, O),
      Wt(U, t, U),
      ze(O, B, C),
      ze(U, B, C);
  }
  return ze(r, tv, A), ze(r, qD, jSe), { start: r, tokens: eW };
}
function USe(n, e, t) {
  let s = t.length,
    r = 0,
    i = [],
    a = [];
  for (; r < s; ) {
    let o = n,
      l = null,
      c = null,
      h = 0,
      m = null,
      p = -1;
    for (; r < s && !(l = o.go(t[r].t)); ) a.push(t[r++]);
    for (; r < s && (c = l || o.go(t[r].t)); )
      (l = null),
        (o = c),
        o.accepts() ? ((p = 0), (m = o)) : p >= 0 && p++,
        r++,
        h++;
    if (p < 0) (r -= h), r < s && (a.push(t[r]), r++);
    else {
      a.length > 0 && (i.push(lA(I4, e, a)), (a = [])), (r -= p), (h -= p);
      const g = m.t,
        y = t.slice(r - h, r);
      i.push(lA(g, e, y));
    }
  }
  return a.length > 0 && i.push(lA(I4, e, a)), i;
}
function lA(n, e, t) {
  const s = t[0].s,
    r = t[t.length - 1].e,
    i = e.slice(s, r);
  return new n(i, t);
}
const Ar = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1,
};
function $Se() {
  Ar.scanner = NSe(Ar.customSchemes);
  for (let n = 0; n < Ar.tokenQueue.length; n++)
    Ar.tokenQueue[n][1]({ scanner: Ar.scanner });
  Ar.parser = FSe(Ar.scanner.tokens);
  for (let n = 0; n < Ar.pluginQueue.length; n++)
    Ar.pluginQueue[n][1]({ scanner: Ar.scanner, parser: Ar.parser });
  return (Ar.initialized = !0), Ar;
}
function sW(n) {
  return (
    Ar.initialized || $Se(), USe(Ar.parser.start, n, tW(Ar.scanner.start, n))
  );
}
sW.scan = tW;
function BSe(n, e, t) {
  const s = sW(n),
    r = [];
  for (let i = 0; i < s.length; i++) {
    const a = s[i];
    if (a.t === "nl" && e.get("nl2br")) {
      const o = `__linkify-el-${t.elementId++}`;
      r.push(E.createElement("br", { key: o }));
    } else if (!a.isLink || !e.check(a)) r.push(a.toString());
    else {
      let o = e.render(a);
      if (!("key" in o.props)) {
        const l = `__linkify-el-${t.elementId++}`,
          c = Object.assign({ key: l }, o.props);
        o = E.cloneElement(o, c);
      }
      r.push(o);
    }
  }
  return r;
}
function rW(n, e, t) {
  if (E.Children.count(n.props.children) === 0) return n;
  const s = [];
  E.Children.forEach(n.props.children, (a) => {
    typeof a == "string"
      ? s.push.apply(s, BSe(a, e, t))
      : E.isValidElement(a)
      ? typeof a.type == "string" &&
        e.ignoreTags.indexOf(a.type.toUpperCase()) >= 0
        ? s.push(a)
        : s.push(rW(a, e, t))
      : s.push(a);
  });
  const r = `__linkify-el-${t.elementId++}`,
    i = Object.assign({ key: r }, n.props);
  return E.cloneElement(n, i, s);
}
const iW = (n) => {
    let e = 0;
    const t = ({ tagName: l, attributes: c, content: h }) => (
        (c.key = `__linkify-lnk-${e++}`),
        c.class && ((c.className = c.class), delete c.class),
        E.createElement(l, c, h)
      ),
      s = { key: "__linkify-wrapper" };
    for (const l in n)
      l !== "options" &&
        l !== "as" &&
        l !== "tagName" &&
        l !== "children" &&
        (s[l] = n[l]);
    const r = new QD(n.options, t),
      i = n.as || n.tagName || E.Fragment || "span",
      a = n.children,
      o = E.createElement(i, s, a);
    return rW(o, r, { elementId: 0 });
  },
  aW = ({
    element: n,
    hasEditingPermissions: e,
    isSelected: t,
    containerRef: s,
    isReplyElement: r = !1,
  }) => {
    const i = hn((S) => S.user),
      a = Ce((S) => S.isElementInTextEditMode),
      o = Ce((S) => S.exitTextEditMode),
      l = Ce((S) => S.updateElement),
      c = Ce((S) => S.boardState.elements[n.id]);
    i?.id, n.createdBy;
    const h = a(n.id),
      m = E.useRef(null),
      p = E.useRef(!1),
      g = c?.content || "";
    E.useEffect(() => {
      if (h && m.current) {
        const S = m.current;
        (S.textContent = g),
          setTimeout(() => {
            S.focus();
            const A = window.getSelection();
            if (!A) return;
            const _ = document.createRange();
            _.selectNodeContents(S),
              _.collapse(!1),
              A.removeAllRanges(),
              A.addRange(_);
          }, 0);
      }
    }, [h, g, n.id]);
    const y = E.useCallback(() => {
      if (h && m.current && !p.current) {
        p.current = !0;
        try {
          const S = m.current.textContent || m.current.innerText || "";
          l(n.id, { content: S }), o(), m.current.blur();
          const A = window.getSelection();
          A && A.removeAllRanges();
        } finally {
          p.current = !1;
        }
      }
    }, [h, l, n.id, o]);
    E.useEffect(() => {
      const S = (A) => {
        h && !p.current && s.current && !s.current.contains(A.target) && y();
      };
      return (
        h && document.addEventListener("mousedown", S),
        () => {
          document.removeEventListener("mousedown", S);
        }
      );
    }, [h, y, s, n.id]),
      E.useEffect(() => {
        !t && h && !p.current && y();
      }, [t, h, y]);
    const b = (S) => {
        let A = S.target;
        for (; A && A !== m.current; ) {
          if (A.tagName === "A") return;
          A = A.parentElement;
        }
        h && m.current?.contains(S.target) && S.stopPropagation();
      },
      w = {
        target: "_blank",
        rel: "noopener noreferrer",
        className: "text-blue-400 hover:underline",
      };
    return u.jsx("div", {
      className: Le(
        "relative  text-left w-full mb-2 mt-1",
        h && "bg-card-background/50 p-2 !rounded-2xl border-b border-white/10"
      ),
      onClick: b,
      children: u.jsxs("div", {
        className: "w-full",
        children: [
          h &&
            u.jsx("div", {
              ref: m,
              contentEditable: !0,
              suppressContentEditableWarning: !0,
              className: Le(
                "text-white w-full focus:outline-none whitespace-pre-wrap overflow-hidden max-h-fit text-editing"
              ),
              "data-placeholder": "Add text..",
              style: {
                fontSize: "12px",
                outline: "none",
                whiteSpace: "pre-wrap",
                wordBreak: "break-word",
                border: "none",
                margin: 0,
                padding: 0,
                minHeight: "1.5em",
                userSelect: "text",
                WebkitUserSelect: "text",
                overflowY: "auto",
              },
              onBlur: () => {
                p.current || setTimeout(y, 0);
              },
            }),
          !h &&
            u.jsx("div", {
              className: Le(
                "text-white w-full whitespace-pre-wrap overflow-hidden max-h-fit text-display"
              ),
              style: {
                fontSize: "12px",
                whiteSpace: "pre-wrap",
                wordBreak: "break-word",
                margin: 0,
                padding: 0,
                minHeight: "1.5em",
                overflowY: "auto",
                userSelect: "text",
                WebkitUserSelect: "text",
                cursor: "default",
              },
              children: u.jsx("span", {
                style: { cursor: "text" },
                children: u.jsx(iW, { options: w, children: g }),
              }),
            }),
          h &&
            u.jsx("div", {
              className: "flex justify-end mt-2",
              children: u.jsx("button", {
                className:
                  "flex button-primary items-center gap-1 justify-center h-7 w-7 text-xs rounded-full transition-colors",
                onClick: (S) => {
                  S.stopPropagation(), y();
                },
                onMouseDown: (S) => S.stopPropagation(),
                children: u.jsx(zs, { className: "w-5 h-5" }),
              }),
            }),
        ],
      }),
    });
  },
  HSe = ({
    element: n,
    hasEditingPermissions: e,
    isSelected: t,
    containerRef: s,
    isReplyElement: r = !1,
  }) => {
    const i = hn((U) => U.user),
      a = Ce((U) => U.isElementInDescriptionEditMode),
      o = Ce((U) => U.exitDescriptionEditMode),
      l = Ce((U) => U.updateElement),
      c = Ce((U) => U.boardState.elements[n.id]),
      h = lf((U) => U.getJobState(n.id)),
      m = lf((U) => U.retryProcessing),
      p = lf((U) => U.hasRetainedBlob(n.id)),
      g = h && (h.status === "uploading" || h.status === "processing"),
      y = h?.status === "failed",
      b = h?.status === "empty";
    i?.id, n.createdBy;
    const w = a(n.id),
      S = E.useRef(null),
      A = E.useRef(!1);
    let _ = c?.aiSummary || "",
      R = c?.hasAIInsights === !0,
      C = !1,
      D = !1;
    y && p
      ? ((_ = "Something went wrong in getting insights"), (R = !0), (D = !0))
      : (b || _ === "No insights detected") &&
        ((_ = "No insights detected"), (R = !0), (C = !0));
    const [L, P] = E.useState(!1),
      V = E.useRef(!1),
      N = E.useRef("");
    E.useEffect(() => {
      g
        ? (V.current = !0)
        : V.current && _ && _ !== N.current
        ? (P(!0),
          (N.current = _),
          (V.current = !1),
          setTimeout(() => {
            P(!1);
          }, 3e3))
        : _ && !N.current && (N.current = _);
    }, [g, _]),
      E.useEffect(() => {
        if (w && S.current) {
          const U = S.current;
          (U.textContent = _),
            setTimeout(() => {
              U.focus();
              const j = window.getSelection();
              if (!j) return;
              const Q = document.createRange();
              Q.selectNodeContents(U),
                Q.collapse(!1),
                j.removeAllRanges(),
                j.addRange(Q);
            }, 0);
        }
      }, [w, _, n.id]);
    const W = E.useCallback(() => {
      if (w && S.current && !A.current) {
        A.current = !0;
        try {
          const U = S.current.textContent || S.current.innerText || "",
            j = c?.aiSummary || "",
            Q = U !== j;
          l(n.id, { aiSummary: U, hasAIInsights: Q ? !1 : c?.hasAIInsights }),
            o(),
            S.current.blur();
          const M = window.getSelection();
          M && M.removeAllRanges();
        } finally {
          A.current = !1;
        }
      }
    }, [w, l, n.id, o, c?.aiSummary, c?.hasAIInsights]);
    E.useEffect(() => {
      const U = (j) => {
        w &&
          (j.key === "Enter" && !j.shiftKey && (j.preventDefault(), W()),
          j.key === "Escape" && (j.preventDefault(), o()));
      };
      return (
        w && document.addEventListener("keydown", U),
        () => {
          document.removeEventListener("keydown", U);
        }
      );
    }, [w, W, o]),
      E.useEffect(() => {
        if (!w) return;
        const U = (Q) => {
            !A.current && s.current && !s.current.contains(Q.target) && W();
          },
          j = setTimeout(() => {
            document.addEventListener("mousedown", U);
          }, 100);
        return () => {
          clearTimeout(j), document.removeEventListener("mousedown", U);
        };
      }, [w, W, s]);
    const H = (U) => {
        let j = U.target;
        for (; j && j !== S.current; ) {
          if (j.tagName === "A") return;
          j = j.parentElement;
        }
        w && S.current?.contains(U.target) && U.stopPropagation();
      },
      z = {
        target: "_blank",
        rel: "noopener noreferrer",
        className: "text-blue-400 hover:underline",
      },
      B = _ ? _.split(" ") : [],
      q = g || (!_ && !w && c?.recordingType);
    if (q) {
      const j = (
        h?.retryCount && h.retryCount > 0
          ? `Compiling insights.. (Attempt ${h.retryCount + 1}/${
              (h.maxRetries || 3) + 1
            })`
          : "Compiling insights.."
      ).split(" ");
      return u.jsx("div", {
        className: "relative text-left w-full",
        children: u.jsx("div", {
          className: "text-[12px] text-white relative",
          children: u.jsx("span", {
            children: j.map((Q, M) => {
              const I = Q.split("");
              return u.jsx(
                la.span,
                {
                  className: "inline-block mr-[0.25em]",
                  initial: { opacity: 0, y: 10 },
                  animate: { opacity: 1, y: 0 },
                  transition: {
                    delay: M * 0.1,
                    duration: 0.3,
                    ease: "easeOut",
                  },
                  children: I.map((F, Y) => {
                    const J = j.slice(0, M).join("").length + Y;
                    return u.jsx(
                      la.span,
                      {
                        className: "inline-block",
                        animate: { opacity: [0.4, 1, 0.4] },
                        transition: {
                          duration: 2,
                          repeat: 1 / 0,
                          ease: "easeInOut",
                          delay: J * 0.1,
                        },
                        children: F,
                      },
                      `char-${M}-${Y}`
                    );
                  }),
                },
                `compiling-word-${M}`
              );
            }),
          }),
        }),
      });
    }
    const O = !_ && !w && !q;
    return u.jsxs("div", {
      className: Le(
        "relative py-1 text-left w-full",
        w &&
          "bg-card-background/50 rounded-lg border-b border-white/10 px-3 py-2"
      ),
      onClick: H,
      children: [
        !w &&
          R &&
          u.jsx(Br, {
            delayDuration: 300,
            children: u.jsxs(Xn, {
              children: [
                u.jsx(Qn, {
                  asChild: !0,
                  children: u.jsx("div", {
                    className: "flex items-center gap-1 mb-1 w-fit",
                    children: u.jsx("span", {
                      className: Le(
                        "text-[10px] font-medium",
                        D ? "text-text-secondary" : "text-white/60"
                      ),
                      children: "Insights",
                    }),
                  }),
                }),
                u.jsx(Pn, {
                  children: u.jsx("p", {
                    children:
                      "Insights are auto-generated automatically by Flask",
                  }),
                }),
              ],
            }),
          }),
        u.jsxs("div", {
          children: [
            w &&
              u.jsx("div", {
                ref: S,
                contentEditable: !0,
                suppressContentEditableWarning: !0,
                className: Le(
                  "text-white w-full py-1 focus:outline-none whitespace-pre-wrap max-h-fit text-editing"
                ),
                "data-placeholder": "Add a note..",
                style: {
                  fontSize: "12px",
                  outline: "none",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-word",
                  border: "none",
                  margin: 0,
                  padding: 0,
                  minHeight: "1.5em",
                  userSelect: "text",
                  WebkitUserSelect: "text",
                  overflowY: "auto",
                },
              }),
            !w &&
              u.jsx("div", {
                className: Le(
                  "w-full py-1 whitespace-pre-wrap max-h-fit text-display",
                  C || D ? "text-text-secondary" : "text-white",
                  O && "opacity-0"
                ),
                style: {
                  fontSize: "12px",
                  margin: 0,
                  padding: 0,
                  minHeight: "1.5em",
                  overflowY: "auto",
                  userSelect: "text",
                  WebkitUserSelect: "text",
                  cursor: "default",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-word",
                },
                children: O
                  ? u.jsx("span", { children: "" })
                  : L
                  ? u.jsx(u.Fragment, {
                      children: B.map((U, j) =>
                        u.jsx(
                          la.span,
                          {
                            className: "inline-block mr-[0.25em]",
                            initial: { opacity: 0, y: 10 },
                            animate: { opacity: 1, y: 0 },
                            transition: {
                              delay: j * 0.03,
                              duration: 0.3,
                              ease: "easeOut",
                            },
                            children: U,
                          },
                          `${n.id}-word-${j}`
                        )
                      ),
                    })
                  : u.jsxs(u.Fragment, {
                      children: [
                        u.jsx(iW, { options: z, children: _ }),
                        D &&
                          p &&
                          u.jsx("button", {
                            className:
                              "ml-2 text-primary hover:underline text-[12px]",
                            onClick: (U) => {
                              U.stopPropagation(), m(n.id);
                            },
                            children: "Try again",
                          }),
                      ],
                    }),
              }),
            w &&
              u.jsx("div", {
                className: "flex justify-end mt-2",
                children: u.jsx("button", {
                  className:
                    "flex button-primary items-center gap-1 justify-center h-7 w-7 text-xs rounded-full transition-colors",
                  onClick: (U) => {
                    U.stopPropagation(), W();
                  },
                  onMouseDown: (U) => U.stopPropagation(),
                  children: u.jsx(zs, { className: "w-5 h-5" }),
                }),
              }),
          ],
        }),
      ],
    });
  },
  VSe = ({ blobUrl: n, durationSeconds: e, className: t }) => {
    const s = E.useRef(null),
      [r, i] = E.useState(!1),
      [a, o] = E.useState(!1);
    return (
      E.useEffect(() => {
        const l = s.current;
        if (!l || !n) return;
        const c = () => {
            const p = e ? e / 2 : l.duration / 2;
            l.currentTime = p;
          },
          h = () => {
            i(!0);
          },
          m = () => {
            console.warn("[RecordingPreview] Failed to load video preview"),
              o(!0);
          };
        return (
          l.addEventListener("loadedmetadata", c),
          l.addEventListener("seeked", h),
          l.addEventListener("error", m),
          (l.src = n),
          () => {
            l.removeEventListener("loadedmetadata", c),
              l.removeEventListener("seeked", h),
              l.removeEventListener("error", m);
          }
        );
      }, [n, e]),
      a
        ? null
        : u.jsx("video", {
            ref: s,
            className: Le(
              "w-full h-full object-cover transition-opacity duration-300",
              r ? "opacity-100" : "opacity-0",
              t
            ),
            muted: !0,
            playsInline: !0,
            preload: "metadata",
          })
    );
  },
  oW = ({
    element: n,
    hasEditingPermissions: e,
    isSelected: t,
    containerRef: s,
    isHovered: r = !1,
    isReplyElement: i = !1,
  }) => {
    const [a, o] = E.useState(!1),
      [l, c] = E.useState(!1),
      h = Ce((U) => U.boardState.elements[n.id]),
      m = {
        ...n,
        aiInsights: h?.aiInsights ?? n.aiInsights,
        hasAIInsights: h?.hasAIInsights ?? n.hasAIInsights,
        aiSummary: h?.aiSummary ?? n.aiSummary,
      },
      p = on((U) => U.getElementState(n.id)),
      [g, y] = E.useState(0),
      [b, w] = E.useState(0),
      A = Be((U) => U.activeRecordingId) === n.id,
      _ = Be((U) => (U.activeRecordingId === n.id ? U.isRecordingLoading : !1)),
      R = Be((U) => U.setActiveRecording),
      C = Be((U) => U.setRecordingFullscreen),
      [D, L] = E.useState(!1),
      P = E.useCallback(() => {
        if (A) Be.getState().toggleRecordingPlayback();
        else {
          const U = n.videoUrl || p?.videoUrl;
          n.id,
            n.videoUrl,
            p?.videoUrl,
            n.recordingType,
            U && (R(n.id, U), n.recordingType === "screen" && C(!0));
        }
      }, [A, n.id, n.videoUrl, n.recordingType, p?.videoUrl, R, C]),
      V = (() => {
        if (n.videoUrl || p?.videoUrl) return "completed";
        if (p) {
          if (p.state === "error") return "error";
          if (p.state === "completed" && p.videoUrl) return "completed";
        }
        return "loading";
      })(),
      N = p?.uploadProgress || 0,
      H =
        p?.state === "preparing"
          ? g
          : p?.state === "uploading" && N > 0
          ? 10 + N * 0.7
          : p?.state === "processing"
          ? 80 + b * 0.2
          : g,
      z = () =>
        p?.state === "processing"
          ? "Processing video..."
          : p?.state === "uploading" && N > 0
          ? `Uploading ${Math.round(N)}%`
          : "Preparing...";
    E.useEffect(() => {
      if (p?.state === "preparing" && p.preparingStartTime) {
        const U = p.preparingStartTime,
          j = 5e3,
          Q = setInterval(() => {
            const M = Date.now() - U,
              I = Math.min((M / j) * 10, 10);
            y(I), I >= 10 && clearInterval(Q);
          }, 50);
        return () => clearInterval(Q);
      }
    }, [p?.state, p?.preparingStartTime]),
      E.useEffect(() => {
        if (p?.state === "processing" && p.muxProcessingStartTime) {
          const U = p.muxProcessingStartTime,
            j =
              p?.recordingDurationSeconds && p.recordingDurationSeconds >= 60
                ? 2e4
                : 1e4,
            Q = setInterval(() => {
              const M = Date.now() - U,
                I = Math.min((M / j) * 100, 100);
              w(I), I >= 100 && clearInterval(Q);
            }, 50);
          return () => clearInterval(Q);
        } else w(0);
      }, [p?.state, p?.muxProcessingStartTime, p?.recordingDurationSeconds]),
      de.useEffect(() => {
        if (p?.state === "uploading" && N === 0 && !a) {
          const U = setTimeout(() => o(!0), 800);
          return () => clearTimeout(U);
        }
      }, [p?.state, N, a]);
    const B = n.videoUrl || p?.videoUrl,
      q = n.thumbnailUrl || p?.thumbnailUrl;
    de.useEffect(() => {
      m.id,
        m.aiInsights,
        m.aiInsights,
        m.aiInsights?.transcript,
        m.aiInsights?.transcript?.length,
        m.hasAIInsights;
    }, [m.id, m.aiInsights, m.hasAIInsights]);
    const O = (U) => {
      if (!U || !isFinite(U)) return "0:00";
      const j = Math.floor(U / 60),
        Q = Math.floor(U % 60);
      return `${j}:${Q.toString().padStart(2, "0")}`;
    };
    return u.jsxs("div", {
      className: "w-full flex flex-col gap-2 pb-2 ",
      children: [
        u.jsx(HSe, {
          element: n,
          hasEditingPermissions: e,
          isSelected: t,
          containerRef: s,
          isReplyElement: i,
        }),
        m.aiInsights?.transcript &&
          u.jsxs("div", {
            className: "w-full flex flex-col",
            children: [
              u.jsxs("button", {
                onClick: () => c(!l),
                className: "flex items-center gap-1 -mt-1 w-fit group",
                children: [
                  u.jsx("span", {
                    className:
                      "text-[10px] font-medium text-text-secondary transition-colors",
                    children: "Transcript",
                  }),
                  u.jsx(cd, {
                    className: Le(
                      "w-3 h-3 text-text-secondary transition-all duration-200",
                      l && "rotate-180"
                    ),
                  }),
                ],
              }),
              u.jsx(Qg, {
                children:
                  l &&
                  u.jsx(la.div, {
                    initial: { height: 0, opacity: 0 },
                    animate: { height: "auto", opacity: 1 },
                    exit: { height: 0, opacity: 0 },
                    transition: { duration: 0.2, ease: "easeInOut" },
                    className: "overflow-hidden",
                    children: u.jsx("div", {
                      className:
                        "text-xs text-text-secondary leading-relaxed pb-2",
                      children: m.aiInsights.transcript,
                    }),
                  }),
              }),
            ],
          }),
        u.jsx("div", {
          className: "w-full aspect-[16/9] relative",
          children: u.jsxs("div", {
            className:
              "absolute inset-0 h-full w-full overflow-hidden rounded-2xl border-t border-white/30 shadow-md shadow-black/50 flex flex-col",
            children: [
              V === "completed" &&
                B &&
                u.jsxs("div", {
                  className: "flex-1 relative",
                  children: [
                    u.jsxs("div", {
                      className: "absolute inset-0 z-[70]",
                      onMouseEnter: () => L(!0),
                      onMouseLeave: () => L(!1),
                      children: [
                        (!A || _) &&
                          q &&
                          u.jsx("img", {
                            src: q,
                            alt: "Recording thumbnail",
                            className: "w-full h-full object-cover",
                          }),
                        (!A || _) &&
                          !q &&
                          u.jsx("div", {
                            className: "w-full h-full bg-black/10",
                          }),
                        u.jsx("div", {
                          className:
                            "absolute inset-0 flex items-center justify-center pointer-events-none",
                          children: u.jsx(Qg, {
                            children:
                              !A &&
                              D &&
                              u.jsxs(la.div, {
                                initial: { scale: 0, opacity: 0 },
                                animate: { scale: 1, opacity: 1 },
                                exit: { scale: 0, opacity: 0 },
                                transition: {
                                  type: "spring",
                                  stiffness: 400,
                                  damping: 25,
                                },
                                className:
                                  "flex items-center gap-2 bg-black/50 rounded-full backdrop-blur-sm shadow-lg hover:bg-black/60 transition-colors cursor-pointer pointer-events-auto px-1.5 py-1.5 pr-3",
                                onClick: P,
                                children: [
                                  u.jsx("div", {
                                    className:
                                      "flex items-center justify-center h-7 w-7",
                                    children: u.jsx("svg", {
                                      className: "w-6 h-6 text-white ml-0.5",
                                      fill: "currentColor",
                                      viewBox: "0 0 24 24",
                                      children: u.jsx("path", {
                                        d: "M8 5v14l11-7z",
                                      }),
                                    }),
                                  }),
                                  (n.duration || p?.recordingDurationSeconds) &&
                                    u.jsx("div", {
                                      className: "text-white text-xs font-mono",
                                      children: O(
                                        n.duration ||
                                          p?.recordingDurationSeconds ||
                                          0
                                      ),
                                    }),
                                ],
                              }),
                          }),
                        }),
                        A &&
                          _ &&
                          u.jsx("div", {
                            className:
                              "absolute inset-0 flex items-center justify-center z-30 pointer-events-none",
                            children: u.jsx("div", {
                              className:
                                "animate-spin rounded-full h-8 w-8 border-2 border-white border-t-transparent drop-shadow-lg",
                            }),
                          }),
                      ],
                    }),
                    u.jsx("div", {
                      id: `recording-player-${n.id}`,
                      className: Le(
                        "absolute inset-0 z-50 pointer-events-none",
                        !A && "hidden"
                      ),
                    }),
                  ],
                }),
              V === "loading" &&
                u.jsx("div", {
                  className: "absolute inset-0 flex flex-col",
                  children: u.jsxs("div", {
                    className: "flex-1 relative",
                    children: [
                      p?.localBlobUrl &&
                        u.jsx(VSe, {
                          blobUrl: p.localBlobUrl,
                          durationSeconds: p.recordingDurationSeconds,
                          className: "absolute inset-0",
                        }),
                      u.jsx("div", {
                        className: "absolute inset-0 bg-black/20",
                      }),
                      (r || t) &&
                        u.jsx("div", {
                          className:
                            "absolute bottom-1.5 left-1.5 right-1.5 z-[60] pointer-events-none",
                          children: u.jsx("div", {
                            className:
                              "flex items-center justify-center h-[36px] bg-element-background border-t border-white/40 rounded-full shadow-[0_2px_8px_rgba(0,0,0,0.5)] overflow-hidden px-4",
                            children: u.jsx(Br, {
                              children: u.jsxs(Xn, {
                                children: [
                                  u.jsx(Qn, {
                                    asChild: !0,
                                    children: u.jsx("div", {
                                      className:
                                        "h-1 rounded-full overflow-hidden w-full bg-white/20",
                                      children: u.jsx("div", {
                                        className:
                                          "h-full bg-white rounded-full transition-all duration-300 ease-out",
                                        style: { width: `${H}%` },
                                      }),
                                    }),
                                  }),
                                  u.jsx(Pn, {
                                    children: u.jsx("p", {
                                      className: "text-xs",
                                      children: z(),
                                    }),
                                  }),
                                ],
                              }),
                            }),
                          }),
                        }),
                    ],
                  }),
                }),
              V === "error" &&
                u.jsx("div", {
                  className:
                    "absolute inset-0 bg-black/50 flex items-center justify-center",
                  children: u.jsxs("div", {
                    className: "text-white text-center p-6 max-w-sm",
                    children: [
                      u.jsx("p", {
                        className: "text-lg font-medium mb-2",
                        children: "Upload Failed",
                      }),
                      u.jsx("p", {
                        className: "text-sm text-white/80",
                        children: p?.errorMessage || "An error occurred",
                      }),
                    ],
                  }),
                }),
            ],
          }),
        }),
      ],
    });
  },
  zSe = (n) => {
    const e = n.trim().split(" ");
    return e.length > 1
      ? `${e[0][0]}${e[e.length - 1][0]}`.toUpperCase()
      : n.substring(0, 2).toUpperCase();
  },
  L4 = {
    "accent-purple": "#a78bfa",
    "accent-blue": "#60a5fa",
    "accent-teal": "#5eead4",
    "accent-green": "#4ade80",
    "accent-lime": "#bef264",
    "accent-orange": "#fdba74",
    "accent-red": "#f87171",
    "accent-gray": "#a1a1aa",
    "no-tags-color": "#6b7280",
    transparent: "transparent",
    apptag: "#71717D",
  },
  Fr = ({
    image: n,
    text: e,
    children: t,
    type: s,
    appTagType: r,
    color: i = "border",
    className: a,
    showRemove: o = !1,
    onRemove: l,
    isRemovable: c = !0,
    icon: h,
    showNewIndicator: m = !1,
  }) => {
    const p = (S) => {
      const A = L4[S] || L4["accent-gray"];
      return {
        background: `linear-gradient(${A}30, ${A}20), var(--card-background)`,
        border: `0.5px solid ${A}2s0`,
        borderTop: `0.5px solid ${A}50`,
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        color: A,
      };
    };
    let g = e;
    s === "person" && e && e.includes("@") && (g = e.split("@")[0]);
    const y = s === "apptag",
      b = y ? "apptag" : i,
      w = o && l && c;
    return u.jsxs("div", {
      className: Le(
        "inline-flex items-center gap-1.5 px-2 py-1 rounded-full font-normal shadow-sm shadow-black/20 relative",
        (s === "tag" || y) && "element-tag",
        a
      ),
      style: (s === "tag" || y) && b ? p(b) : {},
      children: [
        m &&
          u.jsx("div", {
            className:
              "absolute -top-0.5 -right-0.5 w-2 h-2 bg-red-500 rounded-full border border-card-background",
          }),
        (s === "person" || (y && r === "creator")) &&
          u.jsxs(fL, {
            className: "h-4 w-4 -ml-1",
            children: [
              n &&
                u.jsx(mL, {
                  src: n,
                  alt: g || "",
                  className: "h-full w-full object-cover",
                }),
              u.jsx(pL, {
                className:
                  "text-[8px] font-medium bg-current text-current border-0 -ml-1",
                children: zSe(g || ""),
              }),
            ],
          }),
        h &&
          u.jsx("span", {
            className: "flex items-center opacity-60",
            children: h,
          }),
        u.jsx("span", {
          className: Le(
            "text-xs whitespace-nowrap",
            s === "person" && "text-text-primary",
            y && r === "linkTime" && "font-mono",
            y && "text-zinc-400"
          ),
          children: t || g,
        }),
        w &&
          u.jsx("button", {
            className:
              "flex items-center justify-center hover:opacity-70 transition-opacity",
            onClick: (S) => {
              S.preventDefault(), S.stopPropagation(), l(S);
            },
            onMouseDown: (S) => {
              S.preventDefault(), S.stopPropagation();
            },
            children: u.jsx(Pa, { size: 12 }),
          }),
      ],
    });
  };
var lW = "AlertDialog",
  [GSe, t2e] = Pr(lW, [jV]),
  Il = jV(),
  cW = (n) => {
    const { __scopeAlertDialog: e, ...t } = n,
      s = Il(e);
    return u.jsx(JV, { ...s, ...t, modal: !0 });
  };
cW.displayName = lW;
var qSe = "AlertDialogTrigger",
  WSe = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      r = Il(t);
    return u.jsx(ez, { ...r, ...s, ref: e });
  });
WSe.displayName = qSe;
var KSe = "AlertDialogPortal",
  uW = (n) => {
    const { __scopeAlertDialog: e, ...t } = n,
      s = Il(e);
    return u.jsx(tz, { ...s, ...t });
  };
uW.displayName = KSe;
var YSe = "AlertDialogOverlay",
  dW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      r = Il(t);
    return u.jsx(kL, { ...r, ...s, ref: e });
  });
dW.displayName = YSe;
var uf = "AlertDialogContent",
  [XSe, QSe] = GSe(uf),
  ZSe = FH("AlertDialogContent"),
  hW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, children: s, ...r } = n,
      i = Il(t),
      a = E.useRef(null),
      o = Nt(e, a),
      l = E.useRef(null);
    return u.jsx(Mde, {
      contentName: uf,
      titleName: fW,
      docsSlug: "alert-dialog",
      children: u.jsx(XSe, {
        scope: t,
        cancelRef: l,
        children: u.jsxs(CL, {
          role: "alertdialog",
          ...i,
          ...r,
          ref: o,
          onOpenAutoFocus: qe(r.onOpenAutoFocus, (c) => {
            c.preventDefault(), l.current?.focus({ preventScroll: !0 });
          }),
          onPointerDownOutside: (c) => c.preventDefault(),
          onInteractOutside: (c) => c.preventDefault(),
          children: [
            u.jsx(ZSe, { children: s }),
            u.jsx(eTe, { contentRef: a }),
          ],
        }),
      }),
    });
  });
hW.displayName = uf;
var fW = "AlertDialogTitle",
  mW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      r = Il(t);
    return u.jsx(IL, { ...r, ...s, ref: e });
  });
mW.displayName = fW;
var pW = "AlertDialogDescription",
  gW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      r = Il(t);
    return u.jsx(LL, { ...r, ...s, ref: e });
  });
gW.displayName = pW;
var JSe = "AlertDialogAction",
  vW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      r = Il(t);
    return u.jsx(nz, { ...r, ...s, ref: e });
  });
vW.displayName = JSe;
var yW = "AlertDialogCancel",
  bW = E.forwardRef((n, e) => {
    const { __scopeAlertDialog: t, ...s } = n,
      { cancelRef: r } = QSe(yW, t),
      i = Il(t),
      a = Nt(e, r);
    return u.jsx(nz, { ...i, ...s, ref: a });
  });
bW.displayName = yW;
var eTe = ({ contentRef: n }) => {
    const e = `\`${uf}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${uf}\` by passing a \`${pW}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${uf}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
    return (
      E.useEffect(() => {
        document.getElementById(n.current?.getAttribute("aria-describedby")) ||
          console.warn(e);
      }, [e, n]),
      null
    );
  },
  tTe = cW,
  nTe = uW,
  xW = dW,
  wW = hW,
  EW = vW,
  SW = bW,
  TW = mW,
  _W = gW;
const AW = tTe,
  sTe = nTe,
  RW = E.forwardRef(({ className: n, ...e }, t) =>
    u.jsx(xW, {
      className: Le(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        n
      ),
      ...e,
      ref: t,
    })
  );
RW.displayName = xW.displayName;
const ZD = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsxs(sTe, {
    children: [
      u.jsx(RW, {}),
      u.jsx(wW, {
        ref: t,
        className: Le(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          n
        ),
        ...e,
      }),
    ],
  })
);
ZD.displayName = wW.displayName;
const JD = ({ className: n, ...e }) =>
  u.jsx("div", {
    className: Le("flex flex-col space-y-2 text-center sm:text-left", n),
    ...e,
  });
JD.displayName = "AlertDialogHeader";
const eP = ({ className: n, ...e }) =>
  u.jsx("div", {
    className: Le(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      n
    ),
    ...e,
  });
eP.displayName = "AlertDialogFooter";
const tP = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(TW, { ref: t, className: Le("text-lg font-semibold", n), ...e })
);
tP.displayName = TW.displayName;
const nP = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(_W, { ref: t, className: Le("text-sm text-muted-foreground", n), ...e })
);
nP.displayName = _W.displayName;
const sP = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(EW, { ref: t, className: Le(yL(), n), ...e })
);
sP.displayName = EW.displayName;
const rP = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(SW, {
    ref: t,
    className: Le(yL({ variant: "outline" }), "mt-2 sm:mt-0", n),
    ...e,
  })
);
rP.displayName = SW.displayName;
const kW = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    tagName: s,
    elementCount: r,
  }) =>
    u.jsx(AW, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(ZD, {
        children: [
          u.jsxs(JD, {
            children: [
              u.jsx(tP, { children: "Delete Tag" }),
              u.jsxs(nP, {
                children: [
                  "You're deleting the tag ",
                  s,
                  ". This tag will be removed from ",
                  r,
                  " element",
                  r !== 1 ? "s" : "",
                  ".",
                ],
              }),
            ],
          }),
          u.jsxs(eP, {
            children: [
              u.jsx(rP, { onClick: e, children: "Cancel" }),
              u.jsx(sP, {
                onClick: () => {
                  t(), e();
                },
                className:
                  "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                children: "Delete Tag",
              }),
            ],
          }),
        ],
      }),
    }),
  CW = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    currentName: s,
    isRenaming: r = !1,
  }) => {
    const [i, a] = E.useState(s);
    E.useEffect(() => {
      n && a(s);
    }, [n, s]);
    const o = (c) => {
        c.preventDefault(), i.trim() && i.trim() !== s && t(i.trim());
      },
      l = i.trim().length > 0 && i.trim() !== s;
    return u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[425px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: [u.jsx(Dg, { className: "h-5 w-5" }), "Rename Tag"],
              }),
              u.jsxs(Cl, {
                className: "pt-4",
                children: [
                  "Enter a new name for the tag ",
                  u.jsxs("strong", { children: ['"', s, '"'] }),
                ],
              }),
            ],
          }),
          u.jsxs("form", {
            onSubmit: o,
            children: [
              u.jsx("div", {
                className: "py-4",
                children: u.jsx(ta, {
                  value: i,
                  onChange: (c) => a(c.target.value),
                  placeholder: "Tag name",
                  disabled: r,
                  autoFocus: !0,
                  className: "w-full",
                }),
              }),
              u.jsxs(xr, {
                className: "pt-2",
                children: [
                  u.jsx(et, {
                    type: "button",
                    variant: "outline",
                    onClick: e,
                    disabled: r,
                    children: "Cancel",
                  }),
                  u.jsx(et, {
                    type: "submit",
                    className: "button-primary",
                    disabled: !l || r,
                    children: r
                      ? u.jsxs(u.Fragment, {
                          children: [
                            u.jsx("span", {
                              className: "animate-spin h-4 w-4 mr-2",
                              children: "",
                            }),
                            "Renaming...",
                          ],
                        })
                      : u.jsxs(u.Fragment, {
                          children: [
                            u.jsx(Dg, { className: "h-4 w-4 mr-2" }),
                            "Rename Tag",
                          ],
                        }),
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    });
  },
  rTe = {
    "accent-purple": "#a78bfa",
    "accent-blue": "#60a5fa",
    "accent-teal": "#5eead4",
    "accent-green": "#4ade80",
    "accent-lime": "#bef264",
    "accent-orange": "#fdba74",
    "accent-red": "#f87171",
    "accent-gray": "#a1a1aa",
  },
  iTe = ({
    element: n,
    searchValue: e,
    onSearchChange: t,
    onClose: s,
    onTagCreated: r,
  }) => {
    const i = Ce((X) => X.boardState.elements[n.id]?.tagIds || []),
      a = Ce((X) => X.boardState.tags || {}),
      o = Object.values(a),
      l = Ce((X) => X.addTagToElement),
      c = Ce((X) => X.removeTagFromElement),
      h = Ce((X) => X.createTag),
      m = Ce((X) => X.deleteTag),
      p = Ce((X) => X.renameTag),
      g = Ce((X) => X.changeTagColor),
      y = Ce((X) => X.getElementsWithTag),
      [b, w] = E.useState(0),
      [S, A] = E.useState(!1),
      [_, R] = E.useState(null),
      [C, D] = E.useState({
        isOpen: !1,
        tagId: null,
        tagName: "",
        elementCount: 0,
      }),
      [L, P] = E.useState({ isOpen: !1, tagId: null, tagName: "" }),
      [V, N] = E.useState(!1),
      W = o.filter((X) => X.name.toLowerCase().includes(e.toLowerCase())),
      H =
        e.trim() &&
        !o.some((X) => X.name.toLowerCase() === e.trim().toLowerCase()),
      z = W.length + (H ? 1 : 0),
      B = () => {
        const X = [
            "accent-purple",
            "accent-blue",
            "accent-teal",
            "accent-green",
            "accent-lime",
            "accent-orange",
            "accent-red",
          ],
          Z = new Set(o.map((ce) => ce.color));
        let te = X.find((ce) => !Z.has(ce));
        if (!te) {
          const ce = o.length % X.length;
          te = X[ce];
        }
        return te;
      },
      q = E.useCallback(async () => {
        const X = e.trim();
        if (X && !S) {
          A(!0);
          try {
            const Z = await h(X);
            Z && (await l(n.id, Z), r?.());
          } finally {
            A(!1);
          }
        }
      }, [e, S, h, l, n.id, r]),
      O = (X, Z) => {
        const te = y(X);
        if (te.length === 0) {
          m(X);
          return;
        }
        D({ isOpen: !0, tagId: X, tagName: Z, elementCount: te.length });
      },
      U = () => {
        C.tagId && m(C.tagId);
      },
      j = () => {
        D({ isOpen: !1, tagId: null, tagName: "", elementCount: 0 });
      },
      Q = (X, Z) => {
        P({ isOpen: !0, tagId: X, tagName: Z });
      },
      M = async (X) => {
        if (L.tagId) {
          N(!0);
          try {
            await p(L.tagId, X), P({ isOpen: !1, tagId: null, tagName: "" });
          } catch (Z) {
            console.error("Failed to rename tag:", Z);
          } finally {
            N(!1);
          }
        }
      },
      I = () => {
        V || P({ isOpen: !1, tagId: null, tagName: "" });
      },
      F = async (X, Z) => {
        try {
          await g(X, Z);
        } catch (te) {
          console.error("Failed to change tag color:", te);
        }
      },
      Y = [
        { name: "Purple", value: "accent-purple" },
        { name: "Blue", value: "accent-blue" },
        { name: "Teal", value: "accent-teal" },
        { name: "Green", value: "accent-green" },
        { name: "Lime", value: "accent-lime" },
        { name: "Orange", value: "accent-orange" },
        { name: "Red", value: "accent-red" },
      ],
      J = E.useCallback(
        async (X) => {
          if (X < W.length) {
            const Z = W[X];
            i.includes(Z.id) ? await c(n.id, Z.id) : await l(n.id, Z.id), t("");
          } else H && X === W.length && q();
        },
        [W, i, H, n.id, l, c, q, t]
      );
    return (
      E.useEffect(() => {
        const X = (Z) => {
          L.isOpen ||
            C.isOpen ||
            (z !== 0 &&
              (Z.key === "ArrowDown"
                ? (Z.preventDefault(),
                  Z.stopPropagation(),
                  w((te) => (te + 1) % z))
                : Z.key === "ArrowUp"
                ? (Z.preventDefault(),
                  Z.stopPropagation(),
                  w((te) => (te - 1 + z) % z))
                : Z.key === "Enter" &&
                  (Z.preventDefault(), Z.stopPropagation(), J(b))));
        };
        return (
          window.addEventListener("keydown", X, !0),
          () => window.removeEventListener("keydown", X, !0)
        );
      }, [b, z, J, L.isOpen, C.isOpen]),
      E.useEffect(() => {
        w(0);
      }, [e]),
      u.jsxs("div", {
        className: "py-2",
        children: [
          u.jsx("div", {
            className: "px-3 py-2 text-xs text-text-secondary/60",
            children: "Select a Tag or create one",
          }),
          W.length === 0 && !H
            ? u.jsx("div", {
                className: "px-3 py-2 text-xs text-text-secondary",
                children: e ? "No tags found" : "No tags available",
              })
            : u.jsxs("div", {
                className: "overflow-y-auto",
                children: [
                  W.map((X, Z) => {
                    const te = i.includes(X.id),
                      ce = Z === b,
                      pe = _ === X.id;
                    return u.jsxs(
                      "div",
                      {
                        className: Le(
                          "flex items-center justify-between px-3 py-1.5 cursor-pointer transition-colors rounded-lg mx-2",
                          ce && "bg-white/10",
                          !ce && "hover:bg-white/5"
                        ),
                        onClick: () => J(Z),
                        onMouseEnter: () => {
                          w(Z), R(X.id);
                        },
                        onMouseLeave: () => R(null),
                        children: [
                          u.jsx(Fr, {
                            text: X.name,
                            type: "tag",
                            color: X.color,
                          }),
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              pe
                                ? u.jsxs(Ii, {
                                    modal: !1,
                                    children: [
                                      u.jsx(Li, {
                                        asChild: !0,
                                        onClick: (se) => se.stopPropagation(),
                                        children: u.jsx("button", {
                                          className:
                                            "w-5 h-5 flex items-center justify-center hover:bg-white/10 rounded transition-colors",
                                          children: u.jsx(cL, {
                                            className:
                                              "w-4 h-4 text-text-secondary",
                                          }),
                                        }),
                                      }),
                                      u.jsxs(ui, {
                                        align: "start",
                                        side: "bottom",
                                        sideOffset: 4,
                                        className: "min-w-[140px]",
                                        children: [
                                          u.jsxs(jn, {
                                            className:
                                              "text-text-primary focus:text-text-primary gap-2",
                                            onClick: (se) => {
                                              se.stopPropagation(),
                                                Q(X.id, X.name);
                                            },
                                            children: [
                                              u.jsx(Dg, {
                                                className: "w-4 h-4",
                                              }),
                                              u.jsx("span", {
                                                children: "Rename tag",
                                              }),
                                            ],
                                          }),
                                          u.jsxs(ZL, {
                                            children: [
                                              u.jsxs(jE, {
                                                className:
                                                  "text-text-primary focus:text-text-primary gap-2",
                                                children: [
                                                  u.jsx(NH, {
                                                    className: "w-4 h-4",
                                                  }),
                                                  u.jsx("span", {
                                                    children: "Color",
                                                  }),
                                                ],
                                              }),
                                              u.jsx(FE, {
                                                className: "min-w-[120px]",
                                                children: Y.map((se) =>
                                                  u.jsxs(
                                                    jn,
                                                    {
                                                      className:
                                                        "text-text-primary focus:text-text-primary gap-2",
                                                      onClick: (be) => {
                                                        be.stopPropagation(),
                                                          F(X.id, se.value);
                                                      },
                                                      children: [
                                                        u.jsx("div", {
                                                          className:
                                                            "w-4 h-4 rounded-full border border-white/20",
                                                          style: {
                                                            backgroundColor:
                                                              rTe[se.value],
                                                          },
                                                        }),
                                                        u.jsx("span", {
                                                          children: se.name,
                                                        }),
                                                        X.color === se.value &&
                                                          u.jsx("span", {
                                                            className:
                                                              "ml-auto text-xs",
                                                            children: "",
                                                          }),
                                                      ],
                                                    },
                                                    se.value
                                                  )
                                                ),
                                              }),
                                            ],
                                          }),
                                          u.jsxs(jn, {
                                            className:
                                              "text-text-primary focus:text-text-primary gap-2",
                                            onClick: (se) => {
                                              se.stopPropagation(),
                                                O(X.id, X.name);
                                            },
                                            children: [
                                              u.jsx(Mg, {
                                                className: "w-4 h-4",
                                              }),
                                              u.jsx("span", {
                                                children: "Delete tag",
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                                    ],
                                  })
                                : u.jsx("div", { className: "w-5 h-5" }),
                              u.jsx("div", {
                                className: Le(
                                  "w-4 h-4 border rounded-sm flex items-center justify-center transition-colors",
                                  te
                                    ? "bg-accent border-accent text-accent-foreground"
                                    : "border-border/50"
                                ),
                                children:
                                  te &&
                                  u.jsx("span", {
                                    className: "text-xs",
                                    children: "",
                                  }),
                              }),
                            ],
                          }),
                        ],
                      },
                      X.id
                    );
                  }),
                  H &&
                    u.jsx("div", {
                      className: Le(
                        "flex items-center justify-between px-3 py-1.5 cursor-pointer transition-colors border-t border-border/30 mt-1 mx-2 rounded-lg",
                        b === W.length && "bg-white/10",
                        b !== W.length && "hover:bg-white/5"
                      ),
                      onClick: q,
                      onMouseEnter: () => w(W.length),
                      children: u.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [
                          u.jsx(Zu, {
                            size: 14,
                            className: "text-text-secondary",
                          }),
                          u.jsx("span", {
                            className: "text-sm text-text-secondary",
                            children: "Create",
                          }),
                          u.jsx(Fr, {
                            text: e.trim(),
                            type: "tag",
                            color: B(),
                          }),
                        ],
                      }),
                    }),
                ],
              }),
          u.jsx(kW, {
            isOpen: C.isOpen,
            onClose: j,
            onConfirm: U,
            tagName: C.tagName,
            elementCount: C.elementCount,
          }),
          u.jsx(CW, {
            isOpen: L.isOpen,
            onClose: I,
            onConfirm: M,
            currentName: L.tagName,
            isRenaming: V,
          }),
        ],
      })
    );
  },
  iP = de.memo(
    ({
      element: n,
      hasEditingPermissions: e,
      isVisible: t,
      isSelected: s,
      isHovered: r = !1,
      variant: i = "reply",
    }) => {
      const a = hn((b) => b.user),
        { accessLevel: o, isCreator: l } = dd(),
        [c, h] = E.useState(!1),
        m = o === "viewonly" && !l,
        p = a?.id === n.createdBy;
      E.useEffect(() => {
        (!s || !t) && h(!1);
      }, [s, t]);
      const g = () => {
          h(!1);
          const b = Ce.getState().deleteElements;
          b([n.id]);
        },
        y = () => {
          if ((h(!1), n.type === "text")) {
            const b = Ce.getState().enterTextEditMode;
            b(n.id);
          } else if (n.type === "recording") {
            const b = Ce.getState().enterDescriptionEditMode;
            b(n.id);
          }
        };
      return (
        E.useEffect(() => {
          if (c && !s && i === "main") {
            const b = Ce.getState().setSelectedFrames;
            b([n.id]);
          }
        }, [c, s, n.id, i]),
        !e || m || !p || !t
          ? null
          : i === "reply"
          ? u.jsxs(Ii, {
              modal: !1,
              open: c,
              onOpenChange: h,
              children: [
                u.jsxs(Xn, {
                  children: [
                    u.jsx(Qn, {
                      asChild: !0,
                      children: u.jsx(Li, {
                        asChild: !0,
                        children: u.jsx("button", {
                          className: Le(
                            "flex items-center justify-center transition-opacity duration-200",
                            r ? "opacity-100" : "opacity-0"
                          ),
                          onMouseDown: (b) => b.stopPropagation(),
                          onClick: (b) => b.stopPropagation(),
                          children: u.jsx(_U, {
                            size: 14,
                            className:
                              "text-text-secondary hover:text-text-primary transition-colors duration-100",
                          }),
                        }),
                      }),
                    }),
                    u.jsx(Pn, {
                      side: "bottom",
                      className: "z-[100]",
                      children: u.jsx("p", { children: "More options" }),
                    }),
                  ],
                }),
                u.jsxs(ui, {
                  align: "end",
                  side: "bottom",
                  sideOffset: 8,
                  alignOffset: 0,
                  className: "min-w-[160px] z-[100] bg-card-background",
                  onMouseDown: (b) => b.stopPropagation(),
                  onClick: (b) => b.stopPropagation(),
                  avoidCollisions: !0,
                  collisionPadding: 8,
                  children: [
                    (n.type === "text" || n.type === "recording") &&
                      u.jsxs("button", {
                        className:
                          "flex items-center justify-between w-full px-3 py-2 text-sm hover:bg-border/50 transition-colors rounded-xl",
                        onClick: y,
                        children: [
                          u.jsx("span", { children: "Edit Text" }),
                          s &&
                            u.jsx(mn, {
                              className: "opacity-50",
                              children: "E",
                            }),
                        ],
                      }),
                    u.jsxs("button", {
                      className:
                        "flex items-center justify-between w-full px-3 py-2 text-sm hover:bg-border/50 transition-colors rounded-xl",
                      onClick: g,
                      children: [
                        u.jsx("span", { children: "Delete" }),
                        s &&
                          u.jsx(mn, { className: "opacity-50", children: "" }),
                      ],
                    }),
                  ],
                }),
              ],
            })
          : u.jsxs(Ii, {
              modal: !1,
              open: c,
              onOpenChange: h,
              children: [
                u.jsxs(Xn, {
                  children: [
                    u.jsx(Qn, {
                      asChild: !0,
                      children: u.jsx(Li, {
                        asChild: !0,
                        children: u.jsx("button", {
                          className: Le(
                            "element-button flex items-center justify-center h-[30px] w-[30px] rounded-2xl hover:bg-border/30 transition-opacity duration-200",
                            s || r ? "opacity-100" : "opacity-0"
                          ),
                          onMouseDown: (b) => b.stopPropagation(),
                          onClick: (b) => b.stopPropagation(),
                          children: u.jsx(_U, {
                            size: 14,
                            className:
                              "text-text-secondary hover:text-text-primary transition-colors duration-100",
                          }),
                        }),
                      }),
                    }),
                    u.jsx(Pn, {
                      side: "bottom",
                      className: "z-[100]",
                      children: u.jsx("p", { children: "More options" }),
                    }),
                  ],
                }),
                u.jsxs(ui, {
                  align: "end",
                  side: "bottom",
                  sideOffset: 8,
                  alignOffset: 0,
                  className: "min-w-[160px] z-[100] bg-card-background",
                  onMouseDown: (b) => b.stopPropagation(),
                  onClick: (b) => b.stopPropagation(),
                  avoidCollisions: !0,
                  collisionPadding: 8,
                  children: [
                    (n.type === "text" || n.type === "recording") &&
                      u.jsxs("button", {
                        className:
                          "flex items-center justify-between w-full px-3 py-2 text-sm hover:bg-border/50 transition-colors rounded-xl",
                        onClick: y,
                        children: [
                          u.jsx("span", { children: "Edit Text" }),
                          s &&
                            u.jsx(mn, {
                              className: "opacity-50",
                              children: "E",
                            }),
                        ],
                      }),
                    u.jsxs("button", {
                      className:
                        "flex items-center justify-between w-full px-3 py-2 text-sm hover:bg-border/50 transition-colors rounded-xl",
                      onClick: g,
                      children: [
                        u.jsx("span", { children: "Delete" }),
                        s &&
                          u.jsx(mn, { className: "opacity-50", children: "" }),
                      ],
                    }),
                  ],
                }),
              ],
            })
      );
    }
  );
iP.displayName = "MoreOptionsButton";
var eS = "Popover",
  [IW, n2e] = Pr(eS, [Gc]),
  zv = Gc(),
  [aTe, Xc] = IW(eS),
  LW = (n) => {
    const {
        __scopePopover: e,
        children: t,
        open: s,
        defaultOpen: r,
        onOpenChange: i,
        modal: a = !1,
      } = n,
      o = zv(e),
      l = E.useRef(null),
      [c, h] = E.useState(!1),
      [m, p] = ci({ prop: s, defaultProp: r ?? !1, onChange: i, caller: eS });
    return u.jsx(Cv, {
      ...o,
      children: u.jsx(aTe, {
        scope: e,
        contentId: $r(),
        triggerRef: l,
        open: m,
        onOpenChange: p,
        onOpenToggle: E.useCallback(() => p((g) => !g), [p]),
        hasCustomAnchor: c,
        onCustomAnchorAdd: E.useCallback(() => h(!0), []),
        onCustomAnchorRemove: E.useCallback(() => h(!1), []),
        modal: a,
        children: t,
      }),
    });
  };
LW.displayName = eS;
var DW = "PopoverAnchor",
  oTe = E.forwardRef((n, e) => {
    const { __scopePopover: t, ...s } = n,
      r = Xc(DW, t),
      i = zv(t),
      { onCustomAnchorAdd: a, onCustomAnchorRemove: o } = r;
    return (
      E.useEffect(() => (a(), () => o()), [a, o]),
      u.jsx(Iv, { ...i, ...s, ref: e })
    );
  });
oTe.displayName = DW;
var PW = "PopoverTrigger",
  MW = E.forwardRef((n, e) => {
    const { __scopePopover: t, ...s } = n,
      r = Xc(PW, t),
      i = zv(t),
      a = Nt(e, r.triggerRef),
      o = u.jsx(Et.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": r.open,
        "aria-controls": r.contentId,
        "data-state": UW(r.open),
        ...s,
        ref: a,
        onClick: qe(n.onClick, r.onOpenToggle),
      });
    return r.hasCustomAnchor
      ? o
      : u.jsx(Iv, { asChild: !0, ...i, children: o });
  });
MW.displayName = PW;
var aP = "PopoverPortal",
  [lTe, cTe] = IW(aP, { forceMount: void 0 }),
  NW = (n) => {
    const { __scopePopover: e, forceMount: t, children: s, container: r } = n,
      i = Xc(aP, e);
    return u.jsx(lTe, {
      scope: e,
      forceMount: t,
      children: u.jsx(Pi, {
        present: t || i.open,
        children: u.jsx(Hf, { asChild: !0, container: r, children: s }),
      }),
    });
  };
NW.displayName = aP;
var Cf = "PopoverContent",
  OW = E.forwardRef((n, e) => {
    const t = cTe(Cf, n.__scopePopover),
      { forceMount: s = t.forceMount, ...r } = n,
      i = Xc(Cf, n.__scopePopover);
    return u.jsx(Pi, {
      present: s || i.open,
      children: i.modal
        ? u.jsx(dTe, { ...r, ref: e })
        : u.jsx(hTe, { ...r, ref: e }),
    });
  });
OW.displayName = Cf;
var uTe = Mc("PopoverContent.RemoveScroll"),
  dTe = E.forwardRef((n, e) => {
    const t = Xc(Cf, n.__scopePopover),
      s = E.useRef(null),
      r = Nt(e, s),
      i = E.useRef(!1);
    return (
      E.useEffect(() => {
        const a = s.current;
        if (a) return _E(a);
      }, []),
      u.jsx(Rv, {
        as: uTe,
        allowPinchZoom: !0,
        children: u.jsx(jW, {
          ...n,
          ref: r,
          trapFocus: t.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: qe(n.onCloseAutoFocus, (a) => {
            a.preventDefault(), i.current || t.triggerRef.current?.focus();
          }),
          onPointerDownOutside: qe(
            n.onPointerDownOutside,
            (a) => {
              const o = a.detail.originalEvent,
                l = o.button === 0 && o.ctrlKey === !0,
                c = o.button === 2 || l;
              i.current = c;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: qe(n.onFocusOutside, (a) => a.preventDefault(), {
            checkForDefaultPrevented: !1,
          }),
        }),
      })
    );
  }),
  hTe = E.forwardRef((n, e) => {
    const t = Xc(Cf, n.__scopePopover),
      s = E.useRef(!1),
      r = E.useRef(!1);
    return u.jsx(jW, {
      ...n,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (i) => {
        n.onCloseAutoFocus?.(i),
          i.defaultPrevented ||
            (s.current || t.triggerRef.current?.focus(), i.preventDefault()),
          (s.current = !1),
          (r.current = !1);
      },
      onInteractOutside: (i) => {
        n.onInteractOutside?.(i),
          i.defaultPrevented ||
            ((s.current = !0),
            i.detail.originalEvent.type === "pointerdown" && (r.current = !0));
        const a = i.target;
        t.triggerRef.current?.contains(a) && i.preventDefault(),
          i.detail.originalEvent.type === "focusin" &&
            r.current &&
            i.preventDefault();
      },
    });
  }),
  jW = E.forwardRef((n, e) => {
    const {
        __scopePopover: t,
        trapFocus: s,
        onOpenAutoFocus: r,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: a,
        onEscapeKeyDown: o,
        onPointerDownOutside: l,
        onFocusOutside: c,
        onInteractOutside: h,
        ...m
      } = n,
      p = Xc(Cf, t),
      g = zv(t);
    return (
      SE(),
      u.jsx(Av, {
        asChild: !0,
        loop: !0,
        trapped: s,
        onMountAutoFocus: r,
        onUnmountAutoFocus: i,
        children: u.jsx(Bf, {
          asChild: !0,
          disableOutsidePointerEvents: a,
          onInteractOutside: h,
          onEscapeKeyDown: o,
          onPointerDownOutside: l,
          onFocusOutside: c,
          onDismiss: () => p.onOpenChange(!1),
          children: u.jsx(LE, {
            "data-state": UW(p.open),
            role: "dialog",
            id: p.contentId,
            ...g,
            ...m,
            ref: e,
            style: {
              ...m.style,
              "--radix-popover-content-transform-origin":
                "var(--radix-popper-transform-origin)",
              "--radix-popover-content-available-width":
                "var(--radix-popper-available-width)",
              "--radix-popover-content-available-height":
                "var(--radix-popper-available-height)",
              "--radix-popover-trigger-width":
                "var(--radix-popper-anchor-width)",
              "--radix-popover-trigger-height":
                "var(--radix-popper-anchor-height)",
            },
          }),
        }),
      })
    );
  }),
  FW = "PopoverClose",
  fTe = E.forwardRef((n, e) => {
    const { __scopePopover: t, ...s } = n,
      r = Xc(FW, t);
    return u.jsx(Et.button, {
      type: "button",
      ...s,
      ref: e,
      onClick: qe(n.onClick, () => r.onOpenChange(!1)),
    });
  });
fTe.displayName = FW;
var mTe = "PopoverArrow",
  pTe = E.forwardRef((n, e) => {
    const { __scopePopover: t, ...s } = n,
      r = zv(t);
    return u.jsx(DE, { ...r, ...s, ref: e });
  });
pTe.displayName = mTe;
function UW(n) {
  return n ? "open" : "closed";
}
var gTe = LW,
  vTe = MW,
  yTe = NW,
  $W = OW;
const bTe = gTe,
  xTe = vTe,
  BW = E.forwardRef(
    ({ className: n, align: e = "center", sideOffset: t = 4, ...s }, r) =>
      u.jsx(yTe, {
        children: u.jsx($W, {
          ref: r,
          align: e,
          sideOffset: t,
          className: Le(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n
          ),
          ...s,
        }),
      })
  );
BW.displayName = $W.displayName;
const oP = de.memo(
  ({
    element: n,
    hasEditingPermissions: e,
    forceOpen: t = !1,
    onRequestClose: s,
    isHovered: r = !1,
    isReadOnly: i = !1,
    showMoreMenu: a = !1,
    isVisible: o = !0,
    isSelected: l = !1,
  }) => {
    const c = Ce((z) => z.boardState.elements[n.id]?.tagIds || []),
      h = Ce((z) => z.boardState.tags || {}),
      m = Ce((z) => z.removeTagFromElement),
      p = Ce((z) => z.getElementAppTags),
      g = Ce((z) => z.userProfiles),
      y = Ce((z) => z.unseenElementIds),
      [b, w] = E.useState(!1),
      [S, A] = E.useState(""),
      _ = E.useRef(null),
      R = y.has(n.id),
      C = c
        .map((z) => Object.values(h).find((B) => B.id === z))
        .filter(Boolean),
      D = p(n.id),
      L = i
        ? D.filter((z) => z.type === "creator" || z.type === "creationTime")
        : D.filter((z) => z.type !== "linkTime"),
      P = i ? [] : C;
    if (
      (E.useEffect(() => {
        t && e && w(!0);
      }, [t, e]),
      E.useEffect(() => {
        b && setTimeout(() => _.current?.focus(), 50);
      }, [b]),
      !(i ? L.length > 0 : t || P.length > 0 || L.length > 0))
    )
      return null;
    const N = (z) => {
        const B = Math.floor(z),
          q = Math.floor(B / 3600),
          O = Math.floor((B % 3600) / 60),
          U = B % 60,
          j = [];
        return (
          q > 0 &&
            j.push(
              u.jsxs(
                de.Fragment,
                {
                  children: [
                    q,
                    u.jsx("span", {
                      style: { opacity: 0.6, verticalAlign: "baseline" },
                      children: "h",
                    }),
                  ],
                },
                "h"
              )
            ),
          (O > 0 || q > 0) &&
            (j.length > 0 &&
              j.push(u.jsx(de.Fragment, { children: ":" }, "h-sep")),
            j.push(
              u.jsxs(
                de.Fragment,
                {
                  children: [
                    O.toString().padStart(2, "0"),
                    u.jsx("span", {
                      style: { opacity: 0.6, verticalAlign: "baseline" },
                      children: "m",
                    }),
                  ],
                },
                "m"
              )
            )),
          ((q === 0 && O === 0) || U > 0) &&
            (j.length > 0 &&
              j.push(u.jsx(de.Fragment, { children: ":" }, "m-sep")),
            j.push(
              u.jsxs(
                de.Fragment,
                {
                  children: [
                    U.toString().padStart(2, "0"),
                    u.jsx("span", {
                      style: { opacity: 0.6, verticalAlign: "baseline" },
                      children: "s",
                    }),
                  ],
                },
                "s"
              )
            )),
          u.jsx(u.Fragment, { children: j })
        );
      },
      W = (z) => {
        if (z.type === "creator") {
          const B = z.creatorId ? g[z.creatorId] : void 0;
          return { text: lD(B, z.creatorName) };
        } else if (z.type === "creationTime") {
          const B = new Date(z.timestamp * 1e3);
          return { text: YG(B), icon: u.jsx(Lg, { size: 12 }) };
        } else if (z.type === "linkTime") {
          if (z.timestamp !== void 0)
            return { content: N(z.timestamp), icon: u.jsx(Pg, { size: 12 }) };
          if (z.timeRange)
            return {
              content: u.jsxs(u.Fragment, {
                children: [
                  N(z.timeRange.start),
                  u.jsx("span", { style: { opacity: 0.6 }, children: "-" }),
                  N(z.timeRange.end),
                ],
              }),
              icon: u.jsx(Pg, { size: 12 }),
            };
        }
        return { text: "" };
      },
      H = (z) => {
        w(z), z || (A(""), s?.());
      };
    return i
      ? u.jsx("div", {
          className: "w-full relative group",
          children: u.jsxs(Br, {
            delayDuration: 300,
            children: [
              u.jsx("div", {
                className: "h-full px-2 py-2 flex flex-wrap gap-1 items-center",
                children: L.map((z) => {
                  const B = W(z);
                  return u.jsx(
                    Fr,
                    {
                      text: B.text,
                      type: "apptag",
                      appTagType: z.type,
                      image: z.type === "creator" ? z.creatorAvatarUrl : void 0,
                      isRemovable: !1,
                      icon: B.icon,
                      showNewIndicator: z.type === "creationTime" && R,
                      children: B.content,
                    },
                    z.id
                  );
                }),
              }),
              a &&
                u.jsx("div", {
                  className: "absolute right-[13px] top-2",
                  children: u.jsx(iP, {
                    element: n,
                    hasEditingPermissions: e,
                    isVisible: o,
                    isSelected: l,
                    isHovered: r,
                    variant: "reply",
                  }),
                }),
            ],
          }),
        })
      : u.jsx("div", {
          className: "w-full relative group",
          children: u.jsx(Br, {
            delayDuration: 300,
            children: u.jsxs(bTe, {
              open: b,
              onOpenChange: H,
              modal: !1,
              children: [
                u.jsxs(Xn, {
                  children: [
                    u.jsx(Qn, {
                      asChild: !0,
                      children: u.jsx(xTe, {
                        asChild: !0,
                        disabled: b || !e,
                        children: u.jsxs("div", {
                          className: `border-transparent h-full px-2 rounded-3xl py-2 flex flex-wrap gap-1 items-center transition-colors duration-100 ${
                            e
                              ? `cursor-pointer ${
                                  b
                                    ? "bg-card-background/80"
                                    : "hover:bg-card-background/50"
                                }`
                              : ""
                          }`,
                          onClick: (z) => {
                            z.stopPropagation(), !b && e && H(!0);
                          },
                          onMouseDown: (z) => z.stopPropagation(),
                          children: [
                            L.map((z) => {
                              const B = W(z);
                              return u.jsx(
                                Fr,
                                {
                                  text: B.text,
                                  type: "apptag",
                                  appTagType: z.type,
                                  image:
                                    z.type === "creator"
                                      ? z.creatorAvatarUrl
                                      : void 0,
                                  isRemovable: !1,
                                  icon: B.icon,
                                  showNewIndicator:
                                    z.type === "creationTime" && R,
                                  children: B.content,
                                },
                                z.id
                              );
                            }),
                            P.map((z) =>
                              u.jsx(
                                Fr,
                                {
                                  text: z.name,
                                  type: "tag",
                                  color: z.color,
                                  showRemove: b && e,
                                  onRemove: (B) => {
                                    m(n.id, z.id);
                                  },
                                },
                                z.id
                              )
                            ),
                            b &&
                              e &&
                              u.jsx("input", {
                                ref: _,
                                type: "text",
                                value: S,
                                onChange: (z) => A(z.target.value),
                                onKeyDown: (z) => {
                                  z.stopPropagation(),
                                    z.key === "Escape" &&
                                      (H(!1), z.preventDefault());
                                },
                                onClick: (z) => z.stopPropagation(),
                                onMouseDown: (z) => z.stopPropagation(),
                                className:
                                  "flex-1 w-full bg-transparent outline-none text-xs text-text-primary placeholder:text-text-secondary/60 p-1",
                                placeholder: "",
                              }),
                            !b &&
                              P.length === 0 &&
                              L.length === 0 &&
                              u.jsx("span", {
                                className: "text-xs text-text-secondary/60",
                                children: "Add tags...",
                              }),
                          ],
                        }),
                      }),
                    }),
                    e &&
                      !b &&
                      u.jsx(Pn, {
                        side: "top",
                        className: "text-xs",
                        children: "Tags",
                      }),
                  ],
                }),
                e &&
                  u.jsx(BW, {
                    align: "start",
                    side: "bottom",
                    sideOffset: 4,
                    className: "p-0 min-w-[250px] rounded-xl",
                    onMouseDown: (z) => z.stopPropagation(),
                    onClick: (z) => z.stopPropagation(),
                    children: u.jsx(iTe, {
                      element: n,
                      searchValue: S,
                      onSearchChange: A,
                      onClose: () => H(!1),
                      onTagCreated: () => {
                        A("");
                      },
                    }),
                  }),
              ],
            }),
          }),
        });
  }
);
oP.displayName = "TagsSection";
const lP = de.memo(
  ({
    element: n,
    isVisible: e,
    hasEditingPermissions: t,
    isSelected: s,
    isHovered: r = !1,
    threadId: i,
  }) => {
    const { accessLevel: a, isCreator: o } = dd(),
      l = es(),
      c = hn((w) => w.user),
      h = a === "viewonly" && !o,
      m = i || n.id,
      g = vt((w) => w.replyToolbar.threadId) === m,
      y = (w) => {
        if ((w?.preventDefault(), w?.stopPropagation(), !c)) {
          const _ = window.location.pathname;
          l(`/login?redirect=${encodeURIComponent(_)}`);
          return;
        }
        const S = pt.getState();
        if ((Ce.getState().setSelectedFrames([m]), g)) {
          S.scrollThreadToBottom(m),
            setTimeout(() => {
              vt.getState().focusTextbox("reply");
            }, 100);
          return;
        }
        S.enableThreadScrollOnHover(m),
          vt.getState().setReplyThreadId(m),
          vt.getState().enterReplyFocusedState(m),
          setTimeout(() => {
            S.scrollThreadToBottom(m), S.notifyThreadHeightChanged(m);
          }, 50);
      },
      b = !h;
    return !b || !e
      ? null
      : u.jsx("div", {
          className: "w-full relative px-3",
          children: u.jsx(Br, {
            delayDuration: 300,
            children: u.jsxs("div", {
              className: "flex items-center justify-between gap-2",
              children: [
                b &&
                  u.jsxs(Xn, {
                    children: [
                      u.jsx(Qn, {
                        asChild: !0,
                        children: u.jsxs("button", {
                          className:
                            "element-button flex items-center justify-center gap-1.5 h-[30px] px-2.5 rounded-2xl hover:bg-border/30 transition-colors group/reply-btn",
                          onClick: (w) => y(w),
                          onMouseDown: (w) => w.stopPropagation(),
                          children: [
                            u.jsx("span", {
                              className:
                                "text-xs text-text-secondary group-hover/reply-btn:text-text-primary transition-colors duration-100",
                              children: "Reply",
                            }),
                            u.jsx(wle, {
                              size: 14,
                              className:
                                "text-text-secondary group-hover/reply-btn:text-text-primary transition-colors duration-100",
                            }),
                          ],
                        }),
                      }),
                      u.jsx(Pn, {
                        side: "bottom",
                        className: "z-[100]",
                        children: u.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [
                            u.jsx("p", { children: "Reply" }),
                            s && u.jsx(mn, { children: "" }),
                          ],
                        }),
                      }),
                    ],
                  }),
                u.jsx(iP, {
                  element: n,
                  hasEditingPermissions: t,
                  isVisible: e,
                  isSelected: s,
                  isHovered: r,
                  variant: "main",
                }),
              ],
            }),
          }),
        });
  }
);
lP.displayName = "ActionBar";
const HW = E.memo(
  ({
    element: n,
    hasEditingPermissions: e,
    width: t,
    isLastReply: s = !1,
    parentThreadId: r,
  }) => {
    const i = vn((b) => b.activeFilterIds),
      a = vn((b) => b.filterMode),
      o = vn((b) => b.isElementVisible),
      l = Ce((b) => b.selectedFrames),
      c = E.useMemo(() => o(n), [n, i, a, o]),
      h = l.includes(n.id),
      [m, p] = E.useState(!1),
      g = E.useRef(null);
    E.useEffect(() => {
      if (!g.current) return;
      const b = () => {
          p(!0);
        },
        w = () => {
          p(!1);
        },
        S = new MutationObserver(() => {
          g.current
            ?.querySelectorAll('[data-element-child="true"]')
            ?.forEach((R) => {
              R.addEventListener("mouseenter", b),
                R.addEventListener("mouseleave", w);
            });
        });
      return (
        S.observe(g.current, { childList: !0, subtree: !0 }),
        g.current
          .querySelectorAll('[data-element-child="true"]')
          .forEach((_) => {
            _.addEventListener("mouseenter", b),
              _.addEventListener("mouseleave", w);
          }),
        () => {
          S.disconnect(),
            g.current
              ?.querySelectorAll('[data-element-child="true"]')
              ?.forEach((R) => {
                R.removeEventListener("mouseenter", b),
                  R.removeEventListener("mouseleave", w);
              });
        }
      );
    }, []);
    const y = E.useMemo(() => ({ width: t ?? "100%", height: "auto" }), [t]);
    return u.jsx("div", {
      ref: g,
      className: Le(
        "annotation-element select-none relative overflow-hidden group"
      ),
      style: {
        width: y.width,
        cursor: "default",
        opacity: c ? 1 : f8,
        position: "relative",
        pointerEvents: c ? "auto" : "none",
        transformOrigin: "top center",
      },
      onMouseEnter: c ? () => p(!0) : void 0,
      onMouseLeave: c ? () => p(!1) : void 0,
      "data-testid": `element-reply-${n.id}`,
      "data-element-type": n.type,
      "data-element-id": n.id,
      children: u.jsx("div", {
        className: "w-full overflow-visible",
        children: u.jsx("div", {
          children: u.jsx("div", {
            className: "px-1 overflow-visible border-t border-border",
            children: u.jsxs("div", {
              className: "w-full h-full",
              style: { overflow: "visible" },
              children: [
                u.jsx("div", {
                  className: "px-1 pt-1 pb-1",
                  children: u.jsx(oP, {
                    element: n,
                    hasEditingPermissions: e,
                    isReadOnly: !0,
                    showMoreMenu: !0,
                    isVisible: c,
                    isSelected: h,
                    isHovered: m,
                  }),
                }),
                u.jsx("div", {
                  className: "pl-3 pr-3 pb-1",
                  children:
                    n.type === "recording"
                      ? u.jsx(oW, {
                          element: n,
                          hasEditingPermissions: e,
                          isSelected: !1,
                          containerRef: g,
                          isHovered: m,
                          isReplyElement: !0,
                        })
                      : u.jsx(aW, {
                          element: n,
                          hasEditingPermissions: e,
                          isSelected: !1,
                          wasDragging: !1,
                          containerRef: g,
                          isReplyElement: !0,
                        }),
                }),
                s &&
                  r &&
                  u.jsx("div", {
                    className: "-ml-1 -mb-1",
                    children: u.jsx(lP, {
                      element: n,
                      isVisible: c,
                      hasEditingPermissions: e,
                      isSelected: !1,
                      isReplyElement: !0,
                      threadId: r,
                    }),
                  }),
              ],
            }),
          }),
        }),
      }),
    });
  }
);
HW.displayName = "ElementReply";
const Lw = E.memo(
  ({
    element: n,
    hasEditingPermissions: e,
    isReplyElement: t = !1,
    width: s,
    disableAnimations: r = !1,
  }) => {
    const i = n.isPlaceholder === !0,
      [a] = E.useState(() => Ce.getState().newlyCreatedElements.has(n.id)),
      o = Ce((U) => U.markElementAsAnimated);
    E.useEffect(() => {
      if (a && !i) {
        const U = setTimeout(() => {
          o(n.id);
        }, 600);
        return () => clearTimeout(U);
      }
    }, [a, n.id, o, i]);
    const l = Ce((U) => U.selectedFrames),
      c = Ce((U) => U.selectElementWithModifiers),
      h = vn((U) => U.activeFilterIds),
      m = vn((U) => U.filterMode),
      p = vn((U) => U.isElementVisible),
      g = E.useMemo(() => p(n), [n, h, m, p]),
      [y] = E.useState(!1),
      [b, w] = E.useState(!1);
    E.useEffect(() => {
      if (!S.current) return;
      const U = () => {
          w(!0);
        },
        j = () => {
          w(!1);
        },
        Q = new MutationObserver(() => {
          S.current
            ?.querySelectorAll('[data-element-child="true"]')
            ?.forEach((F) => {
              F.addEventListener("mouseenter", U),
                F.addEventListener("mouseleave", j);
            });
        });
      return (
        Q.observe(S.current, { childList: !0, subtree: !0 }),
        S.current
          .querySelectorAll('[data-element-child="true"]')
          .forEach((I) => {
            I.addEventListener("mouseenter", U),
              I.addEventListener("mouseleave", j);
          }),
        () => {
          Q.disconnect(),
            S.current
              ?.querySelectorAll('[data-element-child="true"]')
              ?.forEach((F) => {
                F.removeEventListener("mouseenter", U),
                  F.removeEventListener("mouseleave", j);
              });
        }
      );
    }, []);
    const S = E.useRef(null),
      A = E.useMemo(() => l.includes(n.id), [l, n.id]),
      _ = E.useMemo(() => ({ width: s ?? Ln, height: "auto" }), [s]),
      R = E.useCallback(
        (U) => {
          !g ||
            i ||
            U.target.dataset.resizeHandle ||
            U.target.tagName === "A" ||
            U.button !== 0 ||
            U.target.closest("[data-tag-picker]") ||
            (U.stopPropagation(), c(n.id));
        },
        [c, n.id, g, i]
      ),
      C = E.useCallback(
        (U) => {
          g &&
            (U.target.dataset.resizeHandle ||
              (U.target.tagName !== "A" &&
                (U.stopPropagation(), U.preventDefault())));
        },
        [g]
      ),
      D = {
        initial: { y: 100, opacity: 0, scale: 0.9 },
        animate: { y: 0, opacity: 1, scale: 1 },
        transition: {
          type: "spring",
          stiffness: 260,
          damping: 20,
          duration: 0.4,
        },
        exit: { opacity: 0, scale: 0.9, transition: { duration: 0.2 } },
      },
      [L, P] = E.useState(!1),
      N = vt((U) => U.replyToolbar.threadId) === n.id,
      W = hn((U) => U.user),
      H = Ce((U) => U.boardState.elements),
      z = E.useMemo(
        () =>
          t
            ? []
            : Object.values(H).filter((U) =>
                U?.links?.some(
                  (j) => j.type === "element" && j.targetElementId === n.id
                )
              ),
        [H, n.id, t]
      ),
      [B, q] = E.useState(!r);
    E.useEffect(() => {
      if (r) return;
      const U = setTimeout(() => q(!1), 50);
      return () => clearTimeout(U);
    }, [r]);
    const O = u.jsx("div", {
      ref: S,
      className: Le(
        "annotation-element select-none relative group",
        !r && "transition-all duration-300 ease-out",
        B ? "opacity-0" : "opacity-100"
      ),
      style: {
        width: _.width,
        opacity: g ? (B ? 0 : 1) : f8,
        position: "relative",
        pointerEvents: g ? "auto" : "none",
        transformOrigin: "top center",
        overflow: "visible",
      },
      onMouseDown: R,
      onDoubleClick: C,
      onMouseEnter: g ? () => w(!0) : void 0,
      onMouseLeave: g ? () => w(!1) : void 0,
      "data-testid": `element-${n.id}`,
      "data-element-type": n.type,
      "data-element-id": n.id,
      children: u.jsx("div", {
        className: "flex flex-col w-full z-10",
        style: { overflow: "visible" },
        children: u.jsx("div", {
          className: Le(
            A && !N ? "border-[0.5px] border-white/40" : "element-border"
          ),
          style: { borderRadius: 24 },
          children: u.jsx("div", {
            className: Le(
              "w-full h-full bg-element-background relative transition-all duration-100 shadow-md shadow-black"
            ),
            style: { borderRadius: 24 },
            children: u.jsxs(u.Fragment, {
              children: [
                u.jsx("div", {
                  className: " pt-1 pl-1 pr-1 pb-1",
                  children: u.jsx(oP, {
                    element: n,
                    hasEditingPermissions: e,
                    forceOpen: L,
                    onRequestClose: () => P(!1),
                    isHovered: b,
                  }),
                }),
                u.jsx("div", {
                  className: "pl-4 pr-3 pb-1",
                  children:
                    n.type === "recording"
                      ? u.jsx(oW, {
                          element: n,
                          hasEditingPermissions: e,
                          isSelected: A,
                          containerRef: S,
                          isHovered: b,
                          isReplyElement: t,
                        })
                      : u.jsx(aW, {
                          element: n,
                          hasEditingPermissions: e,
                          isSelected: A,
                          wasDragging: y,
                          containerRef: S,
                          isReplyElement: t,
                        }),
                }),
                u.jsxs("div", {
                  className: " ",
                  children: [
                    !t &&
                      u.jsx(lP, {
                        element: n,
                        isVisible: g,
                        hasEditingPermissions: e,
                        isSelected: A,
                        isHovered: b,
                        isReplyElement: t,
                      }),
                    z.length === 0 && u.jsx("div", { className: "h-3" }),
                  ],
                }),
                !t &&
                  z.length > 0 &&
                  u.jsx(u.Fragment, {
                    children: u.jsx("div", {
                      className: "flex flex-col py-2",
                      children: z.map((U, j) =>
                        u.jsx(
                          "div",
                          {
                            className: "mb-2 last:mb-0",
                            children: u.jsx(HW, {
                              element: U,
                              hasEditingPermissions: e,
                              width: s,
                              isLastReply: j === z.length - 1,
                              parentThreadId: n.id,
                            }),
                          },
                          U.id
                        )
                      ),
                    }),
                  }),
                !t &&
                  W &&
                  e &&
                  N &&
                  u.jsx("div", {
                    className: "w-full pt-2",
                    children: u.jsx(pq, {
                      hasEditingPermissions: e,
                      variant: "reply",
                      threadId: n.id,
                    }),
                  }),
              ],
            }),
          }),
        }),
      }),
    });
    return a && !i && !r
      ? u.jsx(Qg, {
          mode: "wait",
          children: u.jsx(
            la.div,
            {
              initial: D.initial,
              animate: D.animate,
              transition: D.transition,
              exit: D.exit,
              style: { position: "relative" },
              children: O,
            },
            n.id
          ),
        })
      : O;
  }
);
Lw.displayName = "Element";
function tS(n, e = {}) {
  const { select: t = !0, clearSelection: s = !0 } = e,
    r = Ce.getState(),
    i = pt.getState(),
    a = r.boardState.elements[n];
  if (!a) {
    console.warn(`[centerElement] Element ${n} not found`);
    return;
  }
  const o = a.links?.find((h) => h.type === "element"),
    l = !!(o && o.targetElementId),
    c = l ? r.findRootElementInThread(n) : n;
  if (!c) {
    console.warn(`[centerElement] Could not find root element for ${n}`);
    return;
  }
  t && r.selectElement(c, { clearOthers: s, addToSelection: !1 }),
    i.zoomToShowElements([c]),
    l &&
      setTimeout(() => {
        i.enableThreadScrollOnHover(c), i.scrollThreadToBottom(c);
      }, 150);
}
const D4 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, centerElement: tS },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  wTe = (n, e) => {
    if (
      n.threadId !== e.threadId ||
      n.x !== e.x ||
      n.y !== e.y ||
      n.scale !== e.scale ||
      n.hasEditingPermissions !== e.hasEditingPermissions ||
      n.playbarWidth !== e.playbarWidth ||
      n.isCollapsed !== e.isCollapsed ||
      n.showOnlyFirst !== e.showOnlyFirst ||
      n.isPeekMode !== e.isPeekMode ||
      n.fullWidth !== e.fullWidth ||
      n.elements.length !== e.elements.length
    )
      return !1;
    for (let t = 0; t < n.elements.length; t++)
      if (n.elements[t].id !== e.elements[t].id) return !1;
    return !0;
  },
  yC = E.memo(
    ({
      threadId: n,
      elements: e,
      x: t,
      y: s,
      scale: r,
      hasEditingPermissions: i,
      playbarWidth: a,
      isCollapsed: o = !1,
      isPeekMode: l = !1,
      fullWidth: c = !1,
    }) => {
      const h = Ce((se) => se.selectedFrames),
        m = Ce((se) => se.hoveredElementId),
        p = Ce((se) => se.collapseElements),
        g = Ce((se) => se.expandElements),
        y = E.useRef(null),
        b = E.useRef(null),
        w = E.useRef(null),
        [S, A] = E.useState(!1),
        [_, R] = E.useState(null),
        C = E.useRef(null),
        D = Ce((se) => se.userProfiles),
        L = pt((se) => se.scrollEnabledThreads.has(n)),
        P = pt((se) => se.threadMaxScrollHeights.get(n) ?? null),
        V = pt((se) => se.enableThreadScrollOnHover),
        N = pt((se) => se.disableThreadScrollOnLeave),
        W = pt((se) => se.registerThreadContainer),
        H = pt((se) => se.unregisterThreadContainer),
        z = pt((se) => se.setThreadMaxScrollHeight),
        B = E.useCallback(() => {
          if (P !== null || o || !y.current || !b.current) return;
          b.current.scrollTop > 0 && (b.current.scrollTop = 0);
          const se = y.current.getBoundingClientRect(),
            K = window.innerHeight - J_;
          if (se.bottom > K) {
            const Ee = K - se.top;
            z(n, Ee);
          }
        }, [P, o, n, z]),
        q = E.useCallback(() => {
          V(n);
        }, [n, V]),
        O = E.useCallback(() => {
          N(n);
        }, [n, N]);
      de.useEffect(() => {
        if (o) {
          const se = e.map((be) => be.id);
          p(se);
        } else {
          const se = e.map((be) => be.id);
          g(se);
        }
      }, [o, e, p, g]),
        de.useEffect(() => {
          if (b.current && !o) return W(n, b.current), () => H(n);
        }, [n, o, W, H]),
        de.useEffect(() => {
          L && P === null && B();
        }, [L, P, B]);
      const U = E.useCallback(
        (se) => {
          if (!L || se.ctrlKey) return;
          const be = Math.abs(se.deltaX),
            K = Math.abs(se.deltaY);
          be > K * 0.5 || se.stopPropagation();
        },
        [L, n]
      );
      if (
        (E.useEffect(() => {
          const se = y.current;
          if (!(!se || !L))
            return (
              se.addEventListener("wheel", U, { passive: !1, capture: !0 }),
              () => {
                se.removeEventListener("wheel", U, { capture: !0 });
              }
            );
        }, [U, L, n]),
        e.length === 0)
      )
        return null;
      const j = e.slice(0, 1),
        Q = j[0],
        M = Q.createdBy,
        I = M ? D[M] : void 0,
        F = lD(I, Q.creatorName),
        Y = !o && e.some((se) => h.includes(se.id)),
        J = !o && e.some((se) => se.id === m),
        X = Y || J ? 2 : 1,
        Z = E.useCallback(() => {
          o &&
            (C.current && clearTimeout(C.current),
            (C.current = setTimeout(() => {
              if ((A(!0), w.current)) {
                const se = w.current.getBoundingClientRect();
                R({ x: se.left + se.width / 2, y: se.top - 12 });
              }
            }, 300)));
        }, [o]),
        te = E.useCallback(() => {
          C.current && (clearTimeout(C.current), (C.current = null)),
            A(!1),
            R(null);
        }, []),
        ce = E.useCallback(() => {
          o && tS(Q.id);
        }, [o, Q.id]),
        pe =
          o && S && _
            ? ri.createPortal(
                u.jsx("div", {
                  className: "pointer-events-none overflow-visible",
                  style: {
                    position: "fixed",
                    left: `${_.x}px`,
                    top: `${_.y}px`,
                    transform: "translate(-50%, -100%)",
                    zIndex: 99999,
                  },
                  children: u.jsx(la.div, {
                    initial: { scale: 0, opacity: 0 },
                    animate: { scale: 1, opacity: 1 },
                    exit: { scale: 0, opacity: 0 },
                    transition: { type: "spring", stiffness: 400, damping: 25 },
                    style: { width: Ln },
                    children: u.jsx(Lw, {
                      element: Q,
                      hasEditingPermissions: i,
                      playbarWidth: a,
                      isReplyElement: !1,
                      width: Ln,
                      disableAnimations: !0,
                    }),
                  }),
                }),
                document.body
              )
            : null;
      return u.jsxs(u.Fragment, {
        children: [
          u.jsx("div", {
            ref: y,
            className: "relative",
            style: {
              left: t,
              top: s,
              zIndex: X,
              transform: `scale(${r})`,
              transformOrigin: "top center",
              pointerEvents: "none",
            },
            children: o
              ? u.jsx("div", {
                  ref: w,
                  className:
                    "w-12 h-12 mx-auto group pointer-events-auto cursor-pointer",
                  onMouseEnter: Z,
                  onMouseLeave: te,
                  onClick: ce,
                  children: u.jsx("div", {
                    className: "w-12 h-12 element-border pointer-events-auto",
                    style: { borderRadius: 16 },
                    children: u.jsx("div", {
                      className:
                        "w-full h-full bg-element-background group-hover:bg-inbetween-background flex items-center justify-center relative overflow-hidden cursor-pointer",
                      style: { borderRadius: 16 },
                      children: u.jsx(Ng, {
                        user: I,
                        src: I?.avatar_url || Q.creatorAvatarUrl,
                        name: F,
                        size: "xs",
                        className: "pointer-events-none",
                      }),
                    }),
                  }),
                })
              : u.jsx("div", {
                  ref: b,
                  className: "relative scrollbar-hide",
                  onMouseEnter: q,
                  onMouseLeave: O,
                  style: {
                    width: c || l ? "100%" : `${Ln}px`,
                    minWidth: c || l ? "100%" : `${Ln}px`,
                    pointerEvents: "auto",
                    overflowY: P ? "auto" : "visible",
                    maxHeight: P ? `${P + J_}px` : "none",
                    paddingBottom: P ? `${J_}px` : "0",
                  },
                  children: j.map((se) =>
                    u.jsx(
                      de.Fragment,
                      {
                        children: u.jsx(la.div, {
                          layoutId: `thread-element-${se.id}`,
                          transition: {
                            layout: {
                              type: "spring",
                              stiffness: 300,
                              damping: 20,
                              duration: 100,
                              mass: 0.65,
                            },
                          },
                          className:
                            "pointer-events-auto relative flex flex-col items-center overflow-visible",
                          style: { zIndex: 1 },
                          children: u.jsx(Lw, {
                            element: se,
                            hasEditingPermissions: i,
                            playbarWidth: a,
                            isReplyElement: !1,
                            width: c || l ? "100%" : Ln,
                            allThreadElements: l ? e : void 0,
                          }),
                        }),
                      },
                      se.id
                    )
                  ),
                }),
          }),
          pe,
        ],
      });
    },
    wTe
  );
yC.displayName = "ThreadContainer";
const ETe = ({ creators: n = [], maxVisible: e = 2, size: t = "sm" }) => {
    const r = E.useMemo(
        () =>
          n.filter(
            (c, h, m) =>
              c.avatarUrl &&
              h === m.findIndex((p) => p.avatarUrl === c.avatarUrl)
          ),
        [n]
      ).slice(0, e),
      i = r[0],
      a = r[1];
    if (!i) return null;
    const o = t === "xs" ? "w-5 h-5" : "w-6 h-6",
      l = t === "xs" ? "border" : "border-2";
    return u.jsxs("div", {
      className: "flex items-center justify-center",
      children: [
        u.jsx("img", {
          src: i.avatarUrl,
          alt: i.name || "Creator",
          className: `${o} rounded-full object-cover shadow-lg border border-element-background shadow-black ${l}  z-[2]`,
        }),
        a &&
          u.jsx("img", {
            src: a.avatarUrl,
            alt: a.name || "Creator",
            className: `${o} rounded-full object-cover ${l} border-element-background shadow-lg shadow-black -ml-3 z-[1]`,
          }),
      ],
    });
  },
  VW = E.memo(
    ({
      count: n,
      x: e,
      y: t,
      onClick: s,
      creators: r = [],
      elements: i = [],
      hasEditingPermissions: a = !1,
      playbarWidth: o = 0,
    }) => {
      const [l, c] = E.useState(!0),
        [h, m] = E.useState(!1),
        [p, g] = E.useState(null),
        y = E.useRef(null),
        b = E.useRef(null);
      E.useEffect(() => {
        c(!0);
        const C = setTimeout(() => c(!1), 500);
        return () => clearTimeout(C);
      }, []);
      const w = E.useCallback(() => {
          i.length !== 0 &&
            (b.current && clearTimeout(b.current),
            (b.current = setTimeout(() => {
              if ((m(!0), y.current)) {
                const C = y.current.getBoundingClientRect();
                g({ x: C.left + C.width / 2, y: C.top - 12 });
              }
            }, 300)));
        }, [i.length]),
        S = E.useCallback(() => {
          b.current && (clearTimeout(b.current), (b.current = null)),
            m(!1),
            g(null);
        }, []),
        _ = i.slice(0, 3),
        R =
          h && p && _.length > 0
            ? ri.createPortal(
                u.jsx("div", {
                  className: "pointer-events-none overflow-visible",
                  style: {
                    position: "fixed",
                    left: `${p.x}px`,
                    top: `${p.y}px`,
                    transform: "translate(-50%, -100%)",
                    zIndex: 99999,
                  },
                  children: u.jsx("div", {
                    className: "relative",
                    style: { height: Ln * 1.2, width: Ln * 3 },
                    children: u.jsx(Qg, {
                      children: _.map((C, D) => {
                        const L = _.length,
                          P = 7,
                          V = L > 1 ? (P * 2) / (L - 1) : 0,
                          N = -P + D * V,
                          W = Ln * 0.6 * (D - (L - 1) / 2);
                        return u.jsx(
                          "div",
                          {
                            style: {
                              position: "absolute",
                              width: Ln,
                              left: "50%",
                              bottom: 0,
                              transform: `translateX(calc(-50% + ${W}px)) rotate(${N}deg)`,
                              transformOrigin: "bottom center",
                            },
                            children: u.jsx(la.div, {
                              initial: { scale: 0, opacity: 0 },
                              animate: { scale: 1, opacity: 1 },
                              exit: { scale: 0, opacity: 0 },
                              transition: {
                                type: "spring",
                                stiffness: 400,
                                damping: 25,
                                delay: D * 0.05,
                              },
                              children: u.jsx(Lw, {
                                element: C,
                                hasEditingPermissions: a,
                                playbarWidth: o,
                                isReplyElement: !1,
                                width: Ln,
                                disableAnimations: !0,
                              }),
                            }),
                          },
                          C.id
                        );
                      }),
                    }),
                  }),
                }),
                document.body
              )
            : null;
      return u.jsxs(u.Fragment, {
        children: [
          u.jsx("div", {
            ref: y,
            className: Le(
              "absolute -translate-x-1/2 z-[2]",
              "bg-element-background rounded-full cursor-pointer",
              "element-border shadow-lg",
              "text-white font-medium select-none group",
              l && "animate-springIn"
            ),
            style: {
              left: `${e}%`,
              top: `${t}px`,
              width: `${yF}px`,
              height: `${yF}px`,
              pointerEvents: "auto",
            },
            onClick: (C) => {
              C.stopPropagation(), s();
            },
            onMouseEnter: w,
            onMouseLeave: S,
            title: `${n} annotations grouped - click to expand`,
            children: u.jsxs("div", {
              className:
                "h-full w-full rounded-full flex items-center justify-center relative group-hover:bg-inbetween-background",
              children: [
                u.jsx("span", {
                  className:
                    "text-lg absolute group-hover:opacity-0 transition-opacity duration-150",
                  children: n,
                }),
                r.length > 0 &&
                  u.jsx("div", {
                    className:
                      "absolute opacity-0 group-hover:opacity-100 transition-opacity duration-75",
                    children: u.jsx(ETe, {
                      creators: r,
                      maxVisible: 2,
                      size: "sm",
                    }),
                  }),
              ],
            }),
          }),
          R,
        ],
      });
    }
  );
VW.displayName = "GroupIndicator";
function P4(n, e, t, s) {
  if (n.length === 0)
    return { groups: [], collapsed: [], ungroupedThreads: [] };
  const r = t * e,
    i = (Ln / r) * 100,
    a = (Cie / r) * 100,
    o = [...n].sort((c, h) => c.positionPercent - h.positionPercent),
    l = (c, h = 4) => {
      const m = Math.pow(10, h);
      return Math.round(c * m) / m;
    };
  o.map((c) => ({
    type: "thread",
    positionPercent: l(c.positionPercent),
    widthPercent: l(i),
    threads: [c],
  }));
  {
    const c = (Iie / r) * 100,
      h = a,
      m = [];
    for (let C = 0; C < o.length; C++) {
      const D = o[C];
      let L = i,
        P = "single";
      for (let V = 0; V < m.length; V++) {
        const N = m[V],
          W = Math.abs(D.positionPercent - N.center),
          H = (i + N.width) / 2;
        if (W < H) {
          const z = (c + N.width) / 2;
          if (W >= z) {
            (L = c), (P = "collapsed");
            break;
          } else {
            (L = c), (P = "collapsed");
            break;
          }
        }
      }
      m.push({ kind: P, center: D.positionPercent, width: L, threads: [D] });
    }
    const p = [];
    let g = [...m].sort((C, D) => C.center - D.center),
      y = 0;
    const b = 8,
      w = i * 0.3,
      S = i * 0.1;
    for (; y < g.length; ) {
      const C = g[y];
      let D = y + 1;
      const L = [C];
      for (; D < g.length; ) {
        const P = g[D],
          V = L[L.length - 1],
          N = Math.abs(P.center - V.center),
          W = L.length > 1 ? S : 0,
          H = (P.width + V.width) / 2 + W,
          z = L.reduce(
            (O, U) => O + U.threads.reduce((j, Q) => j + Q.elements.length, 0),
            0
          ),
          B = P.threads.reduce((O, U) => O + U.elements.length, 0),
          q = z + B;
        if (N >= H + w || q > b) break;
        if (N < H) L.push(P), D++;
        else break;
      }
      if (L.length > 1) {
        const P = L.flatMap((W) => W.threads),
          V = P.reduce((W, H) => W + H.elements.length, 0),
          N = P.reduce((W, H) => W + H.positionPercent, 0) / P.length;
        p.push({
          kind: "group",
          center: N,
          width: h,
          threads: P,
          elementCount: V,
        });
      } else p.push(L[0]);
      y = D;
    }
    const A = [],
      _ = [],
      R = [];
    for (const C of p)
      if (C.kind === "group") {
        const D = [];
        C.threads.forEach((N) => {
          N.timestamp !== void 0 && D.push(N.timestamp),
            N.timeRange && D.push(N.timeRange.start, N.timeRange.end);
        });
        const L = D.length > 0 ? Math.min(...D) : 0,
          P = D.length > 0 ? Math.max(...D) : 0,
          V = C.threads.reduce((N, W) => N + W.elements.length, 0);
        A.push({
          threads: C.threads,
          minTime: L,
          maxTime: P,
          centerPercent: C.center,
          elementCount: V,
        });
      } else if (C.kind === "collapsed")
        _.push({ threads: C.threads, centerPercent: C.center });
      else {
        const D = C.threads[0];
        R.push({
          ...D,
          linkPositionPercent: D.positionPercent,
          positionPercent: C.center,
        });
      }
    return { groups: A, collapsed: _, ungroupedThreads: R };
  }
}
const STe = h8,
  TTe = 6,
  zW = E.memo(
    ({ duration: n, hasEditingPermissions: e }) => {
      const t = Ce((w) => w.boardState.elements),
        s = vn((w) => w.isElementVisible),
        r = vn((w) => w.activeFilterIds),
        i = vn((w) => w.filterMode),
        a = pt((w) => w.timelineScale),
        o = 0,
        l = E.useMemo(() => {
          const w = [],
            S = new Set();
          return (
            Object.entries(t).forEach(([A, _]) => {
              if (!_ || !_.links || S.has(A)) return;
              const R = _.links.find((z) => z.type === "timeline");
              if (!R) return;
              if (!s(_)) {
                S.add(A);
                return;
              }
              const C = [],
                D = new Set();
              D.add(A), C.push(_), S.add(A);
              const L = [];
              Object.entries(t).forEach(([z, B]) => {
                if (!B || z === A) return;
                B.links?.some(
                  (O) => O.type === "element" && O.targetElementId === A
                ) &&
                  s(B) &&
                  (L.push(B), D.add(z), S.add(z));
              }),
                L.sort((z, B) => {
                  const q = new Date(z.createdAt || 0).getTime(),
                    O = new Date(B.createdAt || 0).getTime();
                  return q - O;
                }),
                C.push(...L);
              let P = 0,
                V,
                N,
                W,
                H;
              R.timeRange
                ? ((N = R.timeRange),
                  (W = (R.timeRange.start / n) * 100),
                  (H = (R.timeRange.end / n) * 100),
                  (P = ((R.timeRange.start + R.timeRange.end) / 2 / n) * 100))
                : R.timestamp !== void 0 &&
                  ((V = R.timestamp), (P = (R.timestamp / n) * 100)),
                D.forEach((z) => S.add(z)),
                w.push({
                  rootElementId: A,
                  elements: C,
                  positionPercent: P,
                  timestamp: V,
                  timeRange: N,
                  percentStart: W,
                  percentEnd: H,
                });
            }),
            w
          );
        }, [t, n, s, r, i]),
        c = E.useMemo(() => {
          const w = pt.getState(),
            S = Math.max(0, w.viewportWidth - (Ln / 2) * 2),
            A =
              w.playbarWidth > 0 ? w.playbarWidth / (w.timelineScale || 1) : S,
            _ = Math.round(A),
            { groups: R } = P4(l, 1, _),
            C = new Map();
          return (
            R.forEach((D) => {
              const L = D.threads[0]?.rootElementId;
              D.threads.forEach((P) => C.set(P.rootElementId, L));
            }),
            l.forEach((D) => {
              C.has(D.rootElementId) || C.set(D.rootElementId, D.rootElementId);
            }),
            C
          );
        }, [l]),
        {
          groups: h,
          collapsed: m,
          ungroupedThreads: p,
        } = E.useMemo(() => {
          const w = pt.getState(),
            S = Math.max(0, w.viewportWidth - (Ln / 2) * 2),
            A =
              w.playbarWidth > 0 ? w.playbarWidth / (w.timelineScale || 1) : S,
            _ = Math.round(A),
            R = Math.round(a * 100) / 100;
          return P4(l, R, _);
        }, [l, a, c]);
      E.useEffect(() => {
        const w = Be.getState().activeRecordingId;
        if (w) {
          const S = m.some((_) =>
              _.threads.some((R) => R.elements.some((C) => C.id === w))
            ),
            A = h.some((_) =>
              _.threads.some((R) => R.elements.some((C) => C.id === w))
            );
          (S || A) && Be.getState().clearActiveRecording();
        }
      }, [m, h]);
      const g = E.useCallback((w) => {
        const A = [...w.threads].sort((_, R) => {
          const C =
              _.timestamp ??
              (_.timeRange ? (_.timeRange.start + _.timeRange.end) / 2 : 0),
            D =
              R.timestamp ??
              (R.timeRange ? (R.timeRange.start + R.timeRange.end) / 2 : 0);
          return C - D;
        })[0]?.rootElementId;
        if (!A) {
          console.warn("[AnnotationLayer] No element found in group");
          return;
        }
        w.threads.length, tS(A);
      }, []);
      if (n <= 0 || l.length === 0) return null;
      const b = 20 + STe;
      return u.jsxs("div", {
        className: "annotation-layer-container w-full h-full",
        style: { transform: `translateY(${o}px)`, transition: "none" },
        children: [
          h.map((w, S) => {
            const A = w.threads.flatMap((D) =>
                D.elements.map((L) => ({
                  avatarUrl: L.creatorAvatarUrl,
                  name: L.creatorName,
                }))
              ),
              _ = w.threads.map((D) => D.elements[0]),
              R = w.threads
                .map((D) => D.rootElementId)
                .sort()
                .join("-"),
              C = w.threads.length;
            return u.jsx(
              VW,
              {
                count: C,
                x: w.centerPercent,
                y: b - 4 + TTe,
                onClick: () => g(w),
                creators: A,
                elements: _,
                hasEditingPermissions: e,
                playbarWidth: 0,
              },
              `group-${R}`
            );
          }),
          m.map((w, S) => {
            const A = w.threads.flatMap((_) => _.elements);
            return u.jsx(
              "div",
              {
                className: "absolute flex flex-col items-center",
                style: {
                  left: `${w.centerPercent}%`,
                  top: `${b}px`,
                  transform: "translateX(-50%)",
                  width: "48px",
                  pointerEvents: "auto",
                },
                children: u.jsx(yC, {
                  threadId: `collapsed-${S}`,
                  elements: A,
                  x: 0,
                  y: 0,
                  scale: 1,
                  hasEditingPermissions: e,
                  playbarWidth: 0,
                  isCollapsed: !0,
                }),
              },
              `collapsed-${S}`
            );
          }),
          p.map(
            ({
              rootElementId: w,
              elements: S,
              positionPercent: A,
              linkPositionPercent: _,
            }) =>
              u.jsx(
                "div",
                {
                  className:
                    "thread-annotation-group absolute flex flex-col items-center",
                  style: {
                    left: `${_ ?? A}%`,
                    top: `${b}px`,
                    transform: "translateX(-50%)",
                    width: `${Ln}px`,
                    overflow: "visible",
                  },
                  children: u.jsx(yC, {
                    threadId: w,
                    elements: S,
                    x: 0,
                    y: 0,
                    scale: 1,
                    hasEditingPermissions: e,
                    playbarWidth: 0,
                    showOnlyFirst: !1,
                  }),
                },
                w
              )
          ),
        ],
      });
    },
    (n, e) =>
      n.duration === e.duration &&
      n.hasEditingPermissions === e.hasEditingPermissions
  );
zW.displayName = "AnnotationLayer";
const _Te = E.memo(
    gq,
    (n, e) =>
      n.currentTime === e.currentTime &&
      n.duration === e.duration &&
      n.isPlaying === e.isPlaying &&
      n.hasEditingPermissions === e.hasEditingPermissions &&
      n.youtubeUrl === e.youtubeUrl &&
      n.nativeAsset === e.nativeAsset &&
      n.playbarWidth === e.playbarWidth &&
      n.timelineScale === e.timelineScale
  ),
  ATe = ({
    hasEditingPermissions: n,
    youtubeUrl: e,
    nativeAsset: t,
    onCreateLinkedFrame: s,
    onCreateElementInFrame: r,
  }) => {
    const i = E.useRef(null),
      a = E.useRef(null),
      o = E.useRef(null),
      l = E.useRef(null),
      c = E.useRef(null),
      [h, m] = E.useState("none"),
      p = E.useRef("none"),
      [g, y] = E.useState(!1),
      [b, w] = E.useState(0),
      [S, A] = E.useState(0),
      [_, R] = E.useState(!1),
      [C, D] = E.useState(0),
      L = E.useRef({
        initialTouches: null,
        initialScale: 1,
        initialOffset: 20,
        initialDistance: 0,
        centerX: 0,
        lastTouchTime: 0,
      }),
      P = E.useRef({ scale: 1, offsetX: 20 }),
      V = E.useRef(0),
      N = E.useRef({ x: 0, y: 0 }),
      W = E.useRef(null),
      H = E.useRef(!1),
      z = E.useRef("none"),
      B = E.useRef(null),
      q = E.useRef("none"),
      O = Be((_e) => _e.duration),
      U = Be((_e) => _e.currentTime),
      j = Be((_e) => _e.isPlaying),
      Q = pt((_e) => _e.updateTimelineTransform),
      M = pt((_e) => _e.setDuration),
      I = pt((_e) => _e.setViewportWidth),
      F = pt((_e) => _e.setMobileState),
      Y = pt((_e) => _e.timelineScale),
      J = pt((_e) => _e.timelineOffset),
      X = pt((_e) => _e.resetAllThreadScrolls),
      Z = pt((_e) => _e.disableAutoFollow),
      te = pt((_e) => _e.isAutoFollowEnabled),
      ce = pt((_e) => _e.playbarWidth);
    Be((_e) => _e.playbackRate);
    const pe = Ce((_e) => _e.clearSelection),
      [se, be] = E.useState(() =>
        typeof window < "u" ? window.innerWidth < 768 : !1
      );
    E.useEffect(() => {
      const _e = () => be(window.innerWidth < 768);
      return (
        window.addEventListener("resize", _e),
        () => window.removeEventListener("resize", _e)
      );
    }, []),
      E.useEffect(() => {
        F(se);
      }, [se, F]);
    const K = se ? 8 : Ln / 2 + 10,
      ve = E.useCallback(() => i.current?.clientWidth || window.innerWidth, []),
      Ee = E.useCallback(() => Math.max(0, ve() - K * 2), [ve]),
      De = E.useCallback((_e) => Ee() * _e, [Ee]),
      ge = De(P.current?.scale || Y),
      re = E.useCallback(
        (_e, Ue) => {
          const He = P.current.scale;
          _e !== He && X();
          const Ze = pt.getState().scrollEnabledAtOffset;
          Ze !== null && Math.abs(Ue - Ze) > 200 && X();
          const ct = ve(),
            ft = De(_e),
            Ye = ct - K - ft,
            Ot = K,
            $t = Math.max(Ye, Math.min(Ot, Ue));
          P.current = { scale: _e, offsetX: $t };
          const wn = 0.5;
          if (
            (Math.abs($t - Ot) <= wn
              ? (q.current = "left")
              : Math.abs($t - Ye) <= wn
              ? (q.current = "right")
              : (q.current = "none"),
            o.current)
          ) {
            o.current.style.transform = `translate3d(${$t}px, 0, 0)`;
            const Bn = o.current.querySelector(
              ".timeline-element .video-playbar > div > div"
            );
            Bn && (Bn.style.width = `${De(_e)}px`);
          }
          pt.getState().disableAutoFollow(), Q(_e, $t);
        },
        [ve, De, Q, X, Z]
      );
    E.useEffect(() => {
      O > 0 && M(O);
    }, [O, M]),
      E.useEffect(() => {
        const _e = ve();
        I(_e);
      }, []),
      E.useEffect(() => {
        const _e = P.current.scale,
          Ue = P.current.offsetX;
        if (
          (Math.abs(Y - _e) > 0.001 || Math.abs(J - Ue) > 0.5) &&
          ((P.current = { scale: Y, offsetX: J }), o.current)
        ) {
          o.current.style.transform = `translate3d(${J}px, 0, 0)`;
          const He = o.current.querySelector(
            ".timeline-element .video-playbar > div > div"
          );
          He && (He.style.width = `${De(Y)}px`);
        }
      }, [Y, J, De]),
      E.useEffect(() => {
        const _e = () => {
          const { scale: Ue, offsetX: He } = P.current,
            Ve = ve();
          I(Ve), re(Ue, He);
        };
        return (
          window.addEventListener("resize", _e),
          () => window.removeEventListener("resize", _e)
        );
      }, [re, I, ve]),
      E.useEffect(() => {
        j || pt.getState().disableAutoFollow();
      }, [j]),
      E.useEffect(() => {
        if (!te || !j || O === 0) return;
        let _e = null,
          Ue = performance.now();
        const He = (Ve) => {
          if (!pt.getState().isAutoFollowEnabled) return;
          const Ze = (Ve - Ue) / 1e3;
          Ue = Ve;
          const ct = Be.getState().playbackRate || 1,
            ft = Be.getState().currentTime,
            Ye = pt.getState().duration,
            Ot = pt.getState().playbarWidth,
            $t = (Ot / Ye) * ct,
            wn = P.current.offsetX,
            Bn = P.current.scale,
            Ws = (ft / Ye) * Ot,
            ts = wn + Ws,
            Vt = ve(),
            Zt = Vt / 2;
          let ln = 1;
          const Je = ts - Zt;
          Math.abs(Je) > 10 && (Je < 0 ? (ln = 0.5) : (ln = 1.5));
          const zt = $t * ln * Ze,
            an = wn - zt,
            le = De(Bn),
            je = Vt - K - le,
            ut = Math.max(je, Math.min(K, an));
          (P.current.offsetX = ut),
            o.current &&
              (o.current.style.transform = `translate3d(${ut}px, 0, 0)`),
            Q(Bn, ut),
            pt.getState().isAutoFollowEnabled &&
              (_e = requestAnimationFrame(He));
        };
        return (
          (He.lastStoreUpdate = performance.now()),
          (_e = requestAnimationFrame(He)),
          () => {
            _e !== null && cancelAnimationFrame(_e);
          }
        );
      }, [te, j, O, ce, ve, De, Q]);
    const fe = E.useCallback(
        (_e) => {
          const Ue = p.current;
          if (Ue === "none") return;
          const He = i.current?.getBoundingClientRect();
          if (
            !He ||
            !(
              _e.clientX >= He.left &&
              _e.clientX <= He.right &&
              _e.clientY >= He.top &&
              _e.clientY <= He.bottom
            )
          )
            return;
          _e.preventDefault(), _e.stopPropagation();
          const Ze = a.current?.getBoundingClientRect();
          if (!Ze) return;
          const ct = P.current.scale,
            ft = P.current.offsetX,
            Ye = pt.getState();
          if (Ue === "primary") {
            const Ot = _e.deltaY,
              wn = ft - Ot * 1.5;
            re(ct, wn), Ye.startScrolling(), Ye.stopScrollingDelayed();
          } else if (Ue === "secondary") {
            const Ot = _e.deltaY,
              $t = _e.clientX - Ze.left,
              wn = ve(),
              Bn = Ee(),
              Ws = ($t - ft) / ct,
              ts = Ot < 0 ? 1 : -1,
              Zt = 1 + ts * 0.002 * Math.abs(Ot),
              ln = Math.max(1, Math.min(1200, ct * Zt));
            let Je = $t,
              Ge = Ws,
              mt = Je - Ge * ln;
            const zt = De(ln),
              an = wn - K - zt,
              le = K;
            ts < 0 &&
              (mt > le || mt < an) &&
              (mt > le
                ? ((Je = K), (Ge = 0))
                : mt < an && ((Je = wn - K), (Ge = Bn)),
              (mt = Je - Ge * ln)),
              re(ln, mt),
              Ye.startScrolling(),
              Ye.stopScrollingDelayed();
          }
        },
        [re, ve, De, Ee]
      ),
      ke = E.useCallback(
        (_e) => {
          if ((_e.preventDefault(), _e.stopPropagation(), p.current !== "none"))
            return;
          const Ue = a.current?.getBoundingClientRect();
          if (!Ue) return;
          W.current && clearTimeout(W.current);
          const He = pt.getState(),
            Ve = Math.abs(_e.deltaY) > 10 || Math.abs(_e.deltaX) > 10,
            Ze = P.current.scale,
            ct = P.current.offsetX,
            ft =
              _e.ctrlKey &&
              Math.abs(_e.deltaY) > 0 &&
              _e.wheelDeltaY !== void 0 &&
              Math.abs(_e.wheelDeltaY) !== Math.abs(_e.deltaY * 3);
          if (ft) {
            const Ye = _e.deltaY !== 0 ? _e.deltaY : _e.deltaX,
              Ot = _e.clientX - Ue.left,
              $t = ve(),
              wn = Ee(),
              Bn = (Ot - ct) / Ze;
            if (ft) {
              (!B.current || !B.current.isActive) &&
                (B.current = {
                  isActive: !0,
                  initialScale: Ze,
                  initialOffset: ct,
                  anchorX: Ot,
                  anchorXBase: Bn,
                });
              const Ws = B.current,
                ts = Ye < 0 ? 1 : -1,
                Vt = 1,
                Zt = Math.abs(Ye),
                ln = Math.min(1.2, Zt / 100),
                Je = Math.exp(ts * Vt * ln),
                Ge = Math.max(1, Math.min(1200, Ze * Je));
              let mt = Ws.anchorX,
                zt = Ws.anchorXBase,
                an = mt - zt * Ge;
              const le = De(Ge),
                je = $t - K - le,
                Ke = K;
              ts < 0 &&
                (an > Ke || an < je) &&
                (an > Ke
                  ? ((mt = K), (zt = 0))
                  : an < je && ((mt = $t - K), (zt = wn)),
                (an = mt - zt * Ge)),
                re(Ge, an),
                He.startScrolling(),
                He.stopScrollingDelayed();
            }
          } else {
            const Ye = _e.deltaX;
            if (((N.current.x += Ye), Math.abs(N.current.x) > 2)) {
              const $t = Ve ? 1 : 0.5,
                wn = ct - N.current.x * $t;
              re(Ze, wn),
                He.startScrolling(),
                He.stopScrollingDelayed(),
                (N.current.x = 0);
            }
            V.current = 0;
          }
          return (
            (W.current = setTimeout(() => {
              (V.current = 0),
                (N.current = { x: 0, y: 0 }),
                (z.current = "none"),
                (H.current = !1),
                B.current && B.current.isActive && (B.current.isActive = !1);
            }, 150)),
            !1
          );
        },
        [re, ve, De, Ee]
      ),
      ne = E.useCallback(
        (_e) => {
          const Ue = _e.target;
          Ue.closest(".timeline-element") ||
            Ue.closest("button") ||
            Ue.closest("[role='button']") ||
            Ue.closest("[style*='pointer-events: auto']") ||
            (pe(),
            Lt(async () => {
              const { useToolbarStore: Ve } = await Promise.resolve().then(
                () => So
              );
              return { useToolbarStore: Ve };
            }, void 0).then(({ useToolbarStore: Ve }) => {
              const Ze = Ve.getState();
              !Ze.textContent.trim() &&
                Ze.state === "focused" &&
                !Ze.editingElementId &&
                (Ze.exitToIdle(), Ze.clearText());
            }),
            y(!0),
            w(_e.clientX),
            A(P.current.offsetX));
        },
        [pe]
      ),
      ie = E.useCallback(
        (_e) => {
          if (!g) return;
          const Ue = _e.clientX - b,
            He = S + Ue,
            Ve = P.current.scale;
          re(Ve, He);
        },
        [g, b, S, re]
      ),
      Ne = E.useCallback(() => {
        y(!1);
      }, []),
      $e = E.useCallback((_e) => {
        if (_e.length < 2) return 0;
        const Ue = _e[0],
          He = _e[1],
          Ve = Ue.clientX - He.clientX,
          Ze = Ue.clientY - He.clientY;
        return Math.sqrt(Ve * Ve + Ze * Ze);
      }, []),
      ot = E.useCallback((_e) => {
        if (_e.length === 1) return { x: _e[0].clientX, y: _e[0].clientY };
        const Ue = _e[0],
          He = _e[1];
        return {
          x: (Ue.clientX + He.clientX) / 2,
          y: (Ue.clientY + He.clientY) / 2,
        };
      }, []),
      st = E.useCallback(
        (_e) => {
          const Ue = _e.target;
          if (
            Ue.closest(".timeline-element") ||
            Ue.closest("button") ||
            Ue.closest("[role='button']") ||
            Ue.closest("[style*='pointer-events: auto']")
          )
            return;
          const He = _e.touches,
            Ve = Date.now();
          R(!0),
            D(Ve),
            (L.current = {
              initialTouches: He,
              initialScale: P.current.scale,
              initialOffset: P.current.offsetX,
              initialDistance: $e(He),
              centerX: ot(He).x,
              lastTouchTime: Ve,
            }),
            pe();
        },
        [$e, ot, pe]
      ),
      ht = E.useCallback(
        (_e) => {
          if (!_ || !L.current.initialTouches) return;
          _e.preventDefault();
          const Ue = _e.touches,
            He = L.current;
          if (Ue.length === 1 && He.initialTouches.length === 1) {
            const Ve = Ue[0],
              Ze = He.initialTouches[0],
              ct = Ve.clientX - Ze.clientX,
              ft = He.initialOffset + ct;
            re(P.current.scale, ft);
          } else if (Ue.length === 2 && He.initialTouches.length === 2) {
            const Ve = $e(Ue),
              Ze = ot(Ue);
            if (He.initialDistance > 0) {
              const ct = Ve / He.initialDistance,
                ft = Math.max(1, Math.min(1200, He.initialScale * ct)),
                Ye = a.current?.getBoundingClientRect();
              if (Ye) {
                const Ot = Ze.x - Ye.left,
                  $t = (Ot - He.initialOffset) / He.initialScale,
                  wn = Ot - $t * ft;
                re(ft, wn);
              }
            }
          }
        },
        [_, $e, ot, re]
      ),
      xt = E.useCallback(
        (_e) => {
          if (!_) return;
          Date.now() - C < 200 &&
            _e.changedTouches.length === 1 &&
            Lt(async () => {
              const { useToolbarStore: Ve } = await Promise.resolve().then(
                () => So
              );
              return { useToolbarStore: Ve };
            }, void 0).then(({ useToolbarStore: Ve }) => {
              const Ze = Ve.getState();
              !Ze.textContent.trim() &&
                Ze.state === "focused" &&
                !Ze.editingElementId &&
                (Ze.exitToIdle(), Ze.clearText());
            }),
            R(!1),
            (L.current = {
              initialTouches: null,
              initialScale: 1,
              initialOffset: 20,
              initialDistance: 0,
              centerX: 0,
              lastTouchTime: 0,
            });
        },
        [_, C]
      );
    return (
      E.useEffect(() => {
        if (g)
          return (
            document.addEventListener("mousemove", ie),
            document.addEventListener("mouseup", Ne),
            () => {
              document.removeEventListener("mousemove", ie),
                document.removeEventListener("mouseup", Ne);
            }
          );
      }, [g, ie, Ne]),
      E.useEffect(() => {
        if (!i.current) return;
        const Ue = (Ze) => {
            const ct = Ze.ctrlKey || Ze.metaKey,
              ft = Ze.altKey;
            let Ye = "none";
            ft ? (Ye = "secondary") : ct && (Ye = "primary"),
              p.current !== Ye &&
                ((p.current = Ye),
                m(Ye),
                Ye !== "none" &&
                  !c.current &&
                  ((c.current = fe),
                  document.addEventListener("wheel", fe, {
                    passive: !1,
                    capture: !0,
                  })));
          },
          He = (Ze) => {
            const ct = Ze.ctrlKey || Ze.metaKey,
              ft = Ze.altKey;
            let Ye = "none";
            ft ? (Ye = "secondary") : ct && (Ye = "primary"),
              p.current !== Ye &&
                ((p.current = Ye),
                m(Ye),
                Ye === "none" &&
                  c.current &&
                  (document.removeEventListener("wheel", c.current, {
                    capture: !0,
                  }),
                  (c.current = null)));
          },
          Ve = () => {
            p.current !== "none" &&
              ((p.current = "none"),
              m("none"),
              c.current &&
                (document.removeEventListener("wheel", c.current, {
                  capture: !0,
                }),
                (c.current = null)));
          };
        return (
          document.addEventListener("keydown", Ue),
          document.addEventListener("keyup", He),
          window.addEventListener("blur", Ve),
          () => {
            document.removeEventListener("keydown", Ue),
              document.removeEventListener("keyup", He),
              window.removeEventListener("blur", Ve),
              c.current &&
                (document.removeEventListener("wheel", c.current, {
                  capture: !0,
                }),
                (c.current = null));
          }
        );
      }, [fe]),
      E.useEffect(() => {
        if (!a.current || !i.current) return;
        l.current = ke;
        const _e = i.current,
          Ue = a.current;
        (_e.style.touchAction = se ? "manipulation" : "none"),
          (_e.style.userSelect = "none"),
          (Ue.style.touchAction = se ? "manipulation" : "none"),
          (Ue.style.userSelect = "none"),
          _e.addEventListener("wheel", ke, { passive: !1 });
        const He = (Ve) => (Ve.preventDefault(), !1);
        return (
          document.addEventListener("gesturestart", He, { passive: !1 }),
          document.addEventListener("gesturechange", He, { passive: !1 }),
          document.addEventListener("gestureend", He, { passive: !1 }),
          () => {
            W.current && clearTimeout(W.current),
              _e && _e.removeEventListener("wheel", ke),
              _e && ((_e.style.touchAction = ""), (_e.style.userSelect = "")),
              Ue && ((Ue.style.touchAction = ""), (Ue.style.userSelect = "")),
              (V.current = 0),
              (N.current = { x: 0, y: 0 }),
              document.removeEventListener("gesturestart", He),
              document.removeEventListener("gesturechange", He),
              document.removeEventListener("gestureend", He);
          }
        );
      }, [ke, se]),
      u.jsxs("div", {
        ref: i,
        className: "relative w-full h-full overflow-hidden",
        style: { backgroundColor: "#0a0a0a" },
        onMouseDown: ne,
        onTouchStart: st,
        onTouchMove: ht,
        onTouchEnd: xt,
        children: [
          u.jsx(Lye, { offsetX: J, offsetY: 0 }),
          u.jsx("div", {
            className:
              "absolute pointer-events-none bg-gradient-to-b from-card-background to-transparent",
            style: {
              left: "50%",
              transform: "translateX(-50%)",
              top: "60px",
              width: "100000px",
              height: "96px",
              zIndex: 0,
              opacity: 1,
            },
          }),
          u.jsx("div", {
            ref: a,
            className: "absolute inset-0 flex items-start justify-start pt-8",
            style: { cursor: g ? "grabbing" : "grab" },
            children: u.jsx("div", {
              ref: o,
              className: "relative",
              style: {
                transform: `translate3d(${J}px, 0, 0)`,
                transition: "none",
                willChange: "transform",
                minHeight: "600px",
                height: "auto",
              },
              children: u.jsxs("div", {
                className: "timeline-element",
                style: { position: "relative" },
                children: [
                  u.jsx(_Te, {
                    currentTime: U,
                    duration: O,
                    isPlaying: j,
                    playbarWidth: ge,
                    hasEditingPermissions: n,
                    youtubeUrl: e,
                    nativeAsset: t,
                    onCreateLinkedFrame: s,
                    onCreateElementInFrame: r,
                    preventSeekOnLinkClick: !1,
                    timelineScale: Y,
                  }),
                  u.jsx("div", {
                    style: {
                      position: "absolute",
                      top: "100%",
                      left: 0,
                      width: "100%",
                      pointerEvents: "none",
                    },
                    children: u.jsx(zW, {
                      duration: O,
                      hasEditingPermissions: n,
                    }),
                  }),
                ],
              }),
            }),
          }),
        ],
      })
    );
  },
  RTe = ({ teamType: n }) => {
    const [e, t] = E.useState(!1),
      s = es();
    if (n === "pro_team") return null;
    const r = () => {
      window.open("https://flask.do/#pricing", "_blank", "noopener,noreferrer"),
        t(!1);
    };
    return u.jsxs(u.Fragment, {
      children: [
        u.jsx("div", {
          className: "pointer-events-none",
          children: u.jsx("div", {
            className: "p-2",
            children: u.jsxs("div", {
              className:
                "relative px-3 py-2 pr-1.5 bg-card-background group border rounded-full pointer-events-auto group cursor-pointer overflow-hidden",
              onClick: () => s("/"),
              children: [
                u.jsx("img", {
                  src: "/images/flasklogo.png",
                  alt: "Flask",
                  className:
                    "absolute left-0 bottom- -translate-y-1 h-20 mb-2 object-contain pointer-events-none",
                }),
                u.jsxs("div", {
                  className: "relative flex items-center gap-2 pl-12",
                  children: [
                    u.jsxs("p", {
                      className:
                        "text-xs text-text-secondary group-hover:text-text-primary transition-all whitespace-nowrap",
                      children: [
                        "You're using ",
                        u.jsx("span", {
                          className: "underline",
                          children: "Flask",
                        }),
                        ". Pretty cool, huh?",
                      ],
                    }),
                    u.jsx("button", {
                      onClick: (i) => {
                        i.stopPropagation(), t(!0);
                      },
                      className:
                        "relative z-10 p-1 rounded-full bg-element-background transition-colors duration-200 ml-auto",
                      "aria-label": "About Flask branding",
                      children: u.jsx(Pa, {
                        className:
                          "h-3 w-3 text-text-secondary/50 hover:text-text-secondary",
                      }),
                    }),
                  ],
                }),
              ],
            }),
          }),
        }),
        u.jsx(os, {
          open: e,
          onOpenChange: t,
          children: u.jsxs(Jn, {
            className: "sm:max-w-[425px]",
            children: [
              u.jsx(bs, {
                children: u.jsx(xs, { children: "Flask Branding" }),
              }),
              u.jsx("div", {
                className: "text-sm text-muted-foreground",
                children:
                  "Flasks created on a free plan include this Flask branding.",
              }),
              u.jsx("div", {
                className: "text-sm text-muted-foreground",
                children:
                  "This helps us share the product with more people and keep it free.",
              }),
              u.jsx("div", {
                className: "text-sm text-muted-foreground",
                children:
                  "To create Flasks without this branding, discover Flask Pro.",
              }),
              u.jsxs(xr, {
                className: "gap-2",
                children: [
                  u.jsx(et, {
                    variant: "ghost",
                    onClick: () => t(!1),
                    children: "Cancel",
                  }),
                  u.jsx(et, {
                    variant: "default",
                    onClick: r,
                    autoFocus: !0,
                    children: "About Flask Pro",
                  }),
                ],
              }),
            ],
          }),
        }),
      ],
    });
  },
  kTe = {
    "accent-purple": "#a78bfa",
    "accent-blue": "#60a5fa",
    "accent-teal": "#5eead4",
    "accent-green": "#4ade80",
    "accent-lime": "#bef264",
    "accent-orange": "#fdba74",
    "accent-red": "#f87171",
    "accent-gray": "#a1a1aa",
  },
  CTe = ({ hasEditingPermissions: n = !1 }) => {
    const e = Ce((ne) => ne.boardState.tags || {}),
      t = Object.values(e),
      s = Ce(),
      r = Ce((ne) => ne.unseenElementIds),
      i = E.useMemo(() => _7(s), [s.boardState.elements]),
      a = E.useMemo(() => A7(s), [r]),
      o = E.useMemo(
        () =>
          t.map((ne) => ({
            id: ne.id,
            type: "tag",
            name: ne.name,
            color: ne.color,
          })),
        [t]
      ),
      l = E.useMemo(() => [...i, ...a, ...o], [i, a, o]),
      c = vn((ne) => ne.addFilter),
      h = vn((ne) => ne.removeFilter),
      m = vn((ne) => ne.isFilterActive),
      p = vn((ne) => ne.isFilteringActive),
      g = vn((ne) => ne.filterMode),
      y = vn((ne) => ne.setFilterMode),
      b = Ce((ne) => ne.deleteTag),
      w = Ce((ne) => ne.renameTag),
      S = Ce((ne) => ne.changeTagColor),
      A = Ce((ne) => ne.getElementsWithTag),
      _ = Ce((ne) => ne.createTag),
      [R, C] = E.useState(""),
      [D, L] = E.useState(0),
      [P, V] = E.useState(null),
      [N, W] = E.useState(!1),
      H = g === "include" ? "is" : "is-not",
      [z, B] = E.useState({
        isOpen: !1,
        tagId: null,
        tagName: "",
        elementCount: 0,
      }),
      [q, O] = E.useState({ isOpen: !1, tagId: null, tagName: "" }),
      [U, j] = E.useState(!1),
      Q = E.useRef(null),
      M = p(),
      I = E.useMemo(
        () =>
          M
            ? l.filter((ne) => {
                const ie = m(ne.id);
                return H === "is" ? ie : !ie;
              })
            : [],
        [M, l, m, H]
      ),
      F = E.useMemo(
        () => l.filter((ne) => ne.name.toLowerCase().includes(R.toLowerCase())),
        [l, R]
      ),
      Y =
        R.trim() &&
        !t.some((ne) => ne.name.toLowerCase() === R.trim().toLowerCase()),
      J = F.length + (Y ? 1 : 0),
      X = () => {
        const ne = [
            "accent-purple",
            "accent-blue",
            "accent-teal",
            "accent-green",
            "accent-lime",
            "accent-orange",
            "accent-red",
          ],
          ie = new Set(t.map(($e) => $e.color));
        let Ne = ne.find(($e) => !ie.has($e));
        if (!Ne) {
          const $e = t.length % ne.length;
          Ne = ne[$e];
        }
        return Ne;
      };
    E.useEffect(() => {
      setTimeout(() => Q.current?.focus(), 0);
    }, []),
      E.useEffect(() => {
        L(0);
      }, [R]);
    const Z = E.useCallback(
        (ne) => {
          M && m(ne) ? h(ne) : c(ne);
        },
        [M, H, m, c, h]
      ),
      te = E.useCallback(async () => {
        const ne = R.trim();
        if (ne && !N) {
          W(!0);
          try {
            (await _(ne)) && C("");
          } finally {
            W(!1);
          }
        }
      }, [R, N, _]),
      ce = E.useCallback(
        (ne) => {
          ne < F.length ? (Z(F[ne].id), C("")) : Y && ne === F.length && te();
        },
        [F, Z, Y, te]
      ),
      pe = E.useCallback(
        (ne, ie) => {
          ie && (ie.preventDefault(), ie.stopPropagation()), h(ne);
        },
        [h]
      ),
      se = (ne, ie) => {
        const Ne = A(ne);
        if (Ne.length === 0) {
          b(ne);
          return;
        }
        B({ isOpen: !0, tagId: ne, tagName: ie, elementCount: Ne.length });
      },
      be = () => {
        z.tagId && b(z.tagId);
      },
      K = () => {
        B({ isOpen: !1, tagId: null, tagName: "", elementCount: 0 });
      },
      ve = (ne, ie) => {
        O({ isOpen: !0, tagId: ne, tagName: ie });
      },
      Ee = async (ne) => {
        if (q.tagId) {
          j(!0);
          try {
            await w(q.tagId, ne), O({ isOpen: !1, tagId: null, tagName: "" });
          } catch (ie) {
            console.error("Failed to rename tag:", ie);
          } finally {
            j(!1);
          }
        }
      },
      De = () => {
        U || O({ isOpen: !1, tagId: null, tagName: "" });
      },
      ge = async (ne, ie) => {
        try {
          await S(ne, ie);
        } catch (Ne) {
          console.error("Failed to change tag color:", Ne);
        }
      },
      re = [
        { name: "Purple", value: "accent-purple" },
        { name: "Blue", value: "accent-blue" },
        { name: "Teal", value: "accent-teal" },
        { name: "Green", value: "accent-green" },
        { name: "Lime", value: "accent-lime" },
        { name: "Orange", value: "accent-orange" },
        { name: "Red", value: "accent-red" },
      ];
    E.useEffect(() => {
      const ne = (ie) => {
        q.isOpen ||
          z.isOpen ||
          (J !== 0 &&
            (ie.key === "ArrowDown"
              ? (ie.preventDefault(),
                ie.stopPropagation(),
                L((Ne) => (Ne + 1) % J))
              : ie.key === "ArrowUp"
              ? (ie.preventDefault(),
                ie.stopPropagation(),
                L((Ne) => (Ne - 1 + J) % J))
              : ie.key === "Enter" &&
                (ie.preventDefault(), ie.stopPropagation(), ce(D))));
      };
      return (
        window.addEventListener("keydown", ne, !0),
        () => window.removeEventListener("keydown", ne, !0)
      );
    }, [D, J, ce, q.isOpen, z.isOpen]);
    const fe = (ne) => {
        if (!M) return !1;
        const ie = m(ne);
        return H === "is" ? ie : !ie;
      },
      ke = (ne) => {
        if (ne.type === "apptag") {
          if (ne.appTagType === "creator")
            return u.jsx(Fr, {
              text: ne.name,
              type: "apptag",
              appTagType: "creator",
              image: ne.avatarUrl,
            });
          if (ne.appTagType === "time") {
            const ie = ne.appTagValue === "new";
            return u.jsx(Fr, {
              text: ne.name,
              type: "apptag",
              appTagType: "creationTime",
              icon: u.jsx(Lg, { size: 12 }),
              showNewIndicator: ie,
            });
          }
        }
        return u.jsx(Fr, { text: ne.name, type: "tag", color: ne.color });
      };
    return u.jsxs("div", {
      className:
        "w-[260px] animate-in fade-in-0 slide-in-from-bottom-2 duration-200",
      children: [
        u.jsxs("div", {
          className:
            "w-full bg-inbetween-background element-border shadow-xl shadow-black/50 rounded-3xl",
          children: [
            u.jsx("div", {
              className: "overflow-y-auto py-3",
              children:
                F.length === 0 && !Y
                  ? u.jsx("div", {
                      className: "px-3 py-2 text-xs text-text-secondary",
                      children: R ? "No filters found" : "No filters available",
                    })
                  : u.jsxs(u.Fragment, {
                      children: [
                        F.map((ne, ie) => {
                          const Ne = fe(ne.id),
                            $e = ie === D,
                            ot = P === ne.id;
                          ne.type;
                          const st = ne.type === "tag",
                            ht = ie > 0 ? F[ie - 1] : null,
                            xt =
                              !R &&
                              ne.appTagType === "creator" &&
                              (!ht || ht.appTagType !== "creator"),
                            _e =
                              !R &&
                              ne.appTagType === "time" &&
                              (!ht || ht.appTagType !== "time"),
                            Ue = !R && st && (!ht || ht.type !== "tag");
                          return u.jsxs(
                            de.Fragment,
                            {
                              children: [
                                xt &&
                                  u.jsx("div", {
                                    className:
                                      "px-4 pt-2 pb-1 text-[10px] font-semibold text-text-secondary uppercase tracking-wider",
                                    children: "Created by",
                                  }),
                                _e &&
                                  u.jsx("div", {
                                    className:
                                      "px-4 pt-2 pb-1 text-[10px] font-semibold text-text-secondary uppercase tracking-wider",
                                    children: "Creation time",
                                  }),
                                Ue &&
                                  u.jsx("div", {
                                    className:
                                      "px-4 pt-2 pb-1 text-[10px] font-semibold text-text-secondary uppercase tracking-wider",
                                    children: "Tags",
                                  }),
                                u.jsxs("div", {
                                  className: Le(
                                    "flex items-center justify-between pr-3 pl-1.5 py-1.5 cursor-pointer transition-colors rounded-3xl mx-2",
                                    $e && "bg-white/10",
                                    !$e && "hover:bg-white/5"
                                  ),
                                  onClick: () => ce(ie),
                                  onMouseEnter: () => {
                                    L(ie), V(ne.id);
                                  },
                                  onMouseLeave: () => V(null),
                                  children: [
                                    ke(ne),
                                    u.jsxs("div", {
                                      className: "flex items-center gap-2",
                                      children: [
                                        n && ot && st
                                          ? u.jsxs(Ii, {
                                              modal: !1,
                                              children: [
                                                u.jsx(Li, {
                                                  asChild: !0,
                                                  onClick: (He) =>
                                                    He.stopPropagation(),
                                                  children: u.jsx("button", {
                                                    className:
                                                      "w-5 h-5 flex items-center justify-center hover:bg-white/10 rounded transition-colors",
                                                    children: u.jsx(cL, {
                                                      className:
                                                        "w-4 h-4 text-text-secondary",
                                                    }),
                                                  }),
                                                }),
                                                u.jsxs(ui, {
                                                  align: "start",
                                                  side: "bottom",
                                                  sideOffset: 4,
                                                  className: "min-w-[140px]",
                                                  children: [
                                                    u.jsxs(jn, {
                                                      className:
                                                        "text-text-primary focus:text-text-primary gap-2",
                                                      onClick: (He) => {
                                                        He.stopPropagation(),
                                                          ve(ne.id, ne.name);
                                                      },
                                                      children: [
                                                        u.jsx(Dg, {
                                                          className: "w-4 h-4",
                                                        }),
                                                        u.jsx("span", {
                                                          children:
                                                            "Rename tag",
                                                        }),
                                                      ],
                                                    }),
                                                    u.jsxs(ZL, {
                                                      children: [
                                                        u.jsxs(jE, {
                                                          className:
                                                            "text-text-primary focus:text-text-primary gap-2",
                                                          children: [
                                                            u.jsx(NH, {
                                                              className:
                                                                "w-4 h-4",
                                                            }),
                                                            u.jsx("span", {
                                                              children: "Color",
                                                            }),
                                                          ],
                                                        }),
                                                        u.jsx(FE, {
                                                          className:
                                                            "min-w-[120px]",
                                                          children: re.map(
                                                            (He) =>
                                                              u.jsxs(
                                                                jn,
                                                                {
                                                                  className:
                                                                    "text-text-primary focus:text-text-primary gap-2",
                                                                  onClick: (
                                                                    Ve
                                                                  ) => {
                                                                    Ve.stopPropagation(),
                                                                      ge(
                                                                        ne.id,
                                                                        He.value
                                                                      );
                                                                  },
                                                                  children: [
                                                                    u.jsx(
                                                                      "div",
                                                                      {
                                                                        className:
                                                                          "w-4 h-4 rounded-full border border-white/20",
                                                                        style: {
                                                                          backgroundColor:
                                                                            kTe[
                                                                              He
                                                                                .value
                                                                            ],
                                                                        },
                                                                      }
                                                                    ),
                                                                    u.jsx(
                                                                      "span",
                                                                      {
                                                                        children:
                                                                          He.name,
                                                                      }
                                                                    ),
                                                                    ne.color ===
                                                                      He.value &&
                                                                      u.jsx(
                                                                        "span",
                                                                        {
                                                                          className:
                                                                            "ml-auto text-xs",
                                                                          children:
                                                                            "",
                                                                        }
                                                                      ),
                                                                  ],
                                                                },
                                                                He.value
                                                              )
                                                          ),
                                                        }),
                                                      ],
                                                    }),
                                                    u.jsxs(jn, {
                                                      className:
                                                        "text-text-primary focus:text-text-primary gap-2",
                                                      onClick: (He) => {
                                                        He.stopPropagation(),
                                                          se(ne.id, ne.name);
                                                      },
                                                      children: [
                                                        u.jsx(Mg, {
                                                          className: "w-4 h-4",
                                                        }),
                                                        u.jsx("span", {
                                                          children:
                                                            "Delete tag",
                                                        }),
                                                      ],
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            })
                                          : u.jsx("div", {
                                              className: "w-5 h-5",
                                            }),
                                        u.jsx("div", {
                                          className: Le(
                                            "w-4 h-4 border rounded-sm flex items-center justify-center transition-colors",
                                            Ne
                                              ? "bg-text-secondary text-card-background"
                                              : "border-text-secondary/50"
                                          ),
                                          children:
                                            Ne &&
                                            u.jsx("span", {
                                              className: "text-xs",
                                              children: "",
                                            }),
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            },
                            ne.id
                          );
                        }),
                        Y &&
                          u.jsx("div", {
                            className: Le(
                              "flex items-center justify-between pr-3 pl-1.5 py-1.5 cursor-pointer transition-colors border-t border-border/30 mt-1 mx-2 rounded-3xl",
                              D === F.length && "bg-white/10",
                              D !== F.length && "hover:bg-white/5"
                            ),
                            onClick: te,
                            onMouseEnter: () => L(F.length),
                            children: u.jsxs("div", {
                              className: "flex items-center gap-2",
                              children: [
                                u.jsx(Zu, {
                                  size: 14,
                                  className: "text-text-secondary ml-1",
                                }),
                                u.jsx("span", {
                                  className: "text-xs text-text-secondary",
                                  children: "Create Tag ",
                                }),
                                u.jsx(Fr, {
                                  text: R.trim(),
                                  type: "tag",
                                  color: X(),
                                }),
                              ],
                            }),
                          }),
                      ],
                    }),
            }),
            u.jsx("div", {
              className: "px-3 pt-3",
              children: u.jsxs("div", {
                className:
                  "flex items-center gap-1  text-xs text-text-secondary font-medium",
                children: [
                  u.jsx("span", { children: "Tag" }),
                  u.jsxs(Ii, {
                    modal: !1,
                    children: [
                      u.jsx(Li, {
                        asChild: !0,
                        children: u.jsxs("button", {
                          className:
                            "inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-border/30 hover:bg-border/50 transition-colors",
                          children: [
                            u.jsx("span", {
                              className: "text-text-secondary text-xs",
                              children:
                                H === "is" ? "contains" : "does not contain",
                            }),
                            u.jsx(cd, {
                              className: "w-3 h-3 text-text-secondary",
                            }),
                          ],
                        }),
                      }),
                      u.jsxs(ui, {
                        align: "start",
                        side: "top",
                        sideOffset: 4,
                        children: [
                          u.jsx(jn, {
                            onClick: () => y("include"),
                            children: "contains",
                          }),
                          u.jsx(jn, {
                            onClick: () => y("exclude"),
                            children: "does not contain",
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
            u.jsx("div", {
              className: "p-2 ",
              children: u.jsxs("div", {
                className:
                  "flex flex-wrap gap-1.5 items-center min-h-[44px] px-3 py-2 rounded-3xl bg-card-background element-border",
                children: [
                  I.map((ne) =>
                    u.jsx(
                      de.Fragment,
                      {
                        children:
                          ne.type === "apptag" && ne.appTagType === "creator"
                            ? u.jsx(Fr, {
                                text: ne.name,
                                type: "apptag",
                                appTagType: "creator",
                                image: ne.avatarUrl,
                                showRemove: !0,
                                onRemove: (ie) => pe(ne.id, ie),
                              })
                            : ne.type === "apptag" && ne.appTagType === "time"
                            ? u.jsx(Fr, {
                                text: ne.name,
                                type: "apptag",
                                appTagType: "creationTime",
                                icon: u.jsx(Lg, { size: 12 }),
                                showNewIndicator: ne.appTagValue === "new",
                                showRemove: !0,
                                onRemove: (ie) => pe(ne.id, ie),
                              })
                            : u.jsx(Fr, {
                                text: ne.name,
                                type: "tag",
                                color: ne.color,
                                showRemove: !0,
                                onRemove: (ie) => pe(ne.id, ie),
                              }),
                      },
                      ne.id
                    )
                  ),
                  u.jsx("input", {
                    ref: Q,
                    type: "text",
                    value: R,
                    onChange: (ne) => C(ne.target.value),
                    onKeyDown: (ne) => {
                      if ((ne.stopPropagation(), ne.key === "Escape")) C("");
                      else if (
                        ne.key === "Backspace" &&
                        R === "" &&
                        I.length > 0
                      ) {
                        const ie = I[I.length - 1];
                        pe(ie.id);
                      }
                    },
                    className:
                      " pl-22flex-1 min-w-[60px] bg-transparent outline-none text-xs text-text-primary placeholder:text-text-secondary/60",
                    placeholder:
                      I.length === 0 ? "Search or Create Tags..." : "",
                  }),
                ],
              }),
            }),
          ],
        }),
        u.jsx(kW, {
          isOpen: z.isOpen,
          onClose: K,
          onConfirm: be,
          tagName: z.tagName,
          elementCount: z.elementCount,
        }),
        u.jsx(CW, {
          isOpen: q.isOpen,
          onClose: De,
          onConfirm: Ee,
          currentName: q.tagName,
          isRenaming: U,
        }),
      ],
    });
  },
  ITe = () => {
    const n = pt((L) => L.timelineScale),
      e = pt((L) => L.timelineOffset),
      t = pt((L) => L.viewportWidth),
      s = pt((L) => L.playbarWidth),
      r = pt((L) => L.updateTimelineTransform),
      i = E.useRef(null),
      a = E.useRef(!1),
      [o, l] = E.useState(!1),
      [c, h] = E.useState(() => window.innerWidth < 768);
    E.useEffect(() => {
      const L = () => h(window.innerWidth < 768);
      return (
        window.addEventListener("resize", L),
        () => window.removeEventListener("resize", L)
      );
    }, []);
    const p = typeof window < "u" && window.innerWidth < 768 ? 8 : Ln / 2 + 10,
      g = E.useCallback(
        (L) => {
          if (!i.current || a.current) return;
          const P = i.current.getBoundingClientRect(),
            N = (L.clientX - P.left) / P.width,
            W = p,
            H = t - p - s,
            z = W + N * (H - W);
          r(n, z);
        },
        [n, t, s, r]
      ),
      y = E.useCallback(
        (L) => {
          L.stopPropagation(), L.preventDefault(), (a.current = !0), l(!0);
          const P = L.clientX,
            V = e,
            N = (H) => {
              if (!i.current) return;
              const z = H.clientX - P,
                B = i.current.clientWidth,
                q = p,
                U = t - p - s - q,
                Q = (z / B) * U,
                M = V + Q;
              r(n, M);
            },
            W = () => {
              (a.current = !1),
                l(!1),
                document.removeEventListener("mousemove", N),
                document.removeEventListener("mouseup", W),
                (document.body.style.cursor = "");
            };
          document.addEventListener("mousemove", N),
            document.addEventListener("mouseup", W),
            (document.body.style.cursor = "grabbing");
        },
        [e, n, t, s, r]
      ),
      b = n > 1 && s > t,
      w = Math.max(2, (t / s) * 100),
      S = p,
      A = t - p - s;
    let _ = 0;
    A < S && ((_ = (e - S) / (A - S)), (_ = Math.max(0, Math.min(1, _))));
    const R = 100 - w,
      C = _ * R,
      D = o
        ? "border-text-primary"
        : "border-text-primary/30 hover:border-text-primary/30";
    return c
      ? null
      : u.jsx("div", {
          ref: i,
          className:
            "group relative w-full rounded-full cursor-pointer transition-all duration-200",
          style: {
            height: "6px",
            opacity: b ? 1 : 0,
            pointerEvents: b ? "auto" : "none",
          },
          onMouseDown: g,
          onMouseEnter: (L) => {
            L.currentTarget.style.height = "12px";
          },
          onMouseLeave: (L) => {
            L.currentTarget.style.height = "6px";
          },
          children: u.jsx("div", {
            className: `absolute top-0 h-full ${D} bg-card-background border rounded-full transition-colors duration-150`,
            style: { width: `${w}%`, left: `${C}%`, cursor: "grab" },
            onMouseDown: y,
          }),
        });
  },
  LTe = ({ hasEditingPermissions: n, teamType: e }) => {
    const [t, s] = E.useState(!1),
      r = vn((D) => D.isFilterToolbarOpen),
      i = vn((D) => D.toggleFilterToolbar),
      a = vn((D) => D.clearAllFilters),
      o = vn((D) => D.addFilter),
      l = vn((D) => D.setFilterMode);
    vn((D) => D.getVisibleElementCount);
    const c = vn((D) => D.activeFilterIds),
      h = vn((D) => D.filterMode),
      m = vn((D) => D.isFilteringActive)(),
      p = Ce((D) => D.boardState.tags || {}),
      g = Ce(),
      y = Ce((D) => D.unseenElementIds),
      b = E.useMemo(() => _7(g), [g.boardState.elements]),
      w = E.useMemo(() => A7(g), [y]),
      S = Object.values(p),
      A = () => {
        a(), l("include"), o("apptag:time:new"), s(!0);
      },
      _ = y.size > 0 && !t,
      R = E.useMemo(() => {
        const D = [];
        return (
          c.forEach((L) => {
            if (L.startsWith("apptag:creator:")) {
              const P = b.find((V) => V.id === L);
              P && D.push(P);
            } else if (L.startsWith("apptag:time:")) {
              const P = w.find((V) => V.id === L);
              P && D.push(P);
            } else {
              const P = S.find((V) => V.id === L);
              P &&
                D.push({ id: P.id, name: P.name, color: P.color, type: "tag" });
            }
          }),
          D
        );
      }, [c, b, w, S]),
      C = (D) =>
        D.type === "tag"
          ? u.jsx(Fr, { text: D.name, type: "tag", color: D.color }, D.id)
          : D.appTagType === "creator"
          ? u.jsx(
              Fr,
              {
                text: D.name,
                type: "apptag",
                appTagType: "creator",
                image: D.avatarUrl,
              },
              D.id
            )
          : D.appTagType === "time"
          ? u.jsx(
              Fr,
              {
                text: D.name,
                type: "apptag",
                appTagType: "creationTime",
                icon: u.jsx(Lg, { size: 12 }),
                showNewIndicator: D.appTagValue === "new",
              },
              D.id
            )
          : null;
    return u.jsxs(Br, {
      delayDuration: 0,
      children: [
        u.jsx("div", {
          className: "hidden md:block fixed -bottom-0.5 left-0 z-50",
          children: u.jsx(RTe, { teamType: e }),
        }),
        _ &&
          u.jsx("div", {
            className:
              "hidden md:flex fixed bottom-28 left-1/2 -translate-x-1/2 z-50",
            children: u.jsx("div", {
              className: "pointer-events-none",
              children: u.jsx("div", {
                className:
                  "relative px-6 py-2 pr-2 bg-card-background group border rounded-full pointer-events-auto",
                children: u.jsxs("div", {
                  className: "relative flex items-center gap-2",
                  children: [
                    u.jsxs("p", {
                      className:
                        "text-xs text-text-secondary whitespace-nowrap",
                      children: [
                        u.jsx("span", {
                          className: "text-primary",
                          children: y.size,
                        }),
                        " new comment since last access",
                      ],
                    }),
                    u.jsx(et, {
                      onClick: A,
                      className: "h-7 px-4 text-xs button-primary rounded-full",
                      variant: "default",
                      children: "Show",
                    }),
                    u.jsx("button", {
                      onClick: (D) => {
                        D.stopPropagation(), s(!0);
                      },
                      className:
                        "relative z-10 p-1 rounded-full bg-element-background transition-colors duration-200",
                      "aria-label": "Dismiss new elements indicator",
                      children: u.jsx(Pa, {
                        className:
                          "h-3 w-3 text-text-secondary/50 hover:text-text-secondary",
                      }),
                    }),
                  ],
                }),
              }),
            }),
          }),
        u.jsx("div", {
          className:
            "hidden md:flex fixed bottom-2 right-2 z-50 items-center gap-2",
          children: u.jsxs(Ii, {
            modal: !1,
            open: r,
            onOpenChange: i,
            children: [
              u.jsx(Li, {
                asChild: !0,
                children: u.jsx("div", {
                  children: m
                    ? u.jsxs("button", {
                        className:
                          "flex items-start cursor-pointer transition-all duration-200 ease-out button-primary rounded-[20px] px-4 py-2 gap-2 min-h-[40px] max-w-[400px]",
                        type: "button",
                        children: [
                          u.jsx(AU, {
                            className: "h-4 w-4 flex-shrink-0 mt-1",
                          }),
                          u.jsxs("div", {
                            className:
                              "flex-1 flex flex-wrap items-center gap-1.5 min-w-0",
                            children: [
                              u.jsx("span", {
                                className:
                                  "text-xs font-medium text-card-background whitespace-nowrap",
                                children:
                                  h === "include"
                                    ? "Contains"
                                    : "Does not contain",
                              }),
                              R.map(C),
                            ],
                          }),
                          u.jsxs(Xn, {
                            delayDuration: 100,
                            children: [
                              u.jsx(Qn, {
                                asChild: !0,
                                children: u.jsx("button", {
                                  onClick: (D) => {
                                    D.preventDefault(),
                                      D.stopPropagation(),
                                      a();
                                  },
                                  className:
                                    "flex items-center justify-center w-6 h-6 rounded-full  text-card-background hover:bg-card-background/70 hover:text-white transition-all flex-shrink-0 -mr-2",
                                  type: "button",
                                  children: u.jsx(Pa, {
                                    className: "h-3.5 w-3.5",
                                  }),
                                }),
                              }),
                              u.jsx(Pn, {
                                side: "top",
                                children: u.jsx("p", {
                                  children: "Clear Filter",
                                }),
                              }),
                            ],
                          }),
                        ],
                      })
                    : u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center h-10 w-10 cursor-pointer transition-all duration-200 ease-out overflow-hidden button-secondary rounded-full",
                              type: "button",
                              children: u.jsx(AU, {
                                className: "h-4 w-4 flex-shrink-0",
                              }),
                            }),
                          }),
                          u.jsx(Pn, { side: "top", children: "Filter" }),
                        ],
                      }),
                }),
              }),
              u.jsx(ui, {
                align: "end",
                side: "top",
                sideOffset: 10,
                className: "p-0 bg-transparent border-none shadow-none",
                children: u.jsx(CTe, { hasEditingPermissions: n }),
              }),
            ],
          }),
        }),
        u.jsx("div", {
          className: "fixed bottom-0 left-0 right-0 z-40",
          children: u.jsx(ITe, {}),
        }),
      ],
    });
  },
  DTe = () => {
    const n = Ce((m) => m.deletionConfirmationState),
      e = Ce((m) => m.closeDeletionConfirmation),
      t = Ce((m) => m.confirmDeletion),
      s = Ce((m) => m.boardState),
      { isOpen: r, elementsToDelete: i } = n,
      a = i.map((m) => s.elements[m]?.title).filter(Boolean),
      o = i.length,
      l = o > 1,
      c = async () => {
        await t();
      },
      h = () => {
        e();
      };
    return u.jsx(os, {
      open: r,
      onOpenChange: h,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[425px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: ["Delete ", l ? "Elements" : "Element"],
              }),
              u.jsx(Cl, {
                children: l
                  ? u.jsxs(u.Fragment, {
                      children: [
                        "Are you sure you want to delete ",
                        o,
                        " elements? This action cannot be undone.",
                      ],
                    })
                  : u.jsx(u.Fragment, {
                      children:
                        "Are you sure you want to delete this element? This action cannot be undone.",
                    }),
              }),
            ],
          }),
          o > 1 &&
            o <= 5 &&
            u.jsxs("div", {
              className: "py-4",
              children: [
                u.jsx("p", {
                  className: "text-sm text-muted-foreground mb-2",
                  children: "Elements to delete:",
                }),
                u.jsx("ul", {
                  className: "text-sm space-y-1",
                  children: a.map((m, p) =>
                    u.jsxs(
                      "li",
                      { className: "truncate", children: [" ", m] },
                      p
                    )
                  ),
                }),
              ],
            }),
          o > 5 &&
            u.jsx("div", {
              className: "py-4",
              children: u.jsxs("p", {
                className: "text-sm text-muted-foreground",
                children: [o, " elements will be deleted."],
              }),
            }),
          u.jsxs(xr, {
            children: [
              u.jsx(et, { variant: "outline", onClick: h, children: "Cancel" }),
              u.jsxs(et, {
                variant: "destructive",
                onClick: c,
                autoFocus: !0,
                children: ["Delete ", l ? "All" : ""],
              }),
            ],
          }),
        ],
      }),
    });
  },
  bt = {
    MEDIA_PLAY_REQUEST: "mediaplayrequest",
    MEDIA_PAUSE_REQUEST: "mediapauserequest",
    MEDIA_MUTE_REQUEST: "mediamuterequest",
    MEDIA_UNMUTE_REQUEST: "mediaunmuterequest",
    MEDIA_VOLUME_REQUEST: "mediavolumerequest",
    MEDIA_SEEK_REQUEST: "mediaseekrequest",
    MEDIA_AIRPLAY_REQUEST: "mediaairplayrequest",
    MEDIA_ENTER_FULLSCREEN_REQUEST: "mediaenterfullscreenrequest",
    MEDIA_EXIT_FULLSCREEN_REQUEST: "mediaexitfullscreenrequest",
    MEDIA_PREVIEW_REQUEST: "mediapreviewrequest",
    MEDIA_ENTER_PIP_REQUEST: "mediaenterpiprequest",
    MEDIA_EXIT_PIP_REQUEST: "mediaexitpiprequest",
    MEDIA_ENTER_CAST_REQUEST: "mediaentercastrequest",
    MEDIA_EXIT_CAST_REQUEST: "mediaexitcastrequest",
    MEDIA_SHOW_TEXT_TRACKS_REQUEST: "mediashowtexttracksrequest",
    MEDIA_HIDE_TEXT_TRACKS_REQUEST: "mediahidetexttracksrequest",
    MEDIA_SHOW_SUBTITLES_REQUEST: "mediashowsubtitlesrequest",
    MEDIA_DISABLE_SUBTITLES_REQUEST: "mediadisablesubtitlesrequest",
    MEDIA_TOGGLE_SUBTITLES_REQUEST: "mediatogglesubtitlesrequest",
    MEDIA_PLAYBACK_RATE_REQUEST: "mediaplaybackraterequest",
    MEDIA_RENDITION_REQUEST: "mediarenditionrequest",
    MEDIA_AUDIO_TRACK_REQUEST: "mediaaudiotrackrequest",
    MEDIA_SEEK_TO_LIVE_REQUEST: "mediaseektoliverequest",
    REGISTER_MEDIA_STATE_RECEIVER: "registermediastatereceiver",
    UNREGISTER_MEDIA_STATE_RECEIVER: "unregistermediastatereceiver",
  },
  xn = {
    MEDIA_CHROME_ATTRIBUTES: "mediachromeattributes",
    MEDIA_CONTROLLER: "mediacontroller",
  },
  GW = {
    MEDIA_AIRPLAY_UNAVAILABLE: "mediaAirplayUnavailable",
    MEDIA_AUDIO_TRACK_ENABLED: "mediaAudioTrackEnabled",
    MEDIA_AUDIO_TRACK_LIST: "mediaAudioTrackList",
    MEDIA_AUDIO_TRACK_UNAVAILABLE: "mediaAudioTrackUnavailable",
    MEDIA_BUFFERED: "mediaBuffered",
    MEDIA_CAST_UNAVAILABLE: "mediaCastUnavailable",
    MEDIA_CHAPTERS_CUES: "mediaChaptersCues",
    MEDIA_CURRENT_TIME: "mediaCurrentTime",
    MEDIA_DURATION: "mediaDuration",
    MEDIA_ENDED: "mediaEnded",
    MEDIA_ERROR: "mediaError",
    MEDIA_ERROR_CODE: "mediaErrorCode",
    MEDIA_ERROR_MESSAGE: "mediaErrorMessage",
    MEDIA_FULLSCREEN_UNAVAILABLE: "mediaFullscreenUnavailable",
    MEDIA_HAS_PLAYED: "mediaHasPlayed",
    MEDIA_HEIGHT: "mediaHeight",
    MEDIA_IS_AIRPLAYING: "mediaIsAirplaying",
    MEDIA_IS_CASTING: "mediaIsCasting",
    MEDIA_IS_FULLSCREEN: "mediaIsFullscreen",
    MEDIA_IS_PIP: "mediaIsPip",
    MEDIA_LOADING: "mediaLoading",
    MEDIA_MUTED: "mediaMuted",
    MEDIA_PAUSED: "mediaPaused",
    MEDIA_PIP_UNAVAILABLE: "mediaPipUnavailable",
    MEDIA_PLAYBACK_RATE: "mediaPlaybackRate",
    MEDIA_PREVIEW_CHAPTER: "mediaPreviewChapter",
    MEDIA_PREVIEW_COORDS: "mediaPreviewCoords",
    MEDIA_PREVIEW_IMAGE: "mediaPreviewImage",
    MEDIA_PREVIEW_TIME: "mediaPreviewTime",
    MEDIA_RENDITION_LIST: "mediaRenditionList",
    MEDIA_RENDITION_SELECTED: "mediaRenditionSelected",
    MEDIA_RENDITION_UNAVAILABLE: "mediaRenditionUnavailable",
    MEDIA_SEEKABLE: "mediaSeekable",
    MEDIA_STREAM_TYPE: "mediaStreamType",
    MEDIA_SUBTITLES_LIST: "mediaSubtitlesList",
    MEDIA_SUBTITLES_SHOWING: "mediaSubtitlesShowing",
    MEDIA_TARGET_LIVE_WINDOW: "mediaTargetLiveWindow",
    MEDIA_TIME_IS_LIVE: "mediaTimeIsLive",
    MEDIA_VOLUME: "mediaVolume",
    MEDIA_VOLUME_LEVEL: "mediaVolumeLevel",
    MEDIA_VOLUME_UNAVAILABLE: "mediaVolumeUnavailable",
    MEDIA_LANG: "mediaLang",
    MEDIA_WIDTH: "mediaWidth",
  },
  qW = Object.entries(GW),
  ae = qW.reduce((n, [e, t]) => ((n[e] = t.toLowerCase()), n), {}),
  PTe = {
    USER_INACTIVE_CHANGE: "userinactivechange",
    BREAKPOINTS_CHANGE: "breakpointchange",
    BREAKPOINTS_COMPUTED: "breakpointscomputed",
  },
  If = qW.reduce((n, [e, t]) => ((n[e] = t.toLowerCase()), n), { ...PTe });
Object.entries(If).reduce(
  (n, [e, t]) => {
    const s = ae[e];
    return s && (n[t] = s), n;
  },
  { userinactivechange: "userinactive" }
);
const MTe = Object.entries(ae).reduce(
    (n, [e, t]) => {
      const s = If[e];
      return s && (n[t] = s), n;
    },
    { userinactive: "userinactivechange" }
  ),
  Do = {
    SUBTITLES: "subtitles",
    CAPTIONS: "captions",
    CHAPTERS: "chapters",
    METADATA: "metadata",
  },
  df = { DISABLED: "disabled", SHOWING: "showing" },
  M4 = { MOUSE: "mouse", TOUCH: "touch" },
  Gi = { UNAVAILABLE: "unavailable", UNSUPPORTED: "unsupported" },
  ml = { LIVE: "live", ON_DEMAND: "on-demand", UNKNOWN: "unknown" },
  NTe = { FULLSCREEN: "fullscreen" };
function OTe(n) {
  return n?.map(jTe).join(" ");
}
function jTe(n) {
  if (n) {
    const { id: e, width: t, height: s } = n;
    return [e, t, s].filter((r) => r != null).join(":");
  }
}
function FTe(n) {
  return n?.map(UTe).join(" ");
}
function UTe(n) {
  if (n) {
    const { id: e, kind: t, language: s, label: r } = n;
    return [e, t, s, r].filter((i) => i != null).join(":");
  }
}
function cP(n) {
  return typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n);
}
const WW = (n) => new Promise((e) => setTimeout(e, n)),
  N4 = [
    { singular: "hour", plural: "hours" },
    { singular: "minute", plural: "minutes" },
    { singular: "second", plural: "seconds" },
  ],
  $Te = (n, e) => {
    const t = n === 1 ? N4[e].singular : N4[e].plural;
    return `${n} ${t}`;
  },
  ug = (n) => {
    if (!cP(n)) return "";
    const e = Math.abs(n),
      t = e !== n,
      s = new Date(0, 0, 0, 0, 0, e, 0);
    return `${[s.getHours(), s.getMinutes(), s.getSeconds()]
      .map((o, l) => o && $Te(o, l))
      .filter((o) => o)
      .join(", ")}${t ? " remaining" : ""}`;
  };
function Lc(n, e) {
  let t = !1;
  n < 0 && ((t = !0), (n = 0 - n)), (n = n < 0 ? 0 : n);
  let s = Math.floor(n % 60),
    r = Math.floor((n / 60) % 60),
    i = Math.floor(n / 3600);
  const a = Math.floor((e / 60) % 60),
    o = Math.floor(e / 3600);
  return (
    (isNaN(n) || n === 1 / 0) && (i = r = s = "0"),
    (i = i > 0 || o > 0 ? i + ":" : ""),
    (r = ((i || a >= 10) && r < 10 ? "0" + r : r) + ":"),
    (s = s < 10 ? "0" + s : s),
    (t ? "-" : "") + i + r + s
  );
}
const BTe = {
  "Start airplay": "Start airplay",
  "Stop airplay": "Stop airplay",
  Audio: "Audio",
  Captions: "Captions",
  "Enable captions": "Enable captions",
  "Disable captions": "Disable captions",
  "Start casting": "Start casting",
  "Stop casting": "Stop casting",
  "Enter fullscreen mode": "Enter fullscreen mode",
  "Exit fullscreen mode": "Exit fullscreen mode",
  Mute: "Mute",
  Unmute: "Unmute",
  "Enter picture in picture mode": "Enter picture in picture mode",
  "Exit picture in picture mode": "Exit picture in picture mode",
  Play: "Play",
  Pause: "Pause",
  "Playback rate": "Playback rate",
  "Playback rate {playbackRate}": "Playback rate {playbackRate}",
  Quality: "Quality",
  "Seek backward": "Seek backward",
  "Seek forward": "Seek forward",
  Settings: "Settings",
  Auto: "Auto",
  "audio player": "audio player",
  "video player": "video player",
  volume: "volume",
  seek: "seek",
  "closed captions": "closed captions",
  "current playback rate": "current playback rate",
  "playback time": "playback time",
  "media loading": "media loading",
  settings: "settings",
  "audio tracks": "audio tracks",
  quality: "quality",
  play: "play",
  pause: "pause",
  mute: "mute",
  unmute: "unmute",
  "chapter: {chapterName}": "chapter: {chapterName}",
  live: "live",
  Off: "Off",
  "start airplay": "start airplay",
  "stop airplay": "stop airplay",
  "start casting": "start casting",
  "stop casting": "stop casting",
  "enter fullscreen mode": "enter fullscreen mode",
  "exit fullscreen mode": "exit fullscreen mode",
  "enter picture in picture mode": "enter picture in picture mode",
  "exit picture in picture mode": "exit picture in picture mode",
  "seek to live": "seek to live",
  "playing live": "playing live",
  "seek back {seekOffset} seconds": "seek back {seekOffset} seconds",
  "seek forward {seekOffset} seconds": "seek forward {seekOffset} seconds",
  "Network Error": "Network Error",
  "Decode Error": "Decode Error",
  "Source Not Supported": "Source Not Supported",
  "Encryption Error": "Encryption Error",
  "A network error caused the media download to fail.":
    "A network error caused the media download to fail.",
  "A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.":
    "A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format.",
  "An unsupported error occurred. The server or network failed, or your browser does not support this format.":
    "An unsupported error occurred. The server or network failed, or your browser does not support this format.",
  "The media is encrypted and there are no keys to decrypt it.":
    "The media is encrypted and there are no keys to decrypt it.",
};
var O4;
const cA = { en: BTe };
let bC = ((O4 = globalThis.navigator) == null ? void 0 : O4.language) || "en";
const HTe = (n) => {
    bC = n;
  },
  VTe = (n) => {
    var e, t, s;
    const [r] = bC.split("-");
    return (
      ((e = cA[bC]) == null ? void 0 : e[n]) ||
      ((t = cA[r]) == null ? void 0 : t[n]) ||
      ((s = cA.en) == null ? void 0 : s[n]) ||
      n
    );
  },
  Tt = (n, e = {}) =>
    VTe(n).replace(/\{(\w+)\}/g, (t, s) => (s in e ? String(e[s]) : `{${s}}`));
let KW = class {
    addEventListener() {}
    removeEventListener() {}
    dispatchEvent() {
      return !0;
    }
  },
  YW = class extends KW {},
  j4 = class extends YW {
    constructor() {
      super(...arguments), (this.role = null);
    }
  },
  zTe = class {
    observe() {}
    unobserve() {}
    disconnect() {}
  };
const XW = {
    createElement: function () {
      return new sv.HTMLElement();
    },
    createElementNS: function () {
      return new sv.HTMLElement();
    },
    addEventListener() {},
    removeEventListener() {},
    dispatchEvent(n) {
      return !1;
    },
  },
  sv = {
    ResizeObserver: zTe,
    document: XW,
    Node: YW,
    Element: j4,
    HTMLElement: class extends j4 {
      constructor() {
        super(...arguments), (this.innerHTML = "");
      }
      get content() {
        return new sv.DocumentFragment();
      }
    },
    DocumentFragment: class extends KW {},
    customElements: {
      get: function () {},
      define: function () {},
      whenDefined: function () {},
    },
    localStorage: {
      getItem(n) {
        return null;
      },
      setItem(n, e) {},
      removeItem(n) {},
    },
    CustomEvent: function () {},
    getComputedStyle: function () {},
    navigator: {
      languages: [],
      get userAgent() {
        return "";
      },
    },
    matchMedia(n) {
      return { matches: !1, media: n };
    },
    DOMParser: class {
      parseFromString(e, t) {
        return { body: { textContent: e } };
      }
    },
  },
  QW = typeof window > "u" || typeof window.customElements > "u",
  ZW = Object.keys(sv).every((n) => n in globalThis),
  Ie = QW && !ZW ? sv : globalThis,
  li = QW && !ZW ? XW : globalThis.document,
  F4 = new WeakMap(),
  uP = (n) => {
    let e = F4.get(n);
    return e || F4.set(n, (e = new Set())), e;
  },
  JW = new Ie.ResizeObserver((n) => {
    for (const e of n) for (const t of uP(e.target)) t(e);
  });
function eK(n, e) {
  uP(n).add(e), JW.observe(n);
}
function tK(n, e) {
  const t = uP(n);
  t.delete(e), t.size || JW.unobserve(n);
}
function Va(n) {
  const e = {};
  for (const t of n) e[t.name] = t.value;
  return e;
}
function GTe(n) {
  var e;
  return (e = qTe(n)) != null ? e : Gv(n, "media-controller");
}
function qTe(n) {
  var e;
  const { MEDIA_CONTROLLER: t } = xn,
    s = n.getAttribute(t);
  if (s) return (e = KTe(n)) == null ? void 0 : e.getElementById(s);
}
const nK = (n, e, t = ".value") => {
    const s = n.querySelector(t);
    s && (s.textContent = e);
  },
  WTe = (n, e) => {
    const t = `slot[name="${e}"]`,
      s = n.shadowRoot.querySelector(t);
    return s ? s.children : [];
  },
  sK = (n, e) => WTe(n, e)[0],
  Qf = (n, e) =>
    !n || !e ? !1 : n?.contains(e) ? !0 : Qf(n, e.getRootNode().host),
  Gv = (n, e) => {
    if (!n) return null;
    const t = n.closest(e);
    return t || Gv(n.getRootNode().host, e);
  };
function rK(n = document) {
  var e;
  const t = n?.activeElement;
  return t ? ((e = rK(t.shadowRoot)) != null ? e : t) : null;
}
function KTe(n) {
  var e;
  const t = (e = n?.getRootNode) == null ? void 0 : e.call(n);
  return t instanceof ShadowRoot || t instanceof Document ? t : null;
}
function iK(
  n,
  { depth: e = 3, checkOpacity: t = !0, checkVisibilityCSS: s = !0 } = {}
) {
  if (n.checkVisibility)
    return n.checkVisibility({ checkOpacity: t, checkVisibilityCSS: s });
  let r = n;
  for (; r && e > 0; ) {
    const i = getComputedStyle(r);
    if (
      (t && i.opacity === "0") ||
      (s && i.visibility === "hidden") ||
      i.display === "none"
    )
      return !1;
    (r = r.parentElement), e--;
  }
  return !0;
}
function YTe(n, e, t, s) {
  const r = s.x - t.x,
    i = s.y - t.y,
    a = r * r + i * i;
  if (a === 0) return 0;
  const o = ((n - t.x) * r + (e - t.y) * i) / a;
  return Math.max(0, Math.min(1, o));
}
function Ns(n, e) {
  const t = XTe(n, (s) => s === e);
  return t || QTe(n, e);
}
function XTe(n, e) {
  var t, s;
  let r;
  for (r of (t = n.querySelectorAll("style:not([media])")) != null ? t : []) {
    let i;
    try {
      i = (s = r.sheet) == null ? void 0 : s.cssRules;
    } catch {
      continue;
    }
    for (const a of i ?? []) if (e(a.selectorText)) return a;
  }
}
function QTe(n, e) {
  var t, s;
  const r = (t = n.querySelectorAll("style:not([media])")) != null ? t : [],
    i = r?.[r.length - 1];
  return i?.sheet
    ? (i?.sheet.insertRule(`${e}{}`, i.sheet.cssRules.length),
      (s = i.sheet.cssRules) == null ? void 0 : s[i.sheet.cssRules.length - 1])
    : (console.warn("Media Chrome: No style sheet found on style tag of", n),
      {
        style: {
          setProperty: () => {},
          removeProperty: () => "",
          getPropertyValue: () => "",
        },
      });
}
function ps(n, e, t = Number.NaN) {
  const s = n.getAttribute(e);
  return s != null ? +s : t;
}
function lr(n, e, t) {
  const s = +t;
  if (t == null || Number.isNaN(s)) {
    n.hasAttribute(e) && n.removeAttribute(e);
    return;
  }
  ps(n, e, void 0) !== s && n.setAttribute(e, `${s}`);
}
function un(n, e) {
  return n.hasAttribute(e);
}
function dn(n, e, t) {
  if (t == null) {
    n.hasAttribute(e) && n.removeAttribute(e);
    return;
  }
  un(n, e) != t && n.toggleAttribute(e, t);
}
function gs(n, e, t = null) {
  var s;
  return (s = n.getAttribute(e)) != null ? s : t;
}
function vs(n, e, t) {
  if (t == null) {
    n.hasAttribute(e) && n.removeAttribute(e);
    return;
  }
  const s = `${t}`;
  gs(n, e, void 0) !== s && n.setAttribute(e, s);
}
var aK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  ac = (n, e, t) => (
    aK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  ZTe = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Uy = (n, e, t, s) => (aK(n, e, "write to private field"), e.set(n, t), t),
  Xr;
function JTe(n) {
  return `
    <style>
      :host {
        display: var(--media-control-display, var(--media-gesture-receiver-display, inline-block));
        box-sizing: border-box;
      }
    </style>
  `;
}
class nS extends Ie.HTMLElement {
  constructor() {
    if ((super(), ZTe(this, Xr, void 0), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
  }
  static get observedAttributes() {
    return [xn.MEDIA_CONTROLLER, ae.MEDIA_PAUSED];
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === xn.MEDIA_CONTROLLER &&
      (t &&
        ((i = (r = ac(this, Xr)) == null ? void 0 : r.unassociateElement) ==
          null || i.call(r, this),
        Uy(this, Xr, null)),
      s &&
        this.isConnected &&
        (Uy(
          this,
          Xr,
          (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
        ),
        (l = (o = ac(this, Xr)) == null ? void 0 : o.associateElement) ==
          null || l.call(o, this)));
  }
  connectedCallback() {
    var e, t, s, r;
    (this.tabIndex = -1),
      this.setAttribute("aria-hidden", "true"),
      Uy(this, Xr, e_e(this)),
      this.getAttribute(xn.MEDIA_CONTROLLER) &&
        ((t = (e = ac(this, Xr)) == null ? void 0 : e.associateElement) ==
          null ||
          t.call(e, this)),
      (s = ac(this, Xr)) == null || s.addEventListener("pointerdown", this),
      (r = ac(this, Xr)) == null || r.addEventListener("click", this);
  }
  disconnectedCallback() {
    var e, t, s, r;
    this.getAttribute(xn.MEDIA_CONTROLLER) &&
      ((t = (e = ac(this, Xr)) == null ? void 0 : e.unassociateElement) ==
        null ||
        t.call(e, this)),
      (s = ac(this, Xr)) == null || s.removeEventListener("pointerdown", this),
      (r = ac(this, Xr)) == null || r.removeEventListener("click", this),
      Uy(this, Xr, null);
  }
  handleEvent(e) {
    var t;
    const s = (t = e.composedPath()) == null ? void 0 : t[0];
    if (["video", "media-controller"].includes(s?.localName)) {
      if (e.type === "pointerdown") this._pointerType = e.pointerType;
      else if (e.type === "click") {
        const { clientX: i, clientY: a } = e,
          {
            left: o,
            top: l,
            width: c,
            height: h,
          } = this.getBoundingClientRect(),
          m = i - o,
          p = a - l;
        if (m < 0 || p < 0 || m > c || p > h || (c === 0 && h === 0)) return;
        const { pointerType: g = this._pointerType } = e;
        if (((this._pointerType = void 0), g === M4.TOUCH)) {
          this.handleTap(e);
          return;
        } else if (g === M4.MOUSE) {
          this.handleMouseClick(e);
          return;
        }
      }
    }
  }
  get mediaPaused() {
    return un(this, ae.MEDIA_PAUSED);
  }
  set mediaPaused(e) {
    dn(this, ae.MEDIA_PAUSED, e);
  }
  handleTap(e) {}
  handleMouseClick(e) {
    const t = this.mediaPaused ? bt.MEDIA_PLAY_REQUEST : bt.MEDIA_PAUSE_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(t, { composed: !0, bubbles: !0 }));
  }
}
Xr = new WeakMap();
nS.shadowRootOptions = { mode: "open" };
nS.getTemplateHTML = JTe;
function e_e(n) {
  var e;
  const t = n.getAttribute(xn.MEDIA_CONTROLLER);
  return t
    ? (e = n.getRootNode()) == null
      ? void 0
      : e.getElementById(t)
    : Gv(n, "media-controller");
}
Ie.customElements.get("media-gesture-receiver") ||
  Ie.customElements.define("media-gesture-receiver", nS);
var U4 = nS,
  dP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  xi = (n, e, t) => (
    dP(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  yi = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  ku = (n, e, t, s) => (dP(n, e, "write to private field"), e.set(n, t), t),
  ea = (n, e, t) => (dP(n, e, "access private method"), t),
  Dw,
  Ah,
  rv,
  Yh,
  Lb,
  xC,
  oK,
  Lp,
  Db,
  wC,
  lK,
  EC,
  cK,
  iv,
  sS,
  rS,
  hP,
  Lf,
  av;
const At = {
  AUDIO: "audio",
  AUTOHIDE: "autohide",
  BREAKPOINTS: "breakpoints",
  GESTURES_DISABLED: "gesturesdisabled",
  KEYBOARD_CONTROL: "keyboardcontrol",
  NO_AUTOHIDE: "noautohide",
  USER_INACTIVE: "userinactive",
  AUTOHIDE_OVER_CONTROLS: "autohideovercontrols",
};
function t_e(n) {
  return `
    <style>
      
      :host([${ae.MEDIA_IS_FULLSCREEN}]) ::slotted([slot=media]) {
        outline: none;
      }

      :host {
        box-sizing: border-box;
        position: relative;
        display: inline-block;
        line-height: 0;
        background-color: var(--media-background-color, #000);
      }

      :host(:not([${At.AUDIO}])) [part~=layer]:not([part~=media-layer]) {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        display: flex;
        flex-flow: column nowrap;
        align-items: start;
        pointer-events: none;
        background: none;
      }

      slot[name=media] {
        display: var(--media-slot-display, contents);
      }

      
      :host([${At.AUDIO}]) slot[name=media] {
        display: var(--media-slot-display, none);
      }

      
      :host([${At.AUDIO}]) [part~=layer][part~=gesture-layer] {
        height: 0;
        display: block;
      }

      
      :host(:not([${At.AUDIO}])[${
    At.GESTURES_DISABLED
  }]) ::slotted([slot=gestures-chrome]),
          :host(:not([${At.AUDIO}])[${
    At.GESTURES_DISABLED
  }]) media-gesture-receiver[slot=gestures-chrome] {
        display: none;
      }

      
      ::slotted(:not([slot=media]):not([slot=poster]):not(media-loading-indicator):not([role=dialog]):not([hidden])) {
        pointer-events: auto;
      }

      :host(:not([${At.AUDIO}])) *[part~=layer][part~=centered-layer] {
        align-items: center;
        justify-content: center;
      }

      :host(:not([${
        At.AUDIO
      }])) ::slotted(media-gesture-receiver[slot=gestures-chrome]),
      :host(:not([${At.AUDIO}])) media-gesture-receiver[slot=gestures-chrome] {
        align-self: stretch;
        flex-grow: 1;
      }

      slot[name=middle-chrome] {
        display: inline;
        flex-grow: 1;
        pointer-events: none;
        background: none;
      }

      
      ::slotted([slot=media]),
      ::slotted([slot=poster]) {
        width: 100%;
        height: 100%;
      }

      
      :host(:not([${At.AUDIO}])) .spacer {
        flex-grow: 1;
      }

      
      :host(:-webkit-full-screen) {
        
        width: 100% !important;
        height: 100% !important;
      }

      
      ::slotted(:not([slot=media]):not([slot=poster]):not([${
        At.NO_AUTOHIDE
      }]):not([hidden]):not([role=dialog])) {
        opacity: 1;
        transition: var(--media-control-transition-in, opacity 0.25s);
      }

      
      :host([${At.USER_INACTIVE}]:not([${ae.MEDIA_PAUSED}]):not([${
    ae.MEDIA_IS_AIRPLAYING
  }]):not([${ae.MEDIA_IS_CASTING}]):not([${
    At.AUDIO
  }])) ::slotted(:not([slot=media]):not([slot=poster]):not([${
    At.NO_AUTOHIDE
  }]):not([role=dialog])) {
        opacity: 0;
        transition: var(--media-control-transition-out, opacity 1s);
      }

      :host([${At.USER_INACTIVE}]:not([${At.NO_AUTOHIDE}]):not([${
    ae.MEDIA_PAUSED
  }]):not([${ae.MEDIA_IS_CASTING}]):not([${
    At.AUDIO
  }])) ::slotted([slot=media]) {
        cursor: none;
      }

      :host([${At.USER_INACTIVE}][${At.AUTOHIDE_OVER_CONTROLS}]:not([${
    At.NO_AUTOHIDE
  }]):not([${ae.MEDIA_PAUSED}]):not([${ae.MEDIA_IS_CASTING}]):not([${
    At.AUDIO
  }])) * {
        --media-cursor: none;
        cursor: none;
      }


      ::slotted(media-control-bar)  {
        align-self: stretch;
      }

      
      :host(:not([${At.AUDIO}])[${ae.MEDIA_HAS_PLAYED}]) slot[name=poster] {
        display: none;
      }

      ::slotted([role=dialog]) {
        width: 100%;
        height: 100%;
        align-self: center;
      }

      ::slotted([role=menu]) {
        align-self: end;
      }
    </style>

    <slot name="media" part="layer media-layer"></slot>
    <slot name="poster" part="layer poster-layer"></slot>
    <slot name="gestures-chrome" part="layer gesture-layer">
      <media-gesture-receiver slot="gestures-chrome">
        <template shadowrootmode="${U4.shadowRootOptions.mode}">
          ${U4.getTemplateHTML({})}
        </template>
      </media-gesture-receiver>
    </slot>
    <span part="layer vertical-layer">
      <slot name="top-chrome" part="top chrome"></slot>
      <slot name="middle-chrome" part="middle chrome"></slot>
      <slot name="centered-chrome" part="layer centered-layer center centered chrome"></slot>
      
      <slot part="bottom chrome"></slot>
    </span>
    <slot name="dialog" part="layer dialog-layer"></slot>
  `;
}
const n_e = Object.values(ae),
  s_e = "sm:384 md:576 lg:768 xl:960";
function r_e(n) {
  uK(n.target, n.contentRect.width);
}
function uK(n, e) {
  var t;
  if (!n.isConnected) return;
  const s = (t = n.getAttribute(At.BREAKPOINTS)) != null ? t : s_e,
    r = i_e(s),
    i = a_e(r, e);
  let a = !1;
  if (
    (Object.keys(r).forEach((o) => {
      if (i.includes(o)) {
        n.hasAttribute(`breakpoint${o}`) ||
          (n.setAttribute(`breakpoint${o}`, ""), (a = !0));
        return;
      }
      n.hasAttribute(`breakpoint${o}`) &&
        (n.removeAttribute(`breakpoint${o}`), (a = !0));
    }),
    a)
  ) {
    const o = new CustomEvent(If.BREAKPOINTS_CHANGE, { detail: i });
    n.dispatchEvent(o);
  }
  n.breakpointsComputed ||
    ((n.breakpointsComputed = !0),
    n.dispatchEvent(
      new CustomEvent(If.BREAKPOINTS_COMPUTED, { bubbles: !0, composed: !0 })
    ));
}
function i_e(n) {
  const e = n.split(/\s+/);
  return Object.fromEntries(e.map((t) => t.split(":")));
}
function a_e(n, e) {
  return Object.keys(n).filter((t) => e >= parseInt(n[t]));
}
class iS extends Ie.HTMLElement {
  constructor() {
    if (
      (super(),
      yi(this, xC),
      yi(this, wC),
      yi(this, EC),
      yi(this, iv),
      yi(this, rS),
      yi(this, Lf),
      yi(this, Dw, 0),
      yi(this, Ah, null),
      yi(this, rv, null),
      yi(this, Yh, void 0),
      (this.breakpointsComputed = !1),
      yi(this, Lb, new MutationObserver(ea(this, xC, oK).bind(this))),
      yi(this, Lp, !1),
      yi(this, Db, (t) => {
        xi(this, Lp) ||
          (setTimeout(() => {
            r_e(t), ku(this, Lp, !1);
          }, 0),
          ku(this, Lp, !0));
      }),
      !this.shadowRoot)
    ) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const t = Va(this.attributes),
        s = this.constructor.getTemplateHTML(t);
      this.shadowRoot.setHTMLUnsafe
        ? this.shadowRoot.setHTMLUnsafe(s)
        : (this.shadowRoot.innerHTML = s);
    }
    const e = this.querySelector(":scope > slot[slot=media]");
    e &&
      e.addEventListener("slotchange", () => {
        if (!e.assignedElements({ flatten: !0 }).length) {
          xi(this, Ah) && this.mediaUnsetCallback(xi(this, Ah));
          return;
        }
        this.handleMediaUpdated(this.media);
      });
  }
  static get observedAttributes() {
    return [At.AUTOHIDE, At.GESTURES_DISABLED]
      .concat(n_e)
      .filter(
        (e) =>
          ![
            ae.MEDIA_RENDITION_LIST,
            ae.MEDIA_AUDIO_TRACK_LIST,
            ae.MEDIA_CHAPTERS_CUES,
            ae.MEDIA_WIDTH,
            ae.MEDIA_HEIGHT,
            ae.MEDIA_ERROR,
            ae.MEDIA_ERROR_MESSAGE,
          ].includes(e)
      );
  }
  attributeChangedCallback(e, t, s) {
    e.toLowerCase() == At.AUTOHIDE && (this.autohide = s);
  }
  get media() {
    let e = this.querySelector(":scope > [slot=media]");
    return (
      e?.nodeName == "SLOT" && (e = e.assignedElements({ flatten: !0 })[0]), e
    );
  }
  async handleMediaUpdated(e) {
    e &&
      (ku(this, Ah, e),
      e.localName.includes("-") &&
        (await Ie.customElements.whenDefined(e.localName)),
      this.mediaSetCallback(e));
  }
  connectedCallback() {
    var e;
    xi(this, Lb).observe(this, { childList: !0, subtree: !0 }),
      eK(this, xi(this, Db));
    const t = this.getAttribute(At.AUDIO) != null,
      s = Tt(t ? "audio player" : "video player");
    this.setAttribute("role", "region"),
      this.setAttribute("aria-label", s),
      this.handleMediaUpdated(this.media),
      this.setAttribute(At.USER_INACTIVE, ""),
      uK(this, this.getBoundingClientRect().width),
      this.addEventListener("pointerdown", this),
      this.addEventListener("pointermove", this),
      this.addEventListener("pointerup", this),
      this.addEventListener("mouseleave", this),
      this.addEventListener("keyup", this),
      (e = Ie.window) == null || e.addEventListener("mouseup", this);
  }
  disconnectedCallback() {
    var e;
    xi(this, Lb).disconnect(),
      tK(this, xi(this, Db)),
      this.media && this.mediaUnsetCallback(this.media),
      (e = Ie.window) == null || e.removeEventListener("mouseup", this);
  }
  mediaSetCallback(e) {}
  mediaUnsetCallback(e) {
    ku(this, Ah, null);
  }
  handleEvent(e) {
    switch (e.type) {
      case "pointerdown":
        ku(this, Dw, e.timeStamp);
        break;
      case "pointermove":
        ea(this, wC, lK).call(this, e);
        break;
      case "pointerup":
        ea(this, EC, cK).call(this, e);
        break;
      case "mouseleave":
        ea(this, iv, sS).call(this);
        break;
      case "mouseup":
        this.removeAttribute(At.KEYBOARD_CONTROL);
        break;
      case "keyup":
        ea(this, Lf, av).call(this), this.setAttribute(At.KEYBOARD_CONTROL, "");
        break;
    }
  }
  set autohide(e) {
    const t = Number(e);
    ku(this, Yh, isNaN(t) ? 0 : t);
  }
  get autohide() {
    return (xi(this, Yh) === void 0 ? 2 : xi(this, Yh)).toString();
  }
  get breakpoints() {
    return gs(this, At.BREAKPOINTS);
  }
  set breakpoints(e) {
    vs(this, At.BREAKPOINTS, e);
  }
  get audio() {
    return un(this, At.AUDIO);
  }
  set audio(e) {
    dn(this, At.AUDIO, e);
  }
  get gesturesDisabled() {
    return un(this, At.GESTURES_DISABLED);
  }
  set gesturesDisabled(e) {
    dn(this, At.GESTURES_DISABLED, e);
  }
  get keyboardControl() {
    return un(this, At.KEYBOARD_CONTROL);
  }
  set keyboardControl(e) {
    dn(this, At.KEYBOARD_CONTROL, e);
  }
  get noAutohide() {
    return un(this, At.NO_AUTOHIDE);
  }
  set noAutohide(e) {
    dn(this, At.NO_AUTOHIDE, e);
  }
  get autohideOverControls() {
    return un(this, At.AUTOHIDE_OVER_CONTROLS);
  }
  set autohideOverControls(e) {
    dn(this, At.AUTOHIDE_OVER_CONTROLS, e);
  }
  get userInteractive() {
    return un(this, At.USER_INACTIVE);
  }
  set userInteractive(e) {
    dn(this, At.USER_INACTIVE, e);
  }
}
Dw = new WeakMap();
Ah = new WeakMap();
rv = new WeakMap();
Yh = new WeakMap();
Lb = new WeakMap();
xC = new WeakSet();
oK = function (n) {
  const e = this.media;
  for (const t of n) {
    if (t.type !== "childList") continue;
    const s = t.removedNodes;
    for (const r of s) {
      if (r.slot != "media" || t.target != this) continue;
      let i = t.previousSibling && t.previousSibling.previousElementSibling;
      if (!i || !e) this.mediaUnsetCallback(r);
      else {
        let a = i.slot !== "media";
        for (; (i = i.previousSibling) !== null; )
          i.slot == "media" && (a = !1);
        a && this.mediaUnsetCallback(r);
      }
    }
    if (e) for (const r of t.addedNodes) r === e && this.handleMediaUpdated(e);
  }
};
Lp = new WeakMap();
Db = new WeakMap();
wC = new WeakSet();
lK = function (n) {
  if (n.pointerType !== "mouse" && n.timeStamp - xi(this, Dw) < 250) return;
  ea(this, rS, hP).call(this), clearTimeout(xi(this, rv));
  const e = this.hasAttribute(At.AUTOHIDE_OVER_CONTROLS);
  ([this, this.media].includes(n.target) || e) && ea(this, Lf, av).call(this);
};
EC = new WeakSet();
cK = function (n) {
  if (n.pointerType === "touch") {
    const e = !this.hasAttribute(At.USER_INACTIVE);
    [this, this.media].includes(n.target) && e
      ? ea(this, iv, sS).call(this)
      : ea(this, Lf, av).call(this);
  } else
    n
      .composedPath()
      .some((e) =>
        ["media-play-button", "media-fullscreen-button"].includes(e?.localName)
      ) && ea(this, Lf, av).call(this);
};
iv = new WeakSet();
sS = function () {
  if (xi(this, Yh) < 0 || this.hasAttribute(At.USER_INACTIVE)) return;
  this.setAttribute(At.USER_INACTIVE, "");
  const n = new Ie.CustomEvent(If.USER_INACTIVE_CHANGE, {
    composed: !0,
    bubbles: !0,
    detail: !0,
  });
  this.dispatchEvent(n);
};
rS = new WeakSet();
hP = function () {
  if (!this.hasAttribute(At.USER_INACTIVE)) return;
  this.removeAttribute(At.USER_INACTIVE);
  const n = new Ie.CustomEvent(If.USER_INACTIVE_CHANGE, {
    composed: !0,
    bubbles: !0,
    detail: !1,
  });
  this.dispatchEvent(n);
};
Lf = new WeakSet();
av = function () {
  ea(this, rS, hP).call(this), clearTimeout(xi(this, rv));
  const n = parseInt(this.autohide);
  n < 0 ||
    ku(
      this,
      rv,
      setTimeout(() => {
        ea(this, iv, sS).call(this);
      }, n * 1e3)
    );
};
iS.shadowRootOptions = { mode: "open" };
iS.getTemplateHTML = t_e;
Ie.customElements.get("media-container") ||
  Ie.customElements.define("media-container", iS);
var dK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  tr = (n, e, t) => (
    dK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  fp = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  $y = (n, e, t, s) => (dK(n, e, "write to private field"), e.set(n, t), t),
  Rh,
  kh,
  Pw,
  Uu,
  ll,
  pc;
class hK {
  constructor(e, t, { defaultValue: s } = { defaultValue: void 0 }) {
    fp(this, ll),
      fp(this, Rh, void 0),
      fp(this, kh, void 0),
      fp(this, Pw, void 0),
      fp(this, Uu, new Set()),
      $y(this, Rh, e),
      $y(this, kh, t),
      $y(this, Pw, new Set(s));
  }
  [Symbol.iterator]() {
    return tr(this, ll, pc).values();
  }
  get length() {
    return tr(this, ll, pc).size;
  }
  get value() {
    var e;
    return (e = [...tr(this, ll, pc)].join(" ")) != null ? e : "";
  }
  set value(e) {
    var t;
    e !== this.value &&
      ($y(this, Uu, new Set()),
      this.add(...((t = e?.split(" ")) != null ? t : [])));
  }
  toString() {
    return this.value;
  }
  item(e) {
    return [...tr(this, ll, pc)][e];
  }
  values() {
    return tr(this, ll, pc).values();
  }
  forEach(e, t) {
    tr(this, ll, pc).forEach(e, t);
  }
  add(...e) {
    var t, s;
    e.forEach((r) => tr(this, Uu).add(r)),
      !(
        this.value === "" &&
        !((t = tr(this, Rh)) != null && t.hasAttribute(`${tr(this, kh)}`))
      ) &&
        ((s = tr(this, Rh)) == null ||
          s.setAttribute(`${tr(this, kh)}`, `${this.value}`));
  }
  remove(...e) {
    var t;
    e.forEach((s) => tr(this, Uu).delete(s)),
      (t = tr(this, Rh)) == null ||
        t.setAttribute(`${tr(this, kh)}`, `${this.value}`);
  }
  contains(e) {
    return tr(this, ll, pc).has(e);
  }
  toggle(e, t) {
    return typeof t < "u"
      ? t
        ? (this.add(e), !0)
        : (this.remove(e), !1)
      : this.contains(e)
      ? (this.remove(e), !1)
      : (this.add(e), !0);
  }
  replace(e, t) {
    return this.remove(e), this.add(t), e === t;
  }
}
Rh = new WeakMap();
kh = new WeakMap();
Pw = new WeakMap();
Uu = new WeakMap();
ll = new WeakSet();
pc = function () {
  return tr(this, Uu).size ? tr(this, Uu) : tr(this, Pw);
};
const o_e = (n = "") => n.split(/\s+/),
  fK = (n = "") => {
    const [e, t, s] = n.split(":"),
      r = s ? decodeURIComponent(s) : void 0;
    return {
      kind: e === "cc" ? Do.CAPTIONS : Do.SUBTITLES,
      language: t,
      label: r,
    };
  },
  mK = (n = "", e = {}) =>
    o_e(n).map((t) => {
      const s = fK(t);
      return { ...e, ...s };
    }),
  pK = (n) =>
    n
      ? Array.isArray(n)
        ? n.map((e) => (typeof e == "string" ? fK(e) : e))
        : typeof n == "string"
        ? mK(n)
        : [n]
      : [],
  l_e = ({ kind: n, label: e, language: t } = { kind: "subtitles" }) =>
    e ? `${n === "captions" ? "cc" : "sb"}:${t}:${encodeURIComponent(e)}` : t,
  SC = (n = []) => Array.prototype.map.call(n, l_e).join(" "),
  c_e = (n, e) => (t) => t[n] === e,
  gK = (n) => {
    const e = Object.entries(n).map(([t, s]) => c_e(t, s));
    return (t) => e.every((s) => s(t));
  },
  dg = (n, e = [], t = []) => {
    const s = pK(t).map(gK),
      r = (i) => s.some((a) => a(i));
    Array.from(e)
      .filter(r)
      .forEach((i) => {
        i.mode = n;
      });
  },
  aS = (n, e = () => !0) => {
    if (!n?.textTracks) return [];
    const t = typeof e == "function" ? e : gK(e);
    return Array.from(n.textTracks).filter(t);
  },
  u_e = (n) => {
    var e;
    return (
      !!((e = n.mediaSubtitlesShowing) != null && e.length) ||
      n.hasAttribute(ae.MEDIA_SUBTITLES_SHOWING)
    );
  },
  d_e = (n) => {
    var e;
    const { media: t, fullscreenElement: s } = n;
    try {
      const r =
        s && "requestFullscreen" in s
          ? "requestFullscreen"
          : s && "webkitRequestFullScreen" in s
          ? "webkitRequestFullScreen"
          : void 0;
      if (r) {
        const i = (e = s[r]) == null ? void 0 : e.call(s);
        if (i instanceof Promise) return i.catch(() => {});
      } else
        t?.webkitEnterFullscreen
          ? t.webkitEnterFullscreen()
          : t?.requestFullscreen && t.requestFullscreen();
    } catch (r) {
      console.error(r);
    }
  },
  $4 =
    "exitFullscreen" in li
      ? "exitFullscreen"
      : "webkitExitFullscreen" in li
      ? "webkitExitFullscreen"
      : "webkitCancelFullScreen" in li
      ? "webkitCancelFullScreen"
      : void 0,
  h_e = (n) => {
    var e;
    const { documentElement: t } = n;
    if ($4) {
      const s = (e = t?.[$4]) == null ? void 0 : e.call(t);
      if (s instanceof Promise) return s.catch(() => {});
    }
  },
  Dp =
    "fullscreenElement" in li
      ? "fullscreenElement"
      : "webkitFullscreenElement" in li
      ? "webkitFullscreenElement"
      : void 0,
  f_e = (n) => {
    const { documentElement: e, media: t } = n,
      s = e?.[Dp];
    return !s &&
      "webkitDisplayingFullscreen" in t &&
      "webkitPresentationMode" in t &&
      t.webkitDisplayingFullscreen &&
      t.webkitPresentationMode === NTe.FULLSCREEN
      ? t
      : s;
  },
  m_e = (n) => {
    var e;
    const { media: t, documentElement: s, fullscreenElement: r = t } = n;
    if (!t || !s) return !1;
    const i = f_e(n);
    if (!i) return !1;
    if (i === r || i === t) return !0;
    if (i.localName.includes("-")) {
      let a = i.shadowRoot;
      if (!(Dp in a)) return Qf(i, r);
      for (; a?.[Dp]; ) {
        if (a[Dp] === r) return !0;
        a = (e = a[Dp]) == null ? void 0 : e.shadowRoot;
      }
    }
    return !1;
  },
  p_e =
    "fullscreenEnabled" in li
      ? "fullscreenEnabled"
      : "webkitFullscreenEnabled" in li
      ? "webkitFullscreenEnabled"
      : void 0,
  g_e = (n) => {
    const { documentElement: e, media: t } = n;
    return !!e?.[p_e] || (t && "webkitSupportsFullscreen" in t);
  };
let By;
const fP = () => {
    var n, e;
    return (
      By ||
      ((By =
        (e = (n = li) == null ? void 0 : n.createElement) == null
          ? void 0
          : e.call(n, "video")),
      By)
    );
  },
  v_e = async (n = fP()) => {
    if (!n) return !1;
    const e = n.volume;
    n.volume = e / 2 + 0.1;
    const t = new AbortController(),
      s = await Promise.race([y_e(n, t.signal), b_e(n, e)]);
    return t.abort(), s;
  },
  y_e = (n, e) =>
    new Promise((t) => {
      n.addEventListener("volumechange", () => t(!0), { signal: e });
    }),
  b_e = async (n, e) => {
    for (let t = 0; t < 10; t++) {
      if (n.volume === e) return !1;
      await WW(10);
    }
    return n.volume !== e;
  },
  x_e = /.*Version\/.*Safari\/.*/.test(Ie.navigator.userAgent),
  vK = (n = fP()) =>
    Ie.matchMedia("(display-mode: standalone)").matches && x_e
      ? !1
      : typeof n?.requestPictureInPicture == "function",
  yK = (n = fP()) => g_e({ documentElement: li, media: n }),
  w_e = yK(),
  E_e = vK(),
  S_e = !!Ie.WebKitPlaybackTargetAvailabilityEvent,
  T_e = !!Ie.chrome,
  Mw = (n) =>
    aS(n.media, (e) => [Do.SUBTITLES, Do.CAPTIONS].includes(e.kind)).sort(
      (e, t) => (e.kind >= t.kind ? 1 : -1)
    ),
  bK = (n) =>
    aS(
      n.media,
      (e) =>
        e.mode === df.SHOWING && [Do.SUBTITLES, Do.CAPTIONS].includes(e.kind)
    ),
  xK = (n, e) => {
    const t = Mw(n),
      s = bK(n),
      r = !!s.length;
    if (t.length) {
      if (e === !1 || (r && e !== !0)) dg(df.DISABLED, t, s);
      else if (e === !0 || (!r && e !== !1)) {
        let i = t[0];
        const { options: a } = n;
        if (!a?.noSubtitlesLangPref) {
          const h = globalThis.localStorage.getItem(
              "media-chrome-pref-subtitles-lang"
            ),
            m = h
              ? [h, ...globalThis.navigator.languages]
              : globalThis.navigator.languages,
            p = t
              .filter((g) =>
                m.some((y) =>
                  g.language.toLowerCase().startsWith(y.split("-")[0])
                )
              )
              .sort((g, y) => {
                const b = m.findIndex((S) =>
                    g.language.toLowerCase().startsWith(S.split("-")[0])
                  ),
                  w = m.findIndex((S) =>
                    y.language.toLowerCase().startsWith(S.split("-")[0])
                  );
                return b - w;
              });
          p[0] && (i = p[0]);
        }
        const { language: o, label: l, kind: c } = i;
        dg(df.DISABLED, t, s),
          dg(df.SHOWING, t, [{ language: o, label: l, kind: c }]);
      }
    }
  },
  mP = (n, e) =>
    n === e
      ? !0
      : n == null || e == null || typeof n != typeof e
      ? !1
      : typeof n == "number" && Number.isNaN(n) && Number.isNaN(e)
      ? !0
      : typeof n != "object"
      ? !1
      : Array.isArray(n)
      ? __e(n, e)
      : Object.entries(n).every(([t, s]) => t in e && mP(s, e[t])),
  __e = (n, e) => {
    const t = Array.isArray(n),
      s = Array.isArray(e);
    return t !== s
      ? !1
      : t || s
      ? n.length !== e.length
        ? !1
        : n.every((r, i) => mP(r, e[i]))
      : !0;
  },
  A_e = Object.values(ml);
let Nw;
const R_e = v_e().then((n) => ((Nw = n), Nw)),
  k_e = async (...n) => {
    await Promise.all(
      n
        .filter((e) => e)
        .map(async (e) => {
          if (!("localName" in e && e instanceof Ie.HTMLElement)) return;
          const t = e.localName;
          if (!t.includes("-")) return;
          const s = Ie.customElements.get(t);
          (s && e instanceof s) ||
            (await Ie.customElements.whenDefined(t),
            Ie.customElements.upgrade(e));
        })
    );
  },
  C_e = new Ie.DOMParser(),
  I_e = (n) => n && (C_e.parseFromString(n, "text/html").body.textContent || n),
  Pp = {
    mediaError: {
      get(n, e) {
        const { media: t } = n;
        if (e?.type !== "playing") return t?.error;
      },
      mediaEvents: ["emptied", "error", "playing"],
    },
    mediaErrorCode: {
      get(n, e) {
        var t;
        const { media: s } = n;
        if (e?.type !== "playing")
          return (t = s?.error) == null ? void 0 : t.code;
      },
      mediaEvents: ["emptied", "error", "playing"],
    },
    mediaErrorMessage: {
      get(n, e) {
        var t, s;
        const { media: r } = n;
        if (e?.type !== "playing")
          return (s = (t = r?.error) == null ? void 0 : t.message) != null
            ? s
            : "";
      },
      mediaEvents: ["emptied", "error", "playing"],
    },
    mediaWidth: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.videoWidth) != null ? e : 0;
      },
      mediaEvents: ["resize"],
    },
    mediaHeight: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.videoHeight) != null ? e : 0;
      },
      mediaEvents: ["resize"],
    },
    mediaPaused: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.paused) != null ? e : !0;
      },
      set(n, e) {
        var t;
        const { media: s } = e;
        s && (n ? s.pause() : (t = s.play()) == null || t.catch(() => {}));
      },
      mediaEvents: ["play", "playing", "pause", "emptied"],
    },
    mediaHasPlayed: {
      get(n, e) {
        const { media: t } = n;
        return t ? (e ? e.type === "playing" : !t.paused) : !1;
      },
      mediaEvents: ["playing", "emptied"],
    },
    mediaEnded: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.ended) != null ? e : !1;
      },
      mediaEvents: ["seeked", "ended", "emptied"],
    },
    mediaPlaybackRate: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.playbackRate) != null ? e : 1;
      },
      set(n, e) {
        const { media: t } = e;
        t && Number.isFinite(+n) && (t.playbackRate = +n);
      },
      mediaEvents: ["ratechange", "loadstart"],
    },
    mediaMuted: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.muted) != null ? e : !1;
      },
      set(n, e) {
        const { media: t } = e;
        if (t) {
          try {
            Ie.localStorage.setItem(
              "media-chrome-pref-muted",
              n ? "true" : "false"
            );
          } catch (s) {}
          t.muted = n;
        }
      },
      mediaEvents: ["volumechange"],
      stateOwnersUpdateHandlers: [
        (n, e) => {
          const {
              options: { noMutedPref: t },
            } = e,
            { media: s } = e;
          if (!(!s || s.muted || t))
            try {
              const r =
                Ie.localStorage.getItem("media-chrome-pref-muted") === "true";
              Pp.mediaMuted.set(r, e), n(r);
            } catch (r) {}
        },
      ],
    },
    mediaVolume: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.volume) != null ? e : 1;
      },
      set(n, e) {
        const { media: t } = e;
        if (t) {
          try {
            n == null
              ? Ie.localStorage.removeItem("media-chrome-pref-volume")
              : Ie.localStorage.setItem(
                  "media-chrome-pref-volume",
                  n.toString()
                );
          } catch (s) {}
          Number.isFinite(+n) && (t.volume = +n);
        }
      },
      mediaEvents: ["volumechange"],
      stateOwnersUpdateHandlers: [
        (n, e) => {
          const {
            options: { noVolumePref: t },
          } = e;
          if (!t)
            try {
              const { media: s } = e;
              if (!s) return;
              const r = Ie.localStorage.getItem("media-chrome-pref-volume");
              if (r == null) return;
              Pp.mediaVolume.set(+r, e), n(+r);
            } catch (s) {}
        },
      ],
    },
    mediaVolumeLevel: {
      get(n) {
        const { media: e } = n;
        return typeof e?.volume > "u"
          ? "high"
          : e.muted || e.volume === 0
          ? "off"
          : e.volume < 0.5
          ? "low"
          : e.volume < 0.75
          ? "medium"
          : "high";
      },
      mediaEvents: ["volumechange"],
    },
    mediaCurrentTime: {
      get(n) {
        var e;
        const { media: t } = n;
        return (e = t?.currentTime) != null ? e : 0;
      },
      set(n, e) {
        const { media: t } = e;
        !t || !cP(n) || (t.currentTime = n);
      },
      mediaEvents: ["timeupdate", "loadedmetadata"],
    },
    mediaDuration: {
      get(n) {
        const { media: e, options: { defaultDuration: t } = {} } = n;
        return t &&
          (!e ||
            !e.duration ||
            Number.isNaN(e.duration) ||
            !Number.isFinite(e.duration))
          ? t
          : Number.isFinite(e?.duration)
          ? e.duration
          : Number.NaN;
      },
      mediaEvents: ["durationchange", "loadedmetadata", "emptied"],
    },
    mediaLoading: {
      get(n) {
        const { media: e } = n;
        return e?.readyState < 3;
      },
      mediaEvents: ["waiting", "playing", "emptied"],
    },
    mediaSeekable: {
      get(n) {
        var e;
        const { media: t } = n;
        if (!((e = t?.seekable) != null && e.length)) return;
        const s = t.seekable.start(0),
          r = t.seekable.end(t.seekable.length - 1);
        if (!(!s && !r)) return [Number(s.toFixed(3)), Number(r.toFixed(3))];
      },
      mediaEvents: ["loadedmetadata", "emptied", "progress", "seekablechange"],
    },
    mediaBuffered: {
      get(n) {
        var e;
        const { media: t } = n,
          s = (e = t?.buffered) != null ? e : [];
        return Array.from(s).map((r, i) => [
          Number(s.start(i).toFixed(3)),
          Number(s.end(i).toFixed(3)),
        ]);
      },
      mediaEvents: ["progress", "emptied"],
    },
    mediaStreamType: {
      get(n) {
        const { media: e, options: { defaultStreamType: t } = {} } = n,
          s = [ml.LIVE, ml.ON_DEMAND].includes(t) ? t : void 0;
        if (!e) return s;
        const { streamType: r } = e;
        if (A_e.includes(r)) return r === ml.UNKNOWN ? s : r;
        const i = e.duration;
        return i === 1 / 0 ? ml.LIVE : Number.isFinite(i) ? ml.ON_DEMAND : s;
      },
      mediaEvents: [
        "emptied",
        "durationchange",
        "loadedmetadata",
        "streamtypechange",
      ],
    },
    mediaTargetLiveWindow: {
      get(n) {
        const { media: e } = n;
        if (!e) return Number.NaN;
        const { targetLiveWindow: t } = e,
          s = Pp.mediaStreamType.get(n);
        return (t == null || Number.isNaN(t)) && s === ml.LIVE ? 0 : t;
      },
      mediaEvents: [
        "emptied",
        "durationchange",
        "loadedmetadata",
        "streamtypechange",
        "targetlivewindowchange",
      ],
    },
    mediaTimeIsLive: {
      get(n) {
        const { media: e, options: { liveEdgeOffset: t = 10 } = {} } = n;
        if (!e) return !1;
        if (typeof e.liveEdgeStart == "number")
          return Number.isNaN(e.liveEdgeStart)
            ? !1
            : e.currentTime >= e.liveEdgeStart;
        if (!(Pp.mediaStreamType.get(n) === ml.LIVE)) return !1;
        const r = e.seekable;
        if (!r) return !0;
        if (!r.length) return !1;
        const i = r.end(r.length - 1) - t;
        return e.currentTime >= i;
      },
      mediaEvents: ["playing", "timeupdate", "progress", "waiting", "emptied"],
    },
    mediaSubtitlesList: {
      get(n) {
        return Mw(n).map(({ kind: e, label: t, language: s }) => ({
          kind: e,
          label: t,
          language: s,
        }));
      },
      mediaEvents: ["loadstart"],
      textTracksEvents: ["addtrack", "removetrack"],
    },
    mediaSubtitlesShowing: {
      get(n) {
        return bK(n).map(({ kind: e, label: t, language: s }) => ({
          kind: e,
          label: t,
          language: s,
        }));
      },
      mediaEvents: ["loadstart"],
      textTracksEvents: ["addtrack", "removetrack", "change"],
      stateOwnersUpdateHandlers: [
        (n, e) => {
          var t, s;
          const { media: r, options: i } = e;
          if (!r) return;
          const a = (o) => {
            var l;
            !i.defaultSubtitles ||
              (o &&
                ![Do.CAPTIONS, Do.SUBTITLES].includes(
                  (l = o?.track) == null ? void 0 : l.kind
                )) ||
              xK(e, !0);
          };
          return (
            r.addEventListener("loadstart", a),
            (t = r.textTracks) == null || t.addEventListener("addtrack", a),
            (s = r.textTracks) == null || s.addEventListener("removetrack", a),
            () => {
              var o, l;
              r.removeEventListener("loadstart", a),
                (o = r.textTracks) == null ||
                  o.removeEventListener("addtrack", a),
                (l = r.textTracks) == null ||
                  l.removeEventListener("removetrack", a);
            }
          );
        },
      ],
    },
    mediaChaptersCues: {
      get(n) {
        var e;
        const { media: t } = n;
        if (!t) return [];
        const [s] = aS(t, { kind: Do.CHAPTERS });
        return Array.from((e = s?.cues) != null ? e : []).map(
          ({ text: r, startTime: i, endTime: a }) => ({
            text: I_e(r),
            startTime: i,
            endTime: a,
          })
        );
      },
      mediaEvents: ["loadstart", "loadedmetadata"],
      textTracksEvents: ["addtrack", "removetrack", "change"],
      stateOwnersUpdateHandlers: [
        (n, e) => {
          var t;
          const { media: s } = e;
          if (!s) return;
          const r = s.querySelector('track[kind="chapters"][default][src]'),
            i =
              (t = s.shadowRoot) == null
                ? void 0
                : t.querySelector(
                    ':is(video,audio) > track[kind="chapters"][default][src]'
                  );
          return (
            r?.addEventListener("load", n),
            i?.addEventListener("load", n),
            () => {
              r?.removeEventListener("load", n),
                i?.removeEventListener("load", n);
            }
          );
        },
      ],
    },
    mediaIsPip: {
      get(n) {
        var e, t;
        const { media: s, documentElement: r } = n;
        if (!s || !r || !r.pictureInPictureElement) return !1;
        if (r.pictureInPictureElement === s) return !0;
        if (r.pictureInPictureElement instanceof HTMLMediaElement)
          return (e = s.localName) != null && e.includes("-")
            ? Qf(s, r.pictureInPictureElement)
            : !1;
        if (r.pictureInPictureElement.localName.includes("-")) {
          let i = r.pictureInPictureElement.shadowRoot;
          for (; i?.pictureInPictureElement; ) {
            if (i.pictureInPictureElement === s) return !0;
            i = (t = i.pictureInPictureElement) == null ? void 0 : t.shadowRoot;
          }
        }
        return !1;
      },
      set(n, e) {
        const { media: t } = e;
        if (t)
          if (n) {
            if (!li.pictureInPictureEnabled) {
              console.warn("MediaChrome: Picture-in-picture is not enabled");
              return;
            }
            if (!t.requestPictureInPicture) {
              console.warn(
                "MediaChrome: The current media does not support picture-in-picture"
              );
              return;
            }
            const s = () => {
              console.warn(
                "MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0."
              );
            };
            t.requestPictureInPicture().catch((r) => {
              if (r.code === 11) {
                if (!t.src) {
                  console.warn(
                    "MediaChrome: The media is not ready for picture-in-picture. It must have a src set."
                  );
                  return;
                }
                if (t.readyState === 0 && t.preload === "none") {
                  const i = () => {
                      t.removeEventListener("loadedmetadata", a),
                        (t.preload = "none");
                    },
                    a = () => {
                      t.requestPictureInPicture().catch(s), i();
                    };
                  t.addEventListener("loadedmetadata", a),
                    (t.preload = "metadata"),
                    setTimeout(() => {
                      t.readyState === 0 && s(), i();
                    }, 1e3);
                } else throw r;
              } else throw r;
            });
          } else li.pictureInPictureElement && li.exitPictureInPicture();
      },
      mediaEvents: ["enterpictureinpicture", "leavepictureinpicture"],
    },
    mediaRenditionList: {
      get(n) {
        var e;
        const { media: t } = n;
        return [...((e = t?.videoRenditions) != null ? e : [])].map((s) => ({
          ...s,
        }));
      },
      mediaEvents: ["emptied", "loadstart"],
      videoRenditionsEvents: ["addrendition", "removerendition"],
    },
    mediaRenditionSelected: {
      get(n) {
        var e, t, s;
        const { media: r } = n;
        return (s =
          (t = r?.videoRenditions) == null
            ? void 0
            : t[(e = r.videoRenditions) == null ? void 0 : e.selectedIndex]) ==
          null
          ? void 0
          : s.id;
      },
      set(n, e) {
        const { media: t } = e;
        if (!t?.videoRenditions) {
          console.warn(
            "MediaController: Rendition selection not supported by this media."
          );
          return;
        }
        const s = n,
          r = Array.prototype.findIndex.call(
            t.videoRenditions,
            (i) => i.id == s
          );
        t.videoRenditions.selectedIndex != r &&
          (t.videoRenditions.selectedIndex = r);
      },
      mediaEvents: ["emptied"],
      videoRenditionsEvents: ["addrendition", "removerendition", "change"],
    },
    mediaAudioTrackList: {
      get(n) {
        var e;
        const { media: t } = n;
        return [...((e = t?.audioTracks) != null ? e : [])];
      },
      mediaEvents: ["emptied", "loadstart"],
      audioTracksEvents: ["addtrack", "removetrack"],
    },
    mediaAudioTrackEnabled: {
      get(n) {
        var e, t;
        const { media: s } = n;
        return (t = [...((e = s?.audioTracks) != null ? e : [])].find(
          (r) => r.enabled
        )) == null
          ? void 0
          : t.id;
      },
      set(n, e) {
        const { media: t } = e;
        if (!t?.audioTracks) {
          console.warn(
            "MediaChrome: Audio track selection not supported by this media."
          );
          return;
        }
        const s = n;
        for (const r of t.audioTracks) r.enabled = s == r.id;
      },
      mediaEvents: ["emptied"],
      audioTracksEvents: ["addtrack", "removetrack", "change"],
    },
    mediaIsFullscreen: {
      get(n) {
        return m_e(n);
      },
      set(n, e) {
        n ? d_e(e) : h_e(e);
      },
      rootEvents: ["fullscreenchange", "webkitfullscreenchange"],
      mediaEvents: [
        "webkitbeginfullscreen",
        "webkitendfullscreen",
        "webkitpresentationmodechanged",
      ],
    },
    mediaIsCasting: {
      get(n) {
        var e;
        const { media: t } = n;
        return !t?.remote ||
          ((e = t.remote) == null ? void 0 : e.state) === "disconnected"
          ? !1
          : !!t.remote.state;
      },
      set(n, e) {
        var t, s;
        const { media: r } = e;
        if (
          r &&
          !(
            n && ((t = r.remote) == null ? void 0 : t.state) !== "disconnected"
          ) &&
          !(!n && ((s = r.remote) == null ? void 0 : s.state) !== "connected")
        ) {
          if (typeof r.remote.prompt != "function") {
            console.warn(
              "MediaChrome: Casting is not supported in this environment"
            );
            return;
          }
          r.remote.prompt().catch(() => {});
        }
      },
      remoteEvents: ["connect", "connecting", "disconnect"],
    },
    mediaIsAirplaying: {
      get() {
        return !1;
      },
      set(n, e) {
        const { media: t } = e;
        if (t) {
          if (
            !(
              t.webkitShowPlaybackTargetPicker &&
              Ie.WebKitPlaybackTargetAvailabilityEvent
            )
          ) {
            console.error(
              "MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment"
            );
            return;
          }
          t.webkitShowPlaybackTargetPicker();
        }
      },
      mediaEvents: ["webkitcurrentplaybacktargetiswirelesschanged"],
    },
    mediaFullscreenUnavailable: {
      get(n) {
        const { media: e } = n;
        if (!w_e || !yK(e)) return Gi.UNSUPPORTED;
      },
    },
    mediaPipUnavailable: {
      get(n) {
        const { media: e } = n;
        if (!E_e || !vK(e)) return Gi.UNSUPPORTED;
      },
    },
    mediaVolumeUnavailable: {
      get(n) {
        const { media: e } = n;
        if (Nw === !1 || e?.volume == null) return Gi.UNSUPPORTED;
      },
      stateOwnersUpdateHandlers: [
        (n) => {
          Nw == null && R_e.then((e) => n(e ? void 0 : Gi.UNSUPPORTED));
        },
      ],
    },
    mediaCastUnavailable: {
      get(n, { availability: e = "not-available" } = {}) {
        var t;
        const { media: s } = n;
        if (!T_e || !((t = s?.remote) != null && t.state))
          return Gi.UNSUPPORTED;
        if (!(e == null || e === "available")) return Gi.UNAVAILABLE;
      },
      stateOwnersUpdateHandlers: [
        (n, e) => {
          var t;
          const { media: s } = e;
          return s
            ? (s.disableRemotePlayback ||
                s.hasAttribute("disableremoteplayback") ||
                (t = s?.remote) == null ||
                t
                  .watchAvailability((i) => {
                    n({ availability: i ? "available" : "not-available" });
                  })
                  .catch((i) => {
                    i.name === "NotSupportedError"
                      ? n({ availability: null })
                      : n({ availability: "not-available" });
                  }),
              () => {
                var i;
                (i = s?.remote) == null ||
                  i.cancelWatchAvailability().catch(() => {});
              })
            : void 0;
        },
      ],
    },
    mediaAirplayUnavailable: {
      get(n, e) {
        if (!S_e) return Gi.UNSUPPORTED;
        if (e?.availability === "not-available") return Gi.UNAVAILABLE;
      },
      mediaEvents: ["webkitplaybacktargetavailabilitychanged"],
      stateOwnersUpdateHandlers: [
        (n, e) => {
          var t;
          const { media: s } = e;
          return s
            ? (s.disableRemotePlayback ||
                s.hasAttribute("disableremoteplayback") ||
                (t = s?.remote) == null ||
                t
                  .watchAvailability((i) => {
                    n({ availability: i ? "available" : "not-available" });
                  })
                  .catch((i) => {
                    i.name === "NotSupportedError"
                      ? n({ availability: null })
                      : n({ availability: "not-available" });
                  }),
              () => {
                var i;
                (i = s?.remote) == null ||
                  i.cancelWatchAvailability().catch(() => {});
              })
            : void 0;
        },
      ],
    },
    mediaRenditionUnavailable: {
      get(n) {
        var e;
        const { media: t } = n;
        if (!t?.videoRenditions) return Gi.UNSUPPORTED;
        if (!((e = t.videoRenditions) != null && e.length))
          return Gi.UNAVAILABLE;
      },
      mediaEvents: ["emptied", "loadstart"],
      videoRenditionsEvents: ["addrendition", "removerendition"],
    },
    mediaAudioTrackUnavailable: {
      get(n) {
        var e, t;
        const { media: s } = n;
        if (!s?.audioTracks) return Gi.UNSUPPORTED;
        if (
          ((t = (e = s.audioTracks) == null ? void 0 : e.length) != null
            ? t
            : 0) <= 1
        )
          return Gi.UNAVAILABLE;
      },
      mediaEvents: ["emptied", "loadstart"],
      audioTracksEvents: ["addtrack", "removetrack"],
    },
    mediaLang: {
      get(n) {
        const { options: { mediaLang: e } = {} } = n;
        return e ?? "en";
      },
    },
  },
  L_e = {
    [bt.MEDIA_PREVIEW_REQUEST](n, e, { detail: t }) {
      var s, r, i;
      const { media: a } = e,
        o = t ?? void 0;
      let l, c;
      if (a && o != null) {
        const [g] = aS(a, { kind: Do.METADATA, label: "thumbnails" }),
          y = Array.prototype.find.call(
            (s = g?.cues) != null ? s : [],
            (b, w, S) =>
              w === 0
                ? b.endTime > o
                : w === S.length - 1
                ? b.startTime <= o
                : b.startTime <= o && b.endTime > o
          );
        if (y) {
          const b =
              /'^(?:[a-z]+:)?\/\//i.test(y.text) ||
              (r = a?.querySelector('track[label="thumbnails"]')) == null
                ? void 0
                : r.src,
            w = new URL(y.text, b);
          (c = new URLSearchParams(w.hash)
            .get("#xywh")
            .split(",")
            .map((A) => +A)),
            (l = w.href);
        }
      }
      const h = n.mediaDuration.get(e);
      let p =
        (i = n.mediaChaptersCues
          .get(e)
          .find((g, y, b) =>
            y === b.length - 1 && h === g.endTime
              ? g.startTime <= o && g.endTime >= o
              : g.startTime <= o && g.endTime > o
          )) == null
          ? void 0
          : i.text;
      return (
        t != null && p == null && (p = ""),
        {
          mediaPreviewTime: o,
          mediaPreviewImage: l,
          mediaPreviewCoords: c,
          mediaPreviewChapter: p,
        }
      );
    },
    [bt.MEDIA_PAUSE_REQUEST](n, e) {
      n["mediaPaused"].set(!0, e);
    },
    [bt.MEDIA_PLAY_REQUEST](n, e) {
      var t, s, r, i;
      const a = "mediaPaused",
        l = n.mediaStreamType.get(e) === ml.LIVE,
        c = !((t = e.options) != null && t.noAutoSeekToLive),
        h = n.mediaTargetLiveWindow.get(e) > 0;
      if (l && c && !h) {
        const m = (s = n.mediaSeekable.get(e)) == null ? void 0 : s[1];
        if (m) {
          const p =
              (i = (r = e.options) == null ? void 0 : r.seekToLiveOffset) !=
              null
                ? i
                : 0,
            g = m - p;
          n.mediaCurrentTime.set(g, e);
        }
      }
      n[a].set(!1, e);
    },
    [bt.MEDIA_PLAYBACK_RATE_REQUEST](n, e, { detail: t }) {
      const s = "mediaPlaybackRate",
        r = t;
      n[s].set(r, e);
    },
    [bt.MEDIA_MUTE_REQUEST](n, e) {
      n["mediaMuted"].set(!0, e);
    },
    [bt.MEDIA_UNMUTE_REQUEST](n, e) {
      const t = "mediaMuted";
      n.mediaVolume.get(e) || n.mediaVolume.set(0.25, e), n[t].set(!1, e);
    },
    [bt.MEDIA_VOLUME_REQUEST](n, e, { detail: t }) {
      const s = "mediaVolume",
        r = t;
      r && n.mediaMuted.get(e) && n.mediaMuted.set(!1, e), n[s].set(r, e);
    },
    [bt.MEDIA_SEEK_REQUEST](n, e, { detail: t }) {
      const s = "mediaCurrentTime",
        r = t;
      n[s].set(r, e);
    },
    [bt.MEDIA_SEEK_TO_LIVE_REQUEST](n, e) {
      var t, s, r;
      const i = "mediaCurrentTime",
        a = (t = n.mediaSeekable.get(e)) == null ? void 0 : t[1];
      if (Number.isNaN(Number(a))) return;
      const o =
          (r = (s = e.options) == null ? void 0 : s.seekToLiveOffset) != null
            ? r
            : 0,
        l = a - o;
      n[i].set(l, e);
    },
    [bt.MEDIA_SHOW_SUBTITLES_REQUEST](n, e, { detail: t }) {
      var s;
      const { options: r } = e,
        i = Mw(e),
        a = pK(t),
        o = (s = a[0]) == null ? void 0 : s.language;
      o &&
        !r.noSubtitlesLangPref &&
        Ie.localStorage.setItem("media-chrome-pref-subtitles-lang", o),
        dg(df.SHOWING, i, a);
    },
    [bt.MEDIA_DISABLE_SUBTITLES_REQUEST](n, e, { detail: t }) {
      const s = Mw(e),
        r = t ?? [];
      dg(df.DISABLED, s, r);
    },
    [bt.MEDIA_TOGGLE_SUBTITLES_REQUEST](n, e, { detail: t }) {
      xK(e, t);
    },
    [bt.MEDIA_RENDITION_REQUEST](n, e, { detail: t }) {
      const s = "mediaRenditionSelected",
        r = t;
      n[s].set(r, e);
    },
    [bt.MEDIA_AUDIO_TRACK_REQUEST](n, e, { detail: t }) {
      const s = "mediaAudioTrackEnabled",
        r = t;
      n[s].set(r, e);
    },
    [bt.MEDIA_ENTER_PIP_REQUEST](n, e) {
      const t = "mediaIsPip";
      n.mediaIsFullscreen.get(e) && n.mediaIsFullscreen.set(!1, e),
        n[t].set(!0, e);
    },
    [bt.MEDIA_EXIT_PIP_REQUEST](n, e) {
      n["mediaIsPip"].set(!1, e);
    },
    [bt.MEDIA_ENTER_FULLSCREEN_REQUEST](n, e) {
      const t = "mediaIsFullscreen";
      n.mediaIsPip.get(e) && n.mediaIsPip.set(!1, e), n[t].set(!0, e);
    },
    [bt.MEDIA_EXIT_FULLSCREEN_REQUEST](n, e) {
      n["mediaIsFullscreen"].set(!1, e);
    },
    [bt.MEDIA_ENTER_CAST_REQUEST](n, e) {
      const t = "mediaIsCasting";
      n.mediaIsFullscreen.get(e) && n.mediaIsFullscreen.set(!1, e),
        n[t].set(!0, e);
    },
    [bt.MEDIA_EXIT_CAST_REQUEST](n, e) {
      n["mediaIsCasting"].set(!1, e);
    },
    [bt.MEDIA_AIRPLAY_REQUEST](n, e) {
      n["mediaIsAirplaying"].set(!0, e);
    },
  },
  D_e = ({
    media: n,
    fullscreenElement: e,
    documentElement: t,
    stateMediator: s = Pp,
    requestMap: r = L_e,
    options: i = {},
    monitorStateOwnersOnlyWithSubscriptions: a = !0,
  }) => {
    const o = [],
      l = { options: { ...i } };
    let c = Object.freeze({
      mediaPreviewTime: void 0,
      mediaPreviewImage: void 0,
      mediaPreviewCoords: void 0,
      mediaPreviewChapter: void 0,
    });
    const h = (b) => {
        b != null &&
          (mP(b, c) ||
            ((c = Object.freeze({ ...c, ...b })), o.forEach((w) => w(c))));
      },
      m = () => {
        const b = Object.entries(s).reduce(
          (w, [S, { get: A }]) => ((w[S] = A(l)), w),
          {}
        );
        h(b);
      },
      p = {};
    let g;
    const y = async (b, w) => {
      var S, A, _, R, C, D, L, P, V, N, W, H, z, B, q, O;
      const U = !!g;
      if (((g = { ...l, ...(g ?? {}), ...b }), U)) return;
      await k_e(...Object.values(b));
      const j = o.length > 0 && w === 0 && a,
        Q = l.media !== g.media,
        M =
          ((S = l.media) == null ? void 0 : S.textTracks) !==
          ((A = g.media) == null ? void 0 : A.textTracks),
        I =
          ((_ = l.media) == null ? void 0 : _.videoRenditions) !==
          ((R = g.media) == null ? void 0 : R.videoRenditions),
        F =
          ((C = l.media) == null ? void 0 : C.audioTracks) !==
          ((D = g.media) == null ? void 0 : D.audioTracks),
        Y =
          ((L = l.media) == null ? void 0 : L.remote) !==
          ((P = g.media) == null ? void 0 : P.remote),
        J = l.documentElement !== g.documentElement,
        X = !!l.media && (Q || j),
        Z = !!((V = l.media) != null && V.textTracks) && (M || j),
        te = !!((N = l.media) != null && N.videoRenditions) && (I || j),
        ce = !!((W = l.media) != null && W.audioTracks) && (F || j),
        pe = !!((H = l.media) != null && H.remote) && (Y || j),
        se = !!l.documentElement && (J || j),
        be = X || Z || te || ce || pe || se,
        K = o.length === 0 && w === 1 && a,
        ve = !!g.media && (Q || K),
        Ee = !!((z = g.media) != null && z.textTracks) && (M || K),
        De = !!((B = g.media) != null && B.videoRenditions) && (I || K),
        ge = !!((q = g.media) != null && q.audioTracks) && (F || K),
        re = !!((O = g.media) != null && O.remote) && (Y || K),
        fe = !!g.documentElement && (J || K),
        ke = ve || Ee || De || ge || re || fe;
      if (!(be || ke)) {
        Object.entries(g).forEach(([ie, Ne]) => {
          l[ie] = Ne;
        }),
          m(),
          (g = void 0);
        return;
      }
      Object.entries(s).forEach(
        ([
          ie,
          {
            get: Ne,
            mediaEvents: $e = [],
            textTracksEvents: ot = [],
            videoRenditionsEvents: st = [],
            audioTracksEvents: ht = [],
            remoteEvents: xt = [],
            rootEvents: _e = [],
            stateOwnersUpdateHandlers: Ue = [],
          },
        ]) => {
          p[ie] || (p[ie] = {});
          const He = (ct) => {
            const ft = Ne(l, ct);
            h({ [ie]: ft });
          };
          let Ve;
          (Ve = p[ie].mediaEvents),
            $e.forEach((ct) => {
              Ve &&
                X &&
                (l.media.removeEventListener(ct, Ve),
                (p[ie].mediaEvents = void 0)),
                ve &&
                  (g.media.addEventListener(ct, He), (p[ie].mediaEvents = He));
            }),
            (Ve = p[ie].textTracksEvents),
            ot.forEach((ct) => {
              var ft, Ye;
              Ve &&
                Z &&
                ((ft = l.media.textTracks) == null ||
                  ft.removeEventListener(ct, Ve),
                (p[ie].textTracksEvents = void 0)),
                Ee &&
                  ((Ye = g.media.textTracks) == null ||
                    Ye.addEventListener(ct, He),
                  (p[ie].textTracksEvents = He));
            }),
            (Ve = p[ie].videoRenditionsEvents),
            st.forEach((ct) => {
              var ft, Ye;
              Ve &&
                te &&
                ((ft = l.media.videoRenditions) == null ||
                  ft.removeEventListener(ct, Ve),
                (p[ie].videoRenditionsEvents = void 0)),
                De &&
                  ((Ye = g.media.videoRenditions) == null ||
                    Ye.addEventListener(ct, He),
                  (p[ie].videoRenditionsEvents = He));
            }),
            (Ve = p[ie].audioTracksEvents),
            ht.forEach((ct) => {
              var ft, Ye;
              Ve &&
                ce &&
                ((ft = l.media.audioTracks) == null ||
                  ft.removeEventListener(ct, Ve),
                (p[ie].audioTracksEvents = void 0)),
                ge &&
                  ((Ye = g.media.audioTracks) == null ||
                    Ye.addEventListener(ct, He),
                  (p[ie].audioTracksEvents = He));
            }),
            (Ve = p[ie].remoteEvents),
            xt.forEach((ct) => {
              var ft, Ye;
              Ve &&
                pe &&
                ((ft = l.media.remote) == null ||
                  ft.removeEventListener(ct, Ve),
                (p[ie].remoteEvents = void 0)),
                re &&
                  ((Ye = g.media.remote) == null || Ye.addEventListener(ct, He),
                  (p[ie].remoteEvents = He));
            }),
            (Ve = p[ie].rootEvents),
            _e.forEach((ct) => {
              Ve &&
                se &&
                (l.documentElement.removeEventListener(ct, Ve),
                (p[ie].rootEvents = void 0)),
                fe &&
                  (g.documentElement.addEventListener(ct, He),
                  (p[ie].rootEvents = He));
            });
          const Ze = p[ie].stateOwnersUpdateHandlers;
          Ue.forEach((ct) => {
            Ze && be && Ze(),
              ke && (p[ie].stateOwnersUpdateHandlers = ct(He, g));
          });
        }
      ),
        Object.entries(g).forEach(([ie, Ne]) => {
          l[ie] = Ne;
        }),
        m(),
        (g = void 0);
    };
    return (
      y({ media: n, fullscreenElement: e, documentElement: t, options: i }),
      {
        dispatch(b) {
          const { type: w, detail: S } = b;
          if (r[w] && c.mediaErrorCode == null) {
            h(r[w](s, l, b));
            return;
          }
          w === "mediaelementchangerequest"
            ? y({ media: S })
            : w === "fullscreenelementchangerequest"
            ? y({ fullscreenElement: S })
            : w === "documentelementchangerequest"
            ? y({ documentElement: S })
            : w === "optionschangerequest" &&
              (Object.entries(S ?? {}).forEach(([A, _]) => {
                l.options[A] = _;
              }),
              m());
        },
        getState() {
          return c;
        },
        subscribe(b) {
          return (
            y({}, o.length + 1),
            o.push(b),
            b(c),
            () => {
              const w = o.indexOf(b);
              w >= 0 && (y({}, o.length - 1), o.splice(w, 1));
            }
          );
        },
      }
    );
  };
var pP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Xt = (n, e, t) => (
    pP(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  nl = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  oc = (n, e, t, s) => (pP(n, e, "write to private field"), e.set(n, t), t),
  _c = (n, e, t) => (pP(n, e, "access private method"), t),
  $u,
  Mp,
  Cn,
  Np,
  to,
  Pb,
  Mb,
  TC,
  Df,
  ov,
  Nb,
  _C;
const wK = ["ArrowLeft", "ArrowRight", "Enter", " ", "f", "m", "k", "c"],
  B4 = 10,
  tt = {
    DEFAULT_SUBTITLES: "defaultsubtitles",
    DEFAULT_STREAM_TYPE: "defaultstreamtype",
    DEFAULT_DURATION: "defaultduration",
    FULLSCREEN_ELEMENT: "fullscreenelement",
    HOTKEYS: "hotkeys",
    KEYS_USED: "keysused",
    LIVE_EDGE_OFFSET: "liveedgeoffset",
    SEEK_TO_LIVE_OFFSET: "seektoliveoffset",
    NO_AUTO_SEEK_TO_LIVE: "noautoseektolive",
    NO_HOTKEYS: "nohotkeys",
    NO_VOLUME_PREF: "novolumepref",
    NO_SUBTITLES_LANG_PREF: "nosubtitleslangpref",
    NO_DEFAULT_STORE: "nodefaultstore",
    KEYBOARD_FORWARD_SEEK_OFFSET: "keyboardforwardseekoffset",
    KEYBOARD_BACKWARD_SEEK_OFFSET: "keyboardbackwardseekoffset",
    LANG: "lang",
  };
class P_e extends iS {
  constructor() {
    super(),
      nl(this, Mb),
      nl(this, Df),
      nl(this, Nb),
      (this.mediaStateReceivers = []),
      (this.associatedElementSubscriptions = new Map()),
      nl(this, $u, new hK(this, tt.HOTKEYS)),
      nl(this, Mp, void 0),
      nl(this, Cn, void 0),
      nl(this, Np, void 0),
      nl(this, to, void 0),
      nl(this, Pb, (t) => {
        var s;
        (s = Xt(this, Cn)) == null || s.dispatch(t);
      }),
      this.associateElement(this);
    let e = {};
    oc(this, Np, (t) => {
      Object.entries(t).forEach(([s, r]) => {
        if (s in e && e[s] === r) return;
        this.propagateMediaState(s, r);
        const i = s.toLowerCase(),
          a = new Ie.CustomEvent(MTe[i], { composed: !0, detail: r });
        this.dispatchEvent(a);
      }),
        (e = t);
    }),
      this.enableHotkeys();
  }
  static get observedAttributes() {
    return super.observedAttributes.concat(
      tt.NO_HOTKEYS,
      tt.HOTKEYS,
      tt.DEFAULT_STREAM_TYPE,
      tt.DEFAULT_SUBTITLES,
      tt.DEFAULT_DURATION,
      tt.LANG
    );
  }
  get mediaStore() {
    return Xt(this, Cn);
  }
  set mediaStore(e) {
    var t, s;
    if (
      (Xt(this, Cn) &&
        ((t = Xt(this, to)) == null || t.call(this), oc(this, to, void 0)),
      oc(this, Cn, e),
      !Xt(this, Cn) && !this.hasAttribute(tt.NO_DEFAULT_STORE))
    ) {
      _c(this, Mb, TC).call(this);
      return;
    }
    oc(
      this,
      to,
      (s = Xt(this, Cn)) == null ? void 0 : s.subscribe(Xt(this, Np))
    );
  }
  get fullscreenElement() {
    var e;
    return (e = Xt(this, Mp)) != null ? e : this;
  }
  set fullscreenElement(e) {
    var t;
    this.hasAttribute(tt.FULLSCREEN_ELEMENT) &&
      this.removeAttribute(tt.FULLSCREEN_ELEMENT),
      oc(this, Mp, e),
      (t = Xt(this, Cn)) == null ||
        t.dispatch({
          type: "fullscreenelementchangerequest",
          detail: this.fullscreenElement,
        });
  }
  get defaultSubtitles() {
    return un(this, tt.DEFAULT_SUBTITLES);
  }
  set defaultSubtitles(e) {
    dn(this, tt.DEFAULT_SUBTITLES, e);
  }
  get defaultStreamType() {
    return gs(this, tt.DEFAULT_STREAM_TYPE);
  }
  set defaultStreamType(e) {
    vs(this, tt.DEFAULT_STREAM_TYPE, e);
  }
  get defaultDuration() {
    return ps(this, tt.DEFAULT_DURATION);
  }
  set defaultDuration(e) {
    lr(this, tt.DEFAULT_DURATION, e);
  }
  get noHotkeys() {
    return un(this, tt.NO_HOTKEYS);
  }
  set noHotkeys(e) {
    dn(this, tt.NO_HOTKEYS, e);
  }
  get keysUsed() {
    return gs(this, tt.KEYS_USED);
  }
  set keysUsed(e) {
    vs(this, tt.KEYS_USED, e);
  }
  get liveEdgeOffset() {
    return ps(this, tt.LIVE_EDGE_OFFSET);
  }
  set liveEdgeOffset(e) {
    lr(this, tt.LIVE_EDGE_OFFSET, e);
  }
  get noAutoSeekToLive() {
    return un(this, tt.NO_AUTO_SEEK_TO_LIVE);
  }
  set noAutoSeekToLive(e) {
    dn(this, tt.NO_AUTO_SEEK_TO_LIVE, e);
  }
  get noVolumePref() {
    return un(this, tt.NO_VOLUME_PREF);
  }
  set noVolumePref(e) {
    dn(this, tt.NO_VOLUME_PREF, e);
  }
  get noSubtitlesLangPref() {
    return un(this, tt.NO_SUBTITLES_LANG_PREF);
  }
  set noSubtitlesLangPref(e) {
    dn(this, tt.NO_SUBTITLES_LANG_PREF, e);
  }
  get noDefaultStore() {
    return un(this, tt.NO_DEFAULT_STORE);
  }
  set noDefaultStore(e) {
    dn(this, tt.NO_DEFAULT_STORE, e);
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l, c, h, m, p;
    if ((super.attributeChangedCallback(e, t, s), e === tt.NO_HOTKEYS))
      s !== t && s === ""
        ? (this.hasAttribute(tt.HOTKEYS) &&
            console.warn(
              "Media Chrome: Both `hotkeys` and `nohotkeys` have been set. All hotkeys will be disabled."
            ),
          this.disableHotkeys())
        : s !== t && s === null && this.enableHotkeys();
    else if (e === tt.HOTKEYS) Xt(this, $u).value = s;
    else if (e === tt.DEFAULT_SUBTITLES && s !== t)
      (r = Xt(this, Cn)) == null ||
        r.dispatch({
          type: "optionschangerequest",
          detail: { defaultSubtitles: this.hasAttribute(tt.DEFAULT_SUBTITLES) },
        });
    else if (e === tt.DEFAULT_STREAM_TYPE)
      (a = Xt(this, Cn)) == null ||
        a.dispatch({
          type: "optionschangerequest",
          detail: {
            defaultStreamType:
              (i = this.getAttribute(tt.DEFAULT_STREAM_TYPE)) != null
                ? i
                : void 0,
          },
        });
    else if (e === tt.LIVE_EDGE_OFFSET)
      (o = Xt(this, Cn)) == null ||
        o.dispatch({
          type: "optionschangerequest",
          detail: {
            liveEdgeOffset: this.hasAttribute(tt.LIVE_EDGE_OFFSET)
              ? +this.getAttribute(tt.LIVE_EDGE_OFFSET)
              : void 0,
            seekToLiveOffset: this.hasAttribute(tt.SEEK_TO_LIVE_OFFSET)
              ? void 0
              : +this.getAttribute(tt.LIVE_EDGE_OFFSET),
          },
        });
    else if (e === tt.SEEK_TO_LIVE_OFFSET)
      (l = Xt(this, Cn)) == null ||
        l.dispatch({
          type: "optionschangerequest",
          detail: {
            seekToLiveOffset: this.hasAttribute(tt.SEEK_TO_LIVE_OFFSET)
              ? +this.getAttribute(tt.SEEK_TO_LIVE_OFFSET)
              : void 0,
          },
        });
    else if (e === tt.NO_AUTO_SEEK_TO_LIVE)
      (c = Xt(this, Cn)) == null ||
        c.dispatch({
          type: "optionschangerequest",
          detail: {
            noAutoSeekToLive: this.hasAttribute(tt.NO_AUTO_SEEK_TO_LIVE),
          },
        });
    else if (e === tt.FULLSCREEN_ELEMENT) {
      const g = s
        ? (h = this.getRootNode()) == null
          ? void 0
          : h.getElementById(s)
        : void 0;
      oc(this, Mp, g),
        (m = Xt(this, Cn)) == null ||
          m.dispatch({
            type: "fullscreenelementchangerequest",
            detail: this.fullscreenElement,
          });
    } else
      e === tt.LANG &&
        s !== t &&
        (HTe(s),
        (p = Xt(this, Cn)) == null ||
          p.dispatch({
            type: "optionschangerequest",
            detail: { mediaLang: s },
          }));
  }
  connectedCallback() {
    var e, t;
    !Xt(this, Cn) &&
      !this.hasAttribute(tt.NO_DEFAULT_STORE) &&
      _c(this, Mb, TC).call(this),
      (e = Xt(this, Cn)) == null ||
        e.dispatch({ type: "documentelementchangerequest", detail: li }),
      super.connectedCallback(),
      Xt(this, Cn) &&
        !Xt(this, to) &&
        oc(
          this,
          to,
          (t = Xt(this, Cn)) == null ? void 0 : t.subscribe(Xt(this, Np))
        ),
      this.enableHotkeys();
  }
  disconnectedCallback() {
    var e, t, s, r;
    (e = super.disconnectedCallback) == null || e.call(this),
      Xt(this, Cn) &&
        ((t = Xt(this, Cn)) == null ||
          t.dispatch({ type: "documentelementchangerequest", detail: void 0 }),
        (s = Xt(this, Cn)) == null ||
          s.dispatch({ type: bt.MEDIA_TOGGLE_SUBTITLES_REQUEST, detail: !1 })),
      Xt(this, to) &&
        ((r = Xt(this, to)) == null || r.call(this), oc(this, to, void 0));
  }
  mediaSetCallback(e) {
    var t;
    super.mediaSetCallback(e),
      (t = Xt(this, Cn)) == null ||
        t.dispatch({ type: "mediaelementchangerequest", detail: e }),
      e.hasAttribute("tabindex") || (e.tabIndex = -1);
  }
  mediaUnsetCallback(e) {
    var t;
    super.mediaUnsetCallback(e),
      (t = Xt(this, Cn)) == null ||
        t.dispatch({ type: "mediaelementchangerequest", detail: void 0 });
  }
  propagateMediaState(e, t) {
    z4(this.mediaStateReceivers, e, t);
  }
  associateElement(e) {
    if (!e) return;
    const { associatedElementSubscriptions: t } = this;
    if (t.has(e)) return;
    const s = this.registerMediaStateReceiver.bind(this),
      r = this.unregisterMediaStateReceiver.bind(this),
      i = U_e(e, s, r);
    Object.values(bt).forEach((a) => {
      e.addEventListener(a, Xt(this, Pb));
    }),
      t.set(e, i);
  }
  unassociateElement(e) {
    if (!e) return;
    const { associatedElementSubscriptions: t } = this;
    if (!t.has(e)) return;
    t.get(e)(),
      t.delete(e),
      Object.values(bt).forEach((r) => {
        e.removeEventListener(r, Xt(this, Pb));
      });
  }
  registerMediaStateReceiver(e) {
    if (!e) return;
    const t = this.mediaStateReceivers;
    t.indexOf(e) > -1 ||
      (t.push(e),
      Xt(this, Cn) &&
        Object.entries(Xt(this, Cn).getState()).forEach(([r, i]) => {
          z4([e], r, i);
        }));
  }
  unregisterMediaStateReceiver(e) {
    const t = this.mediaStateReceivers,
      s = t.indexOf(e);
    s < 0 || t.splice(s, 1);
  }
  enableHotkeys() {
    this.addEventListener("keydown", _c(this, Nb, _C));
  }
  disableHotkeys() {
    this.removeEventListener("keydown", _c(this, Nb, _C)),
      this.removeEventListener("keyup", _c(this, Df, ov));
  }
  get hotkeys() {
    return gs(this, tt.HOTKEYS);
  }
  set hotkeys(e) {
    vs(this, tt.HOTKEYS, e);
  }
  keyboardShortcutHandler(e) {
    var t, s, r, i, a;
    const o = e.target;
    if (
      ((r =
        (s =
          (t = o.getAttribute(tt.KEYS_USED)) == null ? void 0 : t.split(" ")) !=
        null
          ? s
          : o?.keysUsed) != null
        ? r
        : []
      )
        .map((p) => (p === "Space" ? " " : p))
        .filter(Boolean)
        .includes(e.key)
    )
      return;
    let c, h, m;
    if (
      !Xt(this, $u).contains(`no${e.key.toLowerCase()}`) &&
      !(e.key === " " && Xt(this, $u).contains("nospace"))
    )
      switch (e.key) {
        case " ":
        case "k":
          (c = Xt(this, Cn).getState().mediaPaused
            ? bt.MEDIA_PLAY_REQUEST
            : bt.MEDIA_PAUSE_REQUEST),
            this.dispatchEvent(
              new Ie.CustomEvent(c, { composed: !0, bubbles: !0 })
            );
          break;
        case "m":
          (c =
            this.mediaStore.getState().mediaVolumeLevel === "off"
              ? bt.MEDIA_UNMUTE_REQUEST
              : bt.MEDIA_MUTE_REQUEST),
            this.dispatchEvent(
              new Ie.CustomEvent(c, { composed: !0, bubbles: !0 })
            );
          break;
        case "f":
          (c = this.mediaStore.getState().mediaIsFullscreen
            ? bt.MEDIA_EXIT_FULLSCREEN_REQUEST
            : bt.MEDIA_ENTER_FULLSCREEN_REQUEST),
            this.dispatchEvent(
              new Ie.CustomEvent(c, { composed: !0, bubbles: !0 })
            );
          break;
        case "c":
          this.dispatchEvent(
            new Ie.CustomEvent(bt.MEDIA_TOGGLE_SUBTITLES_REQUEST, {
              composed: !0,
              bubbles: !0,
            })
          );
          break;
        case "ArrowLeft": {
          const p = this.hasAttribute(tt.KEYBOARD_BACKWARD_SEEK_OFFSET)
            ? +this.getAttribute(tt.KEYBOARD_BACKWARD_SEEK_OFFSET)
            : B4;
          (h = Math.max(
            ((i = this.mediaStore.getState().mediaCurrentTime) != null
              ? i
              : 0) - p,
            0
          )),
            (m = new Ie.CustomEvent(bt.MEDIA_SEEK_REQUEST, {
              composed: !0,
              bubbles: !0,
              detail: h,
            })),
            this.dispatchEvent(m);
          break;
        }
        case "ArrowRight": {
          const p = this.hasAttribute(tt.KEYBOARD_FORWARD_SEEK_OFFSET)
            ? +this.getAttribute(tt.KEYBOARD_FORWARD_SEEK_OFFSET)
            : B4;
          (h = Math.max(
            ((a = this.mediaStore.getState().mediaCurrentTime) != null
              ? a
              : 0) + p,
            0
          )),
            (m = new Ie.CustomEvent(bt.MEDIA_SEEK_REQUEST, {
              composed: !0,
              bubbles: !0,
              detail: h,
            })),
            this.dispatchEvent(m);
          break;
        }
      }
  }
}
$u = new WeakMap();
Mp = new WeakMap();
Cn = new WeakMap();
Np = new WeakMap();
to = new WeakMap();
Pb = new WeakMap();
Mb = new WeakSet();
TC = function () {
  var n;
  this.mediaStore = D_e({
    media: this.media,
    fullscreenElement: this.fullscreenElement,
    options: {
      defaultSubtitles: this.hasAttribute(tt.DEFAULT_SUBTITLES),
      defaultDuration: this.hasAttribute(tt.DEFAULT_DURATION)
        ? +this.getAttribute(tt.DEFAULT_DURATION)
        : void 0,
      defaultStreamType:
        (n = this.getAttribute(tt.DEFAULT_STREAM_TYPE)) != null ? n : void 0,
      liveEdgeOffset: this.hasAttribute(tt.LIVE_EDGE_OFFSET)
        ? +this.getAttribute(tt.LIVE_EDGE_OFFSET)
        : void 0,
      seekToLiveOffset: this.hasAttribute(tt.SEEK_TO_LIVE_OFFSET)
        ? +this.getAttribute(tt.SEEK_TO_LIVE_OFFSET)
        : this.hasAttribute(tt.LIVE_EDGE_OFFSET)
        ? +this.getAttribute(tt.LIVE_EDGE_OFFSET)
        : void 0,
      noAutoSeekToLive: this.hasAttribute(tt.NO_AUTO_SEEK_TO_LIVE),
      noVolumePref: this.hasAttribute(tt.NO_VOLUME_PREF),
      noSubtitlesLangPref: this.hasAttribute(tt.NO_SUBTITLES_LANG_PREF),
    },
  });
};
Df = new WeakSet();
ov = function (n) {
  const { key: e } = n;
  if (!wK.includes(e)) {
    this.removeEventListener("keyup", _c(this, Df, ov));
    return;
  }
  this.keyboardShortcutHandler(n);
};
Nb = new WeakSet();
_C = function (n) {
  const { metaKey: e, altKey: t, key: s } = n;
  if (e || t || !wK.includes(s)) {
    this.removeEventListener("keyup", _c(this, Df, ov));
    return;
  }
  [" ", "ArrowLeft", "ArrowRight"].includes(s) &&
    !(
      Xt(this, $u).contains(`no${s.toLowerCase()}`) ||
      (s === " " && Xt(this, $u).contains("nospace"))
    ) &&
    n.preventDefault(),
    this.addEventListener("keyup", _c(this, Df, ov), { once: !0 });
};
const M_e = Object.values(ae),
  N_e = Object.values(GW),
  EK = (n) => {
    var e, t, s, r;
    let { observedAttributes: i } = n.constructor;
    !i &&
      (e = n.nodeName) != null &&
      e.includes("-") &&
      (Ie.customElements.upgrade(n),
      ({ observedAttributes: i } = n.constructor));
    const a =
      (r =
        (s =
          (t = n?.getAttribute) == null
            ? void 0
            : t.call(n, xn.MEDIA_CHROME_ATTRIBUTES)) == null
          ? void 0
          : s.split) == null
        ? void 0
        : r.call(s, /\s+/);
    return Array.isArray(i || a) ? (i || a).filter((o) => M_e.includes(o)) : [];
  },
  O_e = (n) => {
    var e, t;
    return (
      (e = n.nodeName) != null &&
        e.includes("-") &&
        Ie.customElements.get(
          (t = n.nodeName) == null ? void 0 : t.toLowerCase()
        ) &&
        !(n instanceof Ie.customElements.get(n.nodeName.toLowerCase())) &&
        Ie.customElements.upgrade(n),
      N_e.some((s) => s in n)
    );
  },
  AC = (n) => O_e(n) || !!EK(n).length,
  H4 = (n) => {
    var e;
    return (e = n?.join) == null ? void 0 : e.call(n, ":");
  },
  V4 = {
    [ae.MEDIA_SUBTITLES_LIST]: SC,
    [ae.MEDIA_SUBTITLES_SHOWING]: SC,
    [ae.MEDIA_SEEKABLE]: H4,
    [ae.MEDIA_BUFFERED]: (n) => n?.map(H4).join(" "),
    [ae.MEDIA_PREVIEW_COORDS]: (n) => n?.join(" "),
    [ae.MEDIA_RENDITION_LIST]: OTe,
    [ae.MEDIA_AUDIO_TRACK_LIST]: FTe,
  },
  j_e = async (n, e, t) => {
    var s, r;
    if ((n.isConnected || (await WW(0)), typeof t == "boolean" || t == null))
      return dn(n, e, t);
    if (typeof t == "number") return lr(n, e, t);
    if (typeof t == "string") return vs(n, e, t);
    if (Array.isArray(t) && !t.length) return n.removeAttribute(e);
    const i =
      (r = (s = V4[e]) == null ? void 0 : s.call(V4, t)) != null ? r : t;
    return n.setAttribute(e, i);
  },
  F_e = (n) => {
    var e;
    return !!((e = n.closest) != null && e.call(n, '*[slot="media"]'));
  },
  Cu = (n, e) => {
    if (F_e(n)) return;
    const t = (r, i) => {
        var a, o;
        AC(r) && i(r);
        const { children: l = [] } = r ?? {},
          c =
            (o = (a = r?.shadowRoot) == null ? void 0 : a.children) != null
              ? o
              : [];
        [...l, ...c].forEach((m) => Cu(m, i));
      },
      s = n?.nodeName.toLowerCase();
    if (s.includes("-") && !AC(n)) {
      Ie.customElements.whenDefined(s).then(() => {
        t(n, e);
      });
      return;
    }
    t(n, e);
  },
  z4 = (n, e, t) => {
    n.forEach((s) => {
      if (e in s) {
        s[e] = t;
        return;
      }
      const r = EK(s),
        i = e.toLowerCase();
      r.includes(i) && j_e(s, i, t);
    });
  },
  U_e = (n, e, t) => {
    Cu(n, e);
    const s = (h) => {
        var m;
        const p = (m = h?.composedPath()[0]) != null ? m : h.target;
        e(p);
      },
      r = (h) => {
        var m;
        const p = (m = h?.composedPath()[0]) != null ? m : h.target;
        t(p);
      };
    n.addEventListener(bt.REGISTER_MEDIA_STATE_RECEIVER, s),
      n.addEventListener(bt.UNREGISTER_MEDIA_STATE_RECEIVER, r);
    const i = (h) => {
      h.forEach((m) => {
        const {
          addedNodes: p = [],
          removedNodes: g = [],
          type: y,
          target: b,
          attributeName: w,
        } = m;
        y === "childList"
          ? (Array.prototype.forEach.call(p, (S) => Cu(S, e)),
            Array.prototype.forEach.call(g, (S) => Cu(S, t)))
          : y === "attributes" &&
            w === xn.MEDIA_CHROME_ATTRIBUTES &&
            (AC(b) ? e(b) : t(b));
      });
    };
    let a = [];
    const o = (h) => {
      const m = h.target;
      m.name !== "media" &&
        (a.forEach((p) => Cu(p, t)),
        (a = [...m.assignedElements({ flatten: !0 })]),
        a.forEach((p) => Cu(p, e)));
    };
    n.addEventListener("slotchange", o);
    const l = new MutationObserver(i);
    return (
      l.observe(n, { childList: !0, attributes: !0, subtree: !0 }),
      () => {
        Cu(n, t),
          n.removeEventListener("slotchange", o),
          l.disconnect(),
          n.removeEventListener(bt.REGISTER_MEDIA_STATE_RECEIVER, s),
          n.removeEventListener(bt.UNREGISTER_MEDIA_STATE_RECEIVER, r);
      }
    );
  };
Ie.customElements.get("media-controller") ||
  Ie.customElements.define("media-controller", P_e);
const fh = { PLACEMENT: "placement", BOUNDS: "bounds" };
function $_e(n) {
  return `
    <style>
      :host {
        --_tooltip-background-color: var(--media-tooltip-background-color, var(--media-secondary-color, rgba(20, 20, 30, .7)));
        --_tooltip-background: var(--media-tooltip-background, var(--_tooltip-background-color));
        --_tooltip-arrow-half-width: calc(var(--media-tooltip-arrow-width, 12px) / 2);
        --_tooltip-arrow-height: var(--media-tooltip-arrow-height, 5px);
        --_tooltip-arrow-background: var(--media-tooltip-arrow-color, var(--_tooltip-background-color));
        position: relative;
        pointer-events: none;
        display: var(--media-tooltip-display, inline-flex);
        justify-content: center;
        align-items: center;
        box-sizing: border-box;
        z-index: var(--media-tooltip-z-index, 1);
        background: var(--_tooltip-background);
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        font: var(--media-font,
          var(--media-font-weight, 400)
          var(--media-font-size, 13px) /
          var(--media-text-content-height, var(--media-control-height, 18px))
          var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
        padding: var(--media-tooltip-padding, .35em .7em);
        border: var(--media-tooltip-border, none);
        border-radius: var(--media-tooltip-border-radius, 5px);
        filter: var(--media-tooltip-filter, drop-shadow(0 0 4px rgba(0, 0, 0, .2)));
        white-space: var(--media-tooltip-white-space, nowrap);
      }

      :host([hidden]) {
        display: none;
      }

      img, svg {
        display: inline-block;
      }

      #arrow {
        position: absolute;
        width: 0px;
        height: 0px;
        border-style: solid;
        display: var(--media-tooltip-arrow-display, block);
      }

      :host(:not([placement])),
      :host([placement="top"]) {
        position: absolute;
        bottom: calc(100% + var(--media-tooltip-distance, 12px));
        left: 50%;
        transform: translate(calc(-50% - var(--media-tooltip-offset-x, 0px)), 0);
      }
      :host(:not([placement])) #arrow,
      :host([placement="top"]) #arrow {
        top: 100%;
        left: 50%;
        border-width: var(--_tooltip-arrow-height) var(--_tooltip-arrow-half-width) 0 var(--_tooltip-arrow-half-width);
        border-color: var(--_tooltip-arrow-background) transparent transparent transparent;
        transform: translate(calc(-50% + var(--media-tooltip-offset-x, 0px)), 0);
      }

      :host([placement="right"]) {
        position: absolute;
        left: calc(100% + var(--media-tooltip-distance, 12px));
        top: 50%;
        transform: translate(0, -50%);
      }
      :host([placement="right"]) #arrow {
        top: 50%;
        right: 100%;
        border-width: var(--_tooltip-arrow-half-width) var(--_tooltip-arrow-height) var(--_tooltip-arrow-half-width) 0;
        border-color: transparent var(--_tooltip-arrow-background) transparent transparent;
        transform: translate(0, -50%);
      }

      :host([placement="bottom"]) {
        position: absolute;
        top: calc(100% + var(--media-tooltip-distance, 12px));
        left: 50%;
        transform: translate(calc(-50% - var(--media-tooltip-offset-x, 0px)), 0);
      }
      :host([placement="bottom"]) #arrow {
        bottom: 100%;
        left: 50%;
        border-width: 0 var(--_tooltip-arrow-half-width) var(--_tooltip-arrow-height) var(--_tooltip-arrow-half-width);
        border-color: transparent transparent var(--_tooltip-arrow-background) transparent;
        transform: translate(calc(-50% + var(--media-tooltip-offset-x, 0px)), 0);
      }

      :host([placement="left"]) {
        position: absolute;
        right: calc(100% + var(--media-tooltip-distance, 12px));
        top: 50%;
        transform: translate(0, -50%);
      }
      :host([placement="left"]) #arrow {
        top: 50%;
        left: 100%;
        border-width: var(--_tooltip-arrow-half-width) 0 var(--_tooltip-arrow-half-width) var(--_tooltip-arrow-height);
        border-color: transparent transparent transparent var(--_tooltip-arrow-background);
        transform: translate(0, -50%);
      }
      
      :host([placement="none"]) #arrow {
        display: none;
      }
    </style>
    <slot></slot>
    <div id="arrow"></div>
  `;
}
class oS extends Ie.HTMLElement {
  constructor() {
    if (
      (super(),
      (this.updateXOffset = () => {
        var e;
        if (!iK(this, { checkOpacity: !1, checkVisibilityCSS: !1 })) return;
        const t = this.placement;
        if (t === "left" || t === "right") {
          this.style.removeProperty("--media-tooltip-offset-x");
          return;
        }
        const s = getComputedStyle(this),
          r = (e = Gv(this, "#" + this.bounds)) != null ? e : GTe(this);
        if (!r) return;
        const { x: i, width: a } = r.getBoundingClientRect(),
          { x: o, width: l } = this.getBoundingClientRect(),
          c = o + l,
          h = i + a,
          m = s.getPropertyValue("--media-tooltip-offset-x"),
          p = m ? parseFloat(m.replace("px", "")) : 0,
          g = s.getPropertyValue("--media-tooltip-container-margin"),
          y = g ? parseFloat(g.replace("px", "")) : 0,
          b = o - i + p - y,
          w = c - h + p + y;
        if (b < 0) {
          this.style.setProperty("--media-tooltip-offset-x", `${b}px`);
          return;
        }
        if (w > 0) {
          this.style.setProperty("--media-tooltip-offset-x", `${w}px`);
          return;
        }
        this.style.removeProperty("--media-tooltip-offset-x");
      }),
      !this.shadowRoot)
    ) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
    if (
      ((this.arrowEl = this.shadowRoot.querySelector("#arrow")),
      Object.prototype.hasOwnProperty.call(this, "placement"))
    ) {
      const e = this.placement;
      delete this.placement, (this.placement = e);
    }
  }
  static get observedAttributes() {
    return [fh.PLACEMENT, fh.BOUNDS];
  }
  get placement() {
    return gs(this, fh.PLACEMENT);
  }
  set placement(e) {
    vs(this, fh.PLACEMENT, e);
  }
  get bounds() {
    return gs(this, fh.BOUNDS);
  }
  set bounds(e) {
    vs(this, fh.BOUNDS, e);
  }
}
oS.shadowRootOptions = { mode: "open" };
oS.getTemplateHTML = $_e;
Ie.customElements.get("media-tooltip") ||
  Ie.customElements.define("media-tooltip", oS);
var G4 = oS,
  gP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Ls = (n, e, t) => (
    gP(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  mh = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Hy = (n, e, t, s) => (gP(n, e, "write to private field"), e.set(n, t), t),
  B_e = (n, e, t) => (gP(n, e, "access private method"), t),
  no,
  Xh,
  Ac,
  Ch,
  Ob,
  RC,
  SK;
const lc = {
  TOOLTIP_PLACEMENT: "tooltipplacement",
  DISABLED: "disabled",
  NO_TOOLTIP: "notooltip",
};
function H_e(n, e = {}) {
  return `
    <style>
      :host {
        position: relative;
        font: var(--media-font,
          var(--media-font-weight, bold)
          var(--media-font-size, 14px) /
          var(--media-text-content-height, var(--media-control-height, 24px))
          var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));
        padding: var(--media-button-padding, var(--media-control-padding, 10px));
        justify-content: var(--media-button-justify-content, center);
        display: inline-flex;
        align-items: center;
        vertical-align: middle;
        box-sizing: border-box;
        transition: background .15s linear;
        pointer-events: auto;
        cursor: var(--media-cursor, pointer);
        -webkit-tap-highlight-color: transparent;
      }

      
      :host(:focus-visible) {
        box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);
        outline: 0;
      }
      
      :host(:where(:focus)) {
        box-shadow: none;
        outline: 0;
      }

      :host(:hover) {
        background: var(--media-control-hover-background, rgba(50 50 70 / .7));
      }

      svg, img, ::slotted(svg), ::slotted(img) {
        width: var(--media-button-icon-width);
        height: var(--media-button-icon-height, var(--media-control-height, 24px));
        transform: var(--media-button-icon-transform);
        transition: var(--media-button-icon-transition);
        fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));
        vertical-align: middle;
        max-width: 100%;
        max-height: 100%;
        min-width: 100%;
      }

      media-tooltip {
        
        max-width: 0;
        overflow-x: clip;
        opacity: 0;
        transition: opacity .3s, max-width 0s 9s;
      }

      :host(:hover) media-tooltip,
      :host(:focus-visible) media-tooltip {
        max-width: 100vw;
        opacity: 1;
        transition: opacity .3s;
      }

      :host([notooltip]) slot[name="tooltip"] {
        display: none;
      }
    </style>

    ${this.getSlotTemplateHTML(n, e)}

    <slot name="tooltip">
      <media-tooltip part="tooltip" aria-hidden="true">
        <template shadowrootmode="${G4.shadowRootOptions.mode}">
          ${G4.getTemplateHTML({})}
        </template>
        <slot name="tooltip-content">
          ${this.getTooltipContentHTML(n)}
        </slot>
      </media-tooltip>
    </slot>
  `;
}
function V_e(n, e) {
  return `
    <slot></slot>
  `;
}
function z_e() {
  return "";
}
class Nr extends Ie.HTMLElement {
  constructor() {
    if (
      (super(),
      mh(this, RC),
      mh(this, no, void 0),
      (this.preventClick = !1),
      (this.tooltipEl = null),
      mh(this, Xh, (e) => {
        this.preventClick || this.handleClick(e), setTimeout(Ls(this, Ac), 0);
      }),
      mh(this, Ac, () => {
        var e, t;
        (t = (e = this.tooltipEl) == null ? void 0 : e.updateXOffset) == null ||
          t.call(e);
      }),
      mh(this, Ch, (e) => {
        const { key: t } = e;
        if (!this.keysUsed.includes(t)) {
          this.removeEventListener("keyup", Ls(this, Ch));
          return;
        }
        this.preventClick || this.handleClick(e);
      }),
      mh(this, Ob, (e) => {
        const { metaKey: t, altKey: s, key: r } = e;
        if (t || s || !this.keysUsed.includes(r)) {
          this.removeEventListener("keyup", Ls(this, Ch));
          return;
        }
        this.addEventListener("keyup", Ls(this, Ch), { once: !0 });
      }),
      !this.shadowRoot)
    ) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes),
        t = this.constructor.getTemplateHTML(e);
      this.shadowRoot.setHTMLUnsafe
        ? this.shadowRoot.setHTMLUnsafe(t)
        : (this.shadowRoot.innerHTML = t);
    }
    this.tooltipEl = this.shadowRoot.querySelector("media-tooltip");
  }
  static get observedAttributes() {
    return [
      "disabled",
      lc.TOOLTIP_PLACEMENT,
      xn.MEDIA_CONTROLLER,
      ae.MEDIA_LANG,
    ];
  }
  enable() {
    this.addEventListener("click", Ls(this, Xh)),
      this.addEventListener("keydown", Ls(this, Ob)),
      (this.tabIndex = 0);
  }
  disable() {
    this.removeEventListener("click", Ls(this, Xh)),
      this.removeEventListener("keydown", Ls(this, Ob)),
      this.removeEventListener("keyup", Ls(this, Ch)),
      (this.tabIndex = -1);
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === xn.MEDIA_CONTROLLER
      ? (t &&
          ((i = (r = Ls(this, no)) == null ? void 0 : r.unassociateElement) ==
            null || i.call(r, this),
          Hy(this, no, null)),
        s &&
          this.isConnected &&
          (Hy(
            this,
            no,
            (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
          ),
          (l = (o = Ls(this, no)) == null ? void 0 : o.associateElement) ==
            null || l.call(o, this)))
      : e === "disabled" && s !== t
      ? s == null
        ? this.enable()
        : this.disable()
      : e === lc.TOOLTIP_PLACEMENT && this.tooltipEl && s !== t
      ? (this.tooltipEl.placement = s)
      : e === ae.MEDIA_LANG &&
        (this.shadowRoot.querySelector(
          'slot[name="tooltip-content"]'
        ).innerHTML = this.constructor.getTooltipContentHTML()),
      Ls(this, Ac).call(this);
  }
  connectedCallback() {
    var e, t, s;
    const { style: r } = Ns(this.shadowRoot, ":host");
    r.setProperty(
      "display",
      `var(--media-control-display, var(--${this.localName}-display, inline-flex))`
    ),
      this.hasAttribute("disabled") ? this.disable() : this.enable(),
      this.setAttribute("role", "button");
    const i = this.getAttribute(xn.MEDIA_CONTROLLER);
    i &&
      (Hy(
        this,
        no,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(i)
      ),
      (s = (t = Ls(this, no)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this)),
      Ie.customElements
        .whenDefined("media-tooltip")
        .then(() => B_e(this, RC, SK).call(this));
  }
  disconnectedCallback() {
    var e, t;
    this.disable(),
      (t = (e = Ls(this, no)) == null ? void 0 : e.unassociateElement) ==
        null || t.call(e, this),
      Hy(this, no, null),
      this.removeEventListener("mouseenter", Ls(this, Ac)),
      this.removeEventListener("focus", Ls(this, Ac)),
      this.removeEventListener("click", Ls(this, Xh));
  }
  get keysUsed() {
    return ["Enter", " "];
  }
  get tooltipPlacement() {
    return gs(this, lc.TOOLTIP_PLACEMENT);
  }
  set tooltipPlacement(e) {
    vs(this, lc.TOOLTIP_PLACEMENT, e);
  }
  get mediaController() {
    return gs(this, xn.MEDIA_CONTROLLER);
  }
  set mediaController(e) {
    vs(this, xn.MEDIA_CONTROLLER, e);
  }
  get disabled() {
    return un(this, lc.DISABLED);
  }
  set disabled(e) {
    dn(this, lc.DISABLED, e);
  }
  get noTooltip() {
    return un(this, lc.NO_TOOLTIP);
  }
  set noTooltip(e) {
    dn(this, lc.NO_TOOLTIP, e);
  }
  handleClick(e) {}
}
no = new WeakMap();
Xh = new WeakMap();
Ac = new WeakMap();
Ch = new WeakMap();
Ob = new WeakMap();
RC = new WeakSet();
SK = function () {
  this.addEventListener("mouseenter", Ls(this, Ac)),
    this.addEventListener("focus", Ls(this, Ac)),
    this.addEventListener("click", Ls(this, Xh));
  const n = this.tooltipPlacement;
  n && this.tooltipEl && (this.tooltipEl.placement = n);
};
Nr.shadowRootOptions = { mode: "open" };
Nr.getTemplateHTML = H_e;
Nr.getSlotTemplateHTML = V_e;
Nr.getTooltipContentHTML = z_e;
Ie.customElements.get("media-chrome-button") ||
  Ie.customElements.define("media-chrome-button", Nr);
const q4 = `<svg aria-hidden="true" viewBox="0 0 26 24">
  <path d="M22.13 3H3.87a.87.87 0 0 0-.87.87v13.26a.87.87 0 0 0 .87.87h3.4L9 16H5V5h16v11h-4l1.72 2h3.4a.87.87 0 0 0 .87-.87V3.87a.87.87 0 0 0-.86-.87Zm-8.75 11.44a.5.5 0 0 0-.76 0l-4.91 5.73a.5.5 0 0 0 .38.83h9.82a.501.501 0 0 0 .38-.83l-4.91-5.73Z"/>
</svg>
`;
function G_e(n) {
  return `
    <style>
      :host([${ae.MEDIA_IS_AIRPLAYING}]) slot[name=icon] slot:not([name=exit]) {
        display: none !important;
      }

      
      :host(:not([${ae.MEDIA_IS_AIRPLAYING}])) slot[name=icon] slot:not([name=enter]) {
        display: none !important;
      }

      :host([${ae.MEDIA_IS_AIRPLAYING}]) slot[name=tooltip-enter],
      :host(:not([${ae.MEDIA_IS_AIRPLAYING}])) slot[name=tooltip-exit] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="enter">${q4}</slot>
      <slot name="exit">${q4}</slot>
    </slot>
  `;
}
function q_e() {
  return `
    <slot name="tooltip-enter">${Tt("start airplay")}</slot>
    <slot name="tooltip-exit">${Tt("stop airplay")}</slot>
  `;
}
const W4 = (n) => {
  const e = n.mediaIsAirplaying ? Tt("stop airplay") : Tt("start airplay");
  n.setAttribute("aria-label", e);
};
class vP extends Nr {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_IS_AIRPLAYING,
      ae.MEDIA_AIRPLAY_UNAVAILABLE,
    ];
  }
  connectedCallback() {
    super.connectedCallback(), W4(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_IS_AIRPLAYING && W4(this);
  }
  get mediaIsAirplaying() {
    return un(this, ae.MEDIA_IS_AIRPLAYING);
  }
  set mediaIsAirplaying(e) {
    dn(this, ae.MEDIA_IS_AIRPLAYING, e);
  }
  get mediaAirplayUnavailable() {
    return gs(this, ae.MEDIA_AIRPLAY_UNAVAILABLE);
  }
  set mediaAirplayUnavailable(e) {
    vs(this, ae.MEDIA_AIRPLAY_UNAVAILABLE, e);
  }
  handleClick() {
    const e = new Ie.CustomEvent(bt.MEDIA_AIRPLAY_REQUEST, {
      composed: !0,
      bubbles: !0,
    });
    this.dispatchEvent(e);
  }
}
vP.getSlotTemplateHTML = G_e;
vP.getTooltipContentHTML = q_e;
Ie.customElements.get("media-airplay-button") ||
  Ie.customElements.define("media-airplay-button", vP);
const W_e = `<svg aria-hidden="true" viewBox="0 0 26 24">
  <path d="M22.83 5.68a2.58 2.58 0 0 0-2.3-2.5c-3.62-.24-11.44-.24-15.06 0a2.58 2.58 0 0 0-2.3 2.5c-.23 4.21-.23 8.43 0 12.64a2.58 2.58 0 0 0 2.3 2.5c3.62.24 11.44.24 15.06 0a2.58 2.58 0 0 0 2.3-2.5c.23-4.21.23-8.43 0-12.64Zm-11.39 9.45a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.92 3.92 0 0 1 .92-2.77 3.18 3.18 0 0 1 2.43-1 2.94 2.94 0 0 1 2.13.78c.364.359.62.813.74 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.17 1.61 1.61 0 0 0-1.29.58 2.79 2.79 0 0 0-.5 1.89 3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.48 1.48 0 0 0 1-.37 2.1 2.1 0 0 0 .59-1.14l1.4.44a3.23 3.23 0 0 1-1.07 1.69Zm7.22 0a3.07 3.07 0 0 1-1.91.57 3.06 3.06 0 0 1-2.34-1 3.75 3.75 0 0 1-.92-2.67 3.88 3.88 0 0 1 .93-2.77 3.14 3.14 0 0 1 2.42-1 3 3 0 0 1 2.16.82 2.8 2.8 0 0 1 .73 1.31l-1.43.35a1.49 1.49 0 0 0-1.51-1.21 1.61 1.61 0 0 0-1.29.58A2.79 2.79 0 0 0 15 12a3 3 0 0 0 .49 1.93 1.61 1.61 0 0 0 1.27.58 1.44 1.44 0 0 0 1-.37 2.1 2.1 0 0 0 .6-1.15l1.4.44a3.17 3.17 0 0 1-1.1 1.7Z"/>
</svg>`,
  K_e = `<svg aria-hidden="true" viewBox="0 0 26 24">
  <path d="M17.73 14.09a1.4 1.4 0 0 1-1 .37 1.579 1.579 0 0 1-1.27-.58A3 3 0 0 1 15 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34A2.89 2.89 0 0 0 19 9.07a3 3 0 0 0-2.14-.78 3.14 3.14 0 0 0-2.42 1 3.91 3.91 0 0 0-.93 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.17 3.17 0 0 0 1.07-1.74l-1.4-.45c-.083.43-.3.822-.62 1.12Zm-7.22 0a1.43 1.43 0 0 1-1 .37 1.58 1.58 0 0 1-1.27-.58A3 3 0 0 1 7.76 12a2.8 2.8 0 0 1 .5-1.85 1.63 1.63 0 0 1 1.29-.57 1.47 1.47 0 0 1 1.51 1.2l1.43-.34a2.81 2.81 0 0 0-.74-1.32 2.94 2.94 0 0 0-2.13-.78 3.18 3.18 0 0 0-2.43 1 4 4 0 0 0-.92 2.78 3.74 3.74 0 0 0 .92 2.66 3.07 3.07 0 0 0 2.34 1 3.07 3.07 0 0 0 1.91-.57 3.23 3.23 0 0 0 1.07-1.74l-1.4-.45a2.06 2.06 0 0 1-.6 1.07Zm12.32-8.41a2.59 2.59 0 0 0-2.3-2.51C18.72 3.05 15.86 3 13 3c-2.86 0-5.72.05-7.53.17a2.59 2.59 0 0 0-2.3 2.51c-.23 4.207-.23 8.423 0 12.63a2.57 2.57 0 0 0 2.3 2.5c1.81.13 4.67.19 7.53.19 2.86 0 5.72-.06 7.53-.19a2.57 2.57 0 0 0 2.3-2.5c.23-4.207.23-8.423 0-12.63Zm-1.49 12.53a1.11 1.11 0 0 1-.91 1.11c-1.67.11-4.45.18-7.43.18-2.98 0-5.76-.07-7.43-.18a1.11 1.11 0 0 1-.91-1.11c-.21-4.14-.21-8.29 0-12.43a1.11 1.11 0 0 1 .91-1.11C7.24 4.56 10 4.49 13 4.49s5.76.07 7.43.18a1.11 1.11 0 0 1 .91 1.11c.21 4.14.21 8.29 0 12.43Z"/>
</svg>`;
function Y_e(n) {
  return `
    <style>
      :host([aria-checked="true"]) slot[name=off] {
        display: none !important;
      }

      
      :host(:not([aria-checked="true"])) slot[name=on] {
        display: none !important;
      }

      :host([aria-checked="true"]) slot[name=tooltip-enable],
      :host(:not([aria-checked="true"])) slot[name=tooltip-disable] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="on">${W_e}</slot>
      <slot name="off">${K_e}</slot>
    </slot>
  `;
}
function X_e() {
  return `
    <slot name="tooltip-enable">${Tt("Enable captions")}</slot>
    <slot name="tooltip-disable">${Tt("Disable captions")}</slot>
  `;
}
const K4 = (n) => {
  n.setAttribute("aria-checked", u_e(n).toString());
};
class yP extends Nr {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_SUBTITLES_LIST,
      ae.MEDIA_SUBTITLES_SHOWING,
    ];
  }
  connectedCallback() {
    super.connectedCallback(),
      this.setAttribute("role", "switch"),
      this.setAttribute("aria-label", Tt("closed captions")),
      K4(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_SUBTITLES_SHOWING && K4(this);
  }
  get mediaSubtitlesList() {
    return Y4(this, ae.MEDIA_SUBTITLES_LIST);
  }
  set mediaSubtitlesList(e) {
    X4(this, ae.MEDIA_SUBTITLES_LIST, e);
  }
  get mediaSubtitlesShowing() {
    return Y4(this, ae.MEDIA_SUBTITLES_SHOWING);
  }
  set mediaSubtitlesShowing(e) {
    X4(this, ae.MEDIA_SUBTITLES_SHOWING, e);
  }
  handleClick() {
    this.dispatchEvent(
      new Ie.CustomEvent(bt.MEDIA_TOGGLE_SUBTITLES_REQUEST, {
        composed: !0,
        bubbles: !0,
      })
    );
  }
}
yP.getSlotTemplateHTML = Y_e;
yP.getTooltipContentHTML = X_e;
const Y4 = (n, e) => {
    const t = n.getAttribute(e);
    return t ? mK(t) : [];
  },
  X4 = (n, e, t) => {
    if (!t?.length) {
      n.removeAttribute(e);
      return;
    }
    const s = SC(t);
    n.getAttribute(e) !== s && n.setAttribute(e, s);
  };
Ie.customElements.get("media-captions-button") ||
  Ie.customElements.define("media-captions-button", yP);
const Q_e =
    '<svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/></g></svg>',
  Z_e =
    '<svg aria-hidden="true" viewBox="0 0 24 24"><g><path class="cast_caf_icon_arch0" d="M1,18 L1,21 L4,21 C4,19.3 2.66,18 1,18 L1,18 Z"/><path class="cast_caf_icon_arch1" d="M1,14 L1,16 C3.76,16 6,18.2 6,21 L8,21 C8,17.13 4.87,14 1,14 L1,14 Z"/><path class="cast_caf_icon_arch2" d="M1,10 L1,12 C5.97,12 10,16.0 10,21 L12,21 C12,14.92 7.07,10 1,10 L1,10 Z"/><path class="cast_caf_icon_box" d="M21,3 L3,3 C1.9,3 1,3.9 1,5 L1,8 L3,8 L3,5 L21,5 L21,19 L14,19 L14,21 L21,21 C22.1,21 23,20.1 23,19 L23,5 C23,3.9 22.1,3 21,3 L21,3 Z"/><path class="cast_caf_icon_boxfill" d="M5,7 L5,8.63 C8,8.6 13.37,14 13.37,17 L19,17 L19,7 Z"/></g></svg>';
function J_e(n) {
  return `
    <style>
      :host([${ae.MEDIA_IS_CASTING}]) slot[name=icon] slot:not([name=exit]) {
        display: none !important;
      }

      
      :host(:not([${ae.MEDIA_IS_CASTING}])) slot[name=icon] slot:not([name=enter]) {
        display: none !important;
      }

      :host([${ae.MEDIA_IS_CASTING}]) slot[name=tooltip-enter],
      :host(:not([${ae.MEDIA_IS_CASTING}])) slot[name=tooltip-exit] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="enter">${Q_e}</slot>
      <slot name="exit">${Z_e}</slot>
    </slot>
  `;
}
function e1e() {
  return `
    <slot name="tooltip-enter">${Tt("Start casting")}</slot>
    <slot name="tooltip-exit">${Tt("Stop casting")}</slot>
  `;
}
const Q4 = (n) => {
  const e = n.mediaIsCasting ? Tt("stop casting") : Tt("start casting");
  n.setAttribute("aria-label", e);
};
class bP extends Nr {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_IS_CASTING,
      ae.MEDIA_CAST_UNAVAILABLE,
    ];
  }
  connectedCallback() {
    super.connectedCallback(), Q4(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_IS_CASTING && Q4(this);
  }
  get mediaIsCasting() {
    return un(this, ae.MEDIA_IS_CASTING);
  }
  set mediaIsCasting(e) {
    dn(this, ae.MEDIA_IS_CASTING, e);
  }
  get mediaCastUnavailable() {
    return gs(this, ae.MEDIA_CAST_UNAVAILABLE);
  }
  set mediaCastUnavailable(e) {
    vs(this, ae.MEDIA_CAST_UNAVAILABLE, e);
  }
  handleClick() {
    const e = this.mediaIsCasting
      ? bt.MEDIA_EXIT_CAST_REQUEST
      : bt.MEDIA_ENTER_CAST_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(e, { composed: !0, bubbles: !0 }));
  }
}
bP.getSlotTemplateHTML = J_e;
bP.getTooltipContentHTML = e1e;
Ie.customElements.get("media-cast-button") ||
  Ie.customElements.define("media-cast-button", bP);
var xP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  zu = (n, e, t) => (xP(n, e, "read from private field"), e.get(n)),
  sl = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  wP = (n, e, t, s) => (xP(n, e, "write to private field"), e.set(n, t), t),
  Eu = (n, e, t) => (xP(n, e, "access private method"), t),
  Ow,
  lv,
  rd,
  jb,
  kC,
  CC,
  TK,
  IC,
  _K,
  LC,
  AK,
  DC,
  RK,
  PC,
  kK;
function t1e(n) {
  return `
    <style>
      :host {
        font: var(--media-font,
          var(--media-font-weight, normal)
          var(--media-font-size, 14px) /
          var(--media-text-content-height, var(--media-control-height, 24px))
          var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        display: var(--media-dialog-display, inline-flex);
        justify-content: center;
        align-items: center;
        
        transition-behavior: allow-discrete;
        visibility: hidden;
        opacity: 0;
        transform: translateY(2px) scale(.99);
        pointer-events: none;
      }

      :host([open]) {
        transition: display .2s, visibility 0s, opacity .2s ease-out, transform .15s ease-out;
        visibility: visible;
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      #content {
        display: flex;
        position: relative;
        box-sizing: border-box;
        width: min(320px, 100%);
        word-wrap: break-word;
        max-height: 100%;
        overflow: auto;
        text-align: center;
        line-height: 1.4;
      }
    </style>
    ${this.getSlotTemplateHTML(n)}
  `;
}
function n1e(n) {
  return `
    <slot id="content"></slot>
  `;
}
const mp = { OPEN: "open", ANCHOR: "anchor" };
class qv extends Ie.HTMLElement {
  constructor() {
    super(),
      sl(this, jb),
      sl(this, CC),
      sl(this, IC),
      sl(this, LC),
      sl(this, DC),
      sl(this, PC),
      sl(this, Ow, !1),
      sl(this, lv, null),
      sl(this, rd, null),
      this.addEventListener("invoke", this),
      this.addEventListener("focusout", this),
      this.addEventListener("keydown", this);
  }
  static get observedAttributes() {
    return [mp.OPEN, mp.ANCHOR];
  }
  get open() {
    return un(this, mp.OPEN);
  }
  set open(e) {
    dn(this, mp.OPEN, e);
  }
  handleEvent(e) {
    switch (e.type) {
      case "invoke":
        Eu(this, LC, AK).call(this, e);
        break;
      case "focusout":
        Eu(this, DC, RK).call(this, e);
        break;
      case "keydown":
        Eu(this, PC, kK).call(this, e);
        break;
    }
  }
  connectedCallback() {
    Eu(this, jb, kC).call(this), this.role || (this.role = "dialog");
  }
  attributeChangedCallback(e, t, s) {
    Eu(this, jb, kC).call(this),
      e === mp.OPEN &&
        s !== t &&
        (this.open ? Eu(this, CC, TK).call(this) : Eu(this, IC, _K).call(this));
  }
  focus() {
    wP(this, lv, rK());
    const e = !this.dispatchEvent(
        new Event("focus", { composed: !0, cancelable: !0 })
      ),
      t = !this.dispatchEvent(
        new Event("focusin", { composed: !0, bubbles: !0, cancelable: !0 })
      );
    if (e || t) return;
    const s = this.querySelector(
      '[autofocus], [tabindex]:not([tabindex="-1"]), [role="menu"]'
    );
    s?.focus();
  }
  get keysUsed() {
    return ["Escape", "Tab"];
  }
}
Ow = new WeakMap();
lv = new WeakMap();
rd = new WeakMap();
jb = new WeakSet();
kC = function () {
  if (!zu(this, Ow) && (wP(this, Ow, !0), !this.shadowRoot)) {
    this.attachShadow(this.constructor.shadowRootOptions);
    const n = Va(this.attributes);
    (this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(n)),
      queueMicrotask(() => {
        const { style: e } = Ns(this.shadowRoot, ":host");
        e.setProperty(
          "transition",
          "display .15s, visibility .15s, opacity .15s ease-in, transform .15s ease-in"
        );
      });
  }
};
CC = new WeakSet();
TK = function () {
  var n;
  (n = zu(this, rd)) == null || n.setAttribute("aria-expanded", "true"),
    this.dispatchEvent(new Event("open", { composed: !0, bubbles: !0 })),
    this.addEventListener("transitionend", () => this.focus(), { once: !0 });
};
IC = new WeakSet();
_K = function () {
  var n;
  (n = zu(this, rd)) == null || n.setAttribute("aria-expanded", "false"),
    this.dispatchEvent(new Event("close", { composed: !0, bubbles: !0 }));
};
LC = new WeakSet();
AK = function (n) {
  wP(this, rd, n.relatedTarget),
    Qf(this, n.relatedTarget) || (this.open = !this.open);
};
DC = new WeakSet();
RK = function (n) {
  var e;
  Qf(this, n.relatedTarget) ||
    ((e = zu(this, lv)) == null || e.focus(),
    zu(this, rd) &&
      zu(this, rd) !== n.relatedTarget &&
      this.open &&
      (this.open = !1));
};
PC = new WeakSet();
kK = function (n) {
  var e, t, s, r, i;
  const { key: a, ctrlKey: o, altKey: l, metaKey: c } = n;
  o ||
    l ||
    c ||
    (this.keysUsed.includes(a) &&
      (n.preventDefault(),
      n.stopPropagation(),
      a === "Tab"
        ? (n.shiftKey
            ? (t =
                (e = this.previousElementSibling) == null ? void 0 : e.focus) ==
                null || t.call(e)
            : (r = (s = this.nextElementSibling) == null ? void 0 : s.focus) ==
                null || r.call(s),
          this.blur())
        : a === "Escape" &&
          ((i = zu(this, lv)) == null || i.focus(), (this.open = !1))));
};
qv.shadowRootOptions = { mode: "open" };
qv.getTemplateHTML = t1e;
qv.getSlotTemplateHTML = n1e;
Ie.customElements.get("media-chrome-dialog") ||
  Ie.customElements.define("media-chrome-dialog", qv);
var EP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  ss = (n, e, t) => (
    EP(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  mr = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  gc = (n, e, t, s) => (EP(n, e, "write to private field"), e.set(n, t), t),
  wa = (n, e, t) => (EP(n, e, "access private method"), t),
  so,
  lS,
  Fb,
  Ub,
  Ta,
  jw,
  $b,
  Bb,
  Hb,
  SP,
  CK,
  Vb,
  MC,
  zb,
  NC,
  Fw,
  TP,
  OC,
  IK,
  jC,
  LK,
  FC,
  DK,
  UC,
  PK;
function s1e(n) {
  return `
    <style>
      :host {
        --_focus-box-shadow: var(--media-focus-box-shadow, inset 0 0 0 2px rgb(27 127 204 / .9));
        --_media-range-padding: var(--media-range-padding, var(--media-control-padding, 10px));

        box-shadow: var(--_focus-visible-box-shadow, none);
        background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));
        height: calc(var(--media-control-height, 24px) + 2 * var(--_media-range-padding));
        display: inline-flex;
        align-items: center;
        
        vertical-align: middle;
        box-sizing: border-box;
        position: relative;
        width: 100px;
        transition: background .15s linear;
        cursor: var(--media-cursor, pointer);
        pointer-events: auto;
        touch-action: none; 
      }

      
      input[type=range]:focus {
        outline: 0;
      }
      input[type=range]:focus::-webkit-slider-runnable-track {
        outline: 0;
      }

      :host(:hover) {
        background: var(--media-control-hover-background, rgb(50 50 70 / .7));
      }

      #leftgap {
        padding-left: var(--media-range-padding-left, var(--_media-range-padding));
      }

      #rightgap {
        padding-right: var(--media-range-padding-right, var(--_media-range-padding));
      }

      #startpoint,
      #endpoint {
        position: absolute;
      }

      #endpoint {
        right: 0;
      }

      #container {
        
        width: var(--media-range-track-width, 100%);
        transform: translate(var(--media-range-track-translate-x, 0px), var(--media-range-track-translate-y, 0px));
        position: relative;
        height: 100%;
        display: flex;
        align-items: center;
        min-width: 40px;
      }

      #range {
        
        display: var(--media-time-range-hover-display, block);
        bottom: var(--media-time-range-hover-bottom, -7px);
        height: var(--media-time-range-hover-height, max(100% + 7px, 25px));
        width: 100%;
        position: absolute;
        cursor: var(--media-cursor, pointer);

        -webkit-appearance: none; 
        -webkit-tap-highlight-color: transparent;
        background: transparent; 
        margin: 0;
        z-index: 1;
      }

      @media (hover: hover) {
        #range {
          bottom: var(--media-time-range-hover-bottom, -5px);
          height: var(--media-time-range-hover-height, max(100% + 5px, 20px));
        }
      }

      
      
      #range::-webkit-slider-thumb {
        -webkit-appearance: none;
        background: transparent;
        width: .1px;
        height: .1px;
      }

      
      #range::-moz-range-thumb {
        background: transparent;
        border: transparent;
        width: .1px;
        height: .1px;
      }

      #appearance {
        height: var(--media-range-track-height, 4px);
        display: flex;
        flex-direction: column;
        justify-content: center;
        width: 100%;
        position: absolute;
        
        will-change: transform;
      }

      #track {
        background: var(--media-range-track-background, rgb(255 255 255 / .2));
        border-radius: var(--media-range-track-border-radius, 1px);
        border: var(--media-range-track-border, none);
        outline: var(--media-range-track-outline);
        outline-offset: var(--media-range-track-outline-offset);
        backdrop-filter: var(--media-range-track-backdrop-filter);
        -webkit-backdrop-filter: var(--media-range-track-backdrop-filter);
        box-shadow: var(--media-range-track-box-shadow, none);
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #progress,
      #pointer {
        position: absolute;
        height: 100%;
        will-change: width;
      }

      #progress {
        background: var(--media-range-bar-color, var(--media-primary-color, rgb(238 238 238)));
        transition: var(--media-range-track-transition);
      }

      #pointer {
        background: var(--media-range-track-pointer-background);
        border-right: var(--media-range-track-pointer-border-right);
        transition: visibility .25s, opacity .25s;
        visibility: hidden;
        opacity: 0;
      }

      @media (hover: hover) {
        :host(:hover) #pointer {
          transition: visibility .5s, opacity .5s;
          visibility: visible;
          opacity: 1;
        }
      }

      #thumb,
      ::slotted([slot=thumb]) {
        width: var(--media-range-thumb-width, 10px);
        height: var(--media-range-thumb-height, 10px);
        transition: var(--media-range-thumb-transition);
        transform: var(--media-range-thumb-transform, none);
        opacity: var(--media-range-thumb-opacity, 1);
        translate: -50%;
        position: absolute;
        left: 0;
        cursor: var(--media-cursor, pointer);
      }

      #thumb {
        border-radius: var(--media-range-thumb-border-radius, 10px);
        background: var(--media-range-thumb-background, var(--media-primary-color, rgb(238 238 238)));
        box-shadow: var(--media-range-thumb-box-shadow, 1px 1px 1px transparent);
        border: var(--media-range-thumb-border, none);
      }

      :host([disabled]) #thumb {
        background-color: #777;
      }

      .segments #appearance {
        height: var(--media-range-segment-hover-height, 7px);
      }

      #track {
        clip-path: url(#segments-clipping);
      }

      #segments {
        --segments-gap: var(--media-range-segments-gap, 2px);
        position: absolute;
        width: 100%;
        height: 100%;
      }

      #segments-clipping {
        transform: translateX(calc(var(--segments-gap) / 2));
      }

      #segments-clipping:empty {
        display: none;
      }

      #segments-clipping rect {
        height: var(--media-range-track-height, 4px);
        y: calc((var(--media-range-segment-hover-height, 7px) - var(--media-range-track-height, 4px)) / 2);
        transition: var(--media-range-segment-transition, transform .1s ease-in-out);
        transform: var(--media-range-segment-transform, scaleY(1));
        transform-origin: center;
      }
    </style>
    <div id="leftgap"></div>
    <div id="container">
      <div id="startpoint"></div>
      <div id="endpoint"></div>
      <div id="appearance">
        <div id="track" part="track">
          <div id="pointer"></div>
          <div id="progress" part="progress"></div>
        </div>
        <slot name="thumb">
          <div id="thumb" part="thumb"></div>
        </slot>
        <svg id="segments"><clipPath id="segments-clipping"></clipPath></svg>
      </div>
      <input id="range" type="range" min="0" max="1" step="any" value="0">
    </div>
    <div id="rightgap"></div>
  `;
}
class Zf extends Ie.HTMLElement {
  constructor() {
    if (
      (super(),
      mr(this, SP),
      mr(this, Vb),
      mr(this, zb),
      mr(this, Fw),
      mr(this, OC),
      mr(this, jC),
      mr(this, FC),
      mr(this, UC),
      mr(this, so, void 0),
      mr(this, lS, void 0),
      mr(this, Fb, void 0),
      mr(this, Ub, void 0),
      mr(this, Ta, {}),
      mr(this, jw, []),
      mr(this, $b, () => {
        if (this.range.matches(":focus-visible")) {
          const { style: e } = Ns(this.shadowRoot, ":host");
          e.setProperty(
            "--_focus-visible-box-shadow",
            "var(--_focus-box-shadow)"
          );
        }
      }),
      mr(this, Bb, () => {
        const { style: e } = Ns(this.shadowRoot, ":host");
        e.removeProperty("--_focus-visible-box-shadow");
      }),
      mr(this, Hb, () => {
        const e = this.shadowRoot.querySelector("#segments-clipping");
        e && e.parentNode.append(e);
      }),
      !this.shadowRoot)
    ) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes),
        t = this.constructor.getTemplateHTML(e);
      this.shadowRoot.setHTMLUnsafe
        ? this.shadowRoot.setHTMLUnsafe(t)
        : (this.shadowRoot.innerHTML = t);
    }
    (this.container = this.shadowRoot.querySelector("#container")),
      gc(this, Fb, this.shadowRoot.querySelector("#startpoint")),
      gc(this, Ub, this.shadowRoot.querySelector("#endpoint")),
      (this.range = this.shadowRoot.querySelector("#range")),
      (this.appearance = this.shadowRoot.querySelector("#appearance"));
  }
  static get observedAttributes() {
    return ["disabled", "aria-disabled", xn.MEDIA_CONTROLLER];
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === xn.MEDIA_CONTROLLER
      ? (t &&
          ((i = (r = ss(this, so)) == null ? void 0 : r.unassociateElement) ==
            null || i.call(r, this),
          gc(this, so, null)),
        s &&
          this.isConnected &&
          (gc(
            this,
            so,
            (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
          ),
          (l = (o = ss(this, so)) == null ? void 0 : o.associateElement) ==
            null || l.call(o, this)))
      : (e === "disabled" || (e === "aria-disabled" && t !== s)) &&
        (s == null
          ? (this.range.removeAttribute(e), wa(this, Vb, MC).call(this))
          : (this.range.setAttribute(e, s), wa(this, zb, NC).call(this)));
  }
  connectedCallback() {
    var e, t, s;
    const { style: r } = Ns(this.shadowRoot, ":host");
    r.setProperty(
      "display",
      `var(--media-control-display, var(--${this.localName}-display, inline-flex))`
    ),
      (ss(this, Ta).pointer = Ns(this.shadowRoot, "#pointer")),
      (ss(this, Ta).progress = Ns(this.shadowRoot, "#progress")),
      (ss(this, Ta).thumb = Ns(
        this.shadowRoot,
        '#thumb, ::slotted([slot="thumb"])'
      )),
      (ss(this, Ta).activeSegment = Ns(
        this.shadowRoot,
        "#segments-clipping rect:nth-child(0)"
      ));
    const i = this.getAttribute(xn.MEDIA_CONTROLLER);
    i &&
      (gc(
        this,
        so,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(i)
      ),
      (s = (t = ss(this, so)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this)),
      this.updateBar(),
      this.shadowRoot.addEventListener("focusin", ss(this, $b)),
      this.shadowRoot.addEventListener("focusout", ss(this, Bb)),
      wa(this, Vb, MC).call(this),
      eK(this.container, ss(this, Hb));
  }
  disconnectedCallback() {
    var e, t;
    wa(this, zb, NC).call(this),
      (t = (e = ss(this, so)) == null ? void 0 : e.unassociateElement) ==
        null || t.call(e, this),
      gc(this, so, null),
      this.shadowRoot.removeEventListener("focusin", ss(this, $b)),
      this.shadowRoot.removeEventListener("focusout", ss(this, Bb)),
      tK(this.container, ss(this, Hb));
  }
  updatePointerBar(e) {
    var t;
    (t = ss(this, Ta).pointer) == null ||
      t.style.setProperty("width", `${this.getPointerRatio(e) * 100}%`);
  }
  updateBar() {
    var e, t;
    const s = this.range.valueAsNumber * 100;
    (e = ss(this, Ta).progress) == null ||
      e.style.setProperty("width", `${s}%`),
      (t = ss(this, Ta).thumb) == null || t.style.setProperty("left", `${s}%`);
  }
  updateSegments(e) {
    const t = this.shadowRoot.querySelector("#segments-clipping");
    if (
      ((t.textContent = ""),
      this.container.classList.toggle("segments", !!e?.length),
      !e?.length)
    )
      return;
    const s = [
      ...new Set([
        +this.range.min,
        ...e.flatMap((i) => [i.start, i.end]),
        +this.range.max,
      ]),
    ];
    gc(this, jw, [...s]);
    const r = s.pop();
    for (const [i, a] of s.entries()) {
      const [o, l] = [i === 0, i === s.length - 1],
        c = o ? "calc(var(--segments-gap) / -1)" : `${a * 100}%`,
        m = `calc(${((l ? r : s[i + 1]) - a) * 100}%${
          o || l ? "" : " - var(--segments-gap)"
        })`,
        p = li.createElementNS("http://www.w3.org/2000/svg", "rect"),
        g = Ns(this.shadowRoot, `#segments-clipping rect:nth-child(${i + 1})`);
      g.style.setProperty("x", c), g.style.setProperty("width", m), t.append(p);
    }
  }
  getPointerRatio(e) {
    return YTe(
      e.clientX,
      e.clientY,
      ss(this, Fb).getBoundingClientRect(),
      ss(this, Ub).getBoundingClientRect()
    );
  }
  get dragging() {
    return this.hasAttribute("dragging");
  }
  handleEvent(e) {
    switch (e.type) {
      case "pointermove":
        wa(this, UC, PK).call(this, e);
        break;
      case "input":
        this.updateBar();
        break;
      case "pointerenter":
        wa(this, OC, IK).call(this, e);
        break;
      case "pointerdown":
        wa(this, Fw, TP).call(this, e);
        break;
      case "pointerup":
        wa(this, jC, LK).call(this);
        break;
      case "pointerleave":
        wa(this, FC, DK).call(this);
        break;
    }
  }
  get keysUsed() {
    return ["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"];
  }
}
so = new WeakMap();
lS = new WeakMap();
Fb = new WeakMap();
Ub = new WeakMap();
Ta = new WeakMap();
jw = new WeakMap();
$b = new WeakMap();
Bb = new WeakMap();
Hb = new WeakMap();
SP = new WeakSet();
CK = function (n) {
  const e = ss(this, Ta).activeSegment;
  if (!e) return;
  const t = this.getPointerRatio(n),
    r = `#segments-clipping rect:nth-child(${
      ss(this, jw).findIndex((i, a, o) => {
        const l = o[a + 1];
        return l != null && t >= i && t <= l;
      }) + 1
    })`;
  (e.selectorText != r || !e.style.transform) &&
    ((e.selectorText = r),
    e.style.setProperty(
      "transform",
      "var(--media-range-segment-hover-transform, scaleY(2))"
    ));
};
Vb = new WeakSet();
MC = function () {
  this.hasAttribute("disabled") ||
    (this.addEventListener("input", this),
    this.addEventListener("pointerdown", this),
    this.addEventListener("pointerenter", this));
};
zb = new WeakSet();
NC = function () {
  var n, e;
  this.removeEventListener("input", this),
    this.removeEventListener("pointerdown", this),
    this.removeEventListener("pointerenter", this),
    (n = Ie.window) == null || n.removeEventListener("pointerup", this),
    (e = Ie.window) == null || e.removeEventListener("pointermove", this);
};
Fw = new WeakSet();
TP = function (n) {
  var e;
  gc(this, lS, n.composedPath().includes(this.range)),
    (e = Ie.window) == null || e.addEventListener("pointerup", this);
};
OC = new WeakSet();
IK = function (n) {
  var e;
  n.pointerType !== "mouse" && wa(this, Fw, TP).call(this, n),
    this.addEventListener("pointerleave", this),
    (e = Ie.window) == null || e.addEventListener("pointermove", this);
};
jC = new WeakSet();
LK = function () {
  var n;
  (n = Ie.window) == null || n.removeEventListener("pointerup", this),
    this.toggleAttribute("dragging", !1),
    (this.range.disabled = this.hasAttribute("disabled"));
};
FC = new WeakSet();
DK = function () {
  var n, e;
  this.removeEventListener("pointerleave", this),
    (n = Ie.window) == null || n.removeEventListener("pointermove", this),
    this.toggleAttribute("dragging", !1),
    (this.range.disabled = this.hasAttribute("disabled")),
    (e = ss(this, Ta).activeSegment) == null ||
      e.style.removeProperty("transform");
};
UC = new WeakSet();
PK = function (n) {
  this.toggleAttribute(
    "dragging",
    n.buttons === 1 || n.pointerType !== "mouse"
  ),
    this.updatePointerBar(n),
    wa(this, SP, CK).call(this, n),
    this.dragging &&
      (n.pointerType !== "mouse" || !ss(this, lS)) &&
      ((this.range.disabled = !0),
      (this.range.valueAsNumber = this.getPointerRatio(n)),
      this.range.dispatchEvent(
        new Event("input", { bubbles: !0, composed: !0 })
      ));
};
Zf.shadowRootOptions = { mode: "open" };
Zf.getTemplateHTML = s1e;
Ie.customElements.get("media-chrome-range") ||
  Ie.customElements.define("media-chrome-range", Zf);
var MK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Vy = (n, e, t) => (
    MK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  r1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  zy = (n, e, t, s) => (MK(n, e, "write to private field"), e.set(n, t), t),
  ro;
function i1e(n) {
  return `
    <style>
      :host {
        
        box-sizing: border-box;
        display: var(--media-control-display, var(--media-control-bar-display, inline-flex));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        --media-loading-indicator-icon-height: 44px;
      }

      ::slotted(media-time-range),
      ::slotted(media-volume-range) {
        min-height: 100%;
      }

      ::slotted(media-time-range),
      ::slotted(media-clip-selector) {
        flex-grow: 1;
      }

      ::slotted([role="menu"]) {
        position: absolute;
      }
    </style>

    <slot></slot>
  `;
}
class _P extends Ie.HTMLElement {
  constructor() {
    if ((super(), r1e(this, ro, void 0), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
  }
  static get observedAttributes() {
    return [xn.MEDIA_CONTROLLER];
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === xn.MEDIA_CONTROLLER &&
      (t &&
        ((i = (r = Vy(this, ro)) == null ? void 0 : r.unassociateElement) ==
          null || i.call(r, this),
        zy(this, ro, null)),
      s &&
        this.isConnected &&
        (zy(
          this,
          ro,
          (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
        ),
        (l = (o = Vy(this, ro)) == null ? void 0 : o.associateElement) ==
          null || l.call(o, this)));
  }
  connectedCallback() {
    var e, t, s;
    const r = this.getAttribute(xn.MEDIA_CONTROLLER);
    r &&
      (zy(
        this,
        ro,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(r)
      ),
      (s = (t = Vy(this, ro)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this));
  }
  disconnectedCallback() {
    var e, t;
    (t = (e = Vy(this, ro)) == null ? void 0 : e.unassociateElement) == null ||
      t.call(e, this),
      zy(this, ro, null);
  }
}
ro = new WeakMap();
_P.shadowRootOptions = { mode: "open" };
_P.getTemplateHTML = i1e;
Ie.customElements.get("media-control-bar") ||
  Ie.customElements.define("media-control-bar", _P);
var NK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Gy = (n, e, t) => (
    NK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  a1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  qy = (n, e, t, s) => (NK(n, e, "write to private field"), e.set(n, t), t),
  io;
function o1e(n, e = {}) {
  return `
    <style>
      :host {
        font: var(--media-font,
          var(--media-font-weight, normal)
          var(--media-font-size, 14px) /
          var(--media-text-content-height, var(--media-control-height, 24px))
          var(--media-font-family, helvetica neue, segoe ui, roboto, arial, sans-serif));
        color: var(--media-text-color, var(--media-primary-color, rgb(238 238 238)));
        background: var(--media-text-background, var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7))));
        padding: var(--media-control-padding, 10px);
        display: inline-flex;
        justify-content: center;
        align-items: center;
        vertical-align: middle;
        box-sizing: border-box;
        text-align: center;
        pointer-events: auto;
      }

      
      :host(:focus-visible) {
        box-shadow: inset 0 0 0 2px rgb(27 127 204 / .9);
        outline: 0;
      }

      
      :host(:where(:focus)) {
        box-shadow: none;
        outline: 0;
      }
    </style>

    ${this.getSlotTemplateHTML(n, e)}
  `;
}
function l1e(n, e) {
  return `
    <slot></slot>
  `;
}
class Qc extends Ie.HTMLElement {
  constructor() {
    if ((super(), a1e(this, io, void 0), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
  }
  static get observedAttributes() {
    return [xn.MEDIA_CONTROLLER];
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === xn.MEDIA_CONTROLLER &&
      (t &&
        ((i = (r = Gy(this, io)) == null ? void 0 : r.unassociateElement) ==
          null || i.call(r, this),
        qy(this, io, null)),
      s &&
        this.isConnected &&
        (qy(
          this,
          io,
          (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
        ),
        (l = (o = Gy(this, io)) == null ? void 0 : o.associateElement) ==
          null || l.call(o, this)));
  }
  connectedCallback() {
    var e, t, s;
    const { style: r } = Ns(this.shadowRoot, ":host");
    r.setProperty(
      "display",
      `var(--media-control-display, var(--${this.localName}-display, inline-flex))`
    );
    const i = this.getAttribute(xn.MEDIA_CONTROLLER);
    i &&
      (qy(
        this,
        io,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(i)
      ),
      (s = (t = Gy(this, io)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this));
  }
  disconnectedCallback() {
    var e, t;
    (t = (e = Gy(this, io)) == null ? void 0 : e.unassociateElement) == null ||
      t.call(e, this),
      qy(this, io, null);
  }
}
io = new WeakMap();
Qc.shadowRootOptions = { mode: "open" };
Qc.getTemplateHTML = o1e;
Qc.getSlotTemplateHTML = l1e;
Ie.customElements.get("media-text-display") ||
  Ie.customElements.define("media-text-display", Qc);
var OK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Z4 = (n, e, t) => (
    OK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  c1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  u1e = (n, e, t, s) => (OK(n, e, "write to private field"), e.set(n, t), t),
  Op;
function d1e(n, e) {
  return `
    <slot>${Lc(e.mediaDuration)}</slot>
  `;
}
class jK extends Qc {
  constructor() {
    var e;
    super(),
      c1e(this, Op, void 0),
      u1e(this, Op, this.shadowRoot.querySelector("slot")),
      (Z4(this, Op).textContent = Lc((e = this.mediaDuration) != null ? e : 0));
  }
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_DURATION];
  }
  attributeChangedCallback(e, t, s) {
    e === ae.MEDIA_DURATION && (Z4(this, Op).textContent = Lc(+s)),
      super.attributeChangedCallback(e, t, s);
  }
  get mediaDuration() {
    return ps(this, ae.MEDIA_DURATION);
  }
  set mediaDuration(e) {
    lr(this, ae.MEDIA_DURATION, e);
  }
}
Op = new WeakMap();
jK.getSlotTemplateHTML = d1e;
Ie.customElements.get("media-duration-display") ||
  Ie.customElements.define("media-duration-display", jK);
const h1e = {
    2: Tt("Network Error"),
    3: Tt("Decode Error"),
    4: Tt("Source Not Supported"),
    5: Tt("Encryption Error"),
  },
  f1e = {
    2: Tt("A network error caused the media download to fail."),
    3: Tt(
      "A media error caused playback to be aborted. The media could be corrupt or your browser does not support this format."
    ),
    4: Tt(
      "An unsupported error occurred. The server or network failed, or your browser does not support this format."
    ),
    5: Tt("The media is encrypted and there are no keys to decrypt it."),
  },
  FK = (n) => {
    var e, t;
    return n.code === 1
      ? null
      : {
          title: (e = h1e[n.code]) != null ? e : `Error ${n.code}`,
          message: (t = f1e[n.code]) != null ? t : n.message,
        };
  };
var UK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  m1e = (n, e, t) => (
    UK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  p1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  g1e = (n, e, t, s) => (UK(n, e, "write to private field"), e.set(n, t), t),
  Gb;
function v1e(n) {
  return `
    <style>
      :host {
        background: rgb(20 20 30 / .8);
      }

      #content {
        display: block;
        padding: 1.2em 1.5em;
      }

      h3,
      p {
        margin-block: 0 .3em;
      }
    </style>
    <slot name="error-${n.mediaerrorcode}" id="content">
      ${$K({ code: +n.mediaerrorcode, message: n.mediaerrormessage })}
    </slot>
  `;
}
function y1e(n) {
  return n.code && FK(n) !== null;
}
function $K(n) {
  var e;
  const { title: t, message: s } = (e = FK(n)) != null ? e : {};
  let r = "";
  return (
    t && (r += `<slot name="error-${n.code}-title"><h3>${t}</h3></slot>`),
    s && (r += `<slot name="error-${n.code}-message"><p>${s}</p></slot>`),
    r
  );
}
const J4 = [ae.MEDIA_ERROR_CODE, ae.MEDIA_ERROR_MESSAGE];
class AP extends qv {
  constructor() {
    super(...arguments), p1e(this, Gb, null);
  }
  static get observedAttributes() {
    return [...super.observedAttributes, ...J4];
  }
  formatErrorMessage(e) {
    return this.constructor.formatErrorMessage(e);
  }
  attributeChangedCallback(e, t, s) {
    var r;
    if ((super.attributeChangedCallback(e, t, s), !J4.includes(e))) return;
    const i =
      (r = this.mediaError) != null
        ? r
        : { code: this.mediaErrorCode, message: this.mediaErrorMessage };
    (this.open = y1e(i)),
      this.open &&
        ((this.shadowRoot.querySelector(
          "slot"
        ).name = `error-${this.mediaErrorCode}`),
        (this.shadowRoot.querySelector("#content").innerHTML =
          this.formatErrorMessage(i)));
  }
  get mediaError() {
    return m1e(this, Gb);
  }
  set mediaError(e) {
    g1e(this, Gb, e);
  }
  get mediaErrorCode() {
    return ps(this, "mediaerrorcode");
  }
  set mediaErrorCode(e) {
    lr(this, "mediaerrorcode", e);
  }
  get mediaErrorMessage() {
    return gs(this, "mediaerrormessage");
  }
  set mediaErrorMessage(e) {
    vs(this, "mediaerrormessage", e);
  }
}
Gb = new WeakMap();
AP.getSlotTemplateHTML = v1e;
AP.formatErrorMessage = $K;
Ie.customElements.get("media-error-dialog") ||
  Ie.customElements.define("media-error-dialog", AP);
const b1e = `<svg aria-hidden="true" viewBox="0 0 26 24">
  <path d="M16 3v2.5h3.5V9H22V3h-6ZM4 9h2.5V5.5H10V3H4v6Zm15.5 9.5H16V21h6v-6h-2.5v3.5ZM6.5 15H4v6h6v-2.5H6.5V15Z"/>
</svg>`,
  x1e = `<svg aria-hidden="true" viewBox="0 0 26 24">
  <path d="M18.5 6.5V3H16v6h6V6.5h-3.5ZM16 21h2.5v-3.5H22V15h-6v6ZM4 17.5h3.5V21H10v-6H4v2.5Zm3.5-11H4V9h6V3H7.5v3.5Z"/>
</svg>`;
function w1e(n) {
  return `
    <style>
      :host([${ae.MEDIA_IS_FULLSCREEN}]) slot[name=icon] slot:not([name=exit]) {
        display: none !important;
      }

      
      :host(:not([${ae.MEDIA_IS_FULLSCREEN}])) slot[name=icon] slot:not([name=enter]) {
        display: none !important;
      }

      :host([${ae.MEDIA_IS_FULLSCREEN}]) slot[name=tooltip-enter],
      :host(:not([${ae.MEDIA_IS_FULLSCREEN}])) slot[name=tooltip-exit] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="enter">${b1e}</slot>
      <slot name="exit">${x1e}</slot>
    </slot>
  `;
}
function E1e() {
  return `
    <slot name="tooltip-enter">${Tt("Enter fullscreen mode")}</slot>
    <slot name="tooltip-exit">${Tt("Exit fullscreen mode")}</slot>
  `;
}
const eB = (n) => {
  const e = n.mediaIsFullscreen
    ? Tt("exit fullscreen mode")
    : Tt("enter fullscreen mode");
  n.setAttribute("aria-label", e);
};
class RP extends Nr {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_IS_FULLSCREEN,
      ae.MEDIA_FULLSCREEN_UNAVAILABLE,
    ];
  }
  connectedCallback() {
    super.connectedCallback(), eB(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_IS_FULLSCREEN && eB(this);
  }
  get mediaFullscreenUnavailable() {
    return gs(this, ae.MEDIA_FULLSCREEN_UNAVAILABLE);
  }
  set mediaFullscreenUnavailable(e) {
    vs(this, ae.MEDIA_FULLSCREEN_UNAVAILABLE, e);
  }
  get mediaIsFullscreen() {
    return un(this, ae.MEDIA_IS_FULLSCREEN);
  }
  set mediaIsFullscreen(e) {
    dn(this, ae.MEDIA_IS_FULLSCREEN, e);
  }
  handleClick() {
    const e = this.mediaIsFullscreen
      ? bt.MEDIA_EXIT_FULLSCREEN_REQUEST
      : bt.MEDIA_ENTER_FULLSCREEN_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(e, { composed: !0, bubbles: !0 }));
  }
}
RP.getSlotTemplateHTML = w1e;
RP.getTooltipContentHTML = E1e;
Ie.customElements.get("media-fullscreen-button") ||
  Ie.customElements.define("media-fullscreen-button", RP);
const { MEDIA_TIME_IS_LIVE: qb, MEDIA_PAUSED: hg } = ae,
  { MEDIA_SEEK_TO_LIVE_REQUEST: S1e, MEDIA_PLAY_REQUEST: T1e } = bt,
  _1e = '<svg viewBox="0 0 6 12"><circle cx="3" cy="6" r="2"></circle></svg>';
function A1e(n) {
  return `
    <style>
      :host { --media-tooltip-display: none; }
      
      slot[name=indicator] > *,
      :host ::slotted([slot=indicator]) {
        
        min-width: auto;
        fill: var(--media-live-button-icon-color, rgb(140, 140, 140));
        color: var(--media-live-button-icon-color, rgb(140, 140, 140));
      }

      :host([${qb}]:not([${hg}])) slot[name=indicator] > *,
      :host([${qb}]:not([${hg}])) ::slotted([slot=indicator]) {
        fill: var(--media-live-button-indicator-color, rgb(255, 0, 0));
        color: var(--media-live-button-indicator-color, rgb(255, 0, 0));
      }

      :host([${qb}]:not([${hg}])) {
        cursor: var(--media-cursor, not-allowed);
      }

      slot[name=text]{
        text-transform: uppercase;
      }

    </style>

    <slot name="indicator">${_1e}</slot>
    
    <slot name="spacer">&nbsp;</slot><slot name="text">${Tt("live")}</slot>
  `;
}
const tB = (n) => {
  var e;
  const t = n.mediaPaused || !n.mediaTimeIsLive,
    s = Tt(t ? "seek to live" : "playing live");
  n.setAttribute("aria-label", s);
  const r =
    (e = n.shadowRoot) == null ? void 0 : e.querySelector('slot[name="text"]');
  r && (r.textContent = Tt("live")),
    t
      ? n.removeAttribute("aria-disabled")
      : n.setAttribute("aria-disabled", "true");
};
class BK extends Nr {
  static get observedAttributes() {
    return [...super.observedAttributes, qb, hg];
  }
  connectedCallback() {
    super.connectedCallback(), tB(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s), tB(this);
  }
  get mediaPaused() {
    return un(this, ae.MEDIA_PAUSED);
  }
  set mediaPaused(e) {
    dn(this, ae.MEDIA_PAUSED, e);
  }
  get mediaTimeIsLive() {
    return un(this, ae.MEDIA_TIME_IS_LIVE);
  }
  set mediaTimeIsLive(e) {
    dn(this, ae.MEDIA_TIME_IS_LIVE, e);
  }
  handleClick() {
    (!this.mediaPaused && this.mediaTimeIsLive) ||
      (this.dispatchEvent(
        new Ie.CustomEvent(S1e, { composed: !0, bubbles: !0 })
      ),
      this.hasAttribute(hg) &&
        this.dispatchEvent(
          new Ie.CustomEvent(T1e, { composed: !0, bubbles: !0 })
        ));
  }
}
BK.getSlotTemplateHTML = A1e;
Ie.customElements.get("media-live-button") ||
  Ie.customElements.define("media-live-button", BK);
var HK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  pp = (n, e, t) => (
    HK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  nB = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  gp = (n, e, t, s) => (HK(n, e, "write to private field"), e.set(n, t), t),
  ao,
  Wb;
const Wy = { LOADING_DELAY: "loadingdelay", NO_AUTOHIDE: "noautohide" },
  VK = 500,
  R1e = `
<svg aria-hidden="true" viewBox="0 0 100 100">
  <path d="M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50">
    <animateTransform
       attributeName="transform"
       attributeType="XML"
       type="rotate"
       dur="1s"
       from="0 50 50"
       to="360 50 50"
       repeatCount="indefinite" />
  </path>
</svg>
`;
function k1e(n) {
  return `
    <style>
      :host {
        display: var(--media-control-display, var(--media-loading-indicator-display, inline-block));
        vertical-align: middle;
        box-sizing: border-box;
        --_loading-indicator-delay: var(--media-loading-indicator-transition-delay, ${VK}ms);
      }

      #status {
        color: rgba(0,0,0,0);
        width: 0px;
        height: 0px;
      }

      :host slot[name=icon] > *,
      :host ::slotted([slot=icon]) {
        opacity: var(--media-loading-indicator-opacity, 0);
        transition: opacity 0.15s;
      }

      :host([${ae.MEDIA_LOADING}]:not([${
    ae.MEDIA_PAUSED
  }])) slot[name=icon] > *,
      :host([${ae.MEDIA_LOADING}]:not([${
    ae.MEDIA_PAUSED
  }])) ::slotted([slot=icon]) {
        opacity: var(--media-loading-indicator-opacity, 1);
        transition: opacity 0.15s var(--_loading-indicator-delay);
      }

      :host #status {
        visibility: var(--media-loading-indicator-opacity, hidden);
        transition: visibility 0.15s;
      }

      :host([${ae.MEDIA_LOADING}]:not([${ae.MEDIA_PAUSED}])) #status {
        visibility: var(--media-loading-indicator-opacity, visible);
        transition: visibility 0.15s var(--_loading-indicator-delay);
      }

      svg, img, ::slotted(svg), ::slotted(img) {
        width: var(--media-loading-indicator-icon-width);
        height: var(--media-loading-indicator-icon-height, 100px);
        fill: var(--media-icon-color, var(--media-primary-color, rgb(238 238 238)));
        vertical-align: middle;
      }
    </style>

    <slot name="icon">${R1e}</slot>
    <div id="status" role="status" aria-live="polite">${Tt(
      "media loading"
    )}</div>
  `;
}
class kP extends Ie.HTMLElement {
  constructor() {
    if ((super(), nB(this, ao, void 0), nB(this, Wb, VK), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
  }
  static get observedAttributes() {
    return [
      xn.MEDIA_CONTROLLER,
      ae.MEDIA_PAUSED,
      ae.MEDIA_LOADING,
      Wy.LOADING_DELAY,
    ];
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    e === Wy.LOADING_DELAY && t !== s
      ? (this.loadingDelay = Number(s))
      : e === xn.MEDIA_CONTROLLER &&
        (t &&
          ((i = (r = pp(this, ao)) == null ? void 0 : r.unassociateElement) ==
            null || i.call(r, this),
          gp(this, ao, null)),
        s &&
          this.isConnected &&
          (gp(
            this,
            ao,
            (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
          ),
          (l = (o = pp(this, ao)) == null ? void 0 : o.associateElement) ==
            null || l.call(o, this)));
  }
  connectedCallback() {
    var e, t, s;
    const r = this.getAttribute(xn.MEDIA_CONTROLLER);
    r &&
      (gp(
        this,
        ao,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(r)
      ),
      (s = (t = pp(this, ao)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this));
  }
  disconnectedCallback() {
    var e, t;
    (t = (e = pp(this, ao)) == null ? void 0 : e.unassociateElement) == null ||
      t.call(e, this),
      gp(this, ao, null);
  }
  get loadingDelay() {
    return pp(this, Wb);
  }
  set loadingDelay(e) {
    gp(this, Wb, e);
    const { style: t } = Ns(this.shadowRoot, ":host");
    t.setProperty(
      "--_loading-indicator-delay",
      `var(--media-loading-indicator-transition-delay, ${e}ms)`
    );
  }
  get mediaPaused() {
    return un(this, ae.MEDIA_PAUSED);
  }
  set mediaPaused(e) {
    dn(this, ae.MEDIA_PAUSED, e);
  }
  get mediaLoading() {
    return un(this, ae.MEDIA_LOADING);
  }
  set mediaLoading(e) {
    dn(this, ae.MEDIA_LOADING, e);
  }
  get mediaController() {
    return gs(this, xn.MEDIA_CONTROLLER);
  }
  set mediaController(e) {
    vs(this, xn.MEDIA_CONTROLLER, e);
  }
  get noAutohide() {
    return un(this, Wy.NO_AUTOHIDE);
  }
  set noAutohide(e) {
    dn(this, Wy.NO_AUTOHIDE, e);
  }
}
ao = new WeakMap();
Wb = new WeakMap();
kP.shadowRootOptions = { mode: "open" };
kP.getTemplateHTML = k1e;
Ie.customElements.get("media-loading-indicator") ||
  Ie.customElements.define("media-loading-indicator", kP);
const C1e = `<svg aria-hidden="true" viewBox="0 0 24 24">
  <path d="M16.5 12A4.5 4.5 0 0 0 14 8v2.18l2.45 2.45a4.22 4.22 0 0 0 .05-.63Zm2.5 0a6.84 6.84 0 0 1-.54 2.64L20 16.15A8.8 8.8 0 0 0 21 12a9 9 0 0 0-7-8.77v2.06A7 7 0 0 1 19 12ZM4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25A6.92 6.92 0 0 1 14 18.7v2.06A9 9 0 0 0 17.69 19l2 2.05L21 19.73l-9-9L4.27 3ZM12 4 9.91 6.09 12 8.18V4Z"/>
</svg>`,
  sB = `<svg aria-hidden="true" viewBox="0 0 24 24">
  <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4Z"/>
</svg>`,
  I1e = `<svg aria-hidden="true" viewBox="0 0 24 24">
  <path d="M3 9v6h4l5 5V4L7 9H3Zm13.5 3A4.5 4.5 0 0 0 14 8v8a4.47 4.47 0 0 0 2.5-4ZM14 3.23v2.06a7 7 0 0 1 0 13.42v2.06a9 9 0 0 0 0-17.54Z"/>
</svg>`;
function L1e(n) {
  return `
    <style>
      :host(:not([${ae.MEDIA_VOLUME_LEVEL}])) slot[name=icon] slot:not([name=high]),
      :host([${ae.MEDIA_VOLUME_LEVEL}=high]) slot[name=icon] slot:not([name=high]) {
        display: none !important;
      }

      :host([${ae.MEDIA_VOLUME_LEVEL}=off]) slot[name=icon] slot:not([name=off]) {
        display: none !important;
      }

      :host([${ae.MEDIA_VOLUME_LEVEL}=low]) slot[name=icon] slot:not([name=low]) {
        display: none !important;
      }

      :host([${ae.MEDIA_VOLUME_LEVEL}=medium]) slot[name=icon] slot:not([name=medium]) {
        display: none !important;
      }

      :host(:not([${ae.MEDIA_VOLUME_LEVEL}=off])) slot[name=tooltip-unmute],
      :host([${ae.MEDIA_VOLUME_LEVEL}=off]) slot[name=tooltip-mute] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="off">${C1e}</slot>
      <slot name="low">${sB}</slot>
      <slot name="medium">${sB}</slot>
      <slot name="high">${I1e}</slot>
    </slot>
  `;
}
function D1e() {
  return `
    <slot name="tooltip-mute">${Tt("Mute")}</slot>
    <slot name="tooltip-unmute">${Tt("Unmute")}</slot>
  `;
}
const rB = (n) => {
  const e = n.mediaVolumeLevel === "off",
    t = Tt(e ? "unmute" : "mute");
  n.setAttribute("aria-label", t);
};
class CP extends Nr {
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_VOLUME_LEVEL];
  }
  connectedCallback() {
    super.connectedCallback(), rB(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_VOLUME_LEVEL && rB(this);
  }
  get mediaVolumeLevel() {
    return gs(this, ae.MEDIA_VOLUME_LEVEL);
  }
  set mediaVolumeLevel(e) {
    vs(this, ae.MEDIA_VOLUME_LEVEL, e);
  }
  handleClick() {
    const e =
      this.mediaVolumeLevel === "off"
        ? bt.MEDIA_UNMUTE_REQUEST
        : bt.MEDIA_MUTE_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(e, { composed: !0, bubbles: !0 }));
  }
}
CP.getSlotTemplateHTML = L1e;
CP.getTooltipContentHTML = D1e;
Ie.customElements.get("media-mute-button") ||
  Ie.customElements.define("media-mute-button", CP);
const iB = `<svg aria-hidden="true" viewBox="0 0 28 24">
  <path d="M24 3H4a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1Zm-1 16H5V5h18v14Zm-3-8h-7v5h7v-5Z"/>
</svg>`;
function P1e(n) {
  return `
    <style>
      :host([${ae.MEDIA_IS_PIP}]) slot[name=icon] slot:not([name=exit]) {
        display: none !important;
      }

      :host(:not([${ae.MEDIA_IS_PIP}])) slot[name=icon] slot:not([name=enter]) {
        display: none !important;
      }

      :host([${ae.MEDIA_IS_PIP}]) slot[name=tooltip-enter],
      :host(:not([${ae.MEDIA_IS_PIP}])) slot[name=tooltip-exit] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="enter">${iB}</slot>
      <slot name="exit">${iB}</slot>
    </slot>
  `;
}
function M1e() {
  return `
    <slot name="tooltip-enter">${Tt("Enter picture in picture mode")}</slot>
    <slot name="tooltip-exit">${Tt("Exit picture in picture mode")}</slot>
  `;
}
const aB = (n) => {
  const e = n.mediaIsPip
    ? Tt("exit picture in picture mode")
    : Tt("enter picture in picture mode");
  n.setAttribute("aria-label", e);
};
class IP extends Nr {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_IS_PIP,
      ae.MEDIA_PIP_UNAVAILABLE,
    ];
  }
  connectedCallback() {
    super.connectedCallback(), aB(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s), e === ae.MEDIA_IS_PIP && aB(this);
  }
  get mediaPipUnavailable() {
    return gs(this, ae.MEDIA_PIP_UNAVAILABLE);
  }
  set mediaPipUnavailable(e) {
    vs(this, ae.MEDIA_PIP_UNAVAILABLE, e);
  }
  get mediaIsPip() {
    return un(this, ae.MEDIA_IS_PIP);
  }
  set mediaIsPip(e) {
    dn(this, ae.MEDIA_IS_PIP, e);
  }
  handleClick() {
    const e = this.mediaIsPip
      ? bt.MEDIA_EXIT_PIP_REQUEST
      : bt.MEDIA_ENTER_PIP_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(e, { composed: !0, bubbles: !0 }));
  }
}
IP.getSlotTemplateHTML = P1e;
IP.getTooltipContentHTML = M1e;
Ie.customElements.get("media-pip-button") ||
  Ie.customElements.define("media-pip-button", IP);
var N1e = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  ph = (n, e, t) => (
    N1e(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  O1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  vc;
const uA = { RATES: "rates" },
  j1e = [1, 1.2, 1.5, 1.7, 2],
  jp = 1;
function F1e(n) {
  return `
    <style>
      :host {
        min-width: 5ch;
        padding: var(--media-button-padding, var(--media-control-padding, 10px 5px));
      }
    </style>
    <slot name="icon">${n.mediaplaybackrate || jp}x</slot>
  `;
}
function U1e() {
  return Tt("Playback rate");
}
class LP extends Nr {
  constructor() {
    var e;
    super(),
      O1e(this, vc, new hK(this, uA.RATES, { defaultValue: j1e })),
      (this.container = this.shadowRoot.querySelector('slot[name="icon"]')),
      (this.container.innerHTML = `${
        (e = this.mediaPlaybackRate) != null ? e : jp
      }x`);
  }
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_PLAYBACK_RATE, uA.RATES];
  }
  attributeChangedCallback(e, t, s) {
    if (
      (super.attributeChangedCallback(e, t, s),
      e === uA.RATES && (ph(this, vc).value = s),
      e === ae.MEDIA_PLAYBACK_RATE)
    ) {
      const r = s ? +s : Number.NaN,
        i = Number.isNaN(r) ? jp : r;
      (this.container.innerHTML = `${i}x`),
        this.setAttribute(
          "aria-label",
          Tt("Playback rate {playbackRate}", { playbackRate: i })
        );
    }
  }
  get rates() {
    return ph(this, vc);
  }
  set rates(e) {
    e
      ? Array.isArray(e)
        ? (ph(this, vc).value = e.join(" "))
        : typeof e == "string" && (ph(this, vc).value = e)
      : (ph(this, vc).value = "");
  }
  get mediaPlaybackRate() {
    return ps(this, ae.MEDIA_PLAYBACK_RATE, jp);
  }
  set mediaPlaybackRate(e) {
    lr(this, ae.MEDIA_PLAYBACK_RATE, e);
  }
  handleClick() {
    var e, t;
    const s = Array.from(ph(this, vc).values(), (a) => +a).sort(
        (a, o) => a - o
      ),
      r =
        (t =
          (e = s.find((a) => a > this.mediaPlaybackRate)) != null ? e : s[0]) !=
        null
          ? t
          : jp,
      i = new Ie.CustomEvent(bt.MEDIA_PLAYBACK_RATE_REQUEST, {
        composed: !0,
        bubbles: !0,
        detail: r,
      });
    this.dispatchEvent(i);
  }
}
vc = new WeakMap();
LP.getSlotTemplateHTML = F1e;
LP.getTooltipContentHTML = U1e;
Ie.customElements.get("media-playback-rate-button") ||
  Ie.customElements.define("media-playback-rate-button", LP);
const $1e = `<svg aria-hidden="true" viewBox="0 0 24 24">
  <path d="m6 21 15-9L6 3v18Z"/>
</svg>`,
  B1e = `<svg aria-hidden="true" viewBox="0 0 24 24">
  <path d="M6 20h4V4H6v16Zm8-16v16h4V4h-4Z"/>
</svg>`;
function H1e(n) {
  return `
    <style>
      :host([${ae.MEDIA_PAUSED}]) slot[name=pause],
      :host(:not([${ae.MEDIA_PAUSED}])) slot[name=play] {
        display: none !important;
      }

      :host([${ae.MEDIA_PAUSED}]) slot[name=tooltip-pause],
      :host(:not([${ae.MEDIA_PAUSED}])) slot[name=tooltip-play] {
        display: none;
      }
    </style>

    <slot name="icon">
      <slot name="play">${$1e}</slot>
      <slot name="pause">${B1e}</slot>
    </slot>
  `;
}
function V1e() {
  return `
    <slot name="tooltip-play">${Tt("Play")}</slot>
    <slot name="tooltip-pause">${Tt("Pause")}</slot>
  `;
}
const oB = (n) => {
  const e = n.mediaPaused ? Tt("play") : Tt("pause");
  n.setAttribute("aria-label", e);
};
class DP extends Nr {
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_PAUSED, ae.MEDIA_ENDED];
  }
  connectedCallback() {
    super.connectedCallback(), oB(this);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      (e === ae.MEDIA_PAUSED || e === ae.MEDIA_LANG) && oB(this);
  }
  get mediaPaused() {
    return un(this, ae.MEDIA_PAUSED);
  }
  set mediaPaused(e) {
    dn(this, ae.MEDIA_PAUSED, e);
  }
  handleClick() {
    const e = this.mediaPaused ? bt.MEDIA_PLAY_REQUEST : bt.MEDIA_PAUSE_REQUEST;
    this.dispatchEvent(new Ie.CustomEvent(e, { composed: !0, bubbles: !0 }));
  }
}
DP.getSlotTemplateHTML = H1e;
DP.getTooltipContentHTML = V1e;
Ie.customElements.get("media-play-button") ||
  Ie.customElements.define("media-play-button", DP);
const Xa = { PLACEHOLDER_SRC: "placeholdersrc", SRC: "src" };
function z1e(n) {
  return `
    <style>
      :host {
        pointer-events: none;
        display: var(--media-poster-image-display, inline-block);
        box-sizing: border-box;
      }

      img {
        max-width: 100%;
        max-height: 100%;
        min-width: 100%;
        min-height: 100%;
        background-repeat: no-repeat;
        background-position: var(--media-poster-image-background-position, var(--media-object-position, center));
        background-size: var(--media-poster-image-background-size, var(--media-object-fit, contain));
        object-fit: var(--media-object-fit, contain);
        object-position: var(--media-object-position, center);
      }
    </style>

    <img part="poster img" aria-hidden="true" id="image"/>
  `;
}
const G1e = (n) => {
    n.style.removeProperty("background-image");
  },
  q1e = (n, e) => {
    n.style["background-image"] = `url('${e}')`;
  };
class PP extends Ie.HTMLElement {
  static get observedAttributes() {
    return [Xa.PLACEHOLDER_SRC, Xa.SRC];
  }
  constructor() {
    if ((super(), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
    this.image = this.shadowRoot.querySelector("#image");
  }
  attributeChangedCallback(e, t, s) {
    e === Xa.SRC &&
      (s == null
        ? this.image.removeAttribute(Xa.SRC)
        : this.image.setAttribute(Xa.SRC, s)),
      e === Xa.PLACEHOLDER_SRC &&
        (s == null ? G1e(this.image) : q1e(this.image, s));
  }
  get placeholderSrc() {
    return gs(this, Xa.PLACEHOLDER_SRC);
  }
  set placeholderSrc(e) {
    vs(this, Xa.SRC, e);
  }
  get src() {
    return gs(this, Xa.SRC);
  }
  set src(e) {
    vs(this, Xa.SRC, e);
  }
}
PP.shadowRootOptions = { mode: "open" };
PP.getTemplateHTML = z1e;
Ie.customElements.get("media-poster-image") ||
  Ie.customElements.define("media-poster-image", PP);
var zK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  W1e = (n, e, t) => (
    zK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  K1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Y1e = (n, e, t, s) => (zK(n, e, "write to private field"), e.set(n, t), t),
  Kb;
class X1e extends Qc {
  constructor() {
    super(),
      K1e(this, Kb, void 0),
      Y1e(this, Kb, this.shadowRoot.querySelector("slot"));
  }
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_PREVIEW_CHAPTER,
      ae.MEDIA_LANG,
    ];
  }
  attributeChangedCallback(e, t, s) {
    if (
      (super.attributeChangedCallback(e, t, s),
      (e === ae.MEDIA_PREVIEW_CHAPTER || e === ae.MEDIA_LANG) &&
        s !== t &&
        s != null)
    )
      if (((W1e(this, Kb).textContent = s), s !== "")) {
        const r = Tt("chapter: {chapterName}", { chapterName: s });
        this.setAttribute("aria-valuetext", r);
      } else this.removeAttribute("aria-valuetext");
  }
  get mediaPreviewChapter() {
    return gs(this, ae.MEDIA_PREVIEW_CHAPTER);
  }
  set mediaPreviewChapter(e) {
    vs(this, ae.MEDIA_PREVIEW_CHAPTER, e);
  }
}
Kb = new WeakMap();
Ie.customElements.get("media-preview-chapter-display") ||
  Ie.customElements.define("media-preview-chapter-display", X1e);
var GK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Ky = (n, e, t) => (
    GK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  Q1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Yy = (n, e, t, s) => (GK(n, e, "write to private field"), e.set(n, t), t),
  oo;
function Z1e(n) {
  return `
    <style>
      :host {
        box-sizing: border-box;
        display: var(--media-control-display, var(--media-preview-thumbnail-display, inline-block));
        overflow: hidden;
      }

      img {
        display: none;
        position: relative;
      }
    </style>
    <img crossorigin loading="eager" decoding="async">
  `;
}
class cS extends Ie.HTMLElement {
  constructor() {
    if ((super(), Q1e(this, oo, void 0), !this.shadowRoot)) {
      this.attachShadow(this.constructor.shadowRootOptions);
      const e = Va(this.attributes);
      this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(e);
    }
  }
  static get observedAttributes() {
    return [
      xn.MEDIA_CONTROLLER,
      ae.MEDIA_PREVIEW_IMAGE,
      ae.MEDIA_PREVIEW_COORDS,
    ];
  }
  connectedCallback() {
    var e, t, s;
    const r = this.getAttribute(xn.MEDIA_CONTROLLER);
    r &&
      (Yy(
        this,
        oo,
        (e = this.getRootNode()) == null ? void 0 : e.getElementById(r)
      ),
      (s = (t = Ky(this, oo)) == null ? void 0 : t.associateElement) == null ||
        s.call(t, this));
  }
  disconnectedCallback() {
    var e, t;
    (t = (e = Ky(this, oo)) == null ? void 0 : e.unassociateElement) == null ||
      t.call(e, this),
      Yy(this, oo, null);
  }
  attributeChangedCallback(e, t, s) {
    var r, i, a, o, l;
    [ae.MEDIA_PREVIEW_IMAGE, ae.MEDIA_PREVIEW_COORDS].includes(e) &&
      this.update(),
      e === xn.MEDIA_CONTROLLER &&
        (t &&
          ((i = (r = Ky(this, oo)) == null ? void 0 : r.unassociateElement) ==
            null || i.call(r, this),
          Yy(this, oo, null)),
        s &&
          this.isConnected &&
          (Yy(
            this,
            oo,
            (a = this.getRootNode()) == null ? void 0 : a.getElementById(s)
          ),
          (l = (o = Ky(this, oo)) == null ? void 0 : o.associateElement) ==
            null || l.call(o, this)));
  }
  get mediaPreviewImage() {
    return gs(this, ae.MEDIA_PREVIEW_IMAGE);
  }
  set mediaPreviewImage(e) {
    vs(this, ae.MEDIA_PREVIEW_IMAGE, e);
  }
  get mediaPreviewCoords() {
    const e = this.getAttribute(ae.MEDIA_PREVIEW_COORDS);
    if (e) return e.split(/\s+/).map((t) => +t);
  }
  set mediaPreviewCoords(e) {
    if (!e) {
      this.removeAttribute(ae.MEDIA_PREVIEW_COORDS);
      return;
    }
    this.setAttribute(ae.MEDIA_PREVIEW_COORDS, e.join(" "));
  }
  update() {
    const e = this.mediaPreviewCoords,
      t = this.mediaPreviewImage;
    if (!(e && t)) return;
    const [s, r, i, a] = e,
      o = t.split("#")[0],
      l = getComputedStyle(this),
      { maxWidth: c, maxHeight: h, minWidth: m, minHeight: p } = l,
      g = Math.min(parseInt(c) / i, parseInt(h) / a),
      y = Math.max(parseInt(m) / i, parseInt(p) / a),
      b = g < 1,
      w = b ? g : y > 1 ? y : 1,
      { style: S } = Ns(this.shadowRoot, ":host"),
      A = Ns(this.shadowRoot, "img").style,
      _ = this.shadowRoot.querySelector("img"),
      R = b ? "min" : "max";
    S.setProperty(`${R}-width`, "initial", "important"),
      S.setProperty(`${R}-height`, "initial", "important"),
      (S.width = `${i * w}px`),
      (S.height = `${a * w}px`);
    const C = () => {
      (A.width = `${this.imgWidth * w}px`),
        (A.height = `${this.imgHeight * w}px`),
        (A.display = "block");
    };
    _.src !== o &&
      ((_.onload = () => {
        (this.imgWidth = _.naturalWidth),
          (this.imgHeight = _.naturalHeight),
          C();
      }),
      (_.src = o),
      C()),
      C(),
      (A.transform = `translate(-${s * w}px, -${r * w}px)`);
  }
}
oo = new WeakMap();
cS.shadowRootOptions = { mode: "open" };
cS.getTemplateHTML = Z1e;
Ie.customElements.get("media-preview-thumbnail") ||
  Ie.customElements.define("media-preview-thumbnail", cS);
var lB = cS,
  qK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  cB = (n, e, t) => (
    qK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  J1e = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  eAe = (n, e, t, s) => (qK(n, e, "write to private field"), e.set(n, t), t),
  Fp;
class tAe extends Qc {
  constructor() {
    super(),
      J1e(this, Fp, void 0),
      eAe(this, Fp, this.shadowRoot.querySelector("slot")),
      (cB(this, Fp).textContent = Lc(0));
  }
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_PREVIEW_TIME];
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === ae.MEDIA_PREVIEW_TIME &&
        s != null &&
        (cB(this, Fp).textContent = Lc(parseFloat(s)));
  }
  get mediaPreviewTime() {
    return ps(this, ae.MEDIA_PREVIEW_TIME);
  }
  set mediaPreviewTime(e) {
    lr(this, ae.MEDIA_PREVIEW_TIME, e);
  }
}
Fp = new WeakMap();
Ie.customElements.get("media-preview-time-display") ||
  Ie.customElements.define("media-preview-time-display", tAe);
const gh = { SEEK_OFFSET: "seekoffset" },
  dA = 30,
  nAe = (n) => `
  <svg aria-hidden="true" viewBox="0 0 20 24">
    <defs>
      <style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style>
    </defs>
    <text class="text value" transform="translate(2.18 19.87)">${n}</text>
    <path d="M10 6V3L4.37 7 10 10.94V8a5.54 5.54 0 0 1 1.9 10.48v2.12A7.5 7.5 0 0 0 10 6Z"/>
  </svg>`;
function sAe(n, e) {
  return `
    <slot name="icon">${nAe(e.seekOffset)}</slot>
  `;
}
function rAe() {
  return Tt("Seek backward");
}
const iAe = 0;
class MP extends Nr {
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_CURRENT_TIME, gh.SEEK_OFFSET];
  }
  connectedCallback() {
    super.connectedCallback(), (this.seekOffset = ps(this, gh.SEEK_OFFSET, dA));
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === gh.SEEK_OFFSET && (this.seekOffset = ps(this, gh.SEEK_OFFSET, dA));
  }
  get seekOffset() {
    return ps(this, gh.SEEK_OFFSET, dA);
  }
  set seekOffset(e) {
    lr(this, gh.SEEK_OFFSET, e),
      this.setAttribute(
        "aria-label",
        Tt("seek back {seekOffset} seconds", { seekOffset: this.seekOffset })
      ),
      nK(sK(this, "icon"), this.seekOffset);
  }
  get mediaCurrentTime() {
    return ps(this, ae.MEDIA_CURRENT_TIME, iAe);
  }
  set mediaCurrentTime(e) {
    lr(this, ae.MEDIA_CURRENT_TIME, e);
  }
  handleClick() {
    const e = Math.max(this.mediaCurrentTime - this.seekOffset, 0),
      t = new Ie.CustomEvent(bt.MEDIA_SEEK_REQUEST, {
        composed: !0,
        bubbles: !0,
        detail: e,
      });
    this.dispatchEvent(t);
  }
}
MP.getSlotTemplateHTML = sAe;
MP.getTooltipContentHTML = rAe;
Ie.customElements.get("media-seek-backward-button") ||
  Ie.customElements.define("media-seek-backward-button", MP);
const vh = { SEEK_OFFSET: "seekoffset" },
  hA = 30,
  aAe = (n) => `
  <svg aria-hidden="true" viewBox="0 0 20 24">
    <defs>
      <style>.text{font-size:8px;font-family:Arial-BoldMT, Arial;font-weight:700;}</style>
    </defs>
    <text class="text value" transform="translate(8.9 19.87)">${n}</text>
    <path d="M10 6V3l5.61 4L10 10.94V8a5.54 5.54 0 0 0-1.9 10.48v2.12A7.5 7.5 0 0 1 10 6Z"/>
  </svg>`;
function oAe(n, e) {
  return `
    <slot name="icon">${aAe(e.seekOffset)}</slot>
  `;
}
function lAe() {
  return Tt("Seek forward");
}
const cAe = 0;
class NP extends Nr {
  static get observedAttributes() {
    return [...super.observedAttributes, ae.MEDIA_CURRENT_TIME, vh.SEEK_OFFSET];
  }
  connectedCallback() {
    super.connectedCallback(), (this.seekOffset = ps(this, vh.SEEK_OFFSET, hA));
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      e === vh.SEEK_OFFSET && (this.seekOffset = ps(this, vh.SEEK_OFFSET, hA));
  }
  get seekOffset() {
    return ps(this, vh.SEEK_OFFSET, hA);
  }
  set seekOffset(e) {
    lr(this, vh.SEEK_OFFSET, e),
      this.setAttribute(
        "aria-label",
        Tt("seek forward {seekOffset} seconds", { seekOffset: this.seekOffset })
      ),
      nK(sK(this, "icon"), this.seekOffset);
  }
  get mediaCurrentTime() {
    return ps(this, ae.MEDIA_CURRENT_TIME, cAe);
  }
  set mediaCurrentTime(e) {
    lr(this, ae.MEDIA_CURRENT_TIME, e);
  }
  handleClick() {
    const e = this.mediaCurrentTime + this.seekOffset,
      t = new Ie.CustomEvent(bt.MEDIA_SEEK_REQUEST, {
        composed: !0,
        bubbles: !0,
        detail: e,
      });
    this.dispatchEvent(t);
  }
}
NP.getSlotTemplateHTML = oAe;
NP.getTooltipContentHTML = lAe;
Ie.customElements.get("media-seek-forward-button") ||
  Ie.customElements.define("media-seek-forward-button", NP);
var WK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  fA = (n, e, t) => (
    WK(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  uAe = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  dAe = (n, e, t, s) => (WK(n, e, "write to private field"), e.set(n, t), t),
  Ih;
const Iu = {
    REMAINING: "remaining",
    SHOW_DURATION: "showduration",
    NO_TOGGLE: "notoggle",
  },
  uB = [
    ...Object.values(Iu),
    ae.MEDIA_CURRENT_TIME,
    ae.MEDIA_DURATION,
    ae.MEDIA_SEEKABLE,
  ],
  dB = ["Enter", " "],
  hAe = "&nbsp;/&nbsp;",
  $C = (n, { timesSep: e = hAe } = {}) => {
    var t, s;
    const r = (t = n.mediaCurrentTime) != null ? t : 0,
      [, i] = (s = n.mediaSeekable) != null ? s : [];
    let a = 0;
    Number.isFinite(n.mediaDuration)
      ? (a = n.mediaDuration)
      : Number.isFinite(i) && (a = i);
    const o = n.remaining ? Lc(0 - (a - r)) : Lc(r);
    return n.showDuration ? `${o}${e}${Lc(a)}` : o;
  },
  fAe = "video not loaded, unknown time.",
  mAe = (n) => {
    var e;
    const t = n.mediaCurrentTime,
      [, s] = (e = n.mediaSeekable) != null ? e : [];
    let r = null;
    if (
      (Number.isFinite(n.mediaDuration)
        ? (r = n.mediaDuration)
        : Number.isFinite(s) && (r = s),
      t == null || r === null)
    ) {
      n.setAttribute("aria-valuetext", fAe);
      return;
    }
    const i = n.remaining ? ug(0 - (r - t)) : ug(t);
    if (!n.showDuration) {
      n.setAttribute("aria-valuetext", i);
      return;
    }
    const a = ug(r),
      o = `${i} of ${a}`;
    n.setAttribute("aria-valuetext", o);
  };
function pAe(n, e) {
  return `
    <slot>${$C(e)}</slot>
  `;
}
class KK extends Qc {
  constructor() {
    super(),
      uAe(this, Ih, void 0),
      dAe(this, Ih, this.shadowRoot.querySelector("slot")),
      (fA(this, Ih).innerHTML = `${$C(this)}`);
  }
  static get observedAttributes() {
    return [...super.observedAttributes, ...uB, "disabled"];
  }
  connectedCallback() {
    const { style: e } = Ns(this.shadowRoot, ":host(:hover:not([notoggle]))");
    e.setProperty("cursor", "var(--media-cursor, pointer)"),
      e.setProperty(
        "background",
        "var(--media-control-hover-background, rgba(50 50 70 / .7))"
      ),
      this.hasAttribute("disabled") || this.enable(),
      this.setAttribute("role", "progressbar"),
      this.setAttribute("aria-label", Tt("playback time"));
    const t = (s) => {
      const { key: r } = s;
      if (!dB.includes(r)) {
        this.removeEventListener("keyup", t);
        return;
      }
      this.toggleTimeDisplay();
    };
    this.addEventListener("keydown", (s) => {
      const { metaKey: r, altKey: i, key: a } = s;
      if (r || i || !dB.includes(a)) {
        this.removeEventListener("keyup", t);
        return;
      }
      this.addEventListener("keyup", t);
    }),
      this.addEventListener("click", this.toggleTimeDisplay),
      super.connectedCallback();
  }
  toggleTimeDisplay() {
    this.noToggle ||
      (this.hasAttribute("remaining")
        ? this.removeAttribute("remaining")
        : this.setAttribute("remaining", ""));
  }
  disconnectedCallback() {
    this.disable(), super.disconnectedCallback();
  }
  attributeChangedCallback(e, t, s) {
    uB.includes(e)
      ? this.update()
      : e === "disabled" &&
        s !== t &&
        (s == null ? this.enable() : this.disable()),
      super.attributeChangedCallback(e, t, s);
  }
  enable() {
    this.tabIndex = 0;
  }
  disable() {
    this.tabIndex = -1;
  }
  get remaining() {
    return un(this, Iu.REMAINING);
  }
  set remaining(e) {
    dn(this, Iu.REMAINING, e);
  }
  get showDuration() {
    return un(this, Iu.SHOW_DURATION);
  }
  set showDuration(e) {
    dn(this, Iu.SHOW_DURATION, e);
  }
  get noToggle() {
    return un(this, Iu.NO_TOGGLE);
  }
  set noToggle(e) {
    dn(this, Iu.NO_TOGGLE, e);
  }
  get mediaDuration() {
    return ps(this, ae.MEDIA_DURATION);
  }
  set mediaDuration(e) {
    lr(this, ae.MEDIA_DURATION, e);
  }
  get mediaCurrentTime() {
    return ps(this, ae.MEDIA_CURRENT_TIME);
  }
  set mediaCurrentTime(e) {
    lr(this, ae.MEDIA_CURRENT_TIME, e);
  }
  get mediaSeekable() {
    const e = this.getAttribute(ae.MEDIA_SEEKABLE);
    if (e) return e.split(":").map((t) => +t);
  }
  set mediaSeekable(e) {
    if (e == null) {
      this.removeAttribute(ae.MEDIA_SEEKABLE);
      return;
    }
    this.setAttribute(ae.MEDIA_SEEKABLE, e.join(":"));
  }
  update() {
    const e = $C(this);
    mAe(this), e !== fA(this, Ih).innerHTML && (fA(this, Ih).innerHTML = e);
  }
}
Ih = new WeakMap();
KK.getSlotTemplateHTML = pAe;
Ie.customElements.get("media-time-display") ||
  Ie.customElements.define("media-time-display", KK);
var YK = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  er = (n, e, t) => (YK(n, e, "read from private field"), e.get(n)),
  Qa = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  bi = (n, e, t, s) => (YK(n, e, "write to private field"), e.set(n, t), t),
  gAe = (n, e, t, s) => ({
    set _(r) {
      bi(n, e, r);
    },
    get _() {
      return er(n, e);
    },
  }),
  Lh,
  Yb,
  Dh,
  Up,
  Xb,
  Qb,
  Zb,
  Ph,
  Lu,
  Jb;
class vAe {
  constructor(e, t, s) {
    Qa(this, Lh, void 0),
      Qa(this, Yb, void 0),
      Qa(this, Dh, void 0),
      Qa(this, Up, void 0),
      Qa(this, Xb, void 0),
      Qa(this, Qb, void 0),
      Qa(this, Zb, void 0),
      Qa(this, Ph, void 0),
      Qa(this, Lu, 0),
      Qa(this, Jb, (r = performance.now()) => {
        bi(this, Lu, requestAnimationFrame(er(this, Jb))),
          bi(this, Up, performance.now() - er(this, Dh));
        const i = 1e3 / this.fps;
        if (er(this, Up) > i) {
          bi(this, Dh, r - (er(this, Up) % i));
          const a = 1e3 / ((r - er(this, Yb)) / ++gAe(this, Xb)._),
            o = (r - er(this, Qb)) / 1e3 / this.duration;
          let l = er(this, Zb) + o * this.playbackRate;
          l - er(this, Lh).valueAsNumber > 0
            ? bi(this, Ph, this.playbackRate / this.duration / a)
            : (bi(this, Ph, 0.995 * er(this, Ph)),
              (l = er(this, Lh).valueAsNumber + er(this, Ph))),
            this.callback(l);
        }
      }),
      bi(this, Lh, e),
      (this.callback = t),
      (this.fps = s);
  }
  start() {
    er(this, Lu) === 0 &&
      (bi(this, Dh, performance.now()),
      bi(this, Yb, er(this, Dh)),
      bi(this, Xb, 0),
      er(this, Jb).call(this));
  }
  stop() {
    er(this, Lu) !== 0 && (cancelAnimationFrame(er(this, Lu)), bi(this, Lu, 0));
  }
  update({ start: e, duration: t, playbackRate: s }) {
    const r = e - er(this, Lh).valueAsNumber,
      i = Math.abs(t - this.duration);
    (r > 0 || r < -0.03 || i >= 0.5) && this.callback(e),
      bi(this, Zb, e),
      bi(this, Qb, performance.now()),
      (this.duration = t),
      (this.playbackRate = s);
  }
}
Lh = new WeakMap();
Yb = new WeakMap();
Dh = new WeakMap();
Up = new WeakMap();
Xb = new WeakMap();
Qb = new WeakMap();
Zb = new WeakMap();
Ph = new WeakMap();
Lu = new WeakMap();
Jb = new WeakMap();
var OP = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Hs = (n, e, t) => (
    OP(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  Zs = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  lo = (n, e, t, s) => (OP(n, e, "write to private field"), e.set(n, t), t),
  Rr = (n, e, t) => (OP(n, e, "access private method"), t),
  Mh,
  Gu,
  Uw,
  fg,
  $w,
  ex,
  cv,
  uv,
  Nh,
  Oh,
  $p,
  jP,
  XK,
  BC,
  Bw,
  FP,
  Hw,
  UP,
  Vw,
  $P,
  HC,
  QK,
  dv,
  zw,
  VC,
  ZK;
const yAe = "video not loaded, unknown time.",
  bAe = (n) => {
    const e = n.range,
      t = ug(+JK(n)),
      s = ug(+n.mediaSeekableEnd),
      r = t && s ? `${t} of ${s}` : yAe;
    e.setAttribute("aria-valuetext", r);
  };
function xAe(n) {
  return `
    ${Zf.getTemplateHTML(n)}
    <style>
      :host {
        --media-box-border-radius: 4px;
        --media-box-padding-left: 10px;
        --media-box-padding-right: 10px;
        --media-preview-border-radius: var(--media-box-border-radius);
        --media-box-arrow-offset: var(--media-box-border-radius);
        --_control-background: var(--media-control-background, var(--media-secondary-color, rgb(20 20 30 / .7)));
        --_preview-background: var(--media-preview-background, var(--_control-background));

        
        contain: layout;
      }

      #buffered {
        background: var(--media-time-range-buffered-color, rgb(255 255 255 / .4));
        position: absolute;
        height: 100%;
        will-change: width;
      }

      #preview-rail,
      #current-rail {
        width: 100%;
        position: absolute;
        left: 0;
        bottom: 100%;
        pointer-events: none;
        will-change: transform;
      }

      [part~="box"] {
        width: min-content;
        
        position: absolute;
        bottom: 100%;
        flex-direction: column;
        align-items: center;
        transform: translateX(-50%);
      }

      [part~="current-box"] {
        display: var(--media-current-box-display, var(--media-box-display, flex));
        margin: var(--media-current-box-margin, var(--media-box-margin, 0 0 5px));
        visibility: hidden;
      }

      [part~="preview-box"] {
        display: var(--media-preview-box-display, var(--media-box-display, flex));
        margin: var(--media-preview-box-margin, var(--media-box-margin, 0 0 5px));
        transition-property: var(--media-preview-transition-property, visibility, opacity);
        transition-duration: var(--media-preview-transition-duration-out, .25s);
        transition-delay: var(--media-preview-transition-delay-out, 0s);
        visibility: hidden;
        opacity: 0;
      }

      :host(:is([${ae.MEDIA_PREVIEW_IMAGE}], [${
    ae.MEDIA_PREVIEW_TIME
  }])[dragging]) [part~="preview-box"] {
        transition-duration: var(--media-preview-transition-duration-in, .5s);
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        visibility: visible;
        opacity: 1;
      }

      @media (hover: hover) {
        :host(:is([${ae.MEDIA_PREVIEW_IMAGE}], [${
    ae.MEDIA_PREVIEW_TIME
  }]):hover) [part~="preview-box"] {
          transition-duration: var(--media-preview-transition-duration-in, .5s);
          transition-delay: var(--media-preview-transition-delay-in, .25s);
          visibility: visible;
          opacity: 1;
        }
      }

      media-preview-thumbnail,
      ::slotted(media-preview-thumbnail) {
        visibility: hidden;
        
        transition: visibility 0s .25s;
        transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));
        background: var(--media-preview-thumbnail-background, var(--_preview-background));
        box-shadow: var(--media-preview-thumbnail-box-shadow, 0 0 4px rgb(0 0 0 / .2));
        max-width: var(--media-preview-thumbnail-max-width, 180px);
        max-height: var(--media-preview-thumbnail-max-height, 160px);
        min-width: var(--media-preview-thumbnail-min-width, 120px);
        min-height: var(--media-preview-thumbnail-min-height, 80px);
        border: var(--media-preview-thumbnail-border);
        border-radius: var(--media-preview-thumbnail-border-radius,
          var(--media-preview-border-radius) var(--media-preview-border-radius) 0 0);
      }

      :host([${ae.MEDIA_PREVIEW_IMAGE}][dragging]) media-preview-thumbnail,
      :host([${
        ae.MEDIA_PREVIEW_IMAGE
      }][dragging]) ::slotted(media-preview-thumbnail) {
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        visibility: visible;
      }

      @media (hover: hover) {
        :host([${ae.MEDIA_PREVIEW_IMAGE}]:hover) media-preview-thumbnail,
        :host([${
          ae.MEDIA_PREVIEW_IMAGE
        }]:hover) ::slotted(media-preview-thumbnail) {
          transition-delay: var(--media-preview-transition-delay-in, .25s);
          visibility: visible;
        }

        :host([${ae.MEDIA_PREVIEW_TIME}]:hover) {
          --media-time-range-hover-display: block;
        }
      }

      media-preview-chapter-display,
      ::slotted(media-preview-chapter-display) {
        font-size: var(--media-font-size, 13px);
        line-height: 17px;
        min-width: 0;
        visibility: hidden;
        
        transition: min-width 0s, border-radius 0s, margin 0s, padding 0s, visibility 0s;
        transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));
        background: var(--media-preview-chapter-background, var(--_preview-background));
        border-radius: var(--media-preview-chapter-border-radius,
          var(--media-preview-border-radius) var(--media-preview-border-radius)
          var(--media-preview-border-radius) var(--media-preview-border-radius));
        padding: var(--media-preview-chapter-padding, 3.5px 9px);
        margin: var(--media-preview-chapter-margin, 0 0 5px);
        text-shadow: var(--media-preview-chapter-text-shadow, 0 0 4px rgb(0 0 0 / .75));
      }

      :host([${ae.MEDIA_PREVIEW_IMAGE}]) media-preview-chapter-display,
      :host([${
        ae.MEDIA_PREVIEW_IMAGE
      }]) ::slotted(media-preview-chapter-display) {
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        border-radius: var(--media-preview-chapter-border-radius, 0);
        padding: var(--media-preview-chapter-padding, 3.5px 9px 0);
        margin: var(--media-preview-chapter-margin, 0);
        min-width: 100%;
      }

      media-preview-chapter-display[${ae.MEDIA_PREVIEW_CHAPTER}],
      ::slotted(media-preview-chapter-display[${ae.MEDIA_PREVIEW_CHAPTER}]) {
        visibility: visible;
      }

      media-preview-chapter-display:not([aria-valuetext]),
      ::slotted(media-preview-chapter-display:not([aria-valuetext])) {
        display: none;
      }

      media-preview-time-display,
      ::slotted(media-preview-time-display),
      media-time-display,
      ::slotted(media-time-display) {
        font-size: var(--media-font-size, 13px);
        line-height: 17px;
        min-width: 0;
        
        transition: min-width 0s, border-radius 0s;
        transition-delay: calc(var(--media-preview-transition-delay-out, 0s) + var(--media-preview-transition-duration-out, .25s));
        background: var(--media-preview-time-background, var(--_preview-background));
        border-radius: var(--media-preview-time-border-radius,
          var(--media-preview-border-radius) var(--media-preview-border-radius)
          var(--media-preview-border-radius) var(--media-preview-border-radius));
        padding: var(--media-preview-time-padding, 3.5px 9px);
        margin: var(--media-preview-time-margin, 0);
        text-shadow: var(--media-preview-time-text-shadow, 0 0 4px rgb(0 0 0 / .75));
        transform: translateX(min(
          max(calc(50% - var(--_box-width) / 2),
          calc(var(--_box-shift, 0))),
          calc(var(--_box-width) / 2 - 50%)
        ));
      }

      :host([${ae.MEDIA_PREVIEW_IMAGE}]) media-preview-time-display,
      :host([${ae.MEDIA_PREVIEW_IMAGE}]) ::slotted(media-preview-time-display) {
        transition-delay: var(--media-preview-transition-delay-in, .25s);
        border-radius: var(--media-preview-time-border-radius,
          0 0 var(--media-preview-border-radius) var(--media-preview-border-radius));
        min-width: 100%;
      }

      :host([${ae.MEDIA_PREVIEW_TIME}]:hover) {
        --media-time-range-hover-display: block;
      }

      [part~="arrow"],
      ::slotted([part~="arrow"]) {
        display: var(--media-box-arrow-display, inline-block);
        transform: translateX(min(
          max(calc(50% - var(--_box-width) / 2 + var(--media-box-arrow-offset)),
          calc(var(--_box-shift, 0))),
          calc(var(--_box-width) / 2 - 50% - var(--media-box-arrow-offset))
        ));
        
        border-color: transparent;
        border-top-color: var(--media-box-arrow-background, var(--_control-background));
        border-width: var(--media-box-arrow-border-width,
          var(--media-box-arrow-height, 5px) var(--media-box-arrow-width, 6px) 0);
        border-style: solid;
        justify-content: center;
        height: 0;
      }
    </style>
    <div id="preview-rail">
      <slot name="preview" part="box preview-box">
        <media-preview-thumbnail>
          <template shadowrootmode="${lB.shadowRootOptions.mode}">
            ${lB.getTemplateHTML({})}
          </template>
        </media-preview-thumbnail>
        <media-preview-chapter-display></media-preview-chapter-display>
        <media-preview-time-display></media-preview-time-display>
        <slot name="preview-arrow"><div part="arrow"></div></slot>
      </slot>
    </div>
    <div id="current-rail">
      <slot name="current" part="box current-box">
        
      </slot>
    </div>
  `;
}
const Xy = (n, e = n.mediaCurrentTime) => {
    const t = Number.isFinite(n.mediaSeekableStart) ? n.mediaSeekableStart : 0,
      s = Number.isFinite(n.mediaDuration)
        ? n.mediaDuration
        : n.mediaSeekableEnd;
    if (Number.isNaN(s)) return 0;
    const r = (e - t) / (s - t);
    return Math.max(0, Math.min(r, 1));
  },
  JK = (n, e = n.range.valueAsNumber) => {
    const t = Number.isFinite(n.mediaSeekableStart) ? n.mediaSeekableStart : 0,
      s = Number.isFinite(n.mediaDuration)
        ? n.mediaDuration
        : n.mediaSeekableEnd;
    return Number.isNaN(s) ? 0 : e * (s - t) + t;
  };
class BP extends Zf {
  constructor() {
    super(),
      Zs(this, Oh),
      Zs(this, jP),
      Zs(this, Bw),
      Zs(this, Hw),
      Zs(this, Vw),
      Zs(this, HC),
      Zs(this, dv),
      Zs(this, VC),
      Zs(this, Mh, void 0),
      Zs(this, Gu, void 0),
      Zs(this, Uw, void 0),
      Zs(this, fg, void 0),
      Zs(this, $w, void 0),
      Zs(this, ex, void 0),
      Zs(this, cv, void 0),
      Zs(this, uv, void 0),
      Zs(this, Nh, void 0),
      Zs(this, BC, (s) => {
        this.dragging ||
          (cP(s) && (this.range.valueAsNumber = s), this.updateBar());
      }),
      this.shadowRoot
        .querySelector("#track")
        .insertAdjacentHTML(
          "afterbegin",
          '<div id="buffered" part="buffered"></div>'
        ),
      lo(this, Uw, this.shadowRoot.querySelectorAll('[part~="box"]')),
      lo(this, $w, this.shadowRoot.querySelector('[part~="preview-box"]')),
      lo(this, ex, this.shadowRoot.querySelector('[part~="current-box"]'));
    const t = getComputedStyle(this);
    lo(this, cv, parseInt(t.getPropertyValue("--media-box-padding-left"))),
      lo(this, uv, parseInt(t.getPropertyValue("--media-box-padding-right"))),
      lo(this, Gu, new vAe(this.range, Hs(this, BC), 60));
  }
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_PAUSED,
      ae.MEDIA_DURATION,
      ae.MEDIA_SEEKABLE,
      ae.MEDIA_CURRENT_TIME,
      ae.MEDIA_PREVIEW_IMAGE,
      ae.MEDIA_PREVIEW_TIME,
      ae.MEDIA_PREVIEW_CHAPTER,
      ae.MEDIA_BUFFERED,
      ae.MEDIA_PLAYBACK_RATE,
      ae.MEDIA_LOADING,
      ae.MEDIA_ENDED,
    ];
  }
  connectedCallback() {
    var e;
    super.connectedCallback(),
      this.range.setAttribute("aria-label", Tt("seek")),
      Rr(this, Oh, $p).call(this),
      lo(this, Mh, this.getRootNode()),
      (e = Hs(this, Mh)) == null || e.addEventListener("transitionstart", this);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(),
      Rr(this, Oh, $p).call(this),
      (e = Hs(this, Mh)) == null ||
        e.removeEventListener("transitionstart", this),
      lo(this, Mh, null);
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      t != s &&
        (e === ae.MEDIA_CURRENT_TIME ||
        e === ae.MEDIA_PAUSED ||
        e === ae.MEDIA_ENDED ||
        e === ae.MEDIA_LOADING ||
        e === ae.MEDIA_DURATION ||
        e === ae.MEDIA_SEEKABLE
          ? (Hs(this, Gu).update({
              start: Xy(this),
              duration: this.mediaSeekableEnd - this.mediaSeekableStart,
              playbackRate: this.mediaPlaybackRate,
            }),
            Rr(this, Oh, $p).call(this),
            bAe(this))
          : e === ae.MEDIA_BUFFERED && this.updateBufferedBar(),
        (e === ae.MEDIA_DURATION || e === ae.MEDIA_SEEKABLE) &&
          ((this.mediaChaptersCues = Hs(this, Nh)), this.updateBar()));
  }
  get mediaChaptersCues() {
    return Hs(this, Nh);
  }
  set mediaChaptersCues(e) {
    var t;
    lo(this, Nh, e),
      this.updateSegments(
        (t = Hs(this, Nh)) == null
          ? void 0
          : t.map((s) => ({
              start: Xy(this, s.startTime),
              end: Xy(this, s.endTime),
            }))
      );
  }
  get mediaPaused() {
    return un(this, ae.MEDIA_PAUSED);
  }
  set mediaPaused(e) {
    dn(this, ae.MEDIA_PAUSED, e);
  }
  get mediaLoading() {
    return un(this, ae.MEDIA_LOADING);
  }
  set mediaLoading(e) {
    dn(this, ae.MEDIA_LOADING, e);
  }
  get mediaDuration() {
    return ps(this, ae.MEDIA_DURATION);
  }
  set mediaDuration(e) {
    lr(this, ae.MEDIA_DURATION, e);
  }
  get mediaCurrentTime() {
    return ps(this, ae.MEDIA_CURRENT_TIME);
  }
  set mediaCurrentTime(e) {
    lr(this, ae.MEDIA_CURRENT_TIME, e);
  }
  get mediaPlaybackRate() {
    return ps(this, ae.MEDIA_PLAYBACK_RATE, 1);
  }
  set mediaPlaybackRate(e) {
    lr(this, ae.MEDIA_PLAYBACK_RATE, e);
  }
  get mediaBuffered() {
    const e = this.getAttribute(ae.MEDIA_BUFFERED);
    return e ? e.split(" ").map((t) => t.split(":").map((s) => +s)) : [];
  }
  set mediaBuffered(e) {
    if (!e) {
      this.removeAttribute(ae.MEDIA_BUFFERED);
      return;
    }
    const t = e.map((s) => s.join(":")).join(" ");
    this.setAttribute(ae.MEDIA_BUFFERED, t);
  }
  get mediaSeekable() {
    const e = this.getAttribute(ae.MEDIA_SEEKABLE);
    if (e) return e.split(":").map((t) => +t);
  }
  set mediaSeekable(e) {
    if (e == null) {
      this.removeAttribute(ae.MEDIA_SEEKABLE);
      return;
    }
    this.setAttribute(ae.MEDIA_SEEKABLE, e.join(":"));
  }
  get mediaSeekableEnd() {
    var e;
    const [, t = this.mediaDuration] =
      (e = this.mediaSeekable) != null ? e : [];
    return t;
  }
  get mediaSeekableStart() {
    var e;
    const [t = 0] = (e = this.mediaSeekable) != null ? e : [];
    return t;
  }
  get mediaPreviewImage() {
    return gs(this, ae.MEDIA_PREVIEW_IMAGE);
  }
  set mediaPreviewImage(e) {
    vs(this, ae.MEDIA_PREVIEW_IMAGE, e);
  }
  get mediaPreviewTime() {
    return ps(this, ae.MEDIA_PREVIEW_TIME);
  }
  set mediaPreviewTime(e) {
    lr(this, ae.MEDIA_PREVIEW_TIME, e);
  }
  get mediaEnded() {
    return un(this, ae.MEDIA_ENDED);
  }
  set mediaEnded(e) {
    dn(this, ae.MEDIA_ENDED, e);
  }
  updateBar() {
    super.updateBar(), this.updateBufferedBar(), this.updateCurrentBox();
  }
  updateBufferedBar() {
    var e;
    const t = this.mediaBuffered;
    if (!t.length) return;
    let s;
    if (this.mediaEnded) s = 1;
    else {
      const i = this.mediaCurrentTime,
        [, a = this.mediaSeekableStart] =
          (e = t.find(([o, l]) => o <= i && i <= l)) != null ? e : [];
      s = Xy(this, a);
    }
    const { style: r } = Ns(this.shadowRoot, "#buffered");
    r.setProperty("width", `${s * 100}%`);
  }
  updateCurrentBox() {
    if (
      !this.shadowRoot.querySelector('slot[name="current"]').assignedElements()
        .length
    )
      return;
    const t = Ns(this.shadowRoot, "#current-rail"),
      s = Ns(this.shadowRoot, '[part~="current-box"]'),
      r = Rr(this, Bw, FP).call(this, Hs(this, ex)),
      i = Rr(this, Hw, UP).call(this, r, this.range.valueAsNumber),
      a = Rr(this, Vw, $P).call(this, r, this.range.valueAsNumber);
    (t.style.transform = `translateX(${i})`),
      t.style.setProperty("--_range-width", `${r.range.width}`),
      s.style.setProperty("--_box-shift", `${a}`),
      s.style.setProperty("--_box-width", `${r.box.width}px`),
      s.style.setProperty("visibility", "initial");
  }
  handleEvent(e) {
    switch ((super.handleEvent(e), e.type)) {
      case "input":
        Rr(this, VC, ZK).call(this);
        break;
      case "pointermove":
        Rr(this, HC, QK).call(this, e);
        break;
      case "pointerup":
      case "pointerleave":
        Rr(this, dv, zw).call(this, null);
        break;
      case "transitionstart":
        Qf(e.target, this) && setTimeout(() => Rr(this, Oh, $p).call(this), 0);
        break;
    }
  }
}
Mh = new WeakMap();
Gu = new WeakMap();
Uw = new WeakMap();
fg = new WeakMap();
$w = new WeakMap();
ex = new WeakMap();
cv = new WeakMap();
uv = new WeakMap();
Nh = new WeakMap();
Oh = new WeakSet();
$p = function () {
  Rr(this, jP, XK).call(this) ? Hs(this, Gu).start() : Hs(this, Gu).stop();
};
jP = new WeakSet();
XK = function () {
  return (
    this.isConnected &&
    !this.mediaPaused &&
    !this.mediaLoading &&
    !this.mediaEnded &&
    this.mediaSeekableEnd > 0 &&
    iK(this)
  );
};
BC = new WeakMap();
Bw = new WeakSet();
FP = function (n) {
  var e;
  const s = (
      (e = this.getAttribute("bounds")
        ? Gv(this, `#${this.getAttribute("bounds")}`)
        : this.parentElement) != null
        ? e
        : this
    ).getBoundingClientRect(),
    r = this.range.getBoundingClientRect(),
    i = n.offsetWidth,
    a = -(r.left - s.left - i / 2),
    o = s.right - r.left - i / 2;
  return { box: { width: i, min: a, max: o }, bounds: s, range: r };
};
Hw = new WeakSet();
UP = function (n, e) {
  let t = `${e * 100}%`;
  const { width: s, min: r, max: i } = n.box;
  if (!s) return t;
  if (
    (Number.isNaN(r) ||
      (t = `max(${`calc(1 / var(--_range-width) * 100 * ${r}% + var(--media-box-padding-left))`}, ${t})`),
    !Number.isNaN(i))
  ) {
    const o = `calc(1 / var(--_range-width) * 100 * ${i}% - var(--media-box-padding-right))`;
    t = `min(${t}, ${o})`;
  }
  return t;
};
Vw = new WeakSet();
$P = function (n, e) {
  const { width: t, min: s, max: r } = n.box,
    i = e * n.range.width;
  if (i < s + Hs(this, cv)) {
    const a = n.range.left - n.bounds.left - Hs(this, cv);
    return `${i - t / 2 + a}px`;
  }
  if (i > r - Hs(this, uv)) {
    const a = n.bounds.right - n.range.right - Hs(this, uv);
    return `${i + t / 2 - a - n.range.width}px`;
  }
  return 0;
};
HC = new WeakSet();
QK = function (n) {
  const e = [...Hs(this, Uw)].some((h) => n.composedPath().includes(h));
  if (!this.dragging && (e || !n.composedPath().includes(this))) {
    Rr(this, dv, zw).call(this, null);
    return;
  }
  const t = this.mediaSeekableEnd;
  if (!t) return;
  const s = Ns(this.shadowRoot, "#preview-rail"),
    r = Ns(this.shadowRoot, '[part~="preview-box"]'),
    i = Rr(this, Bw, FP).call(this, Hs(this, $w));
  let a = (n.clientX - i.range.left) / i.range.width;
  a = Math.max(0, Math.min(1, a));
  const o = Rr(this, Hw, UP).call(this, i, a),
    l = Rr(this, Vw, $P).call(this, i, a);
  (s.style.transform = `translateX(${o})`),
    s.style.setProperty("--_range-width", `${i.range.width}`),
    r.style.setProperty("--_box-shift", `${l}`),
    r.style.setProperty("--_box-width", `${i.box.width}px`);
  const c = Math.round(Hs(this, fg)) - Math.round(a * t);
  (Math.abs(c) < 1 && a > 0.01 && a < 0.99) ||
    (lo(this, fg, a * t), Rr(this, dv, zw).call(this, Hs(this, fg)));
};
dv = new WeakSet();
zw = function (n) {
  this.dispatchEvent(
    new Ie.CustomEvent(bt.MEDIA_PREVIEW_REQUEST, {
      composed: !0,
      bubbles: !0,
      detail: n,
    })
  );
};
VC = new WeakSet();
ZK = function () {
  Hs(this, Gu).stop();
  const n = JK(this);
  this.dispatchEvent(
    new Ie.CustomEvent(bt.MEDIA_SEEK_REQUEST, {
      composed: !0,
      bubbles: !0,
      detail: n,
    })
  );
};
BP.shadowRootOptions = { mode: "open" };
BP.getTemplateHTML = xAe;
Ie.customElements.get("media-time-range") ||
  Ie.customElements.define("media-time-range", BP);
const wAe = 1,
  EAe = (n) => (n.mediaMuted ? 0 : n.mediaVolume),
  SAe = (n) => `${Math.round(n * 100)}%`;
class TAe extends Zf {
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ae.MEDIA_VOLUME,
      ae.MEDIA_MUTED,
      ae.MEDIA_VOLUME_UNAVAILABLE,
    ];
  }
  constructor() {
    super(),
      this.range.addEventListener("input", () => {
        const e = this.range.value,
          t = new Ie.CustomEvent(bt.MEDIA_VOLUME_REQUEST, {
            composed: !0,
            bubbles: !0,
            detail: e,
          });
        this.dispatchEvent(t);
      });
  }
  connectedCallback() {
    super.connectedCallback(),
      this.range.setAttribute("aria-label", Tt("volume"));
  }
  attributeChangedCallback(e, t, s) {
    super.attributeChangedCallback(e, t, s),
      (e === ae.MEDIA_VOLUME || e === ae.MEDIA_MUTED) &&
        ((this.range.valueAsNumber = EAe(this)),
        this.range.setAttribute(
          "aria-valuetext",
          SAe(this.range.valueAsNumber)
        ),
        this.updateBar());
  }
  get mediaVolume() {
    return ps(this, ae.MEDIA_VOLUME, wAe);
  }
  set mediaVolume(e) {
    lr(this, ae.MEDIA_VOLUME, e);
  }
  get mediaMuted() {
    return un(this, ae.MEDIA_MUTED);
  }
  set mediaMuted(e) {
    dn(this, ae.MEDIA_MUTED, e);
  }
  get mediaVolumeUnavailable() {
    return gs(this, ae.MEDIA_VOLUME_UNAVAILABLE);
  }
  set mediaVolumeUnavailable(e) {
    vs(this, ae.MEDIA_VOLUME_UNAVAILABLE, e);
  }
}
Ie.customElements.get("media-volume-range") ||
  Ie.customElements.define("media-volume-range", TAe);
const _Ae = [
    "abort",
    "canplay",
    "canplaythrough",
    "durationchange",
    "emptied",
    "encrypted",
    "ended",
    "error",
    "loadeddata",
    "loadedmetadata",
    "loadstart",
    "pause",
    "play",
    "playing",
    "progress",
    "ratechange",
    "seeked",
    "seeking",
    "stalled",
    "suspend",
    "timeupdate",
    "volumechange",
    "waiting",
    "waitingforkey",
    "resize",
    "enterpictureinpicture",
    "leavepictureinpicture",
    "webkitbeginfullscreen",
    "webkitendfullscreen",
    "webkitpresentationmodechanged",
  ],
  eY = [
    "autopictureinpicture",
    "disablepictureinpicture",
    "disableremoteplayback",
    "autoplay",
    "controls",
    "controlslist",
    "crossorigin",
    "loop",
    "muted",
    "playsinline",
    "poster",
    "preload",
    "src",
  ];
function AAe(n) {
  return `
    <style>
      :host {
        display: inline-flex;
        line-height: 0;
        flex-direction: column;
        justify-content: end;
      }

      audio {
        width: 100%;
      }
    </style>
    <slot name="media">
      <audio${nY(n)}></audio>
    </slot>
    <slot></slot>
  `;
}
function RAe(n) {
  return `
    <style>
      :host {
        display: inline-block;
        line-height: 0;
      }

      video {
        max-width: 100%;
        max-height: 100%;
        min-width: 100%;
        min-height: 100%;
        object-fit: var(--media-object-fit, contain);
        object-position: var(--media-object-position, 50% 50%);
      }

      video::-webkit-media-text-track-container {
        transform: var(--media-webkit-text-track-transform);
        transition: var(--media-webkit-text-track-transition);
      }
    </style>
    <slot name="media">
      <video${nY(n)}></video>
    </slot>
    <slot></slot>
  `;
}
function tY(n, { tag: e, is: t }) {
  const s = globalThis.document?.createElement?.(e, { is: t }),
    r = s ? kAe(s) : [];
  return class zC extends n {
    static getTemplateHTML = e.endsWith("audio") ? AAe : RAe;
    static shadowRootOptions = { mode: "open" };
    static Events = _Ae;
    static #e = !1;
    static get observedAttributes() {
      return zC.#t(), [...(s?.constructor?.observedAttributes ?? []), ...eY];
    }
    static #t() {
      if (this.#e) return;
      this.#e = !0;
      const a = new Set(this.observedAttributes);
      a.delete("muted");
      for (const o of r)
        if (!(o in this.prototype))
          if (typeof s[o] == "function")
            this.prototype[o] = function (...l) {
              return (
                this.#i(),
                this.call
                  ? this.call(o, ...l)
                  : this.nativeEl?.[o]?.apply(this.nativeEl, l)
              );
            };
          else {
            const l = {
              get() {
                this.#i();
                const c = o.toLowerCase();
                if (a.has(c)) {
                  const h = this.getAttribute(c);
                  return h === null ? !1 : h === "" ? !0 : h;
                }
                return this.get?.(o) ?? this.nativeEl?.[o];
              },
            };
            o !== o.toUpperCase() &&
              (l.set = function (c) {
                this.#i();
                const h = o.toLowerCase();
                if (a.has(h)) {
                  c === !0 || c === !1 || c == null
                    ? this.toggleAttribute(h, !!c)
                    : this.setAttribute(h, c);
                  return;
                }
                if (this.set) {
                  this.set(o, c);
                  return;
                }
                this.nativeEl && (this.nativeEl[o] = c);
              }),
              Object.defineProperty(this.prototype, o, l);
          }
    }
    #n = !1;
    #s = null;
    #r = new Map();
    #o;
    get;
    set;
    call;
    get nativeEl() {
      return (
        this.#i(),
        this.#s ??
          this.querySelector(":scope > [slot=media]") ??
          this.querySelector(e) ??
          this.shadowRoot?.querySelector(e) ??
          null
      );
    }
    set nativeEl(a) {
      this.#s = a;
    }
    get defaultMuted() {
      return this.hasAttribute("muted");
    }
    set defaultMuted(a) {
      this.toggleAttribute("muted", a);
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(a) {
      this.setAttribute("src", `${a}`);
    }
    get preload() {
      return this.getAttribute("preload") ?? this.nativeEl?.preload;
    }
    set preload(a) {
      this.setAttribute("preload", `${a}`);
    }
    #i() {
      this.#n || ((this.#n = !0), this.init());
    }
    init() {
      if (!this.shadowRoot) {
        this.attachShadow({ mode: "open" });
        const a = CAe(this.attributes);
        t && (a.is = t),
          e && (a.part = e),
          (this.shadowRoot.innerHTML = this.constructor.getTemplateHTML(a));
      }
      this.nativeEl.muted = this.hasAttribute("muted");
      for (const a of r) this.#u(a);
      (this.#o = new MutationObserver(this.#h.bind(this))),
        this.shadowRoot.addEventListener("slotchange", () => this.#a()),
        this.#a();
      for (const a of this.constructor.Events)
        this.shadowRoot.addEventListener(a, this, !0);
    }
    handleEvent(a) {
      a.target === this.nativeEl &&
        this.dispatchEvent(new CustomEvent(a.type, { detail: a.detail }));
    }
    #a() {
      const a = new Map(this.#r);
      this.shadowRoot
        ?.querySelector("slot:not([name])")
        ?.assignedElements({ flatten: !0 })
        .filter((c) => ["track", "source"].includes(c.localName))
        .forEach((c) => {
          a.delete(c);
          let h = this.#r.get(c);
          h ||
            ((h = c.cloneNode()),
            this.#r.set(c, h),
            this.#o?.observe(c, { attributes: !0 })),
            this.nativeEl?.append(h),
            this.#l(h);
        }),
        a.forEach((c, h) => {
          c.remove(), this.#r.delete(h);
        });
    }
    #h(a) {
      for (const o of a)
        if (o.type === "attributes") {
          const { target: l, attributeName: c } = o,
            h = this.#r.get(l);
          h && c && (h.setAttribute(c, l.getAttribute(c) ?? ""), this.#l(h));
        }
    }
    #l(a) {
      a &&
        a.localName === "track" &&
        a.default &&
        (a.kind === "chapters" || a.kind === "metadata") &&
        a.track.mode === "disabled" &&
        (a.track.mode = "hidden");
    }
    #u(a) {
      if (Object.prototype.hasOwnProperty.call(this, a)) {
        const o = this[a];
        delete this[a], (this[a] = o);
      }
    }
    attributeChangedCallback(a, o, l) {
      this.#i(), this.#c(a, o, l);
    }
    #c(a, o, l) {
      ["id", "class"].includes(a) ||
        (!zC.observedAttributes.includes(a) &&
          this.constructor.observedAttributes.includes(a)) ||
        (l === null
          ? this.nativeEl?.removeAttribute(a)
          : this.nativeEl?.getAttribute(a) !== l &&
            this.nativeEl?.setAttribute(a, l));
    }
    connectedCallback() {
      this.#i();
    }
  };
}
function kAe(n) {
  const e = [];
  for (
    let t = Object.getPrototypeOf(n);
    t && t !== HTMLElement.prototype;
    t = Object.getPrototypeOf(t)
  ) {
    const s = Object.getOwnPropertyNames(t);
    e.push(...s);
  }
  return e;
}
function nY(n) {
  let e = "";
  for (const t in n) {
    if (!eY.includes(t)) continue;
    const s = n[t];
    s === "" ? (e += ` ${t}`) : (e += ` ${t}="${s}"`);
  }
  return e;
}
function CAe(n) {
  const e = {};
  for (const t of n) e[t.name] = t.value;
  return e;
}
const IAe = tY(globalThis.HTMLElement ?? class {}, { tag: "video" });
tY(globalThis.HTMLElement ?? class {}, { tag: "audio" });
class uS extends Event {
  track;
  constructor(e, t) {
    super(e), (this.track = t.track);
  }
}
const GC = new WeakMap();
function it(n) {
  return GC.get(n) ?? LAe(n, {});
}
function LAe(n, e) {
  let t = GC.get(n);
  return t || GC.set(n, (t = {})), Object.assign(t, e);
}
function qC(n, e) {
  const t = n.videoTracks;
  (it(e).media = n), it(e).renditionSet || (it(e).renditionSet = new Set());
  const s = it(t).trackSet;
  s.add(e);
  const r = s.size - 1;
  r in KC.prototype ||
    Object.defineProperty(KC.prototype, r, {
      get() {
        return [...it(this).trackSet][r];
      },
    }),
    queueMicrotask(() => {
      t.dispatchEvent(new uS("addtrack", { track: e }));
    });
}
function WC(n) {
  const e = it(n).media?.videoTracks;
  if (!e) return;
  it(e).trackSet.delete(n),
    queueMicrotask(() => {
      e.dispatchEvent(new uS("removetrack", { track: n }));
    });
}
function DAe(n) {
  const e = it(n).media.videoTracks ?? [];
  let t = !1;
  for (const s of e) s !== n && ((s.selected = !1), (t = !0));
  if (t) {
    if (it(e).changeRequested) return;
    (it(e).changeRequested = !0),
      queueMicrotask(() => {
        delete it(e).changeRequested, e.dispatchEvent(new Event("change"));
      });
  }
}
class KC extends EventTarget {
  #e;
  #t;
  #n;
  constructor() {
    super(), (it(this).trackSet = new Set());
  }
  get #s() {
    return it(this).trackSet;
  }
  [Symbol.iterator]() {
    return this.#s.values();
  }
  get length() {
    return this.#s.size;
  }
  getTrackById(e) {
    return [...this.#s].find((t) => t.id === e) ?? null;
  }
  get selectedIndex() {
    return [...this.#s].findIndex((e) => e.selected);
  }
  get onaddtrack() {
    return this.#e;
  }
  set onaddtrack(e) {
    this.#e &&
      (this.removeEventListener("addtrack", this.#e), (this.#e = void 0)),
      typeof e == "function" &&
        ((this.#e = e), this.addEventListener("addtrack", e));
  }
  get onremovetrack() {
    return this.#t;
  }
  set onremovetrack(e) {
    this.#t &&
      (this.removeEventListener("removetrack", this.#t), (this.#t = void 0)),
      typeof e == "function" &&
        ((this.#t = e), this.addEventListener("removetrack", e));
  }
  get onchange() {
    return this.#n;
  }
  set onchange(e) {
    this.#n &&
      (this.removeEventListener("change", this.#n), (this.#n = void 0)),
      typeof e == "function" &&
        ((this.#n = e), this.addEventListener("change", e));
  }
}
class dS extends Event {
  rendition;
  constructor(e, t) {
    super(e), (this.rendition = t.rendition);
  }
}
function PAe(n, e) {
  const t = it(n).media.videoRenditions;
  (it(e).media = it(n).media), (it(e).track = n);
  const s = it(n).renditionSet;
  s.add(e);
  const r = s.size - 1;
  r in YC.prototype ||
    Object.defineProperty(YC.prototype, r, {
      get() {
        return jh(this)[r];
      },
    }),
    queueMicrotask(() => {
      n.selected && t.dispatchEvent(new dS("addrendition", { rendition: e }));
    });
}
function MAe(n) {
  const e = it(n).media.videoRenditions,
    t = it(n).track;
  it(t).renditionSet.delete(n),
    queueMicrotask(() => {
      it(n).track.selected &&
        e.dispatchEvent(new dS("removerendition", { rendition: n }));
    });
}
function NAe(n) {
  const e = it(n).media.videoRenditions;
  !e ||
    it(e).changeRequested ||
    ((it(e).changeRequested = !0),
    queueMicrotask(() => {
      delete it(e).changeRequested,
        it(n).track.selected && e.dispatchEvent(new Event("change"));
    }));
}
function jh(n) {
  return [...it(n).media.videoTracks]
    .filter((t) => t.selected)
    .flatMap((t) => [...it(t).renditionSet]);
}
class YC extends EventTarget {
  #e;
  #t;
  #n;
  [Symbol.iterator]() {
    return jh(this).values();
  }
  get length() {
    return jh(this).length;
  }
  getRenditionById(e) {
    return jh(this).find((t) => `${t.id}` == `${e}`) ?? null;
  }
  get selectedIndex() {
    return jh(this).findIndex((e) => e.selected);
  }
  set selectedIndex(e) {
    for (const [t, s] of jh(this).entries()) s.selected = t === e;
  }
  get onaddrendition() {
    return this.#e;
  }
  set onaddrendition(e) {
    this.#e &&
      (this.removeEventListener("addrendition", this.#e), (this.#e = void 0)),
      typeof e == "function" &&
        ((this.#e = e), this.addEventListener("addrendition", e));
  }
  get onremoverendition() {
    return this.#t;
  }
  set onremoverendition(e) {
    this.#t &&
      (this.removeEventListener("removerendition", this.#t),
      (this.#t = void 0)),
      typeof e == "function" &&
        ((this.#t = e), this.addEventListener("removerendition", e));
  }
  get onchange() {
    return this.#n;
  }
  set onchange(e) {
    this.#n &&
      (this.removeEventListener("change", this.#n), (this.#n = void 0)),
      typeof e == "function" &&
        ((this.#n = e), this.addEventListener("change", e));
  }
}
class OAe {
  src;
  id;
  width;
  height;
  bitrate;
  frameRate;
  codec;
  #e = !1;
  get selected() {
    return this.#e;
  }
  set selected(e) {
    this.#e !== e && ((this.#e = e), NAe(this));
  }
}
class sY {
  id;
  kind;
  label = "";
  language = "";
  sourceBuffer;
  #e = !1;
  addRendition(e, t, s, r, i, a) {
    const o = new OAe();
    return (
      (o.src = e),
      (o.width = t),
      (o.height = s),
      (o.frameRate = a),
      (o.bitrate = i),
      (o.codec = r),
      PAe(this, o),
      o
    );
  }
  removeRendition(e) {
    MAe(e);
  }
  get selected() {
    return this.#e;
  }
  set selected(e) {
    this.#e !== e && ((this.#e = e), e === !0 && DAe(this));
  }
}
function jAe(n, e) {
  const t = it(n).media.audioRenditions;
  (it(e).media = it(n).media), (it(e).track = n);
  const s = it(n).renditionSet;
  s.add(e);
  const r = s.size - 1;
  r in XC.prototype ||
    Object.defineProperty(XC.prototype, r, {
      get() {
        return Fh(this)[r];
      },
    }),
    queueMicrotask(() => {
      n.enabled && t.dispatchEvent(new dS("addrendition", { rendition: e }));
    });
}
function FAe(n) {
  const e = it(n).media.audioRenditions,
    t = it(n).track;
  it(t).renditionSet.delete(n),
    queueMicrotask(() => {
      it(n).track.enabled &&
        e.dispatchEvent(new dS("removerendition", { rendition: n }));
    });
}
function UAe(n) {
  const e = it(n).media.audioRenditions;
  !e ||
    it(e).changeRequested ||
    ((it(e).changeRequested = !0),
    queueMicrotask(() => {
      delete it(e).changeRequested,
        it(n).track.enabled && e.dispatchEvent(new Event("change"));
    }));
}
function Fh(n) {
  return [...it(n).media.audioTracks]
    .filter((t) => t.enabled)
    .flatMap((t) => [...it(t).renditionSet]);
}
class XC extends EventTarget {
  #e;
  #t;
  #n;
  [Symbol.iterator]() {
    return Fh(this).values();
  }
  get length() {
    return Fh(this).length;
  }
  getRenditionById(e) {
    return Fh(this).find((t) => `${t.id}` == `${e}`) ?? null;
  }
  get selectedIndex() {
    return Fh(this).findIndex((e) => e.selected);
  }
  set selectedIndex(e) {
    for (const [t, s] of Fh(this).entries()) s.selected = t === e;
  }
  get onaddrendition() {
    return this.#e;
  }
  set onaddrendition(e) {
    this.#e &&
      (this.removeEventListener("addrendition", this.#e), (this.#e = void 0)),
      typeof e == "function" &&
        ((this.#e = e), this.addEventListener("addrendition", e));
  }
  get onremoverendition() {
    return this.#t;
  }
  set onremoverendition(e) {
    this.#t &&
      (this.removeEventListener("removerendition", this.#t),
      (this.#t = void 0)),
      typeof e == "function" &&
        ((this.#t = e), this.addEventListener("removerendition", e));
  }
  get onchange() {
    return this.#n;
  }
  set onchange(e) {
    this.#n &&
      (this.removeEventListener("change", this.#n), (this.#n = void 0)),
      typeof e == "function" &&
        ((this.#n = e), this.addEventListener("change", e));
  }
}
class $Ae {
  src;
  id;
  bitrate;
  codec;
  #e = !1;
  get selected() {
    return this.#e;
  }
  set selected(e) {
    this.#e !== e && ((this.#e = e), UAe(this));
  }
}
function QC(n, e) {
  const t = n.audioTracks;
  (it(e).media = n), it(e).renditionSet || (it(e).renditionSet = new Set());
  const s = it(t).trackSet;
  s.add(e);
  const r = s.size - 1;
  r in JC.prototype ||
    Object.defineProperty(JC.prototype, r, {
      get() {
        return [...it(this).trackSet][r];
      },
    }),
    queueMicrotask(() => {
      t.dispatchEvent(new uS("addtrack", { track: e }));
    });
}
function ZC(n) {
  const e = it(n).media?.audioTracks;
  if (!e) return;
  it(e).trackSet.delete(n),
    queueMicrotask(() => {
      e.dispatchEvent(new uS("removetrack", { track: n }));
    });
}
function BAe(n) {
  const e = it(n).media.audioTracks;
  !e ||
    it(e).changeRequested ||
    ((it(e).changeRequested = !0),
    queueMicrotask(() => {
      delete it(e).changeRequested, e.dispatchEvent(new Event("change"));
    }));
}
class JC extends EventTarget {
  #e;
  #t;
  #n;
  constructor() {
    super(), (it(this).trackSet = new Set());
  }
  get #s() {
    return it(this).trackSet;
  }
  [Symbol.iterator]() {
    return this.#s.values();
  }
  get length() {
    return this.#s.size;
  }
  getTrackById(e) {
    return [...this.#s].find((t) => t.id === e) ?? null;
  }
  get onaddtrack() {
    return this.#e;
  }
  set onaddtrack(e) {
    this.#e &&
      (this.removeEventListener("addtrack", this.#e), (this.#e = void 0)),
      typeof e == "function" &&
        ((this.#e = e), this.addEventListener("addtrack", e));
  }
  get onremovetrack() {
    return this.#t;
  }
  set onremovetrack(e) {
    this.#t &&
      (this.removeEventListener("removetrack", this.#t), (this.#t = void 0)),
      typeof e == "function" &&
        ((this.#t = e), this.addEventListener("removetrack", e));
  }
  get onchange() {
    return this.#n;
  }
  set onchange(e) {
    this.#n &&
      (this.removeEventListener("change", this.#n), (this.#n = void 0)),
      typeof e == "function" &&
        ((this.#n = e), this.addEventListener("change", e));
  }
}
class rY {
  id;
  kind;
  label = "";
  language = "";
  sourceBuffer;
  #e = !1;
  addRendition(e, t, s) {
    const r = new $Ae();
    return (r.src = e), (r.codec = t), (r.bitrate = s), jAe(this, r), r;
  }
  removeRendition(e) {
    FAe(e);
  }
  get enabled() {
    return this.#e;
  }
  set enabled(e) {
    this.#e !== e && ((this.#e = e), BAe(this));
  }
}
const hB = Gw(globalThis.HTMLMediaElement, "video"),
  fB = Gw(globalThis.HTMLMediaElement, "audio");
function HAe(n) {
  if (!n?.prototype) return n;
  const e = Gw(n, "video");
  (!e || `${e}`.includes("[native code]")) &&
    Object.defineProperty(n.prototype, "videoTracks", {
      get() {
        return VAe(this);
      },
    });
  const t = Gw(n, "audio");
  (!t || `${t}`.includes("[native code]")) &&
    Object.defineProperty(n.prototype, "audioTracks", {
      get() {
        return zAe(this);
      },
    }),
    "addVideoTrack" in n.prototype ||
      (n.prototype.addVideoTrack = function (i, a = "", o = "") {
        const l = new sY();
        return (l.kind = i), (l.label = a), (l.language = o), qC(this, l), l;
      }),
    "removeVideoTrack" in n.prototype || (n.prototype.removeVideoTrack = WC),
    "addAudioTrack" in n.prototype ||
      (n.prototype.addAudioTrack = function (i, a = "", o = "") {
        const l = new rY();
        return (l.kind = i), (l.label = a), (l.language = o), QC(this, l), l;
      }),
    "removeAudioTrack" in n.prototype || (n.prototype.removeAudioTrack = ZC),
    "videoRenditions" in n.prototype ||
      Object.defineProperty(n.prototype, "videoRenditions", {
        get() {
          return s(this);
        },
      });
  const s = (i) => {
    let a = it(i).videoRenditions;
    return (
      a || ((a = new YC()), (it(a).media = i), (it(i).videoRenditions = a)), a
    );
  };
  "audioRenditions" in n.prototype ||
    Object.defineProperty(n.prototype, "audioRenditions", {
      get() {
        return r(this);
      },
    });
  const r = (i) => {
    let a = it(i).audioRenditions;
    return (
      a || ((a = new XC()), (it(a).media = i), (it(i).audioRenditions = a)), a
    );
  };
  return n;
}
function Gw(n, e) {
  if (n?.prototype)
    return Object.getOwnPropertyDescriptor(n.prototype, `${e}Tracks`)?.get;
}
function VAe(n) {
  let e = it(n).videoTracks;
  if (!e && ((e = new KC()), (it(n).videoTracks = e), hB)) {
    const t = hB.call(n.nativeEl ?? n);
    for (const s of t) qC(n, s);
    t.addEventListener("change", () => {
      e.dispatchEvent(new Event("change"));
    }),
      t.addEventListener("addtrack", (s) => {
        if ([...e].some((r) => r instanceof sY)) {
          for (const r of t) WC(r);
          return;
        }
        qC(n, s.track);
      }),
      t.addEventListener("removetrack", (s) => {
        WC(s.track);
      });
  }
  return e;
}
function zAe(n) {
  let e = it(n).audioTracks;
  if (!e && ((e = new JC()), (it(n).audioTracks = e), fB)) {
    const t = fB.call(n.nativeEl ?? n);
    for (const s of t) QC(n, s);
    t.addEventListener("change", () => {
      e.dispatchEvent(new Event("change"));
    }),
      t.addEventListener("addtrack", (s) => {
        if ([...e].some((r) => r instanceof rY)) {
          for (const r of t) ZC(r);
          return;
        }
        QC(n, s.track);
      }),
      t.addEventListener("removetrack", (s) => {
        ZC(s.track);
      });
  }
  return e;
}
const Qe =
    Number.isFinite ||
    function (n) {
      return typeof n == "number" && isFinite(n);
    },
  GAe =
    Number.isSafeInteger ||
    function (n) {
      return typeof n == "number" && Math.abs(n) <= qAe;
    },
  qAe = Number.MAX_SAFE_INTEGER || 9007199254740991;
let gt = (function (n) {
    return (
      (n.NETWORK_ERROR = "networkError"),
      (n.MEDIA_ERROR = "mediaError"),
      (n.KEY_SYSTEM_ERROR = "keySystemError"),
      (n.MUX_ERROR = "muxError"),
      (n.OTHER_ERROR = "otherError"),
      n
    );
  })({}),
  we = (function (n) {
    return (
      (n.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys"),
      (n.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess"),
      (n.KEY_SYSTEM_NO_SESSION = "keySystemNoSession"),
      (n.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense"),
      (n.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed"),
      (n.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED =
        "keySystemServerCertificateRequestFailed"),
      (n.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED =
        "keySystemServerCertificateUpdateFailed"),
      (n.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed"),
      (n.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED =
        "keySystemStatusOutputRestricted"),
      (n.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError"),
      (n.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR =
        "keySystemDestroyMediaKeysError"),
      (n.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR =
        "keySystemDestroyCloseSessionError"),
      (n.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR =
        "keySystemDestroyRemoveSessionError"),
      (n.MANIFEST_LOAD_ERROR = "manifestLoadError"),
      (n.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut"),
      (n.MANIFEST_PARSING_ERROR = "manifestParsingError"),
      (n.MANIFEST_INCOMPATIBLE_CODECS_ERROR =
        "manifestIncompatibleCodecsError"),
      (n.LEVEL_EMPTY_ERROR = "levelEmptyError"),
      (n.LEVEL_LOAD_ERROR = "levelLoadError"),
      (n.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut"),
      (n.LEVEL_PARSING_ERROR = "levelParsingError"),
      (n.LEVEL_SWITCH_ERROR = "levelSwitchError"),
      (n.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError"),
      (n.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut"),
      (n.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError"),
      (n.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut"),
      (n.FRAG_LOAD_ERROR = "fragLoadError"),
      (n.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut"),
      (n.FRAG_DECRYPT_ERROR = "fragDecryptError"),
      (n.FRAG_PARSING_ERROR = "fragParsingError"),
      (n.FRAG_GAP = "fragGap"),
      (n.REMUX_ALLOC_ERROR = "remuxAllocError"),
      (n.KEY_LOAD_ERROR = "keyLoadError"),
      (n.KEY_LOAD_TIMEOUT = "keyLoadTimeOut"),
      (n.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError"),
      (n.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError"),
      (n.BUFFER_APPEND_ERROR = "bufferAppendError"),
      (n.BUFFER_APPENDING_ERROR = "bufferAppendingError"),
      (n.BUFFER_STALLED_ERROR = "bufferStalledError"),
      (n.BUFFER_FULL_ERROR = "bufferFullError"),
      (n.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole"),
      (n.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall"),
      (n.ASSET_LIST_LOAD_ERROR = "assetListLoadError"),
      (n.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout"),
      (n.ASSET_LIST_PARSING_ERROR = "assetListParsingError"),
      (n.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError"),
      (n.INTERNAL_EXCEPTION = "internalException"),
      (n.INTERNAL_ABORTED = "aborted"),
      (n.ATTACH_MEDIA_ERROR = "attachMediaError"),
      (n.UNKNOWN = "unknown"),
      n
    );
  })({}),
  $ = (function (n) {
    return (
      (n.MEDIA_ATTACHING = "hlsMediaAttaching"),
      (n.MEDIA_ATTACHED = "hlsMediaAttached"),
      (n.MEDIA_DETACHING = "hlsMediaDetaching"),
      (n.MEDIA_DETACHED = "hlsMediaDetached"),
      (n.MEDIA_ENDED = "hlsMediaEnded"),
      (n.STALL_RESOLVED = "hlsStallResolved"),
      (n.BUFFER_RESET = "hlsBufferReset"),
      (n.BUFFER_CODECS = "hlsBufferCodecs"),
      (n.BUFFER_CREATED = "hlsBufferCreated"),
      (n.BUFFER_APPENDING = "hlsBufferAppending"),
      (n.BUFFER_APPENDED = "hlsBufferAppended"),
      (n.BUFFER_EOS = "hlsBufferEos"),
      (n.BUFFERED_TO_END = "hlsBufferedToEnd"),
      (n.BUFFER_FLUSHING = "hlsBufferFlushing"),
      (n.BUFFER_FLUSHED = "hlsBufferFlushed"),
      (n.MANIFEST_LOADING = "hlsManifestLoading"),
      (n.MANIFEST_LOADED = "hlsManifestLoaded"),
      (n.MANIFEST_PARSED = "hlsManifestParsed"),
      (n.LEVEL_SWITCHING = "hlsLevelSwitching"),
      (n.LEVEL_SWITCHED = "hlsLevelSwitched"),
      (n.LEVEL_LOADING = "hlsLevelLoading"),
      (n.LEVEL_LOADED = "hlsLevelLoaded"),
      (n.LEVEL_UPDATED = "hlsLevelUpdated"),
      (n.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated"),
      (n.LEVELS_UPDATED = "hlsLevelsUpdated"),
      (n.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated"),
      (n.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching"),
      (n.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched"),
      (n.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading"),
      (n.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded"),
      (n.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated"),
      (n.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated"),
      (n.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared"),
      (n.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch"),
      (n.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading"),
      (n.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded"),
      (n.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated"),
      (n.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed"),
      (n.CUES_PARSED = "hlsCuesParsed"),
      (n.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound"),
      (n.INIT_PTS_FOUND = "hlsInitPtsFound"),
      (n.FRAG_LOADING = "hlsFragLoading"),
      (n.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted"),
      (n.FRAG_LOADED = "hlsFragLoaded"),
      (n.FRAG_DECRYPTED = "hlsFragDecrypted"),
      (n.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment"),
      (n.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata"),
      (n.FRAG_PARSING_METADATA = "hlsFragParsingMetadata"),
      (n.FRAG_PARSED = "hlsFragParsed"),
      (n.FRAG_BUFFERED = "hlsFragBuffered"),
      (n.FRAG_CHANGED = "hlsFragChanged"),
      (n.FPS_DROP = "hlsFpsDrop"),
      (n.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping"),
      (n.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated"),
      (n.ERROR = "hlsError"),
      (n.DESTROYING = "hlsDestroying"),
      (n.KEY_LOADING = "hlsKeyLoading"),
      (n.KEY_LOADED = "hlsKeyLoaded"),
      (n.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached"),
      (n.BACK_BUFFER_REACHED = "hlsBackBufferReached"),
      (n.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded"),
      (n.ASSET_LIST_LOADING = "hlsAssetListLoading"),
      (n.ASSET_LIST_LOADED = "hlsAssetListLoaded"),
      (n.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated"),
      (n.INTERSTITIALS_BUFFERED_TO_BOUNDARY =
        "hlsInterstitialsBufferedToBoundary"),
      (n.INTERSTITIAL_ASSET_PLAYER_CREATED =
        "hlsInterstitialAssetPlayerCreated"),
      (n.INTERSTITIAL_STARTED = "hlsInterstitialStarted"),
      (n.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted"),
      (n.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded"),
      (n.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError"),
      (n.INTERSTITIAL_ENDED = "hlsInterstitialEnded"),
      (n.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed"),
      (n.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached"),
      (n.EVENT_CUE_ENTER = "hlsEventCueEnter"),
      n
    );
  })({});
var en = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack",
  },
  lt = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" };
class yh {
  constructor(e, t = 0, s = 0) {
    (this.halfLife = void 0),
      (this.alpha_ = void 0),
      (this.estimate_ = void 0),
      (this.totalWeight_ = void 0),
      (this.halfLife = e),
      (this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0),
      (this.estimate_ = t),
      (this.totalWeight_ = s);
  }
  sample(e, t) {
    const s = Math.pow(this.alpha_, e);
    (this.estimate_ = t * (1 - s) + s * this.estimate_),
      (this.totalWeight_ += e);
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e) return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class WAe {
  constructor(e, t, s, r = 100) {
    (this.defaultEstimate_ = void 0),
      (this.minWeight_ = void 0),
      (this.minDelayMs_ = void 0),
      (this.slow_ = void 0),
      (this.fast_ = void 0),
      (this.defaultTTFB_ = void 0),
      (this.ttfb_ = void 0),
      (this.defaultEstimate_ = s),
      (this.minWeight_ = 0.001),
      (this.minDelayMs_ = 50),
      (this.slow_ = new yh(e)),
      (this.fast_ = new yh(t)),
      (this.defaultTTFB_ = r),
      (this.ttfb_ = new yh(e));
  }
  update(e, t) {
    const { slow_: s, fast_: r, ttfb_: i } = this;
    s.halfLife !== e &&
      (this.slow_ = new yh(e, s.getEstimate(), s.getTotalWeight())),
      r.halfLife !== t &&
        (this.fast_ = new yh(t, r.getEstimate(), r.getTotalWeight())),
      i.halfLife !== e &&
        (this.ttfb_ = new yh(e, i.getEstimate(), i.getTotalWeight()));
  }
  sample(e, t) {
    e = Math.max(e, this.minDelayMs_);
    const s = 8 * t,
      r = e / 1e3,
      i = s / r;
    this.fast_.sample(r, i), this.slow_.sample(r, i);
  }
  sampleTTFB(e) {
    const t = e / 1e3,
      s = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
    this.ttfb_.sample(s, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate()
      ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate())
      : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_
      ? this.ttfb_.getEstimate()
      : this.defaultTTFB_;
  }
  get defaultEstimate() {
    return this.defaultEstimate_;
  }
  destroy() {}
}
function KAe(n, e, t) {
  return (
    (e = XAe(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function Tn() {
  return (
    (Tn = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var s in t) ({}).hasOwnProperty.call(t, s) && (n[s] = t[s]);
          }
          return n;
        }),
    Tn.apply(null, arguments)
  );
}
function mB(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    e &&
      (s = s.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, s);
  }
  return t;
}
function In(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? mB(Object(t), !0).forEach(function (s) {
          KAe(n, s, t[s]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : mB(Object(t)).forEach(function (s) {
          Object.defineProperty(n, s, Object.getOwnPropertyDescriptor(t, s));
        });
  }
  return n;
}
function YAe(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var s = t.call(n, e);
    if (typeof s != "object") return s;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function XAe(n) {
  var e = YAe(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
class za {
  constructor(e, t) {
    (this.trace = void 0),
      (this.debug = void 0),
      (this.log = void 0),
      (this.warn = void 0),
      (this.info = void 0),
      (this.error = void 0);
    const s = `[${e}]:`;
    (this.trace = xc),
      (this.debug = t.debug.bind(null, s)),
      (this.log = t.log.bind(null, s)),
      (this.warn = t.warn.bind(null, s)),
      (this.info = t.info.bind(null, s)),
      (this.error = t.error.bind(null, s));
  }
}
const xc = function () {},
  QAe = { trace: xc, debug: xc, log: xc, warn: xc, info: xc, error: xc };
function eI() {
  return Tn({}, QAe);
}
function ZAe(n, e) {
  const t = self.console[n];
  return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${n}] >`) : xc;
}
function pB(n, e, t) {
  return e[n] ? e[n].bind(e) : ZAe(n, t);
}
const tI = eI();
function JAe(n, e, t) {
  const s = eI();
  if ((typeof console == "object" && n === !0) || typeof n == "object") {
    const r = ["debug", "log", "info", "warn", "error"];
    r.forEach((i) => {
      s[i] = pB(i, n, t);
    });
    try {
      s.log(`Debug logs enabled for "${e}" in hls.js version 1.6.7`);
    } catch {
      return eI();
    }
    r.forEach((i) => {
      tI[i] = pB(i, n);
    });
  } else Tn(tI, s);
  return s;
}
const pn = tI;
function Bc(n = !0) {
  return typeof self > "u"
    ? void 0
    : ((n || !self.MediaSource) && self.ManagedMediaSource) ||
        self.MediaSource ||
        self.WebKitMediaSource;
}
function eRe(n) {
  return typeof self < "u" && n === self.ManagedMediaSource;
}
function iY(n, e) {
  const t = Object.keys(n),
    s = Object.keys(e),
    r = t.length,
    i = s.length;
  return !r || !i || (r === i && !t.some((a) => s.indexOf(a) === -1));
}
function ki(n, e = !1) {
  if (typeof TextDecoder < "u") {
    const c = new TextDecoder("utf-8").decode(n);
    if (e) {
      const h = c.indexOf("\0");
      return h !== -1 ? c.substring(0, h) : c;
    }
    return c.replace(/\0/g, "");
  }
  const t = n.length;
  let s,
    r,
    i,
    a = "",
    o = 0;
  for (; o < t; ) {
    if (((s = n[o++]), s === 0 && e)) return a;
    if (s === 0 || s === 3) continue;
    switch (s >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(s);
        break;
      case 12:
      case 13:
        (r = n[o++]), (a += String.fromCharCode(((s & 31) << 6) | (r & 63)));
        break;
      case 14:
        (r = n[o++]),
          (i = n[o++]),
          (a += String.fromCharCode(
            ((s & 15) << 12) | ((r & 63) << 6) | ((i & 63) << 0)
          ));
        break;
    }
  }
  return a;
}
const Nu = {
  hexDump: function (n) {
    let e = "";
    for (let t = 0; t < n.length; t++) {
      let s = n[t].toString(16);
      s.length < 2 && (s = "0" + s), (e += s);
    }
    return e;
  },
};
function aY(n) {
  return Uint8Array.from(
    n
      .replace(/^0x/, "")
      .replace(/([\da-fA-F]{2}) ?/g, "0x$1 ")
      .replace(/ +$/, "")
      .split(" ")
  ).buffer;
}
function tRe(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var mA = { exports: {} },
  gB;
function nRe() {
  return (
    gB ||
      ((gB = 1),
      (function (n, e) {
        (function (t) {
          var s =
              /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
            r = /^(?=([^\/?#]*))\1([^]*)$/,
            i = /(?:\/|^)\.(?=\/)/g,
            a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
            o = {
              buildAbsoluteURL: function (l, c, h) {
                if (((h = h || {}), (l = l.trim()), (c = c.trim()), !c)) {
                  if (!h.alwaysNormalize) return l;
                  var m = o.parseURL(l);
                  if (!m) throw new Error("Error trying to parse base URL.");
                  return (
                    (m.path = o.normalizePath(m.path)), o.buildURLFromParts(m)
                  );
                }
                var p = o.parseURL(c);
                if (!p) throw new Error("Error trying to parse relative URL.");
                if (p.scheme)
                  return h.alwaysNormalize
                    ? ((p.path = o.normalizePath(p.path)),
                      o.buildURLFromParts(p))
                    : c;
                var g = o.parseURL(l);
                if (!g) throw new Error("Error trying to parse base URL.");
                if (!g.netLoc && g.path && g.path[0] !== "/") {
                  var y = r.exec(g.path);
                  (g.netLoc = y[1]), (g.path = y[2]);
                }
                g.netLoc && !g.path && (g.path = "/");
                var b = {
                  scheme: g.scheme,
                  netLoc: p.netLoc,
                  path: null,
                  params: p.params,
                  query: p.query,
                  fragment: p.fragment,
                };
                if (!p.netLoc && ((b.netLoc = g.netLoc), p.path[0] !== "/"))
                  if (!p.path)
                    (b.path = g.path),
                      p.params ||
                        ((b.params = g.params), p.query || (b.query = g.query));
                  else {
                    var w = g.path,
                      S = w.substring(0, w.lastIndexOf("/") + 1) + p.path;
                    b.path = o.normalizePath(S);
                  }
                return (
                  b.path === null &&
                    (b.path = h.alwaysNormalize
                      ? o.normalizePath(p.path)
                      : p.path),
                  o.buildURLFromParts(b)
                );
              },
              parseURL: function (l) {
                var c = s.exec(l);
                return c
                  ? {
                      scheme: c[1] || "",
                      netLoc: c[2] || "",
                      path: c[3] || "",
                      params: c[4] || "",
                      query: c[5] || "",
                      fragment: c[6] || "",
                    }
                  : null;
              },
              normalizePath: function (l) {
                for (
                  l = l.split("").reverse().join("").replace(i, "");
                  l.length !== (l = l.replace(a, "")).length;

                );
                return l.split("").reverse().join("");
              },
              buildURLFromParts: function (l) {
                return (
                  l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment
                );
              },
            };
          n.exports = o;
        })();
      })(mA)),
    mA.exports
  );
}
var HP = nRe();
class VP {
  constructor() {
    (this.aborted = !1),
      (this.loaded = 0),
      (this.retry = 0),
      (this.total = 0),
      (this.chunkCount = 0),
      (this.bwEstimate = 0),
      (this.loading = { start: 0, first: 0, end: 0 }),
      (this.parsing = { start: 0, end: 0 }),
      (this.buffering = { start: 0, first: 0, end: 0 });
  }
}
var On = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" };
class oY {
  constructor(e) {
    (this._byteRange = null),
      (this._url = null),
      (this._stats = null),
      (this._streams = null),
      (this.base = void 0),
      (this.relurl = void 0),
      typeof e == "string" && (e = { url: e }),
      (this.base = e),
      rRe(this, "stats");
  }
  setByteRange(e, t) {
    const s = e.split("@", 2);
    let r;
    s.length === 1 ? (r = t?.byteRangeEndOffset || 0) : (r = parseInt(s[1])),
      (this._byteRange = [r, parseInt(s[0]) + r]);
  }
  get baseurl() {
    return this.base.url;
  }
  get byteRange() {
    return this._byteRange === null ? [] : this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get elementaryStreams() {
    return (
      this._streams === null &&
        (this._streams = {
          [On.AUDIO]: null,
          [On.VIDEO]: null,
          [On.AUDIOVIDEO]: null,
        }),
      this._streams
    );
  }
  set elementaryStreams(e) {
    this._streams = e;
  }
  get hasStats() {
    return this._stats !== null;
  }
  get hasStreams() {
    return this._streams !== null;
  }
  get stats() {
    return this._stats === null && (this._stats = new VP()), this._stats;
  }
  set stats(e) {
    this._stats = e;
  }
  get url() {
    return (
      !this._url &&
        this.baseurl &&
        this.relurl &&
        (this._url = HP.buildAbsoluteURL(this.baseurl, this.relurl, {
          alwaysNormalize: !0,
        })),
      this._url || ""
    );
  }
  set url(e) {
    this._url = e;
  }
  clearElementaryStreamInfo() {
    const { elementaryStreams: e } = this;
    (e[On.AUDIO] = null), (e[On.VIDEO] = null), (e[On.AUDIOVIDEO] = null);
  }
}
function Os(n) {
  return n.sn !== "initSegment";
}
class pA extends oY {
  constructor(e, t) {
    super(t),
      (this._decryptdata = null),
      (this._programDateTime = null),
      (this._ref = null),
      (this._bitrate = void 0),
      (this.rawProgramDateTime = null),
      (this.tagList = []),
      (this.duration = 0),
      (this.sn = 0),
      (this.levelkeys = void 0),
      (this.type = void 0),
      (this.loader = null),
      (this.keyLoader = null),
      (this.level = -1),
      (this.cc = 0),
      (this.startPTS = void 0),
      (this.endPTS = void 0),
      (this.startDTS = void 0),
      (this.endDTS = void 0),
      (this.start = 0),
      (this.playlistOffset = 0),
      (this.deltaPTS = void 0),
      (this.maxStartPTS = void 0),
      (this.minEndPTS = void 0),
      (this.data = void 0),
      (this.bitrateTest = !1),
      (this.title = null),
      (this.initSegment = null),
      (this.endList = void 0),
      (this.gap = void 0),
      (this.urlId = 0),
      (this.type = e);
  }
  get byteLength() {
    if (this.hasStats) {
      const e = this.stats.total;
      if (e) return e;
    }
    if (this.byteRange) {
      const e = this.byteRange[0],
        t = this.byteRange[1];
      if (Qe(e) && Qe(t)) return t - e;
    }
    return null;
  }
  get bitrate() {
    return this.byteLength
      ? (this.byteLength * 8) / this.duration
      : this._bitrate
      ? this._bitrate
      : null;
  }
  set bitrate(e) {
    this._bitrate = e;
  }
  get decryptdata() {
    const { levelkeys: e } = this;
    if (!e && !this._decryptdata) return null;
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const t = this.levelkeys.identity;
      if (t) this._decryptdata = t.getDecryptData(this.sn);
      else {
        const s = Object.keys(this.levelkeys);
        if (s.length === 1)
          return (this._decryptdata = this.levelkeys[s[0]].getDecryptData(
            this.sn
          ));
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null) return null;
    const e = Qe(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted) return !0;
    if (this.levelkeys) {
      const t = Object.keys(this.levelkeys),
        s = t.length;
      if (s > 1 || (s === 1 && this.levelkeys[t[0]].encrypted)) return !0;
    }
    return !1;
  }
  get programDateTime() {
    return (
      this._programDateTime === null &&
        this.rawProgramDateTime &&
        (this.programDateTime = Date.parse(this.rawProgramDateTime)),
      this._programDateTime
    );
  }
  set programDateTime(e) {
    if (!Qe(e)) {
      this._programDateTime = this.rawProgramDateTime = null;
      return;
    }
    this._programDateTime = e;
  }
  get ref() {
    return Os(this)
      ? (this._ref ||
          (this._ref = {
            base: this.base,
            start: this.start,
            duration: this.duration,
            sn: this.sn,
            programDateTime: this.programDateTime,
          }),
        this._ref)
      : null;
  }
  addStart(e) {
    this.setStart(this.start + e);
  }
  setStart(e) {
    (this.start = e), this._ref && (this._ref.start = e);
  }
  setDuration(e) {
    (this.duration = e), this._ref && (this._ref.duration = e);
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const t = this.levelkeys[e];
      t &&
        !this._decryptdata &&
        (this._decryptdata = t.getDecryptData(this.sn));
    }
  }
  abortRequests() {
    var e, t;
    (e = this.loader) == null || e.abort(),
      (t = this.keyLoader) == null || t.abort();
  }
  setElementaryStreamInfo(e, t, s, r, i, a = !1) {
    const { elementaryStreams: o } = this,
      l = o[e];
    if (!l) {
      o[e] = { startPTS: t, endPTS: s, startDTS: r, endDTS: i, partial: a };
      return;
    }
    (l.startPTS = Math.min(l.startPTS, t)),
      (l.endPTS = Math.max(l.endPTS, s)),
      (l.startDTS = Math.min(l.startDTS, r)),
      (l.endDTS = Math.max(l.endDTS, i));
  }
}
class sRe extends oY {
  constructor(e, t, s, r, i) {
    super(s),
      (this.fragOffset = 0),
      (this.duration = 0),
      (this.gap = !1),
      (this.independent = !1),
      (this.relurl = void 0),
      (this.fragment = void 0),
      (this.index = void 0),
      (this.duration = e.decimalFloatingPoint("DURATION")),
      (this.gap = e.bool("GAP")),
      (this.independent = e.bool("INDEPENDENT")),
      (this.relurl = e.enumeratedString("URI")),
      (this.fragment = t),
      (this.index = r);
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, i),
      i && (this.fragOffset = i.fragOffset + i.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const { elementaryStreams: e } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
function lY(n, e) {
  const t = Object.getPrototypeOf(n);
  if (t) {
    const s = Object.getOwnPropertyDescriptor(t, e);
    return s || lY(t, e);
  }
}
function rRe(n, e) {
  const t = lY(n, e);
  t && ((t.enumerable = !0), Object.defineProperty(n, e, t));
}
const vB = Math.pow(2, 32) - 1,
  iRe = [].push,
  cY = { video: 1, audio: 2, id3: 3, text: 4 };
function sr(n) {
  return String.fromCharCode.apply(null, n);
}
function uY(n, e) {
  const t = (n[e] << 8) | n[e + 1];
  return t < 0 ? 65536 + t : t;
}
function Dt(n, e) {
  const t = dY(n, e);
  return t < 0 ? 4294967296 + t : t;
}
function yB(n, e) {
  let t = Dt(n, e);
  return (t *= Math.pow(2, 32)), (t += Dt(n, e + 4)), t;
}
function dY(n, e) {
  return (n[e] << 24) | (n[e + 1] << 16) | (n[e + 2] << 8) | n[e + 3];
}
function aRe(n) {
  const e = n.byteLength;
  for (let t = 0; t < e; ) {
    const s = Dt(n, t);
    if (
      s > 8 &&
      n[t + 4] === 109 &&
      n[t + 5] === 111 &&
      n[t + 6] === 111 &&
      n[t + 7] === 102
    )
      return !0;
    t = s > 1 ? t + s : e;
  }
  return !1;
}
function Qt(n, e) {
  const t = [];
  if (!e.length) return t;
  const s = n.byteLength;
  for (let r = 0; r < s; ) {
    const i = Dt(n, r),
      a = sr(n.subarray(r + 4, r + 8)),
      o = i > 1 ? r + i : s;
    if (a === e[0])
      if (e.length === 1) t.push(n.subarray(r + 8, o));
      else {
        const l = Qt(n.subarray(r + 8, o), e.slice(1));
        l.length && iRe.apply(t, l);
      }
    r = o;
  }
  return t;
}
function oRe(n) {
  const e = [],
    t = n[0];
  let s = 8;
  const r = Dt(n, s);
  s += 4;
  let i = 0,
    a = 0;
  t === 0
    ? ((i = Dt(n, s)), (a = Dt(n, s + 4)), (s += 8))
    : ((i = yB(n, s)), (a = yB(n, s + 8)), (s += 16)),
    (s += 2);
  let o = n.length + a;
  const l = uY(n, s);
  s += 2;
  for (let c = 0; c < l; c++) {
    let h = s;
    const m = Dt(n, h);
    h += 4;
    const p = m & 2147483647;
    if ((m & 2147483648) >>> 31 === 1)
      return pn.warn("SIDX has hierarchical references (not supported)"), null;
    const y = Dt(n, h);
    (h += 4),
      e.push({
        referenceSize: p,
        subsegmentDuration: y,
        info: { duration: y / r, start: o, end: o + p - 1 },
      }),
      (o += p),
      (h += 4),
      (s = h);
  }
  return {
    earliestPresentationTime: i,
    timescale: r,
    version: t,
    referencesCount: l,
    references: e,
  };
}
function hY(n) {
  const e = [],
    t = Qt(n, ["moov", "trak"]);
  for (let r = 0; r < t.length; r++) {
    const i = t[r],
      a = Qt(i, ["tkhd"])[0];
    if (a) {
      let o = a[0];
      const l = Dt(a, o === 0 ? 12 : 20),
        c = Qt(i, ["mdia", "mdhd"])[0];
      if (c) {
        o = c[0];
        const h = Dt(c, o === 0 ? 12 : 20),
          m = Qt(i, ["mdia", "hdlr"])[0];
        if (m) {
          const p = sr(m.subarray(8, 12)),
            g = { soun: On.AUDIO, vide: On.VIDEO }[p],
            y = Qt(i, ["mdia", "minf", "stbl", "stsd"])[0],
            b = lRe(y);
          g
            ? ((e[l] = { timescale: h, type: g, stsd: b }),
              (e[g] = In({ timescale: h, id: l }, b)))
            : (e[l] = { timescale: h, type: p, stsd: b });
        }
      }
    }
  }
  return (
    Qt(n, ["moov", "mvex", "trex"]).forEach((r) => {
      const i = Dt(r, 4),
        a = e[i];
      a && (a.default = { duration: Dt(r, 12), flags: Dt(r, 20) });
    }),
    e
  );
}
function lRe(n) {
  const e = n.subarray(8),
    t = e.subarray(86),
    s = sr(e.subarray(4, 8));
  let r = s,
    i;
  const a = s === "enca" || s === "encv";
  if (a) {
    const c = Qt(e, [s])[0].subarray(s === "enca" ? 28 : 78);
    Qt(c, ["sinf"]).forEach((m) => {
      const p = Qt(m, ["schm"])[0];
      if (p) {
        const g = sr(p.subarray(4, 8));
        if (g === "cbcs" || g === "cenc") {
          const y = Qt(m, ["frma"])[0];
          y && (r = sr(y));
        }
      }
    });
  }
  const o = r;
  switch (r) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const l = Qt(t, ["avcC"])[0];
      l &&
        l.length > 3 &&
        ((r += "." + Zy(l[1]) + Zy(l[2]) + Zy(l[3])),
        (i = Qy(o === "avc1" ? "dva1" : "dvav", t)));
      break;
    }
    case "mp4a": {
      const l = Qt(e, [s])[0],
        c = Qt(l.subarray(28), ["esds"])[0];
      if (c && c.length > 7) {
        let h = 4;
        if (c[h++] !== 3) break;
        (h = gA(c, h)), (h += 2);
        const m = c[h++];
        if ((m & 128 && (h += 2), m & 64 && (h += c[h++]), c[h++] !== 4)) break;
        h = gA(c, h);
        const p = c[h++];
        if (p === 64) r += "." + Zy(p);
        else break;
        if (((h += 12), c[h++] !== 5)) break;
        h = gA(c, h);
        const g = c[h++];
        let y = (g & 248) >> 3;
        y === 31 && (y += 1 + ((g & 7) << 3) + ((c[h] & 224) >> 5)),
          (r += "." + y);
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const l = Qt(t, ["hvcC"])[0];
      if (l && l.length > 12) {
        const c = l[1],
          h = ["", "A", "B", "C"][c >> 6],
          m = c & 31,
          p = Dt(l, 2),
          g = (c & 32) >> 5 ? "H" : "L",
          y = l[12],
          b = l.subarray(6, 12);
        (r += "." + h + m),
          (r += "." + cRe(p).toString(16).toUpperCase()),
          (r += "." + g + y);
        let w = "";
        for (let S = b.length; S--; ) {
          const A = b[S];
          (A || w) && (w = "." + A.toString(16).toUpperCase() + w);
        }
        r += w;
      }
      i = Qy(o == "hev1" ? "dvhe" : "dvh1", t);
      break;
    }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1": {
      r = Qy(r, t) || r;
      break;
    }
    case "vp09": {
      const l = Qt(t, ["vpcC"])[0];
      if (l && l.length > 6) {
        const c = l[4],
          h = l[5],
          m = (l[6] >> 4) & 15;
        r += "." + ho(c) + "." + ho(h) + "." + ho(m);
      }
      break;
    }
    case "av01": {
      const l = Qt(t, ["av1C"])[0];
      if (l && l.length > 2) {
        const c = l[1] >>> 5,
          h = l[1] & 31,
          m = l[2] >>> 7 ? "H" : "M",
          p = (l[2] & 64) >> 6,
          g = (l[2] & 32) >> 5,
          y = c === 2 && p ? (g ? 12 : 10) : p ? 10 : 8,
          b = (l[2] & 16) >> 4,
          w = (l[2] & 8) >> 3,
          S = (l[2] & 4) >> 2,
          A = l[2] & 3;
        (r +=
          "." +
          c +
          "." +
          ho(h) +
          m +
          "." +
          ho(y) +
          "." +
          b +
          "." +
          w +
          S +
          A +
          "." +
          ho(1) +
          "." +
          ho(1) +
          "." +
          ho(1) +
          "." +
          0),
          (i = Qy("dav1", t));
      }
      break;
    }
  }
  return { codec: r, encrypted: a, supplemental: i };
}
function Qy(n, e) {
  const t = Qt(e, ["dvvC"]),
    s = t.length ? t[0] : Qt(e, ["dvcC"])[0];
  if (s) {
    const r = (s[2] >> 1) & 127,
      i = ((s[2] << 5) & 32) | ((s[3] >> 3) & 31);
    return n + "." + ho(r) + "." + ho(i);
  }
}
function cRe(n) {
  let e = 0;
  for (let t = 0; t < 32; t++) e |= ((n >> t) & 1) << (31 - t);
  return e >>> 0;
}
function gA(n, e) {
  const t = e + 5;
  for (; n[e++] & 128 && e < t; );
  return e;
}
function Zy(n) {
  return ("0" + n.toString(16).toUpperCase()).slice(-2);
}
function ho(n) {
  return (n < 10 ? "0" : "") + n;
}
function uRe(n, e) {
  if (!n || !e) return n;
  const t = e.keyId;
  return (
    t &&
      e.isCommonEncryption &&
      Qt(n, ["moov", "trak"]).forEach((r) => {
        const a = Qt(r, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
        let o = Qt(a, ["enca"]);
        const l = o.length > 0;
        l || (o = Qt(a, ["encv"])),
          o.forEach((c) => {
            const h = l ? c.subarray(28) : c.subarray(78);
            Qt(h, ["sinf"]).forEach((p) => {
              const g = dRe(p);
              if (g) {
                const y = g.subarray(8, 24);
                y.some((b) => b !== 0) ||
                  (pn.log(
                    `[eme] Patching keyId in 'enc${
                      l ? "a" : "v"
                    }>sinf>>tenc' box: ${Nu.hexDump(y)} -> ${Nu.hexDump(t)}`
                  ),
                  g.set(t, 8));
              }
            });
          });
      }),
    n
  );
}
function dRe(n) {
  const e = Qt(n, ["schm"])[0];
  if (e) {
    const t = sr(e.subarray(4, 8));
    if (t === "cbcs" || t === "cenc") return Qt(n, ["schi", "tenc"])[0];
  }
  return null;
}
function hRe(n, e, t) {
  const s = {},
    r = Qt(n, ["moof", "traf"]);
  for (let i = 0; i < r.length; i++) {
    const a = r[i],
      o = Qt(a, ["tfhd"])[0],
      l = Dt(o, 4),
      c = e[l];
    if (!c) continue;
    const h =
        s[l] ||
        (s[l] = {
          start: NaN,
          duration: 0,
          sampleCount: 0,
          timescale: c.timescale,
          type: c.type,
        }),
      m = Qt(a, ["tfdt"])[0];
    if (m) {
      const _ = m[0];
      let R = Dt(m, 4);
      _ === 1 &&
        (R === vB
          ? t.warn(
              "[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"
            )
          : ((R *= vB + 1), (R += Dt(m, 8)))),
        Qe(R) && (!Qe(h.start) || R < h.start) && (h.start = R);
    }
    const p = c.default,
      g = Dt(o, 0) | p?.flags;
    let y = p?.duration || 0;
    g & 8 && (g & 2 ? (y = Dt(o, 12)) : (y = Dt(o, 8)));
    const b = Qt(a, ["trun"]);
    let w = h.start || 0,
      S = 0,
      A = y;
    for (let _ = 0; _ < b.length; _++) {
      const R = b[_],
        C = Dt(R, 4),
        D = h.sampleCount;
      h.sampleCount += C;
      const L = R[3] & 1,
        P = R[3] & 4,
        V = R[2] & 1,
        N = R[2] & 2,
        W = R[2] & 4,
        H = R[2] & 8;
      let z = 8,
        B = C;
      for (
        L && (z += 4),
          P &&
            C &&
            (!(R[z + 1] & 1) &&
              h.keyFrameIndex === void 0 &&
              (h.keyFrameIndex = D),
            (z += 4),
            V ? ((A = Dt(R, z)), (z += 4)) : (A = y),
            N && (z += 4),
            H && (z += 4),
            (w += A),
            (S += A),
            B--);
        B--;

      )
        V ? ((A = Dt(R, z)), (z += 4)) : (A = y),
          N && (z += 4),
          W &&
            (R[z + 1] & 1 ||
              (h.keyFrameIndex === void 0 &&
                ((h.keyFrameIndex = h.sampleCount - (B + 1)),
                (h.keyFrameStart = w))),
            (z += 4)),
          H && (z += 4),
          (w += A),
          (S += A);
      !S && y && (S += y * C);
    }
    h.duration += S;
  }
  if (!Object.keys(s).some((i) => s[i].duration)) {
    let i = 1 / 0,
      a = 0;
    const o = Qt(n, ["sidx"]);
    for (let l = 0; l < o.length; l++) {
      const c = oRe(o[l]);
      if (c != null && c.references) {
        i = Math.min(i, c.earliestPresentationTime / c.timescale);
        const h = c.references.reduce((m, p) => m + p.info.duration || 0, 0);
        a = Math.max(a, h + c.earliestPresentationTime / c.timescale);
      }
    }
    a &&
      Qe(a) &&
      Object.keys(s).forEach((l) => {
        s[l].duration || (s[l].duration = a * s[l].timescale - s[l].start);
      });
  }
  return s;
}
function fRe(n) {
  const e = { valid: null, remainder: null },
    t = Qt(n, ["moof"]);
  if (t.length < 2) return (e.remainder = n), e;
  const s = t[t.length - 1];
  return (
    (e.valid = n.slice(0, s.byteOffset - 8)),
    (e.remainder = n.slice(s.byteOffset - 8)),
    e
  );
}
function da(n, e) {
  const t = new Uint8Array(n.length + e.length);
  return t.set(n), t.set(e, n.length), t;
}
function bB(n, e) {
  const t = [],
    s = e.samples,
    r = e.timescale,
    i = e.id;
  let a = !1;
  return (
    Qt(s, ["moof"]).map((l) => {
      const c = l.byteOffset - 8;
      Qt(l, ["traf"]).map((m) => {
        const p = Qt(m, ["tfdt"]).map((g) => {
          const y = g[0];
          let b = Dt(g, 4);
          return y === 1 && ((b *= Math.pow(2, 32)), (b += Dt(g, 8))), b / r;
        })[0];
        return (
          p !== void 0 && (n = p),
          Qt(m, ["tfhd"]).map((g) => {
            const y = Dt(g, 4),
              b = Dt(g, 0) & 16777215,
              w = (b & 1) !== 0,
              S = (b & 2) !== 0,
              A = (b & 8) !== 0;
            let _ = 0;
            const R = (b & 16) !== 0;
            let C = 0;
            const D = (b & 32) !== 0;
            let L = 8;
            y === i &&
              (w && (L += 8),
              S && (L += 4),
              A && ((_ = Dt(g, L)), (L += 4)),
              R && ((C = Dt(g, L)), (L += 4)),
              D && (L += 4),
              e.type === "video" && (a = hS(e.codec)),
              Qt(m, ["trun"]).map((P) => {
                const V = P[0],
                  N = Dt(P, 0) & 16777215,
                  W = (N & 1) !== 0;
                let H = 0;
                const z = (N & 4) !== 0,
                  B = (N & 256) !== 0;
                let q = 0;
                const O = (N & 512) !== 0;
                let U = 0;
                const j = (N & 1024) !== 0,
                  Q = (N & 2048) !== 0;
                let M = 0;
                const I = Dt(P, 4);
                let F = 8;
                W && ((H = Dt(P, F)), (F += 4)), z && (F += 4);
                let Y = H + c;
                for (let J = 0; J < I; J++) {
                  if (
                    (B ? ((q = Dt(P, F)), (F += 4)) : (q = _),
                    O ? ((U = Dt(P, F)), (F += 4)) : (U = C),
                    j && (F += 4),
                    Q && (V === 0 ? (M = Dt(P, F)) : (M = dY(P, F)), (F += 4)),
                    e.type === On.VIDEO)
                  ) {
                    let X = 0;
                    for (; X < U; ) {
                      const Z = Dt(s, Y);
                      if (((Y += 4), mRe(a, s[Y]))) {
                        const te = s.subarray(Y, Y + Z);
                        zP(te, a ? 2 : 1, n + M / r, t);
                      }
                      (Y += Z), (X += Z + 4);
                    }
                  }
                  n += q / r;
                }
              }));
          })
        );
      });
    }),
    t
  );
}
function hS(n) {
  if (!n) return !1;
  const e = n.substring(0, 4);
  return e === "hvc1" || e === "hev1" || e === "dvh1" || e === "dvhe";
}
function mRe(n, e) {
  if (n) {
    const t = (e >> 1) & 63;
    return t === 39 || t === 40;
  } else return (e & 31) === 6;
}
function zP(n, e, t, s) {
  const r = fY(n);
  let i = 0;
  i += e;
  let a = 0,
    o = 0,
    l = 0;
  for (; i < r.length; ) {
    a = 0;
    do {
      if (i >= r.length) break;
      (l = r[i++]), (a += l);
    } while (l === 255);
    o = 0;
    do {
      if (i >= r.length) break;
      (l = r[i++]), (o += l);
    } while (l === 255);
    const c = r.length - i;
    let h = i;
    if (o < c) i += o;
    else if (o > c) {
      pn.error(
        `Malformed SEI payload. ${o} is too small, only ${c} bytes left to parse.`
      );
      break;
    }
    if (a === 4) {
      if (r[h++] === 181) {
        const p = uY(r, h);
        if (((h += 2), p === 49)) {
          const g = Dt(r, h);
          if (((h += 4), g === 1195456820)) {
            const y = r[h++];
            if (y === 3) {
              const b = r[h++],
                w = 31 & b,
                S = 64 & b,
                A = S ? 2 + w * 3 : 0,
                _ = new Uint8Array(A);
              if (S) {
                _[0] = b;
                for (let R = 1; R < A; R++) _[R] = r[h++];
              }
              s.push({ type: y, payloadType: a, pts: t, bytes: _ });
            }
          }
        }
      }
    } else if (a === 5 && o > 16) {
      const m = [];
      for (let y = 0; y < 16; y++) {
        const b = r[h++].toString(16);
        m.push(b.length == 1 ? "0" + b : b),
          (y === 3 || y === 5 || y === 7 || y === 9) && m.push("-");
      }
      const p = o - 16,
        g = new Uint8Array(p);
      for (let y = 0; y < p; y++) g[y] = r[h++];
      s.push({
        payloadType: a,
        pts: t,
        uuid: m.join(""),
        userData: ki(g),
        userDataBytes: g,
      });
    }
  }
}
function fY(n) {
  const e = n.byteLength,
    t = [];
  let s = 1;
  for (; s < e - 2; )
    n[s] === 0 && n[s + 1] === 0 && n[s + 2] === 3
      ? (t.push(s + 2), (s += 2))
      : s++;
  if (t.length === 0) return n;
  const r = e - t.length,
    i = new Uint8Array(r);
  let a = 0;
  for (s = 0; s < r; a++, s++) a === t[0] && (a++, t.shift()), (i[s] = n[a]);
  return i;
}
function pRe(n) {
  const e = n[0];
  let t = "",
    s = "",
    r = 0,
    i = 0,
    a = 0,
    o = 0,
    l = 0,
    c = 0;
  if (e === 0) {
    for (; sr(n.subarray(c, c + 1)) !== "\0"; )
      (t += sr(n.subarray(c, c + 1))), (c += 1);
    for (
      t += sr(n.subarray(c, c + 1)), c += 1;
      sr(n.subarray(c, c + 1)) !== "\0";

    )
      (s += sr(n.subarray(c, c + 1))), (c += 1);
    (s += sr(n.subarray(c, c + 1))),
      (c += 1),
      (r = Dt(n, 12)),
      (i = Dt(n, 16)),
      (o = Dt(n, 20)),
      (l = Dt(n, 24)),
      (c = 28);
  } else if (e === 1) {
    (c += 4), (r = Dt(n, c)), (c += 4);
    const m = Dt(n, c);
    c += 4;
    const p = Dt(n, c);
    for (
      c += 4,
        a = 2 ** 32 * m + p,
        GAe(a) ||
          ((a = Number.MAX_SAFE_INTEGER),
          pn.warn(
            "Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box"
          )),
        o = Dt(n, c),
        c += 4,
        l = Dt(n, c),
        c += 4;
      sr(n.subarray(c, c + 1)) !== "\0";

    )
      (t += sr(n.subarray(c, c + 1))), (c += 1);
    for (
      t += sr(n.subarray(c, c + 1)), c += 1;
      sr(n.subarray(c, c + 1)) !== "\0";

    )
      (s += sr(n.subarray(c, c + 1))), (c += 1);
    (s += sr(n.subarray(c, c + 1))), (c += 1);
  }
  const h = n.subarray(c, n.byteLength);
  return {
    schemeIdUri: t,
    value: s,
    timeScale: r,
    presentationTime: a,
    presentationTimeDelta: i,
    eventDuration: o,
    id: l,
    payload: h,
  };
}
function gRe(n, ...e) {
  const t = e.length;
  let s = 8,
    r = t;
  for (; r--; ) s += e[r].byteLength;
  const i = new Uint8Array(s);
  for (
    i[0] = (s >> 24) & 255,
      i[1] = (s >> 16) & 255,
      i[2] = (s >> 8) & 255,
      i[3] = s & 255,
      i.set(n, 4),
      r = 0,
      s = 8;
    r < t;
    r++
  )
    i.set(e[r], s), (s += e[r].byteLength);
  return i;
}
function vRe(n, e, t) {
  if (n.byteLength !== 16) throw new RangeError("Invalid system id");
  let s, r;
  (s = 0), (r = new Uint8Array());
  let i;
  s > 0
    ? ((i = new Uint8Array(4)),
      e.length > 0 && new DataView(i.buffer).setUint32(0, e.length, !1))
    : (i = new Uint8Array());
  const a = new Uint8Array(4);
  return (
    t &&
      t.byteLength > 0 &&
      new DataView(a.buffer).setUint32(0, t.byteLength, !1),
    gRe(
      [112, 115, 115, 104],
      new Uint8Array([s, 0, 0, 0]),
      n,
      i,
      r,
      a,
      t || new Uint8Array()
    )
  );
}
const mY = () => /\(Windows.+Firefox\//i.test(navigator.userAgent),
  Pf = {
    audio: {
      a3ds: 1,
      "ac-3": 0.95,
      "ac-4": 1,
      alac: 0.9,
      alaw: 1,
      dra1: 1,
      "dts+": 1,
      "dts-": 1,
      dtsc: 1,
      dtse: 1,
      dtsh: 1,
      "ec-3": 0.9,
      enca: 1,
      fLaC: 0.9,
      flac: 0.9,
      FLAC: 0.9,
      g719: 1,
      g726: 1,
      m4ae: 1,
      mha1: 1,
      mha2: 1,
      mhm1: 1,
      mhm2: 1,
      mlpa: 1,
      mp4a: 1,
      "raw ": 1,
      Opus: 1,
      opus: 1,
      samr: 1,
      sawb: 1,
      sawp: 1,
      sevc: 1,
      sqcp: 1,
      ssmv: 1,
      twos: 1,
      ulaw: 1,
    },
    video: {
      avc1: 1,
      avc2: 1,
      avc3: 1,
      avc4: 1,
      avcp: 1,
      av01: 0.8,
      dav1: 0.8,
      drac: 1,
      dva1: 1,
      dvav: 1,
      dvh1: 0.7,
      dvhe: 0.7,
      encv: 1,
      hev1: 0.75,
      hvc1: 0.75,
      mjp2: 1,
      mp4v: 1,
      mvc1: 1,
      mvc2: 1,
      mvc3: 1,
      mvc4: 1,
      resv: 1,
      rv60: 1,
      s263: 1,
      svc1: 1,
      svc2: 1,
      "vc-1": 1,
      vp08: 1,
      vp09: 0.9,
    },
    text: { stpp: 1, wvtt: 1 },
  };
function GP(n, e) {
  const t = Pf[e];
  return !!t && !!t[n.slice(0, 4)];
}
function nI(n, e, t = !0) {
  return !n.split(",").some((s) => !qP(s, e, t));
}
function qP(n, e, t = !0) {
  var s;
  const r = Bc(t);
  return (s = r?.isTypeSupported(hv(n, e))) != null ? s : !1;
}
function hv(n, e) {
  return `${e}/mp4;codecs=${n}`;
}
function xB(n) {
  if (n) {
    const e = n.substring(0, 4);
    return Pf.video[e];
  }
  return 2;
}
function qw(n) {
  const e = mY();
  return n.split(",").reduce((t, s) => {
    const i = e && hS(s) ? 9 : Pf.video[s];
    return i ? (i * 2 + t) / (t ? 3 : 2) : (Pf.audio[s] + t) / (t ? 2 : 1);
  }, 0);
}
const vA = {};
function yRe(n, e = !0) {
  if (vA[n]) return vA[n];
  const t = {
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"],
    "mp4a.40.34": ["mp3"],
  }[n];
  for (let r = 0; r < t.length; r++) {
    var s;
    if (qP(t[r], "audio", e)) return (vA[n] = t[r]), t[r];
    if (
      t[r] === "mp3" &&
      (s = Bc(e)) != null &&
      s.isTypeSupported("audio/mpeg")
    )
      return "";
  }
  return n;
}
const bRe = /flac|opus|mp4a\.40\.34/i;
function Ww(n, e = !0) {
  return n.replace(bRe, (t) => yRe(t.toLowerCase(), e));
}
function xRe(n, e) {
  const t = [];
  if (n) {
    const s = n.split(",");
    for (let r = 0; r < s.length; r++) GP(s[r], "video") || t.push(s[r]);
  }
  return e && t.push(e), t.join(",");
}
function tx(n, e) {
  if (
    n &&
    (n.length > 4 ||
      ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(n) !== -1) &&
    (wB(n, "audio") || wB(n, "video"))
  )
    return n;
  if (e) {
    const t = e.split(",");
    if (t.length > 1) {
      if (n) {
        for (let s = t.length; s--; )
          if (t[s].substring(0, 4) === n.substring(0, 4)) return t[s];
      }
      return t[0];
    }
  }
  return e || n;
}
function wB(n, e) {
  return GP(n, e) && qP(n, e);
}
function wRe(n) {
  const e = n.split(",");
  for (let t = 0; t < e.length; t++) {
    const s = e[t].split(".");
    s.length > 2 &&
      s[0] === "avc1" &&
      (e[t] = `avc1.${parseInt(s[1]).toString(16)}${(
        "000" + parseInt(s[2]).toString(16)
      ).slice(-4)}`);
  }
  return e.join(",");
}
function ERe(n) {
  if (n.startsWith("av01.")) {
    const e = n.split("."),
      t = ["0", "111", "01", "01", "01", "0"];
    for (let s = e.length; s > 4 && s < 10; s++) e[s] = t[s - 4];
    return e.join(".");
  }
  return n;
}
function EB(n) {
  const e = Bc(n) || { isTypeSupported: () => !1 };
  return {
    mpeg: e.isTypeSupported("audio/mpeg"),
    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"'),
  };
}
function sI(n) {
  return n.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const pY = {
  supported: !0,
  configurations: [],
  decodingInfoResults: [{ supported: !0, powerEfficient: !0, smooth: !0 }],
};
function gY(n, e) {
  return {
    supported: !1,
    configurations: e,
    decodingInfoResults: [{ supported: !1, smooth: !1, powerEfficient: !1 }],
    error: n,
  };
}
function SRe(n, e, t, s, r, i) {
  const a = n.videoCodec,
    o = n.audioCodec ? n.audioGroups : null,
    l = i?.audioCodec,
    c = i?.channels,
    h = c ? parseInt(c) : l ? 1 / 0 : 2;
  let m = null;
  if (o != null && o.length)
    try {
      o.length === 1 && o[0]
        ? (m = e.groups[o[0]].channels)
        : (m = o.reduce(
            (p, g) => {
              if (g) {
                const y = e.groups[g];
                if (!y) throw new Error(`Audio track group ${g} not found`);
                Object.keys(y.channels).forEach((b) => {
                  p[b] = (p[b] || 0) + y.channels[b];
                });
              }
              return p;
            },
            { 2: 0 }
          ));
    } catch {
      return !0;
    }
  return (
    (a !== void 0 &&
      (a.split(",").some((p) => hS(p)) ||
        (n.width > 1920 && n.height > 1088) ||
        (n.height > 1920 && n.width > 1088) ||
        n.frameRate > Math.max(s, 30) ||
        (n.videoRange !== "SDR" && n.videoRange !== t) ||
        n.bitrate > Math.max(r, 8e6))) ||
    (!!m && Qe(h) && Object.keys(m).some((p) => parseInt(p) > h))
  );
}
function vY(n, e, t, s = {}) {
  const r = n.videoCodec;
  if ((!r && !n.audioCodec) || !t) return Promise.resolve(pY);
  const i = [],
    a = TRe(n),
    o = a.length,
    l = _Re(n, e, o > 0),
    c = l.length;
  for (let h = o || 1 * c || 1; h--; ) {
    const m = { type: "media-source" };
    if ((o && (m.video = a[h % o]), c)) {
      m.audio = l[h % c];
      const p = m.audio.bitrate;
      m.video && p && (m.video.bitrate -= p);
    }
    i.push(m);
  }
  if (r) {
    const h = navigator.userAgent;
    if (r.split(",").some((m) => hS(m)) && mY())
      return Promise.resolve(
        gY(
          new Error(
            `Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${h})`
          ),
          i
        )
      );
  }
  return Promise.all(
    i.map((h) => {
      const m = RRe(h);
      return s[m] || (s[m] = t.decodingInfo(h));
    })
  )
    .then((h) => ({
      supported: !h.some((m) => !m.supported),
      configurations: i,
      decodingInfoResults: h,
    }))
    .catch((h) => ({
      supported: !1,
      configurations: i,
      decodingInfoResults: [],
      error: h,
    }));
}
function TRe(n) {
  var e;
  const t = (e = n.videoCodec) == null ? void 0 : e.split(","),
    s = yY(n),
    r = n.width || 640,
    i = n.height || 480,
    a = n.frameRate || 30,
    o = n.videoRange.toLowerCase();
  return t
    ? t.map((l) => {
        const c = {
          contentType: hv(ERe(l), "video"),
          width: r,
          height: i,
          bitrate: s,
          framerate: a,
        };
        return o !== "sdr" && (c.transferFunction = o), c;
      })
    : [];
}
function _Re(n, e, t) {
  var s;
  const r = (s = n.audioCodec) == null ? void 0 : s.split(","),
    i = yY(n);
  return r && n.audioGroups
    ? n.audioGroups.reduce((a, o) => {
        var l;
        const c = o ? ((l = e.groups[o]) == null ? void 0 : l.tracks) : null;
        return c
          ? c.reduce((h, m) => {
              if (m.groupId === o) {
                const p = parseFloat(m.channels || "");
                r.forEach((g) => {
                  const y = {
                    contentType: hv(g, "audio"),
                    bitrate: t ? ARe(g, i) : i,
                  };
                  p && (y.channels = "" + p), h.push(y);
                });
              }
              return h;
            }, a)
          : a;
      }, [])
    : [];
}
function ARe(n, e) {
  if (e <= 1) return 1;
  let t = 128e3;
  return (
    n === "ec-3" ? (t = 768e3) : n === "ac-3" && (t = 64e4), Math.min(e / 2, t)
  );
}
function yY(n) {
  return (
    Math.ceil(Math.max(n.bitrate * 0.9, n.averageBitrate) / 1e3) * 1e3 || 1
  );
}
function RRe(n) {
  let e = "";
  const { audio: t, video: s } = n;
  if (s) {
    const r = sI(s.contentType);
    e += `${r}_r${s.height}x${s.width}f${Math.ceil(s.framerate)}${
      s.transferFunction || "sd"
    }_${Math.ceil(s.bitrate / 1e5)}`;
  }
  if (t) {
    const r = sI(t.contentType);
    e += `${s ? "_" : ""}${r}_c${t.channels}`;
  }
  return e;
}
const rI = ["NONE", "TYPE-0", "TYPE-1", null];
function kRe(n) {
  return rI.indexOf(n) > -1;
}
const Kw = ["SDR", "PQ", "HLG"];
function CRe(n) {
  return !!n && Kw.indexOf(n) > -1;
}
var nx = { No: "", Yes: "YES", v2: "v2" };
function SB(n) {
  const { canSkipUntil: e, canSkipDateRanges: t, age: s } = n,
    r = s < e / 2;
  return e && r ? (t ? nx.v2 : nx.Yes) : nx.No;
}
class TB {
  constructor(e, t, s) {
    (this.msn = void 0),
      (this.part = void 0),
      (this.skip = void 0),
      (this.msn = e),
      (this.part = t),
      (this.skip = s);
  }
  addDirectives(e) {
    const t = new self.URL(e);
    return (
      this.msn !== void 0 &&
        t.searchParams.set("_HLS_msn", this.msn.toString()),
      this.part !== void 0 &&
        t.searchParams.set("_HLS_part", this.part.toString()),
      this.skip && t.searchParams.set("_HLS_skip", this.skip),
      t.href
    );
  }
}
class fv {
  constructor(e) {
    if (
      ((this._attrs = void 0),
      (this.audioCodec = void 0),
      (this.bitrate = void 0),
      (this.codecSet = void 0),
      (this.url = void 0),
      (this.frameRate = void 0),
      (this.height = void 0),
      (this.id = void 0),
      (this.name = void 0),
      (this.supplemental = void 0),
      (this.videoCodec = void 0),
      (this.width = void 0),
      (this.details = void 0),
      (this.fragmentError = 0),
      (this.loadError = 0),
      (this.loaded = void 0),
      (this.realBitrate = 0),
      (this.supportedPromise = void 0),
      (this.supportedResult = void 0),
      (this._avgBitrate = 0),
      (this._audioGroups = void 0),
      (this._subtitleGroups = void 0),
      (this._urlId = 0),
      (this.url = [e.url]),
      (this._attrs = [e.attrs]),
      (this.bitrate = e.bitrate),
      e.details && (this.details = e.details),
      (this.id = e.id || 0),
      (this.name = e.name),
      (this.width = e.width || 0),
      (this.height = e.height || 0),
      (this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0)),
      (this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH")),
      (this.audioCodec = e.audioCodec),
      (this.videoCodec = e.videoCodec),
      (this.codecSet = [e.videoCodec, e.audioCodec]
        .filter((s) => !!s)
        .map((s) => s.substring(0, 4))
        .join(",")),
      "supplemental" in e)
    ) {
      var t;
      this.supplemental = e.supplemental;
      const s = (t = e.supplemental) == null ? void 0 : t.videoCodec;
      s && s !== e.videoCodec && (this.codecSet += `,${s.substring(0, 4)}`);
    }
    this.addGroupId("audio", e.attrs.AUDIO),
      this.addGroupId("text", e.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(e) {
    return _B(this._audioGroups, e);
  }
  hasSubtitleGroup(e) {
    return _B(this._subtitleGroups, e);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(e, t) {
    if (t) {
      if (e === "audio") {
        let s = this._audioGroups;
        s || (s = this._audioGroups = []), s.indexOf(t) === -1 && s.push(t);
      } else if (e === "text") {
        let s = this._subtitleGroups;
        s || (s = this._subtitleGroups = []), s.indexOf(t) === -1 && s.push(t);
      }
    }
  }
  get urlId() {
    return 0;
  }
  set urlId(e) {}
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : void 0;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : void 0;
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroups) == null ? void 0 : e[0];
  }
  get textGroupId() {
    var e;
    return (e = this.subtitleGroups) == null ? void 0 : e[0];
  }
  addFallback() {}
}
function _B(n, e) {
  return !e || !n ? !1 : n.indexOf(e) !== -1;
}
function IRe() {
  if (typeof matchMedia == "function") {
    const n = matchMedia("(dynamic-range: high)"),
      e = matchMedia("bad query");
    if (n.media !== e.media) return n.matches === !0;
  }
  return !1;
}
function LRe(n, e) {
  let t = !1,
    s = [];
  if ((n && ((t = n !== "SDR"), (s = [n])), e)) {
    s = e.allowedVideoRanges || Kw.slice(0);
    const r = s.join("") !== "SDR" && !e.videoCodec;
    (t = e.preferHDR !== void 0 ? e.preferHDR : r && IRe()), t || (s = ["SDR"]);
  }
  return { preferHDR: t, allowedVideoRanges: s };
}
const DRe = (n) => {
    const e = new WeakSet();
    return (t, s) => {
      if ((n && (s = n(t, s)), typeof s == "object" && s !== null)) {
        if (e.has(s)) return;
        e.add(s);
      }
      return s;
    };
  },
  Wn = (n, e) => JSON.stringify(n, DRe(e));
function PRe(n, e, t, s, r) {
  const i = Object.keys(n),
    a = s?.channels,
    o = s?.audioCodec,
    l = r?.videoCodec,
    c = a && parseInt(a) === 2;
  let h = !1,
    m = !1,
    p = 1 / 0,
    g = 1 / 0,
    y = 1 / 0,
    b = 1 / 0,
    w = 0,
    S = [];
  const { preferHDR: A, allowedVideoRanges: _ } = LRe(e, r);
  for (let P = i.length; P--; ) {
    const V = n[i[P]];
    h || (h = V.channels[2] > 0),
      (p = Math.min(p, V.minHeight)),
      (g = Math.min(g, V.minFramerate)),
      (y = Math.min(y, V.minBitrate)),
      _.filter((W) => V.videoRanges[W] > 0).length > 0 && (m = !0);
  }
  (p = Qe(p) ? p : 0), (g = Qe(g) ? g : 0);
  const R = Math.max(1080, p),
    C = Math.max(30, g);
  (y = Qe(y) ? y : t), (t = Math.max(y, t)), m || (e = void 0);
  const D = i.length > 1;
  return {
    codecSet: i.reduce((P, V) => {
      const N = n[V];
      if (V === P) return P;
      if (((S = m ? _.filter((W) => N.videoRanges[W] > 0) : []), D)) {
        if (N.minBitrate > t)
          return (
            Za(V, `min bitrate of ${N.minBitrate} > current estimate of ${t}`),
            P
          );
        if (!N.hasDefaultAudio)
          return (
            Za(V, "no renditions with default or auto-select sound found"), P
          );
        if (o && V.indexOf(o.substring(0, 4)) % 5 !== 0)
          return Za(V, `audio codec preference "${o}" not found`), P;
        if (a && !c) {
          if (!N.channels[a])
            return (
              Za(
                V,
                `no renditions with ${a} channel sound found (channels options: ${Object.keys(
                  N.channels
                )})`
              ),
              P
            );
        } else if ((!o || c) && h && N.channels[2] === 0)
          return Za(V, "no renditions with stereo sound found"), P;
        if (N.minHeight > R)
          return Za(V, `min resolution of ${N.minHeight} > maximum of ${R}`), P;
        if (N.minFramerate > C)
          return (
            Za(V, `min framerate of ${N.minFramerate} > maximum of ${C}`), P
          );
        if (!S.some((W) => N.videoRanges[W] > 0))
          return Za(V, `no variants with VIDEO-RANGE of ${Wn(S)} found`), P;
        if (l && V.indexOf(l.substring(0, 4)) % 5 !== 0)
          return Za(V, `video codec preference "${l}" not found`), P;
        if (N.maxScore < w)
          return Za(V, `max score of ${N.maxScore} < selected max of ${w}`), P;
      }
      return P && (qw(V) >= qw(P) || N.fragmentError > n[P].fragmentError)
        ? P
        : ((b = N.minIndex), (w = N.maxScore), V);
    }, void 0),
    videoRanges: S,
    preferHDR: A,
    minFramerate: g,
    minBitrate: y,
    minIndex: b,
  };
}
function Za(n, e) {
  pn.log(`[abr] start candidates with "${n}" ignored because ${e}`);
}
function bY(n) {
  return n.reduce(
    (e, t) => {
      let s = e.groups[t.groupId];
      s ||
        (s = e.groups[t.groupId] =
          {
            tracks: [],
            channels: { 2: 0 },
            hasDefault: !1,
            hasAutoSelect: !1,
          }),
        s.tracks.push(t);
      const r = t.channels || "2";
      return (
        (s.channels[r] = (s.channels[r] || 0) + 1),
        (s.hasDefault = s.hasDefault || t.default),
        (s.hasAutoSelect = s.hasAutoSelect || t.autoselect),
        s.hasDefault && (e.hasDefaultAudio = !0),
        s.hasAutoSelect && (e.hasAutoSelectAudio = !0),
        e
      );
    },
    { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} }
  );
}
function MRe(n, e, t, s) {
  return n.slice(t, s + 1).reduce((r, i, a) => {
    if (!i.codecSet) return r;
    const o = i.audioGroups;
    let l = r[i.codecSet];
    l ||
      (r[i.codecSet] = l =
        {
          minBitrate: 1 / 0,
          minHeight: 1 / 0,
          minFramerate: 1 / 0,
          minIndex: a,
          maxScore: 0,
          videoRanges: { SDR: 0 },
          channels: { 2: 0 },
          hasDefaultAudio: !o,
          fragmentError: 0,
        }),
      (l.minBitrate = Math.min(l.minBitrate, i.bitrate));
    const c = Math.min(i.height, i.width);
    return (
      (l.minHeight = Math.min(l.minHeight, c)),
      (l.minFramerate = Math.min(l.minFramerate, i.frameRate)),
      (l.minIndex = Math.min(l.minIndex, a)),
      (l.maxScore = Math.max(l.maxScore, i.score)),
      (l.fragmentError += i.fragmentError),
      (l.videoRanges[i.videoRange] = (l.videoRanges[i.videoRange] || 0) + 1),
      o &&
        o.forEach((h) => {
          if (!h) return;
          const m = e.groups[h];
          m &&
            ((l.hasDefaultAudio =
              l.hasDefaultAudio || e.hasDefaultAudio
                ? m.hasDefault
                : m.hasAutoSelect ||
                  (!e.hasDefaultAudio && !e.hasAutoSelectAudio)),
            Object.keys(m.channels).forEach((p) => {
              l.channels[p] = (l.channels[p] || 0) + m.channels[p];
            }));
        }),
      r
    );
  }, {});
}
function AB(n) {
  if (!n) return n;
  const {
    lang: e,
    assocLang: t,
    characteristics: s,
    channels: r,
    audioCodec: i,
  } = n;
  return {
    lang: e,
    assocLang: t,
    characteristics: s,
    channels: r,
    audioCodec: i,
  };
}
function To(n, e, t) {
  if ("attrs" in n) {
    const s = e.indexOf(n);
    if (s !== -1) return s;
  }
  for (let s = 0; s < e.length; s++) {
    const r = e[s];
    if (qu(n, r, t)) return s;
  }
  return -1;
}
function qu(n, e, t) {
  const { groupId: s, name: r, lang: i, assocLang: a, default: o } = n,
    l = n.forced;
  return (
    (s === void 0 || e.groupId === s) &&
    (r === void 0 || e.name === r) &&
    (i === void 0 || NRe(i, e.lang)) &&
    (i === void 0 || e.assocLang === a) &&
    (o === void 0 || e.default === o) &&
    (l === void 0 || e.forced === l) &&
    (!("characteristics" in n) ||
      ORe(n.characteristics || "", e.characteristics)) &&
    (t === void 0 || t(n, e))
  );
}
function NRe(n, e = "--") {
  return n.length === e.length ? n === e : n.startsWith(e) || e.startsWith(n);
}
function ORe(n, e = "") {
  const t = n.split(","),
    s = e.split(",");
  return t.length === s.length && !t.some((r) => s.indexOf(r) === -1);
}
function Du(n, e) {
  const { audioCodec: t, channels: s } = n;
  return (
    (t === void 0 ||
      (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) &&
    (s === void 0 || s === (e.channels || "2"))
  );
}
function jRe(n, e, t, s, r) {
  const i = e[s],
    o = e.reduce((p, g, y) => {
      const b = g.uri;
      return (p[b] || (p[b] = [])).push(y), p;
    }, {})[i.uri];
  o.length > 1 && (s = Math.max.apply(Math, o));
  const l = i.videoRange,
    c = i.frameRate,
    h = i.codecSet.substring(0, 4),
    m = RB(e, s, (p) => {
      if (
        p.videoRange !== l ||
        p.frameRate !== c ||
        p.codecSet.substring(0, 4) !== h
      )
        return !1;
      const g = p.audioGroups,
        y = t.filter((b) => !g || g.indexOf(b.groupId) !== -1);
      return To(n, y, r) > -1;
    });
  return m > -1
    ? m
    : RB(e, s, (p) => {
        const g = p.audioGroups,
          y = t.filter((b) => !g || g.indexOf(b.groupId) !== -1);
        return To(n, y, r) > -1;
      });
}
function RB(n, e, t) {
  for (let s = e; s > -1; s--) if (t(n[s])) return s;
  for (let s = e + 1; s < n.length; s++) if (t(n[s])) return s;
  return -1;
}
function Yw(n, e) {
  var t;
  return !!n && n !== ((t = e.loadLevelObj) == null ? void 0 : t.uri);
}
class FRe extends za {
  constructor(e) {
    super("abr", e.logger),
      (this.hls = void 0),
      (this.lastLevelLoadSec = 0),
      (this.lastLoadedFragLevel = -1),
      (this.firstSelection = -1),
      (this._nextAutoLevel = -1),
      (this.nextAutoLevelKey = ""),
      (this.audioTracksByGroup = null),
      (this.codecTiers = null),
      (this.timer = -1),
      (this.fragCurrent = null),
      (this.partCurrent = null),
      (this.bitrateTestDelay = 0),
      (this.rebufferNotice = -1),
      (this.supportedCache = {}),
      (this.bwEstimator = void 0),
      (this._abandonRulesCheck = (t) => {
        var s;
        const { fragCurrent: r, partCurrent: i, hls: a } = this,
          { autoLevelEnabled: o, media: l } = a;
        if (!r || !l) return;
        const c = performance.now(),
          h = i ? i.stats : r.stats,
          m = i ? i.duration : r.duration,
          p = c - h.loading.start,
          g = a.minAutoLevel,
          y = r.level,
          b = this._nextAutoLevel;
        if (h.aborted || (h.loaded && h.loaded === h.total) || y <= g) {
          this.clearTimer(), (this._nextAutoLevel = -1);
          return;
        }
        if (!o) return;
        const w = b > -1 && b !== y,
          S = !!t || w;
        if (!S && (l.paused || !l.playbackRate || !l.readyState)) return;
        const A = a.mainForwardBufferInfo;
        if (!S && A === null) return;
        const _ = this.bwEstimator.getEstimateTTFB(),
          R = Math.abs(l.playbackRate);
        if (p <= Math.max(_, 1e3 * (m / (R * 2)))) return;
        const C = A ? A.len / R : 0,
          D = h.loading.first ? h.loading.first - h.loading.start : -1,
          L = h.loaded && D > -1,
          P = this.getBwEstimate(),
          V = a.levels,
          N = V[y],
          W = Math.max(
            h.loaded,
            Math.round((m * (r.bitrate || N.averageBitrate)) / 8)
          );
        let H = L ? p - D : p;
        H < 1 && L && (H = Math.min(p, (h.loaded * 8) / P));
        const z = L ? (h.loaded * 1e3) / H : 0,
          B = _ / 1e3,
          q = z ? (W - h.loaded) / z : (W * 8) / P + B;
        if (q <= C) return;
        const O = z ? z * 8 : P,
          U =
            ((s = t?.details || this.hls.latestLevelDetails) == null
              ? void 0
              : s.live) === !0,
          j = this.hls.config.abrBandWidthUpFactor;
        let Q = Number.POSITIVE_INFINITY,
          M;
        for (M = y - 1; M > g; M--) {
          const J = V[M].maxBitrate,
            X = !V[M].details || U;
          if (
            ((Q = this.getTimeToLoadFrag(B, O, m * J, X)),
            Q < Math.min(C, m + B))
          )
            break;
        }
        if (Q >= q || Q > m * 10) return;
        L
          ? this.bwEstimator.sample(p - Math.min(_, D), h.loaded)
          : this.bwEstimator.sampleTTFB(p);
        const I = V[M].maxBitrate;
        this.getBwEstimate() * j > I && this.resetEstimator(I);
        const F = this.findBestLevel(I, g, M, 0, C, 1, 1);
        F > -1 && (M = F),
          this.warn(`Fragment ${r.sn}${
            i ? " part " + i.index : ""
          } of level ${y} is loading too slowly;
      Fragment duration: ${r.duration.toFixed(3)}
      Time to underbuffer: ${C.toFixed(3)} s
      Estimated load time for current fragment: ${q.toFixed(3)} s
      Estimated load time for down switch fragment: ${Q.toFixed(3)} s
      TTFB estimate: ${D | 0} ms
      Current BW estimate: ${Qe(P) ? P | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${M} @ ${I | 0} bps`),
          (a.nextLoadLevel = a.nextAutoLevel = M),
          this.clearTimer();
        const Y = () => {
          if (
            (this.clearTimer(),
            this.fragCurrent === r && this.hls.loadLevel === M && M > 0)
          ) {
            const J = this.getStarvationDelay();
            if (
              (this.warn(`Aborting inflight request ${
                M > 0 ? "and switching down" : ""
              }
      Fragment duration: ${r.duration.toFixed(3)} s
      Time to underbuffer: ${J.toFixed(3)} s`),
              r.abortRequests(),
              (this.fragCurrent = this.partCurrent = null),
              M > g)
            ) {
              let X = this.findBestLevel(
                this.hls.levels[g].bitrate,
                g,
                M,
                0,
                J,
                1,
                1
              );
              X === -1 && (X = g),
                (this.hls.nextLoadLevel = this.hls.nextAutoLevel = X),
                this.resetEstimator(this.hls.levels[X].bitrate);
            }
          }
        };
        w || q > Q * 2 ? Y() : (this.timer = self.setInterval(Y, Q * 1e3)),
          a.trigger($.FRAG_LOAD_EMERGENCY_ABORTED, {
            frag: r,
            part: i,
            stats: h,
          });
      }),
      (this.hls = e),
      (this.bwEstimator = this.initEstimator()),
      this.registerListeners();
  }
  resetEstimator(e) {
    e &&
      (this.log(`setting initial bwe to ${e}`),
      (this.hls.config.abrEwmaDefaultEstimate = e)),
      (this.firstSelection = -1),
      (this.bwEstimator = this.initEstimator());
  }
  initEstimator() {
    const e = this.hls.config;
    return new WAe(
      e.abrEwmaSlowVoD,
      e.abrEwmaFastVoD,
      e.abrEwmaDefaultEstimate
    );
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.FRAG_LOADING, this.onFragLoading, this),
      e.on($.FRAG_LOADED, this.onFragLoaded, this),
      e.on($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on($.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e &&
      (e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.FRAG_LOADING, this.onFragLoading, this),
      e.off($.FRAG_LOADED, this.onFragLoaded, this),
      e.off($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off($.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
      e.off($.ERROR, this.onError, this));
  }
  destroy() {
    this.unregisterListeners(),
      this.clearTimer(),
      (this.hls = this._abandonRulesCheck = this.supportedCache = null),
      (this.fragCurrent = this.partCurrent = null);
  }
  onManifestLoading(e, t) {
    (this.lastLoadedFragLevel = -1),
      (this.firstSelection = -1),
      (this.lastLevelLoadSec = 0),
      (this.supportedCache = {}),
      (this.fragCurrent = this.partCurrent = null),
      this.onLevelsUpdated(),
      this.clearTimer();
  }
  onLevelsUpdated() {
    this.lastLoadedFragLevel > -1 &&
      this.fragCurrent &&
      (this.lastLoadedFragLevel = this.fragCurrent.level),
      (this._nextAutoLevel = -1),
      this.onMaxAutoLevelUpdated(),
      (this.codecTiers = null),
      (this.audioTracksByGroup = null);
  }
  onMaxAutoLevelUpdated() {
    (this.firstSelection = -1), (this.nextAutoLevelKey = "");
  }
  onFragLoading(e, t) {
    const s = t.frag;
    if (!this.ignoreFragment(s)) {
      if (!s.bitrateTest) {
        var r;
        (this.fragCurrent = s),
          (this.partCurrent = (r = t.part) != null ? r : null);
      }
      this.clearTimer(),
        (this.timer = self.setInterval(this._abandonRulesCheck, 100));
    }
  }
  onLevelSwitching(e, t) {
    this.clearTimer();
  }
  onError(e, t) {
    if (!t.fatal)
      switch (t.details) {
        case we.BUFFER_ADD_CODEC_ERROR:
        case we.BUFFER_APPEND_ERROR:
          (this.lastLoadedFragLevel = -1), (this.firstSelection = -1);
          break;
        case we.FRAG_LOAD_TIMEOUT: {
          const s = t.frag,
            { fragCurrent: r, partCurrent: i } = this;
          if (s && r && s.sn === r.sn && s.level === r.level) {
            const a = performance.now(),
              o = i ? i.stats : s.stats,
              l = a - o.loading.start,
              c = o.loading.first ? o.loading.first - o.loading.start : -1;
            if (o.loaded && c > -1) {
              const m = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(l - Math.min(m, c), o.loaded);
            } else this.bwEstimator.sampleTTFB(l);
          }
          break;
        }
      }
  }
  getTimeToLoadFrag(e, t, s, r) {
    const i = e + s / t,
      a = r ? e + this.lastLevelLoadSec : 0;
    return i + a;
  }
  onLevelLoaded(e, t) {
    const s = this.hls.config,
      { loading: r } = t.stats,
      i = r.end - r.first;
    Qe(i) && (this.lastLevelLoadSec = i / 1e3),
      t.details.live
        ? this.bwEstimator.update(s.abrEwmaSlowLive, s.abrEwmaFastLive)
        : this.bwEstimator.update(s.abrEwmaSlowVoD, s.abrEwmaFastVoD),
      this.timer > -1 && this._abandonRulesCheck(t.levelInfo);
  }
  onFragLoaded(e, { frag: t, part: s }) {
    const r = s ? s.stats : t.stats;
    if (
      (t.type === lt.MAIN &&
        this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start),
      !this.ignoreFragment(t))
    ) {
      if (
        (this.clearTimer(),
        t.level === this._nextAutoLevel && (this._nextAutoLevel = -1),
        (this.firstSelection = -1),
        this.hls.config.abrMaxWithRealBitrate)
      ) {
        const i = s ? s.duration : t.duration,
          a = this.hls.levels[t.level],
          o = (a.loaded ? a.loaded.bytes : 0) + r.loaded,
          l = (a.loaded ? a.loaded.duration : 0) + i;
        (a.loaded = { bytes: o, duration: l }),
          (a.realBitrate = Math.round((8 * o) / l));
      }
      if (t.bitrateTest) {
        const i = { stats: r, frag: t, part: s, id: t.type };
        this.onFragBuffered($.FRAG_BUFFERED, i), (t.bitrateTest = !1);
      } else this.lastLoadedFragLevel = t.level;
    }
  }
  onFragBuffered(e, t) {
    const { frag: s, part: r } = t,
      i = r != null && r.stats.loaded ? r.stats : s.stats;
    if (i.aborted || this.ignoreFragment(s)) return;
    const a =
      i.parsing.end -
      i.loading.start -
      Math.min(
        i.loading.first - i.loading.start,
        this.bwEstimator.getEstimateTTFB()
      );
    this.bwEstimator.sample(a, i.loaded),
      (i.bwEstimate = this.getBwEstimate()),
      s.bitrateTest
        ? (this.bitrateTestDelay = a / 1e3)
        : (this.bitrateTestDelay = 0);
  }
  ignoreFragment(e) {
    return e.type !== lt.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    this.timer > -1 && (self.clearInterval(this.timer), (this.timer = -1));
  }
  get firstAutoLevel() {
    const { maxAutoLevel: e, minAutoLevel: t } = this.hls,
      s = this.getBwEstimate(),
      r = this.hls.config.maxStarvationDelay,
      i = this.findBestLevel(s, t, e, 0, r, 1, 1);
    if (i > -1) return i;
    const a = this.hls.firstLevel,
      o = Math.min(Math.max(a, t), e);
    return (
      this.warn(
        `Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`
      ),
      o
    );
  }
  get forcedAutoLevel() {
    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
  }
  get nextAutoLevel() {
    const e = this.forcedAutoLevel,
      s = this.bwEstimator.canEstimate(),
      r = this.lastLoadedFragLevel > -1;
    if (
      e !== -1 &&
      (!s || !r || this.nextAutoLevelKey === this.getAutoLevelKey())
    )
      return e;
    const i = s && r ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (e !== -1) {
      const a = this.hls.levels;
      if (a.length > Math.max(e, i) && a[e].loadError <= a[i].loadError)
        return e;
    }
    return (
      (this._nextAutoLevel = i),
      (this.nextAutoLevelKey = this.getAutoLevelKey()),
      i
    );
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const { fragCurrent: e, partCurrent: t, hls: s } = this;
    if (s.levels.length <= 1) return s.loadLevel;
    const { maxAutoLevel: r, config: i, minAutoLevel: a } = s,
      o = t ? t.duration : e ? e.duration : 0,
      l = this.getBwEstimate(),
      c = this.getStarvationDelay();
    let h = i.abrBandWidthFactor,
      m = i.abrBandWidthUpFactor;
    if (c) {
      const w = this.findBestLevel(l, a, r, c, 0, h, m);
      if (w >= 0) return (this.rebufferNotice = -1), w;
    }
    let p = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay;
    if (!c) {
      const w = this.bitrateTestDelay;
      w &&
        ((p = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - w),
        this.info(
          `bitrate test took ${Math.round(
            1e3 * w
          )}ms, set first fragment max fetchDuration to ${Math.round(
            1e3 * p
          )} ms`
        ),
        (h = m = 1));
    }
    const g = this.findBestLevel(l, a, r, c, p, h, m);
    if (
      (this.rebufferNotice !== g &&
        ((this.rebufferNotice = g),
        this.info(
          `${
            c ? "rebuffering expected" : "buffer is empty"
          }, optimal quality level ${g}`
        )),
      g > -1)
    )
      return g;
    const y = s.levels[a],
      b = s.loadLevelObj;
    return b && y?.bitrate < b.bitrate ? a : s.loadLevel;
  }
  getStarvationDelay() {
    const e = this.hls,
      t = e.media;
    if (!t) return 1 / 0;
    const s = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1,
      r = e.mainForwardBufferInfo;
    return (r ? r.len : 0) / s;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate()
      ? this.bwEstimator.getEstimate()
      : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(e, t, s, r, i, a, o) {
    var l;
    const c = r + i,
      h = this.lastLoadedFragLevel,
      m = h === -1 ? this.hls.firstLevel : h,
      { fragCurrent: p, partCurrent: g } = this,
      { levels: y, allAudioTracks: b, loadLevel: w, config: S } = this.hls;
    if (y.length === 1) return 0;
    const A = y[m],
      _ = !!((l = this.hls.latestLevelDetails) != null && l.live),
      R = w === -1 || h === -1;
    let C,
      D = "SDR",
      L = A?.frameRate || 0;
    const { audioPreference: P, videoPreference: V } = S,
      N = this.audioTracksByGroup || (this.audioTracksByGroup = bY(b));
    let W = -1;
    if (R) {
      if (this.firstSelection !== -1) return this.firstSelection;
      const U = this.codecTiers || (this.codecTiers = MRe(y, N, t, s)),
        j = PRe(U, D, e, P, V),
        {
          codecSet: Q,
          videoRanges: M,
          minFramerate: I,
          minBitrate: F,
          minIndex: Y,
          preferHDR: J,
        } = j;
      (W = Y),
        (C = Q),
        (D = J ? M[M.length - 1] : M[0]),
        (L = I),
        (e = Math.max(e, F)),
        this.log(`picked start tier ${Wn(j)}`);
    } else (C = A?.codecSet), (D = A?.videoRange);
    const H = g ? g.duration : p ? p.duration : 0,
      z = this.bwEstimator.getEstimateTTFB() / 1e3,
      B = [];
    for (let U = s; U >= t; U--) {
      var q, O;
      const j = y[U],
        Q = U > m;
      if (!j) continue;
      if (S.useMediaCapabilities && !j.supportedResult && !j.supportedPromise) {
        const Z = navigator.mediaCapabilities;
        typeof Z?.decodingInfo == "function" && SRe(j, N, D, L, e, P)
          ? ((j.supportedPromise = vY(j, N, Z, this.supportedCache)),
            j.supportedPromise.then((te) => {
              if (!this.hls) return;
              j.supportedResult = te;
              const ce = this.hls.levels,
                pe = ce.indexOf(j);
              te.error
                ? this.warn(
                    `MediaCapabilities decodingInfo error: "${
                      te.error
                    }" for level ${pe} ${Wn(te)}`
                  )
                : te.supported
                ? te.decodingInfoResults.some(
                    (se) => se.smooth === !1 || se.powerEfficient === !1
                  ) &&
                  this.log(
                    `MediaCapabilities decodingInfo for level ${pe} not smooth or powerEfficient: ${Wn(
                      te
                    )}`
                  )
                : (this.warn(
                    `Unsupported MediaCapabilities decodingInfo result for level ${pe} ${Wn(
                      te
                    )}`
                  ),
                  pe > -1 &&
                    ce.length > 1 &&
                    (this.log(`Removing unsupported level ${pe}`),
                    this.hls.removeLevel(pe),
                    this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
            }))
          : (j.supportedResult = pY);
      }
      if (
        ((C && j.codecSet !== C) ||
          (D && j.videoRange !== D) ||
          (Q && L > j.frameRate) ||
          (!Q && L > 0 && L < j.frameRate) ||
          ((q = j.supportedResult) != null &&
            (O = q.decodingInfoResults) != null &&
            O.some((Z) => Z.smooth === !1))) &&
        (!R || U !== W)
      ) {
        B.push(U);
        continue;
      }
      const M = j.details,
        I = (g ? M?.partTarget : M?.averagetargetduration) || H;
      let F;
      Q ? (F = o * e) : (F = a * e);
      const Y = H && r >= H * 2 && i === 0 ? j.averageBitrate : j.maxBitrate,
        J = this.getTimeToLoadFrag(z, F, Y * I, M === void 0);
      if (
        F >= Y &&
        (U === h || (j.loadError === 0 && j.fragmentError === 0)) &&
        (J <= z || !Qe(J) || (_ && !this.bitrateTestDelay) || J < c)
      ) {
        const Z = this.forcedAutoLevel;
        return (
          U !== w &&
            (Z === -1 || Z !== w) &&
            (B.length &&
              this.trace(
                `Skipped level(s) ${B.join(
                  ","
                )} of ${s} max with CODECS and VIDEO-RANGE:"${
                  y[B[0]].codecs
                }" ${y[B[0]].videoRange}; not compatible with "${C}" ${D}`
              ),
            this.info(
              `switch candidate:${m}->${U} adjustedbw(${Math.round(
                F
              )})-bitrate=${Math.round(F - Y)} ttfb:${z.toFixed(
                1
              )} avgDuration:${I.toFixed(1)} maxFetchDuration:${c.toFixed(
                1
              )} fetchDuration:${J.toFixed(1)} firstSelection:${R} codecSet:${
                j.codecSet
              } videoRange:${j.videoRange} hls.loadLevel:${w}`
            )),
          R && (this.firstSelection = U),
          U
        );
      }
    }
    return -1;
  }
  set nextAutoLevel(e) {
    const t = this.deriveNextAutoLevel(e);
    this._nextAutoLevel !== t &&
      ((this.nextAutoLevelKey = ""), (this._nextAutoLevel = t));
  }
  deriveNextAutoLevel(e) {
    const { maxAutoLevel: t, minAutoLevel: s } = this.hls;
    return Math.min(Math.max(e, s), t);
  }
}
const xY = {
  search: function (n, e) {
    let t = 0,
      s = n.length - 1,
      r = null,
      i = null;
    for (; t <= s; ) {
      (r = ((t + s) / 2) | 0), (i = n[r]);
      const a = e(i);
      if (a > 0) t = r + 1;
      else if (a < 0) s = r - 1;
      else return i;
    }
    return null;
  },
};
function URe(n, e, t) {
  if (e === null || !Array.isArray(n) || !n.length || !Qe(e)) return null;
  const s = n[0].programDateTime;
  if (e < (s || 0)) return null;
  const r = n[n.length - 1].endProgramDateTime;
  if (e >= (r || 0)) return null;
  for (let i = 0; i < n.length; ++i) {
    const a = n[i];
    if (BRe(e, t, a)) return a;
  }
  return null;
}
function id(n, e, t = 0, s = 0, r = 0.005) {
  let i = null;
  if (n) {
    i = e[1 + n.sn - e[0].sn] || null;
    const o = n.endDTS - t;
    o > 0 && o < 15e-7 && (t += 15e-7),
      i &&
        n.level !== i.level &&
        i.end <= n.end &&
        (i = e[2 + n.sn - e[0].sn] || null);
  } else t === 0 && e[0].start === 0 && (i = e[0]);
  if (
    i &&
    (((!n || n.level === i.level) && kB(t, s, i) === 0) ||
      $Re(i, n, Math.min(r, s)))
  )
    return i;
  const a = xY.search(e, kB.bind(null, t, s));
  return a && (a !== n || !i) ? a : i;
}
function $Re(n, e, t) {
  if (e && e.start === 0 && e.level < n.level && (e.endPTS || 0) > 0) {
    const s = e.tagList.reduce(
      (r, i) => (i[0] === "INF" && (r += parseFloat(i[1])), r),
      t
    );
    return n.start <= s;
  }
  return !1;
}
function kB(n = 0, e = 0, t) {
  if (t.start <= n && t.start + t.duration > n) return 0;
  const s = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
  return t.start + t.duration - s <= n
    ? 1
    : t.start - s > n && t.start
    ? -1
    : 0;
}
function BRe(n, e, t) {
  const s = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
  return (t.endProgramDateTime || 0) - s > n;
}
function wY(n, e, t) {
  if (n && n.startCC <= e && n.endCC >= e) {
    let s = n.fragments;
    const { fragmentHint: r } = n;
    r && (s = s.concat(r));
    let i;
    return (
      xY.search(s, (a) =>
        a.cc < e
          ? 1
          : a.cc > e
          ? -1
          : ((i = a), a.end <= t ? 1 : a.start > t ? -1 : 0)
      ),
      i || null
    );
  }
  return null;
}
function Xw(n) {
  switch (n.details) {
    case we.FRAG_LOAD_TIMEOUT:
    case we.KEY_LOAD_TIMEOUT:
    case we.LEVEL_LOAD_TIMEOUT:
    case we.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function CB(n, e) {
  const t = Xw(e);
  return n.default[`${t ? "timeout" : "error"}Retry`];
}
function WP(n, e) {
  const t = n.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(t * n.retryDelayMs, n.maxRetryDelayMs);
}
function IB(n) {
  return In(In({}, n), { errorRetry: null, timeoutRetry: null });
}
function Qw(n, e, t, s) {
  if (!n) return !1;
  const r = s?.code,
    i = e < n.maxNumRetry && (HRe(r) || !!t);
  return n.shouldRetry ? n.shouldRetry(n, e, t, s, i) : i;
}
function HRe(n) {
  return (n === 0 && navigator.onLine === !1) || (!!n && (n < 400 || n > 499));
}
var kr = {
    DoNothing: 0,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    RetryRequest: 5,
  },
  _a = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
  };
class VRe extends za {
  constructor(e) {
    super("error-controller", e.logger),
      (this.hls = void 0),
      (this.playlistError = 0),
      (this.penalizedRenditions = {}),
      (this.hls = e),
      this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on($.ERROR, this.onError, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e &&
      (e.off($.ERROR, this.onError, this),
      e.off($.ERROR, this.onErrorOut, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.LEVEL_UPDATED, this.onLevelUpdated, this));
  }
  destroy() {
    this.unregisterListeners(),
      (this.hls = null),
      (this.penalizedRenditions = {});
  }
  startLoad(e) {}
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(e) {
    return e?.type === lt.MAIN ? e.level : this.hls.loadLevel;
  }
  onManifestLoading() {
    (this.playlistError = 0), (this.penalizedRenditions = {});
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(e, t) {
    var s;
    if (t.fatal) return;
    const r = this.hls,
      i = t.context;
    switch (t.details) {
      case we.FRAG_LOAD_ERROR:
      case we.FRAG_LOAD_TIMEOUT:
      case we.KEY_LOAD_ERROR:
      case we.KEY_LOAD_TIMEOUT:
        t.errorAction = this.getFragRetryOrSwitchAction(t);
        return;
      case we.FRAG_PARSING_ERROR:
        if ((s = t.frag) != null && s.gap) {
          t.errorAction = mv();
          return;
        }
      case we.FRAG_GAP:
      case we.FRAG_DECRYPT_ERROR: {
        (t.errorAction = this.getFragRetryOrSwitchAction(t)),
          (t.errorAction.action = kr.SendAlternateToPenaltyBox);
        return;
      }
      case we.LEVEL_EMPTY_ERROR:
      case we.LEVEL_PARSING_ERROR:
        {
          var a, o;
          const c = t.parent === lt.MAIN ? t.level : r.loadLevel;
          t.details === we.LEVEL_EMPTY_ERROR &&
          (a = t.context) != null &&
          (o = a.levelDetails) != null &&
          o.live
            ? (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, c))
            : ((t.levelRetry = !1),
              (t.errorAction = this.getLevelSwitchAction(t, c)));
        }
        return;
      case we.LEVEL_LOAD_ERROR:
      case we.LEVEL_LOAD_TIMEOUT:
        typeof i?.level == "number" &&
          (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level));
        return;
      case we.AUDIO_TRACK_LOAD_ERROR:
      case we.AUDIO_TRACK_LOAD_TIMEOUT:
      case we.SUBTITLE_LOAD_ERROR:
      case we.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (i) {
          const c = r.loadLevelObj;
          if (
            c &&
            ((i.type === en.AUDIO_TRACK && c.hasAudioGroup(i.groupId)) ||
              (i.type === en.SUBTITLE_TRACK && c.hasSubtitleGroup(i.groupId)))
          ) {
            (t.errorAction = this.getPlaylistRetryOrSwitchAction(
              t,
              r.loadLevel
            )),
              (t.errorAction.action = kr.SendAlternateToPenaltyBox),
              (t.errorAction.flags = _a.MoveAllAlternatesMatchingHost);
            return;
          }
        }
        return;
      case we.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const c = r.loadLevelObj,
            h = c?.attrs["HDCP-LEVEL"];
          h
            ? (t.errorAction = {
                action: kr.SendAlternateToPenaltyBox,
                flags: _a.MoveAllAlternatesMatchingHDCP,
                hdcpLevel: h,
              })
            : this.keySystemError(t);
        }
        return;
      case we.BUFFER_ADD_CODEC_ERROR:
      case we.REMUX_ALLOC_ERROR:
      case we.BUFFER_APPEND_ERROR:
        if (!t.errorAction) {
          var l;
          t.errorAction = this.getLevelSwitchAction(
            t,
            (l = t.level) != null ? l : r.loadLevel
          );
        }
        return;
      case we.INTERNAL_EXCEPTION:
      case we.BUFFER_APPENDING_ERROR:
      case we.BUFFER_FULL_ERROR:
      case we.LEVEL_SWITCH_ERROR:
      case we.BUFFER_STALLED_ERROR:
      case we.BUFFER_SEEK_OVER_HOLE:
      case we.BUFFER_NUDGE_ON_STALL:
        t.errorAction = mv();
        return;
    }
    t.type === gt.KEY_SYSTEM_ERROR && this.keySystemError(t);
  }
  keySystemError(e) {
    const t = this.getVariantLevelIndex(e.frag);
    (e.levelRetry = !1), (e.errorAction = this.getLevelSwitchAction(e, t));
  }
  getPlaylistRetryOrSwitchAction(e, t) {
    const s = this.hls,
      r = CB(s.config.playlistLoadPolicy, e),
      i = this.playlistError++;
    if (Qw(r, i, Xw(e), e.response))
      return {
        action: kr.RetryRequest,
        flags: _a.None,
        retryConfig: r,
        retryCount: i,
      };
    const o = this.getLevelSwitchAction(e, t);
    return r && ((o.retryConfig = r), (o.retryCount = i)), o;
  }
  getFragRetryOrSwitchAction(e) {
    const t = this.hls,
      s = this.getVariantLevelIndex(e.frag),
      r = t.levels[s],
      { fragLoadPolicy: i, keyLoadPolicy: a } = t.config,
      o = CB(e.details.startsWith("key") ? a : i, e),
      l = t.levels.reduce((h, m) => h + m.fragmentError, 0);
    if (
      r &&
      (e.details !== we.FRAG_GAP && r.fragmentError++,
      Qw(o, l, Xw(e), e.response))
    )
      return {
        action: kr.RetryRequest,
        flags: _a.None,
        retryConfig: o,
        retryCount: l,
      };
    const c = this.getLevelSwitchAction(e, s);
    return o && ((c.retryConfig = o), (c.retryCount = l)), c;
  }
  getLevelSwitchAction(e, t) {
    const s = this.hls;
    t == null && (t = s.loadLevel);
    const r = this.hls.levels[t];
    if (r) {
      var i, a;
      const c = e.details;
      r.loadError++, c === we.BUFFER_APPEND_ERROR && r.fragmentError++;
      let h = -1;
      const { levels: m, loadLevel: p, minAutoLevel: g, maxAutoLevel: y } = s;
      !s.autoLevelEnabled &&
        !s.config.preserveManualLevelOnError &&
        (s.loadLevel = -1);
      const b = (i = e.frag) == null ? void 0 : i.type,
        S =
          ((b === lt.AUDIO && c === we.FRAG_PARSING_ERROR) ||
            (e.sourceBufferName === "audio" &&
              (c === we.BUFFER_ADD_CODEC_ERROR ||
                c === we.BUFFER_APPEND_ERROR))) &&
          m.some(({ audioCodec: D }) => r.audioCodec !== D),
        _ =
          e.sourceBufferName === "video" &&
          (c === we.BUFFER_ADD_CODEC_ERROR || c === we.BUFFER_APPEND_ERROR) &&
          m.some(
            ({ codecSet: D, audioCodec: L }) =>
              r.codecSet !== D && r.audioCodec === L
          ),
        { type: R, groupId: C } = (a = e.context) != null ? a : {};
      for (let D = m.length; D--; ) {
        const L = (D + p) % m.length;
        if (L !== p && L >= g && L <= y && m[L].loadError === 0) {
          var o, l;
          const P = m[L];
          if (c === we.FRAG_GAP && b === lt.MAIN && e.frag) {
            const V = m[L].details;
            if (V) {
              const N = id(e.frag, V.fragments, e.frag.start);
              if (N != null && N.gap) continue;
            }
          } else {
            if (
              (R === en.AUDIO_TRACK && P.hasAudioGroup(C)) ||
              (R === en.SUBTITLE_TRACK && P.hasSubtitleGroup(C))
            )
              continue;
            if (
              (b === lt.AUDIO &&
                (o = r.audioGroups) != null &&
                o.some((V) => P.hasAudioGroup(V))) ||
              (b === lt.SUBTITLE &&
                (l = r.subtitleGroups) != null &&
                l.some((V) => P.hasSubtitleGroup(V))) ||
              (S && r.audioCodec === P.audioCodec) ||
              (!S && r.audioCodec !== P.audioCodec) ||
              (_ && r.codecSet === P.codecSet)
            )
              continue;
          }
          h = L;
          break;
        }
      }
      if (h > -1 && s.loadLevel !== h)
        return (
          (e.levelRetry = !0),
          (this.playlistError = 0),
          {
            action: kr.SendAlternateToPenaltyBox,
            flags: _a.None,
            nextAutoLevel: h,
          }
        );
    }
    return {
      action: kr.SendAlternateToPenaltyBox,
      flags: _a.MoveAllAlternatesMatchingHost,
    };
  }
  onErrorOut(e, t) {
    var s;
    switch ((s = t.errorAction) == null ? void 0 : s.action) {
      case kr.DoNothing:
        break;
      case kr.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(t),
          !t.errorAction.resolved && t.details !== we.FRAG_GAP
            ? (t.fatal = !0)
            : /MediaSource readyState: ended/.test(t.error.message) &&
              (this.warn(
                `MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`
              ),
              this.hls.recoverMediaError());
        break;
    }
    if (t.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const t = this.hls,
      s = e.errorAction;
    if (!s) return;
    const { flags: r, hdcpLevel: i, nextAutoLevel: a } = s;
    switch (r) {
      case _a.None:
        this.switchLevel(e, a);
        break;
      case _a.MoveAllAlternatesMatchingHDCP:
        i && ((t.maxHdcpLevel = rI[rI.indexOf(i) - 1]), (s.resolved = !0)),
          this.warn(
            `Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`
          );
        break;
    }
    s.resolved || this.switchLevel(e, a);
  }
  switchLevel(e, t) {
    if (
      t !== void 0 &&
      e.errorAction &&
      (this.warn(`switching to level ${t} after ${e.details}`),
      (this.hls.nextAutoLevel = t),
      (e.errorAction.resolved = !0),
      (this.hls.nextLoadLevel = this.hls.nextAutoLevel),
      e.details === we.BUFFER_ADD_CODEC_ERROR &&
        e.mimeType &&
        e.sourceBufferName !== "audiovideo")
    ) {
      const s = sI(e.mimeType),
        r = this.hls.levels;
      for (let i = r.length; i--; )
        r[i][`${e.sourceBufferName}Codec`] === s && this.hls.removeLevel(i);
    }
  }
}
function mv(n) {
  const e = { action: kr.DoNothing, flags: _a.None };
  return n && (e.resolved = !0), e;
}
var qs = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK",
};
class zRe {
  constructor(e) {
    (this.activePartLists = Object.create(null)),
      (this.endListFragments = Object.create(null)),
      (this.fragments = Object.create(null)),
      (this.timeRanges = Object.create(null)),
      (this.bufferPadding = 0.2),
      (this.hls = void 0),
      (this.hasGaps = !1),
      (this.hls = e),
      this._registerListeners();
  }
  _registerListeners() {
    const { hls: e } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.BUFFER_APPENDED, this.onBufferAppended, this),
      e.on($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on($.FRAG_LOADED, this.onFragLoaded, this);
  }
  _unregisterListeners() {
    const { hls: e } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.BUFFER_APPENDED, this.onBufferAppended, this),
      e.off($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off($.FRAG_LOADED, this.onFragLoaded, this);
  }
  destroy() {
    this._unregisterListeners(),
      (this.fragments =
        this.activePartLists =
        this.endListFragments =
        this.timeRanges =
          null);
  }
  getAppendedFrag(e, t) {
    const s = this.activePartLists[t];
    if (s)
      for (let r = s.length; r--; ) {
        const i = s[r];
        if (!i) break;
        const a = i.end;
        if (i.start <= e && a !== null && e <= a) return i;
      }
    return this.getBufferedFrag(e, t);
  }
  getBufferedFrag(e, t) {
    return this.getFragAtPos(e, t, !0);
  }
  getFragAtPos(e, t, s) {
    const { fragments: r } = this,
      i = Object.keys(r);
    for (let a = i.length; a--; ) {
      const o = r[i[a]];
      if (o?.body.type === t && (!s || o.buffered)) {
        const l = o.body;
        if (l.start <= e && e <= l.end) return l;
      }
    }
    return null;
  }
  detectEvictedFragments(e, t, s, r, i) {
    this.timeRanges && (this.timeRanges[e] = t);
    const a = r?.fragment.sn || -1;
    Object.keys(this.fragments).forEach((o) => {
      const l = this.fragments[o];
      if (!l || a >= l.body.sn) return;
      if (!l.buffered && (!l.loaded || i)) {
        l.body.type === s && this.removeFragment(l.body);
        return;
      }
      const c = l.range[e];
      if (c) {
        if (c.time.length === 0) {
          this.removeFragment(l.body);
          return;
        }
        c.time.some((h) => {
          const m = !this.isTimeBuffered(h.startPTS, h.endPTS, t);
          return m && this.removeFragment(l.body), m;
        });
      }
    });
  }
  detectPartialFragments(e) {
    const t = this.timeRanges;
    if (!t || e.frag.sn === "initSegment") return;
    const s = e.frag,
      r = bh(s),
      i = this.fragments[r];
    if (!i || (i.buffered && s.gap)) return;
    const a = !s.relurl;
    Object.keys(t).forEach((o) => {
      const l = s.elementaryStreams[o];
      if (!l) return;
      const c = t[o],
        h = a || l.partial === !0;
      i.range[o] = this.getBufferedTimes(s, e.part, h, c);
    }),
      (i.loaded = null),
      Object.keys(i.range).length
        ? ((i.buffered = !0),
          (i.body.endList = s.endList || i.body.endList) &&
            (this.endListFragments[i.body.type] = i),
          Jy(i) || this.removeParts(s.sn - 1, s.type))
        : this.removeFragment(i.body);
  }
  removeParts(e, t) {
    const s = this.activePartLists[t];
    s && (this.activePartLists[t] = LB(s, (r) => r.fragment.sn >= e));
  }
  fragBuffered(e, t) {
    const s = bh(e);
    let r = this.fragments[s];
    !r &&
      t &&
      ((r = this.fragments[s] =
        {
          body: e,
          appendedPTS: null,
          loaded: null,
          buffered: !1,
          range: Object.create(null),
        }),
      e.gap && (this.hasGaps = !0)),
      r && ((r.loaded = null), (r.buffered = !0));
  }
  getBufferedTimes(e, t, s, r) {
    const i = { time: [], partial: s },
      a = e.start,
      o = e.end,
      l = e.minEndPTS || o,
      c = e.maxStartPTS || a;
    for (let h = 0; h < r.length; h++) {
      const m = r.start(h) - this.bufferPadding,
        p = r.end(h) + this.bufferPadding;
      if (c >= m && l <= p) {
        i.time.push({
          startPTS: Math.max(a, r.start(h)),
          endPTS: Math.min(o, r.end(h)),
        });
        break;
      } else if (a < p && o > m) {
        const g = Math.max(a, r.start(h)),
          y = Math.min(o, r.end(h));
        y > g && ((i.partial = !0), i.time.push({ startPTS: g, endPTS: y }));
      } else if (o <= m) break;
    }
    return i;
  }
  getPartialFragment(e) {
    let t = null,
      s,
      r,
      i,
      a = 0;
    const { bufferPadding: o, fragments: l } = this;
    return (
      Object.keys(l).forEach((c) => {
        const h = l[c];
        h &&
          Jy(h) &&
          ((r = h.body.start - o),
          (i = h.body.end + o),
          e >= r &&
            e <= i &&
            ((s = Math.min(e - r, i - e)), a <= s && ((t = h.body), (a = s))));
      }),
      t
    );
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e];
    return t !== void 0 && (t.buffered || Jy(t));
  }
  getState(e) {
    const t = bh(e),
      s = this.fragments[t];
    return s
      ? s.buffered
        ? Jy(s)
          ? qs.PARTIAL
          : qs.OK
        : qs.APPENDING
      : qs.NOT_LOADED;
  }
  isTimeBuffered(e, t, s) {
    let r, i;
    for (let a = 0; a < s.length; a++) {
      if (
        ((r = s.start(a) - this.bufferPadding),
        (i = s.end(a) + this.bufferPadding),
        e >= r && t <= i)
      )
        return !0;
      if (t <= r) return !1;
    }
    return !1;
  }
  onManifestLoading() {
    this.removeAllFragments();
  }
  onFragLoaded(e, t) {
    if (t.frag.sn === "initSegment" || t.frag.bitrateTest) return;
    const s = t.frag,
      r = t.part ? null : t,
      i = bh(s);
    this.fragments[i] = {
      body: s,
      appendedPTS: null,
      loaded: r,
      buffered: !1,
      range: Object.create(null),
    };
  }
  onBufferAppended(e, t) {
    const { frag: s, part: r, timeRanges: i, type: a } = t;
    if (s.sn === "initSegment") return;
    const o = s.type;
    if (r) {
      let c = this.activePartLists[o];
      c || (this.activePartLists[o] = c = []), c.push(r);
    }
    this.timeRanges = i;
    const l = i[a];
    this.detectEvictedFragments(a, l, o, r);
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t);
  }
  hasFragment(e) {
    const t = bh(e);
    return !!this.fragments[t];
  }
  hasFragments(e) {
    const { fragments: t } = this,
      s = Object.keys(t);
    if (!e) return s.length > 0;
    for (let r = s.length; r--; ) {
      const i = t[s[r]];
      if (i?.body.type === e) return !0;
    }
    return !1;
  }
  hasParts(e) {
    var t;
    return !!((t = this.activePartLists[e]) != null && t.length);
  }
  removeFragmentsInRange(e, t, s, r, i) {
    (r && !this.hasGaps) ||
      Object.keys(this.fragments).forEach((a) => {
        const o = this.fragments[a];
        if (!o) return;
        const l = o.body;
        l.type !== s ||
          (r && !l.gap) ||
          (l.start < t &&
            l.end > e &&
            (o.buffered || i) &&
            this.removeFragment(l));
      });
  }
  removeFragment(e) {
    const t = bh(e);
    e.clearElementaryStreamInfo();
    const s = this.activePartLists[e.type];
    if (s) {
      const r = e.sn;
      this.activePartLists[e.type] = LB(s, (i) => i.fragment.sn !== r);
    }
    delete this.fragments[t], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    var e, t;
    (this.fragments = Object.create(null)),
      (this.endListFragments = Object.create(null)),
      (this.activePartLists = Object.create(null)),
      (this.hasGaps = !1);
    const s =
      (e = this.hls) == null || (t = e.latestLevelDetails) == null
        ? void 0
        : t.partList;
    s && s.forEach((r) => r.clearElementaryStreamInfo());
  }
}
function Jy(n) {
  var e, t, s;
  return (
    n.buffered &&
    (n.body.gap ||
      ((e = n.range.video) == null ? void 0 : e.partial) ||
      ((t = n.range.audio) == null ? void 0 : t.partial) ||
      ((s = n.range.audiovideo) == null ? void 0 : s.partial))
  );
}
function bh(n) {
  return `${n.type}_${n.level}_${n.sn}`;
}
function LB(n, e) {
  return n.filter((t) => {
    const s = e(t);
    return s || t.clearElementaryStreamInfo(), s;
  });
}
var Hc = { cbc: 0, ctr: 1 };
class GRe {
  constructor(e, t, s) {
    (this.subtle = void 0),
      (this.aesIV = void 0),
      (this.aesMode = void 0),
      (this.subtle = e),
      (this.aesIV = t),
      (this.aesMode = s);
  }
  decrypt(e, t) {
    switch (this.aesMode) {
      case Hc.cbc:
        return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e);
      case Hc.ctr:
        return this.subtle.decrypt(
          { name: "AES-CTR", counter: this.aesIV, length: 64 },
          t,
          e
        );
      default:
        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
    }
  }
}
function qRe(n) {
  const e = n.byteLength,
    t = e && new DataView(n.buffer).getUint8(e - 1);
  return t ? n.slice(0, e - t) : n;
}
class WRe {
  constructor() {
    (this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]),
      (this.subMix = [
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
      ]),
      (this.invSubMix = [
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
      ]),
      (this.sBox = new Uint32Array(256)),
      (this.invSBox = new Uint32Array(256)),
      (this.key = new Uint32Array(0)),
      (this.ksRows = 0),
      (this.keySize = 0),
      (this.keySchedule = void 0),
      (this.invKeySchedule = void 0),
      this.initTable();
  }
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e),
      s = new Uint32Array(4);
    for (let r = 0; r < 4; r++) s[r] = t.getUint32(r * 4);
    return s;
  }
  initTable() {
    const e = this.sBox,
      t = this.invSBox,
      s = this.subMix,
      r = s[0],
      i = s[1],
      a = s[2],
      o = s[3],
      l = this.invSubMix,
      c = l[0],
      h = l[1],
      m = l[2],
      p = l[3],
      g = new Uint32Array(256);
    let y = 0,
      b = 0,
      w = 0;
    for (w = 0; w < 256; w++)
      w < 128 ? (g[w] = w << 1) : (g[w] = (w << 1) ^ 283);
    for (w = 0; w < 256; w++) {
      let S = b ^ (b << 1) ^ (b << 2) ^ (b << 3) ^ (b << 4);
      (S = (S >>> 8) ^ (S & 255) ^ 99), (e[y] = S), (t[S] = y);
      const A = g[y],
        _ = g[A],
        R = g[_];
      let C = (g[S] * 257) ^ (S * 16843008);
      (r[y] = (C << 24) | (C >>> 8)),
        (i[y] = (C << 16) | (C >>> 16)),
        (a[y] = (C << 8) | (C >>> 24)),
        (o[y] = C),
        (C = (R * 16843009) ^ (_ * 65537) ^ (A * 257) ^ (y * 16843008)),
        (c[S] = (C << 24) | (C >>> 8)),
        (h[S] = (C << 16) | (C >>> 16)),
        (m[S] = (C << 8) | (C >>> 24)),
        (p[S] = C),
        y ? ((y = A ^ g[g[g[R ^ A]]]), (b ^= g[g[b]])) : (y = b = 1);
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e);
    let s = !0,
      r = 0;
    for (; r < t.length && s; ) (s = t[r] === this.key[r]), r++;
    if (s) return;
    this.key = t;
    const i = (this.keySize = t.length);
    if (i !== 4 && i !== 6 && i !== 8)
      throw new Error("Invalid aes key size=" + i);
    const a = (this.ksRows = (i + 6 + 1) * 4);
    let o, l;
    const c = (this.keySchedule = new Uint32Array(a)),
      h = (this.invKeySchedule = new Uint32Array(a)),
      m = this.sBox,
      p = this.rcon,
      g = this.invSubMix,
      y = g[0],
      b = g[1],
      w = g[2],
      S = g[3];
    let A, _;
    for (o = 0; o < a; o++) {
      if (o < i) {
        A = c[o] = t[o];
        continue;
      }
      (_ = A),
        o % i === 0
          ? ((_ = (_ << 8) | (_ >>> 24)),
            (_ =
              (m[_ >>> 24] << 24) |
              (m[(_ >>> 16) & 255] << 16) |
              (m[(_ >>> 8) & 255] << 8) |
              m[_ & 255]),
            (_ ^= p[(o / i) | 0] << 24))
          : i > 6 &&
            o % i === 4 &&
            (_ =
              (m[_ >>> 24] << 24) |
              (m[(_ >>> 16) & 255] << 16) |
              (m[(_ >>> 8) & 255] << 8) |
              m[_ & 255]),
        (c[o] = A = (c[o - i] ^ _) >>> 0);
    }
    for (l = 0; l < a; l++)
      (o = a - l),
        l & 3 ? (_ = c[o]) : (_ = c[o - 4]),
        l < 4 || o <= 4
          ? (h[l] = _)
          : (h[l] =
              y[m[_ >>> 24]] ^
              b[m[(_ >>> 16) & 255]] ^
              w[m[(_ >>> 8) & 255]] ^
              S[m[_ & 255]]),
        (h[l] = h[l] >>> 0);
  }
  networkToHostOrderSwap(e) {
    return (e << 24) | ((e & 65280) << 8) | ((e & 16711680) >> 8) | (e >>> 24);
  }
  decrypt(e, t, s) {
    const r = this.keySize + 6,
      i = this.invKeySchedule,
      a = this.invSBox,
      o = this.invSubMix,
      l = o[0],
      c = o[1],
      h = o[2],
      m = o[3],
      p = this.uint8ArrayToUint32Array_(s);
    let g = p[0],
      y = p[1],
      b = p[2],
      w = p[3];
    const S = new Int32Array(e),
      A = new Int32Array(S.length);
    let _, R, C, D, L, P, V, N, W, H, z, B, q, O;
    const U = this.networkToHostOrderSwap;
    for (; t < S.length; ) {
      for (
        W = U(S[t]),
          H = U(S[t + 1]),
          z = U(S[t + 2]),
          B = U(S[t + 3]),
          L = W ^ i[0],
          P = B ^ i[1],
          V = z ^ i[2],
          N = H ^ i[3],
          q = 4,
          O = 1;
        O < r;
        O++
      )
        (_ =
          l[L >>> 24] ^
          c[(P >> 16) & 255] ^
          h[(V >> 8) & 255] ^
          m[N & 255] ^
          i[q]),
          (R =
            l[P >>> 24] ^
            c[(V >> 16) & 255] ^
            h[(N >> 8) & 255] ^
            m[L & 255] ^
            i[q + 1]),
          (C =
            l[V >>> 24] ^
            c[(N >> 16) & 255] ^
            h[(L >> 8) & 255] ^
            m[P & 255] ^
            i[q + 2]),
          (D =
            l[N >>> 24] ^
            c[(L >> 16) & 255] ^
            h[(P >> 8) & 255] ^
            m[V & 255] ^
            i[q + 3]),
          (L = _),
          (P = R),
          (V = C),
          (N = D),
          (q = q + 4);
      (_ =
        (a[L >>> 24] << 24) ^
        (a[(P >> 16) & 255] << 16) ^
        (a[(V >> 8) & 255] << 8) ^
        a[N & 255] ^
        i[q]),
        (R =
          (a[P >>> 24] << 24) ^
          (a[(V >> 16) & 255] << 16) ^
          (a[(N >> 8) & 255] << 8) ^
          a[L & 255] ^
          i[q + 1]),
        (C =
          (a[V >>> 24] << 24) ^
          (a[(N >> 16) & 255] << 16) ^
          (a[(L >> 8) & 255] << 8) ^
          a[P & 255] ^
          i[q + 2]),
        (D =
          (a[N >>> 24] << 24) ^
          (a[(L >> 16) & 255] << 16) ^
          (a[(P >> 8) & 255] << 8) ^
          a[V & 255] ^
          i[q + 3]),
        (A[t] = U(_ ^ g)),
        (A[t + 1] = U(D ^ y)),
        (A[t + 2] = U(C ^ b)),
        (A[t + 3] = U(R ^ w)),
        (g = W),
        (y = H),
        (b = z),
        (w = B),
        (t = t + 4);
    }
    return A.buffer;
  }
}
class KRe {
  constructor(e, t, s) {
    (this.subtle = void 0),
      (this.key = void 0),
      (this.aesMode = void 0),
      (this.subtle = e),
      (this.key = t),
      (this.aesMode = s);
  }
  expandKey() {
    const e = YRe(this.aesMode);
    return this.subtle.importKey("raw", this.key, { name: e }, !1, [
      "encrypt",
      "decrypt",
    ]);
  }
}
function YRe(n) {
  switch (n) {
    case Hc.cbc:
      return "AES-CBC";
    case Hc.ctr:
      return "AES-CTR";
    default:
      throw new Error(`[FastAESKey] invalid aes mode ${n}`);
  }
}
const XRe = 16;
class KP {
  constructor(e, { removePKCS7Padding: t = !0 } = {}) {
    if (
      ((this.logEnabled = !0),
      (this.removePKCS7Padding = void 0),
      (this.subtle = null),
      (this.softwareDecrypter = null),
      (this.key = null),
      (this.fastAesKey = null),
      (this.remainderData = null),
      (this.currentIV = null),
      (this.currentResult = null),
      (this.useSoftware = void 0),
      (this.enableSoftwareAES = void 0),
      (this.enableSoftwareAES = e.enableSoftwareAES),
      (this.removePKCS7Padding = t),
      t)
    )
      try {
        const s = self.crypto;
        s && (this.subtle = s.subtle || s.webkitSubtle);
      } catch {}
    this.useSoftware = !this.subtle;
  }
  destroy() {
    (this.subtle = null),
      (this.softwareDecrypter = null),
      (this.key = null),
      (this.fastAesKey = null),
      (this.remainderData = null),
      (this.currentIV = null),
      (this.currentResult = null);
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const { currentResult: e, remainderData: t } = this;
    if (!e || t) return this.reset(), null;
    const s = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? qRe(s) : s;
  }
  reset() {
    (this.currentResult = null),
      (this.currentIV = null),
      (this.remainderData = null),
      this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, t, s, r) {
    return this.useSoftware
      ? new Promise((i, a) => {
          const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
          this.softwareDecrypt(o, t, s, r);
          const l = this.flush();
          l
            ? i(l.buffer)
            : a(new Error("[softwareDecrypt] Failed to decrypt data"));
        })
      : this.webCryptoDecrypt(new Uint8Array(e), t, s, r);
  }
  softwareDecrypt(e, t, s, r) {
    const { currentIV: i, currentResult: a, remainderData: o } = this;
    if (r !== Hc.cbc || t.byteLength !== 16)
      return pn.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
    this.logOnce("JS AES decrypt"),
      o && ((e = da(o, e)), (this.remainderData = null));
    const l = this.getValidChunk(e);
    if (!l.length) return null;
    i && (s = i);
    let c = this.softwareDecrypter;
    c || (c = this.softwareDecrypter = new WRe()), c.expandKey(t);
    const h = a;
    return (
      (this.currentResult = c.decrypt(l.buffer, 0, s)),
      (this.currentIV = l.slice(-16).buffer),
      h || null
    );
  }
  webCryptoDecrypt(e, t, s, r) {
    if (this.key !== t || !this.fastAesKey) {
      if (!this.subtle)
        return Promise.resolve(this.onWebCryptoError(e, t, s, r));
      (this.key = t), (this.fastAesKey = new KRe(this.subtle, t, r));
    }
    return this.fastAesKey
      .expandKey()
      .then((i) =>
        this.subtle
          ? (this.logOnce("WebCrypto AES decrypt"),
            new GRe(this.subtle, new Uint8Array(s), r).decrypt(e.buffer, i))
          : Promise.reject(new Error("web crypto not initialized"))
      )
      .catch(
        (i) => (
          pn.warn(
            `[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`
          ),
          this.onWebCryptoError(e, t, s, r)
        )
      );
  }
  onWebCryptoError(e, t, s, r) {
    const i = this.enableSoftwareAES;
    if (i) {
      (this.useSoftware = !0),
        (this.logEnabled = !0),
        this.softwareDecrypt(e, t, s, r);
      const a = this.flush();
      if (a) return a.buffer;
    }
    throw new Error(
      "WebCrypto" +
        (i ? " and softwareDecrypt" : "") +
        ": failed to decrypt data"
    );
  }
  getValidChunk(e) {
    let t = e;
    const s = e.length - (e.length % XRe);
    return (
      s !== e.length &&
        ((t = e.slice(0, s)), (this.remainderData = e.slice(s))),
      t
    );
  }
  logOnce(e) {
    this.logEnabled && (pn.log(`[decrypter]: ${e}`), (this.logEnabled = !1));
  }
}
const DB = Math.pow(2, 17);
class QRe {
  constructor(e) {
    (this.config = void 0),
      (this.loader = null),
      (this.partLoadTimeout = -1),
      (this.config = e);
  }
  destroy() {
    this.loader && (this.loader.destroy(), (this.loader = null));
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, t) {
    const s = e.url;
    if (!s)
      return Promise.reject(
        new pl({
          type: gt.NETWORK_ERROR,
          details: we.FRAG_LOAD_ERROR,
          fatal: !1,
          frag: e,
          error: new Error(
            `Fragment does not have a ${s ? "part list" : "url"}`
          ),
          networkDetails: null,
        })
      );
    this.abort();
    const r = this.config,
      i = r.fLoader,
      a = r.loader;
    return new Promise((o, l) => {
      if ((this.loader && this.loader.destroy(), e.gap))
        if (e.tagList.some((y) => y[0] === "GAP")) {
          l(MB(e));
          return;
        } else e.gap = !1;
      const c = (this.loader = i ? new i(r) : new a(r)),
        h = PB(e);
      e.loader = c;
      const m = IB(r.fragLoadPolicy.default),
        p = {
          loadPolicy: m,
          timeout: m.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: e.sn === "initSegment" ? 1 / 0 : DB,
        };
      e.stats = c.stats;
      const g = {
        onSuccess: (y, b, w, S) => {
          this.resetLoader(e, c);
          let A = y.data;
          w.resetIV &&
            e.decryptdata &&
            ((e.decryptdata.iv = new Uint8Array(A.slice(0, 16))),
            (A = A.slice(16))),
            o({ frag: e, part: null, payload: A, networkDetails: S });
        },
        onError: (y, b, w, S) => {
          this.resetLoader(e, c),
            l(
              new pl({
                type: gt.NETWORK_ERROR,
                details: we.FRAG_LOAD_ERROR,
                fatal: !1,
                frag: e,
                response: In({ url: s, data: void 0 }, y),
                error: new Error(`HTTP Error ${y.code} ${y.text}`),
                networkDetails: w,
                stats: S,
              })
            );
        },
        onAbort: (y, b, w) => {
          this.resetLoader(e, c),
            l(
              new pl({
                type: gt.NETWORK_ERROR,
                details: we.INTERNAL_ABORTED,
                fatal: !1,
                frag: e,
                error: new Error("Aborted"),
                networkDetails: w,
                stats: y,
              })
            );
        },
        onTimeout: (y, b, w) => {
          this.resetLoader(e, c),
            l(
              new pl({
                type: gt.NETWORK_ERROR,
                details: we.FRAG_LOAD_TIMEOUT,
                fatal: !1,
                frag: e,
                error: new Error(`Timeout after ${p.timeout}ms`),
                networkDetails: w,
                stats: y,
              })
            );
        },
      };
      t &&
        (g.onProgress = (y, b, w, S) =>
          t({ frag: e, part: null, payload: w, networkDetails: S })),
        c.load(h, p, g);
    });
  }
  loadPart(e, t, s) {
    this.abort();
    const r = this.config,
      i = r.fLoader,
      a = r.loader;
    return new Promise((o, l) => {
      if ((this.loader && this.loader.destroy(), e.gap || t.gap)) {
        l(MB(e, t));
        return;
      }
      const c = (this.loader = i ? new i(r) : new a(r)),
        h = PB(e, t);
      e.loader = c;
      const m = IB(r.fragLoadPolicy.default),
        p = {
          loadPolicy: m,
          timeout: m.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: DB,
        };
      (t.stats = c.stats),
        c.load(h, p, {
          onSuccess: (g, y, b, w) => {
            this.resetLoader(e, c), this.updateStatsFromPart(e, t);
            const S = { frag: e, part: t, payload: g.data, networkDetails: w };
            s(S), o(S);
          },
          onError: (g, y, b, w) => {
            this.resetLoader(e, c),
              l(
                new pl({
                  type: gt.NETWORK_ERROR,
                  details: we.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  part: t,
                  response: In({ url: h.url, data: void 0 }, g),
                  error: new Error(`HTTP Error ${g.code} ${g.text}`),
                  networkDetails: b,
                  stats: w,
                })
              );
          },
          onAbort: (g, y, b) => {
            (e.stats.aborted = t.stats.aborted),
              this.resetLoader(e, c),
              l(
                new pl({
                  type: gt.NETWORK_ERROR,
                  details: we.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error("Aborted"),
                  networkDetails: b,
                  stats: g,
                })
              );
          },
          onTimeout: (g, y, b) => {
            this.resetLoader(e, c),
              l(
                new pl({
                  type: gt.NETWORK_ERROR,
                  details: we.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error(`Timeout after ${p.timeout}ms`),
                  networkDetails: b,
                  stats: g,
                })
              );
          },
        });
    });
  }
  updateStatsFromPart(e, t) {
    const s = e.stats,
      r = t.stats,
      i = r.total;
    if (((s.loaded += r.loaded), i)) {
      const l = Math.round(e.duration / t.duration),
        c = Math.min(Math.round(s.loaded / i), l),
        m = (l - c) * Math.round(s.loaded / c);
      s.total = s.loaded + m;
    } else s.total = Math.max(s.loaded, s.total);
    const a = s.loading,
      o = r.loading;
    a.start
      ? (a.first += o.first - o.start)
      : ((a.start = o.start), (a.first = o.first)),
      (a.end = o.end);
  }
  resetLoader(e, t) {
    (e.loader = null),
      this.loader === t &&
        (self.clearTimeout(this.partLoadTimeout), (this.loader = null)),
      t.destroy();
  }
}
function PB(n, e = null) {
  const t = e || n,
    s = {
      frag: n,
      part: e,
      responseType: "arraybuffer",
      url: t.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0,
    },
    r = t.byteRangeStartOffset,
    i = t.byteRangeEndOffset;
  if (Qe(r) && Qe(i)) {
    var a;
    let o = r,
      l = i;
    if (
      n.sn === "initSegment" &&
      ZRe((a = n.decryptdata) == null ? void 0 : a.method)
    ) {
      const c = i - r;
      c % 16 && (l = i + (16 - (c % 16))),
        r !== 0 && ((s.resetIV = !0), (o = r - 16));
    }
    (s.rangeStart = o), (s.rangeEnd = l);
  }
  return s;
}
function MB(n, e) {
  const t = new Error(`GAP ${n.gap ? "tag" : "attribute"} found`),
    s = {
      type: gt.MEDIA_ERROR,
      details: we.FRAG_GAP,
      fatal: !1,
      frag: n,
      error: t,
      networkDetails: null,
    };
  return e && (s.part = e), ((e || n).stats.aborted = !0), new pl(s);
}
function ZRe(n) {
  return n === "AES-128" || n === "AES-256";
}
class pl extends Error {
  constructor(e) {
    super(e.error.message), (this.data = void 0), (this.data = e);
  }
}
class EY extends za {
  constructor(e, t) {
    super(e, t),
      (this._boundTick = void 0),
      (this._tickTimer = null),
      (this._tickInterval = null),
      (this._tickCallCount = 0),
      (this._boundTick = this.tick.bind(this));
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {}
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  setInterval(e) {
    return this._tickInterval
      ? !1
      : ((this._tickCallCount = 0),
        (this._tickInterval = self.setInterval(this._boundTick, e)),
        !0);
  }
  clearInterval() {
    return this._tickInterval
      ? (self.clearInterval(this._tickInterval),
        (this._tickInterval = null),
        !0)
      : !1;
  }
  clearNextTick() {
    return this._tickTimer
      ? (self.clearTimeout(this._tickTimer), (this._tickTimer = null), !0)
      : !1;
  }
  tick() {
    this._tickCallCount++,
      this._tickCallCount === 1 &&
        (this.doTick(),
        this._tickCallCount > 1 && this.tickImmediate(),
        (this._tickCallCount = 0));
  }
  tickImmediate() {
    this.clearNextTick(),
      (this._tickTimer = self.setTimeout(this._boundTick, 0));
  }
  doTick() {}
}
class YP {
  constructor(e, t, s, r = 0, i = -1, a = !1) {
    (this.level = void 0),
      (this.sn = void 0),
      (this.part = void 0),
      (this.id = void 0),
      (this.size = void 0),
      (this.partial = void 0),
      (this.transmuxing = eb()),
      (this.buffering = { audio: eb(), video: eb(), audiovideo: eb() }),
      (this.level = e),
      (this.sn = t),
      (this.id = s),
      (this.size = r),
      (this.part = i),
      (this.partial = a);
  }
}
function eb() {
  return { start: 0, executeStart: 0, executeEnd: 0, end: 0 };
}
const NB = { length: 0, start: () => 0, end: () => 0 };
class Ft {
  static isBuffered(e, t) {
    if (e) {
      const s = Ft.getBuffered(e);
      for (let r = s.length; r--; )
        if (t >= s.start(r) && t <= s.end(r)) return !0;
    }
    return !1;
  }
  static bufferedRanges(e) {
    if (e) {
      const t = Ft.getBuffered(e);
      return Ft.timeRangesToArray(t);
    }
    return [];
  }
  static timeRangesToArray(e) {
    const t = [];
    for (let s = 0; s < e.length; s++)
      t.push({ start: e.start(s), end: e.end(s) });
    return t;
  }
  static bufferInfo(e, t, s) {
    if (e) {
      const r = Ft.bufferedRanges(e);
      if (r.length) return Ft.bufferedInfo(r, t, s);
    }
    return { len: 0, start: t, end: t, bufferedIndex: -1 };
  }
  static bufferedInfo(e, t, s) {
    (t = Math.max(0, t)),
      e.length > 1 && e.sort((h, m) => h.start - m.start || m.end - h.end);
    let r = -1,
      i = [];
    if (s)
      for (let h = 0; h < e.length; h++) {
        t >= e[h].start && t <= e[h].end && (r = h);
        const m = i.length;
        if (m) {
          const p = i[m - 1].end;
          e[h].start - p < s
            ? e[h].end > p && (i[m - 1].end = e[h].end)
            : i.push(e[h]);
        } else i.push(e[h]);
      }
    else i = e;
    let a = 0,
      o,
      l = t,
      c = t;
    for (let h = 0; h < i.length; h++) {
      const m = i[h].start,
        p = i[h].end;
      if ((r === -1 && t >= m && t <= p && (r = h), t + s >= m && t < p))
        (l = m), (c = p), (a = c - t);
      else if (t + s < m) {
        o = m;
        break;
      }
    }
    return {
      len: a,
      start: l || 0,
      end: c || 0,
      nextStart: o,
      buffered: e,
      bufferedIndex: r,
    };
  }
  static getBuffered(e) {
    try {
      return e.buffered || NB;
    } catch (t) {
      return pn.log("failed to get media.buffered", t), NB;
    }
  }
}
const SY = /\{\$([a-zA-Z0-9-_]+)\}/g;
function OB(n) {
  return SY.test(n);
}
function iI(n, e) {
  if (n.variableList !== null || n.hasVariableRefs) {
    const t = n.variableList;
    return e.replace(SY, (s) => {
      const r = s.substring(2, s.length - 1),
        i = t?.[r];
      return i === void 0
        ? (n.playlistParsingError ||
            (n.playlistParsingError = new Error(
              `Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`
            )),
          s)
        : i;
    });
  }
  return e;
}
function jB(n, e, t) {
  let s = n.variableList;
  s || (n.variableList = s = {});
  let r, i;
  if ("QUERYPARAM" in e) {
    r = e.QUERYPARAM;
    try {
      const a = new self.URL(t).searchParams;
      if (a.has(r)) i = a.get(r);
      else
        throw new Error(
          `"${r}" does not match any query parameter in URI: "${t}"`
        );
    } catch (a) {
      n.playlistParsingError ||
        (n.playlistParsingError = new Error(
          `EXT-X-DEFINE QUERYPARAM: ${a.message}`
        ));
    }
  } else (r = e.NAME), (i = e.VALUE);
  r in s
    ? n.playlistParsingError ||
      (n.playlistParsingError = new Error(
        `EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`
      ))
    : (s[r] = i || "");
}
function JRe(n, e, t) {
  const s = e.IMPORT;
  if (t && s in t) {
    let r = n.variableList;
    r || (n.variableList = r = {}), (r[s] = t[s]);
  } else
    n.playlistParsingError ||
      (n.playlistParsingError = new Error(
        `EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${s}"`
      ));
}
const eke = /^(\d+)x(\d+)$/,
  FB = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class rs {
  constructor(e, t) {
    typeof e == "string" && (e = rs.parseAttrList(e, t)), Tn(this, e);
  }
  get clientAttrs() {
    return Object.keys(this).filter((e) => e.substring(0, 2) === "X-");
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || "0x").slice(2);
      t = (t.length & 1 ? "0" : "") + t;
      const s = new Uint8Array(t.length / 2);
      for (let r = 0; r < t.length / 2; r++)
        s[r] = parseInt(t.slice(r * 2, r * 2 + 2), 16);
      return s;
    }
    return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, t) {
    const s = this[e];
    return s ? parseFloat(s) : t;
  }
  enumeratedString(e) {
    return this[e];
  }
  enumeratedStringList(e, t) {
    const s = this[e];
    return (s ? s.split(/[ ,]+/) : []).reduce(
      (r, i) => ((r[i.toLowerCase()] = !0), r),
      t
    );
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const t = eke.exec(this[e]);
    if (t !== null)
      return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) };
  }
  static parseAttrList(e, t) {
    let s;
    const r = {};
    for (FB.lastIndex = 0; (s = FB.exec(e)) !== null; ) {
      const a = s[1].trim();
      let o = s[2];
      const l = o.indexOf('"') === 0 && o.lastIndexOf('"') === o.length - 1;
      let c = !1;
      if (l) o = o.slice(1, -1);
      else
        switch (a) {
          case "IV":
          case "SCTE35-CMD":
          case "SCTE35-IN":
          case "SCTE35-OUT":
            c = !0;
        }
      if (t && (l || c)) o = iI(t, o);
      else if (!c && !l)
        switch (a) {
          case "CLOSED-CAPTIONS":
            if (o === "NONE") break;
          case "ALLOWED-CPC":
          case "CLASS":
          case "ASSOC-LANGUAGE":
          case "AUDIO":
          case "BYTERANGE":
          case "CHANNELS":
          case "CHARACTERISTICS":
          case "CODECS":
          case "DATA-ID":
          case "END-DATE":
          case "GROUP-ID":
          case "ID":
          case "IMPORT":
          case "INSTREAM-ID":
          case "KEYFORMAT":
          case "KEYFORMATVERSIONS":
          case "LANGUAGE":
          case "NAME":
          case "PATHWAY-ID":
          case "QUERYPARAM":
          case "RECENTLY-REMOVED-DATERANGES":
          case "SERVER-URI":
          case "STABLE-RENDITION-ID":
          case "STABLE-VARIANT-ID":
          case "START-DATE":
          case "SUBTITLES":
          case "SUPPLEMENTAL-CODECS":
          case "URI":
          case "VALUE":
          case "VIDEO":
          case "X-ASSET-LIST":
          case "X-ASSET-URI":
            pn.warn(`${e}: attribute ${a} is missing quotes`);
        }
      r[a] = o;
    }
    return r;
  }
}
const tke = "com.apple.hls.interstitial";
function nke(n) {
  return (
    n !== "ID" &&
    n !== "CLASS" &&
    n !== "CUE" &&
    n !== "START-DATE" &&
    n !== "DURATION" &&
    n !== "END-DATE" &&
    n !== "END-ON-NEXT"
  );
}
function ske(n) {
  return n === "SCTE35-OUT" || n === "SCTE35-IN" || n === "SCTE35-CMD";
}
class TY {
  constructor(e, t, s = 0) {
    var r;
    if (
      ((this.attr = void 0),
      (this.tagAnchor = void 0),
      (this.tagOrder = void 0),
      (this._startDate = void 0),
      (this._endDate = void 0),
      (this._dateAtEnd = void 0),
      (this._cue = void 0),
      (this._badValueForSameId = void 0),
      (this.tagAnchor = t?.tagAnchor || null),
      (this.tagOrder = (r = t?.tagOrder) != null ? r : s),
      t)
    ) {
      const i = t.attr;
      for (const a in i)
        if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== i[a]) {
          pn.warn(
            `DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`
          ),
            (this._badValueForSameId = a);
          break;
        }
      e = Tn(new rs({}), i, e);
    }
    if (
      ((this.attr = e),
      t
        ? ((this._startDate = t._startDate),
          (this._cue = t._cue),
          (this._endDate = t._endDate),
          (this._dateAtEnd = t._dateAtEnd))
        : (this._startDate = new Date(e["START-DATE"])),
      "END-DATE" in this.attr)
    ) {
      const i = t?.endDate || new Date(this.attr["END-DATE"]);
      Qe(i.getTime()) && (this._endDate = i);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get cue() {
    const e = this._cue;
    return e === void 0
      ? (this._cue = this.attr.enumeratedStringList(
          this.attr.CUE ? "CUE" : "X-CUE",
          { pre: !1, post: !1, once: !1 }
        ))
      : e;
  }
  get startTime() {
    const { tagAnchor: e } = this;
    return e === null || e.programDateTime === null
      ? (pn.warn(
          `Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`
        ),
        NaN)
      : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    const e = this._endDate || this._dateAtEnd;
    if (e) return e;
    const t = this.duration;
    return t !== null
      ? (this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3))
      : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (Qe(e)) return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr
      ? this.attr.decimalFloatingPoint("PLANNED-DURATION")
      : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isInterstitial() {
    return this.class === tke;
  }
  get isValid() {
    return (
      !!this.id &&
      !this._badValueForSameId &&
      Qe(this.startDate.getTime()) &&
      (this.duration === null || this.duration >= 0) &&
      (!this.endOnNext || !!this.class) &&
      (!this.attr.CUE ||
        (!this.cue.pre && !this.cue.post) ||
        this.cue.pre !== this.cue.post) &&
      (!this.isInterstitial ||
        "X-ASSET-URI" in this.attr ||
        "X-ASSET-LIST" in this.attr)
    );
  }
}
const rke = 10;
class ike {
  constructor(e) {
    (this.PTSKnown = !1),
      (this.alignedSliding = !1),
      (this.averagetargetduration = void 0),
      (this.endCC = 0),
      (this.endSN = 0),
      (this.fragments = void 0),
      (this.fragmentHint = void 0),
      (this.partList = null),
      (this.dateRanges = void 0),
      (this.dateRangeTagCount = 0),
      (this.live = !0),
      (this.requestScheduled = -1),
      (this.ageHeader = 0),
      (this.advancedDateTime = void 0),
      (this.updated = !0),
      (this.advanced = !0),
      (this.misses = 0),
      (this.startCC = 0),
      (this.startSN = 0),
      (this.startTimeOffset = null),
      (this.targetduration = 0),
      (this.totalduration = 0),
      (this.type = null),
      (this.url = void 0),
      (this.m3u8 = ""),
      (this.version = null),
      (this.canBlockReload = !1),
      (this.canSkipUntil = 0),
      (this.canSkipDateRanges = !1),
      (this.skippedSegments = 0),
      (this.recentlyRemovedDateranges = void 0),
      (this.partHoldBack = 0),
      (this.holdBack = 0),
      (this.partTarget = 0),
      (this.preloadHint = void 0),
      (this.renditionReports = void 0),
      (this.tuneInGoal = 0),
      (this.deltaUpdateFailed = void 0),
      (this.driftStartTime = 0),
      (this.driftEndTime = 0),
      (this.driftStart = 0),
      (this.driftEnd = 0),
      (this.encryptedFragments = void 0),
      (this.playlistParsingError = null),
      (this.variableList = null),
      (this.hasVariableRefs = !1),
      (this.appliedTimelineOffset = void 0),
      (this.fragments = []),
      (this.encryptedFragments = []),
      (this.dateRanges = {}),
      (this.url = e);
  }
  reloaded(e) {
    if (!e) {
      (this.advanced = !0), (this.updated = !0);
      return;
    }
    const t = this.lastPartSn - e.lastPartSn,
      s = this.lastPartIndex - e.lastPartIndex;
    (this.updated = this.endSN !== e.endSN || !!s || !!t || !this.live),
      (this.advanced = this.endSN > e.endSN || t > 0 || (t === 0 && s > 0)),
      this.updated || this.advanced
        ? (this.misses = Math.floor(e.misses * 0.6))
        : (this.misses = e.misses + 1);
  }
  get hasProgramDateTime() {
    return this.fragments.length
      ? Qe(this.fragments[this.fragments.length - 1].programDateTime)
      : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || rke;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? ((this.driftEnd - this.driftStart) * 1e3) / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].end
      : this.fragmentEnd;
  }
  get fragmentEnd() {
    var e;
    return (e = this.fragments) != null && e.length
      ? this.fragments[this.fragments.length - 1].end
      : 0;
  }
  get fragmentStart() {
    var e;
    return (e = this.fragments) != null && e.length
      ? this.fragments[0].start
      : 0;
  }
  get age() {
    return this.advancedDateTime
      ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3
      : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].index
      : -1;
  }
  get maxPartIndex() {
    const e = this.partList;
    if (e) {
      const t = this.lastPartIndex;
      if (t !== -1) {
        for (let s = e.length; s--; ) if (e[s].index > t) return e[s].index;
        return t;
      }
    }
    return 0;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].fragment.sn
      : this.endSN;
  }
  get expired() {
    if (this.live && this.age && this.misses < 3) {
      const e = this.partEnd - this.fragmentStart;
      return (
        this.age > Math.max(e, this.totalduration) + this.levelTargetDuration
      );
    }
    return !1;
  }
}
function hf(n) {
  return n === "AES-128" || n === "AES-256" || n === "AES-256-CTR";
}
function XP(n) {
  switch (n) {
    case "AES-128":
    case "AES-256":
      return Hc.cbc;
    case "AES-256-CTR":
      return Hc.ctr;
    default:
      throw new Error(`invalid full segment method ${n}`);
  }
}
function _Y(n) {
  return Uint8Array.from(atob(n), (e) => e.charCodeAt(0));
}
function aI(n) {
  return Uint8Array.from(unescape(encodeURIComponent(n)), (e) =>
    e.charCodeAt(0)
  );
}
function ake(n) {
  const e = aI(n).subarray(0, 16),
    t = new Uint8Array(16);
  return t.set(e, 16 - e.length), t;
}
function oke(n) {
  const e = function (s, r, i) {
    const a = s[r];
    (s[r] = s[i]), (s[i] = a);
  };
  e(n, 0, 3), e(n, 1, 2), e(n, 4, 5), e(n, 6, 7);
}
function lke(n) {
  const e = n.split(":");
  let t = null;
  if (e[0] === "data" && e.length === 2) {
    const s = e[1].split(";"),
      r = s[s.length - 1].split(",");
    if (r.length === 2) {
      const i = r[0] === "base64",
        a = r[1];
      i ? (s.splice(-1, 1), (t = _Y(a))) : (t = ake(a));
    }
  }
  return t;
}
const Zw = typeof self < "u" ? self : void 0;
var Rs = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha",
  },
  ni = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
  };
function oI(n) {
  switch (n) {
    case ni.FAIRPLAY:
      return Rs.FAIRPLAY;
    case ni.PLAYREADY:
      return Rs.PLAYREADY;
    case ni.WIDEVINE:
      return Rs.WIDEVINE;
    case ni.CLEARKEY:
      return Rs.CLEARKEY;
  }
}
function UB(n) {
  switch (n) {
    case Rs.FAIRPLAY:
      return ni.FAIRPLAY;
    case Rs.PLAYREADY:
      return ni.PLAYREADY;
    case Rs.WIDEVINE:
      return ni.WIDEVINE;
    case Rs.CLEARKEY:
      return ni.CLEARKEY;
  }
}
function sx(n) {
  const { drmSystems: e, widevineLicenseUrl: t } = n,
    s = e
      ? [Rs.FAIRPLAY, Rs.WIDEVINE, Rs.PLAYREADY, Rs.CLEARKEY].filter(
          (r) => !!e[r]
        )
      : [];
  return !s[Rs.WIDEVINE] && t && s.push(Rs.WIDEVINE), s;
}
const AY = (function (n) {
  return Zw != null &&
    (n = Zw.navigator) != null &&
    n.requestMediaKeySystemAccess
    ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator)
    : null;
})();
function cke(n, e, t, s) {
  let r;
  switch (n) {
    case Rs.FAIRPLAY:
      r = ["cenc", "sinf"];
      break;
    case Rs.WIDEVINE:
    case Rs.PLAYREADY:
      r = ["cenc"];
      break;
    case Rs.CLEARKEY:
      r = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${n}`);
  }
  return uke(r, e, t, s);
}
function uke(n, e, t, s) {
  return [
    {
      initDataTypes: n,
      persistentState: s.persistentState || "optional",
      distinctiveIdentifier: s.distinctiveIdentifier || "optional",
      sessionTypes: s.sessionTypes || [s.sessionType || "temporary"],
      audioCapabilities: e.map((i) => ({
        contentType: `audio/mp4; codecs=${i}`,
        robustness: s.audioRobustness || "",
        encryptionScheme: s.audioEncryptionScheme || null,
      })),
      videoCapabilities: t.map((i) => ({
        contentType: `video/mp4; codecs=${i}`,
        robustness: s.videoRobustness || "",
        encryptionScheme: s.videoEncryptionScheme || null,
      })),
    },
  ];
}
function dke(n) {
  var e;
  return (
    n.sessionType === "persistent-license" ||
    !!(
      (e = n.sessionTypes) != null && e.some((t) => t === "persistent-license")
    )
  );
}
function hke(n) {
  const e = new Uint16Array(n.buffer, n.byteOffset, n.byteLength / 2),
    t = String.fromCharCode.apply(null, Array.from(e)),
    s = t.substring(t.indexOf("<"), t.length),
    a = new DOMParser()
      .parseFromString(s, "text/xml")
      .getElementsByTagName("KID")[0];
  if (a) {
    const o = a.childNodes[0]
      ? a.childNodes[0].nodeValue
      : a.getAttribute("VALUE");
    if (o) {
      const l = _Y(o).subarray(0, 16);
      return oke(l), l;
    }
  }
  return null;
}
let tb = {};
class fS {
  static clearKeyUriToKeyIdMap() {
    tb = {};
  }
  constructor(e, t, s, r = [1], i = null, a) {
    (this.uri = void 0),
      (this.method = void 0),
      (this.keyFormat = void 0),
      (this.keyFormatVersions = void 0),
      (this.encrypted = void 0),
      (this.isCommonEncryption = void 0),
      (this.iv = null),
      (this.key = null),
      (this.keyId = null),
      (this.pssh = null),
      (this.method = e),
      (this.uri = t),
      (this.keyFormat = s),
      (this.keyFormatVersions = r),
      (this.iv = i),
      (this.encrypted = e ? e !== "NONE" : !1),
      (this.isCommonEncryption = this.encrypted && !hf(e)),
      a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(aY(a)));
  }
  matches(e) {
    var t, s;
    return (
      e.uri === this.uri &&
      e.method === this.method &&
      e.encrypted === this.encrypted &&
      e.keyFormat === this.keyFormat &&
      e.keyFormatVersions.join(",") === this.keyFormatVersions.join(",") &&
      ((t = e.iv) == null ? void 0 : t.join(",")) ===
        ((s = this.iv) == null ? void 0 : s.join(","))
    );
  }
  isSupported() {
    if (this.method) {
      if (hf(this.method) || this.method === "NONE") return !0;
      if (this.keyFormat === "identity") return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case ni.FAIRPLAY:
        case ni.WIDEVINE:
        case ni.PLAYREADY:
        case ni.CLEARKEY:
          return (
            [
              "ISO-23001-7",
              "SAMPLE-AES",
              "SAMPLE-AES-CENC",
              "SAMPLE-AES-CTR",
            ].indexOf(this.method) !== -1
          );
      }
    }
    return !1;
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri) return null;
    if (hf(this.method) && this.uri && !this.iv) {
      typeof e != "number" &&
        (pn.warn(
          `missing IV for initialization segment with method="${this.method}" - compliance issue`
        ),
        (e = 0));
      const s = fke(e);
      return new fS(
        this.method,
        this.uri,
        "identity",
        this.keyFormatVersions,
        s
      );
    }
    if (this.pssh && this.keyId) return this;
    const t = lke(this.uri);
    if (t)
      switch (this.keyFormat) {
        case ni.WIDEVINE:
          if (((this.pssh = t), !this.keyId && t.length >= 22)) {
            const s = t.length - 22;
            this.keyId = t.subarray(s, s + 16);
          }
          break;
        case ni.PLAYREADY: {
          const s = new Uint8Array([
            154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95,
            149,
          ]);
          (this.pssh = vRe(s, null, t)), (this.keyId = hke(t));
          break;
        }
        default: {
          let s = t.subarray(0, 16);
          if (s.length !== 16) {
            const r = new Uint8Array(16);
            r.set(s, 16 - s.length), (s = r);
          }
          this.keyId = s;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let s = tb[this.uri];
      if (!s) {
        const r = Object.keys(tb).length % Number.MAX_SAFE_INTEGER;
        (s = new Uint8Array(16)),
          new DataView(s.buffer, 12, 4).setUint32(0, r),
          (tb[this.uri] = s);
      }
      this.keyId = s;
    }
    return this;
  }
}
function fke(n) {
  const e = new Uint8Array(16);
  for (let t = 12; t < 16; t++) e[t] = (n >> (8 * (15 - t))) & 255;
  return e;
}
const $B =
    /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
  BB = /#EXT-X-MEDIA:(.*)/g,
  mke = /^#EXT(?:INF|-X-TARGETDURATION):/m,
  yA = new RegExp(
    [
      /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
      /(?!#) *(\S[^\r\n]*)/.source,
      /#.*/.source,
    ].join("|"),
    "g"
  ),
  pke = new RegExp(
    [
      /#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/
        .source,
      /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/
        .source,
      /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source,
      /(#)([^:]*):(.*)/.source,
      /(#)(.*)(?:.*)\r?\n?/.source,
    ].join("|")
  );
class _o {
  static findGroup(e, t) {
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r.id === t) return r;
    }
  }
  static resolve(e, t) {
    return HP.buildAbsoluteURL(t, e, { alwaysNormalize: !0 });
  }
  static isMediaPlaylist(e) {
    return mke.test(e);
  }
  static parseMasterPlaylist(e, t) {
    const s = OB(e),
      r = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs: s,
      },
      i = [];
    $B.lastIndex = 0;
    let a;
    for (; (a = $B.exec(e)) != null; )
      if (a[1]) {
        var o;
        const c = new rs(a[1], r),
          h = iI(r, a[2]),
          m = {
            attrs: c,
            bitrate:
              c.decimalInteger("BANDWIDTH") ||
              c.decimalInteger("AVERAGE-BANDWIDTH"),
            name: c.NAME,
            url: _o.resolve(h, t),
          },
          p = c.decimalResolution("RESOLUTION");
        p && ((m.width = p.width), (m.height = p.height)), zB(c.CODECS, m);
        const g = c["SUPPLEMENTAL-CODECS"];
        g && ((m.supplemental = {}), zB(g, m.supplemental)),
          ((o = m.unknownCodecs) != null && o.length) || i.push(m),
          r.levels.push(m);
      } else if (a[3]) {
        const c = a[3],
          h = a[4];
        switch (c) {
          case "SESSION-DATA": {
            const m = new rs(h, r),
              p = m["DATA-ID"];
            p &&
              (r.sessionData === null && (r.sessionData = {}),
              (r.sessionData[p] = m));
            break;
          }
          case "SESSION-KEY": {
            const m = HB(h, t, r);
            m.encrypted && m.isSupported()
              ? (r.sessionKeys === null && (r.sessionKeys = []),
                r.sessionKeys.push(m))
              : pn.warn(
                  `[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${h}"`
                );
            break;
          }
          case "DEFINE": {
            {
              const m = new rs(h, r);
              jB(r, m, t);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const m = new rs(h, r);
            r.contentSteering = {
              uri: _o.resolve(m["SERVER-URI"], t),
              pathwayId: m["PATHWAY-ID"] || ".",
            };
            break;
          }
          case "START": {
            r.startTimeOffset = VB(h);
            break;
          }
        }
      }
    const l = i.length > 0 && i.length < r.levels.length;
    return (
      (r.levels = l ? i : r.levels),
      r.levels.length === 0 &&
        (r.playlistParsingError = new Error("no levels found in manifest")),
      r
    );
  }
  static parseMasterPlaylistMedia(e, t, s) {
    let r;
    const i = {},
      a = s.levels,
      o = {
        AUDIO: a.map((c) => ({ id: c.attrs.AUDIO, audioCodec: c.audioCodec })),
        SUBTITLES: a.map((c) => ({
          id: c.attrs.SUBTITLES,
          textCodec: c.textCodec,
        })),
        "CLOSED-CAPTIONS": [],
      };
    let l = 0;
    for (BB.lastIndex = 0; (r = BB.exec(e)) !== null; ) {
      const c = new rs(r[1], s),
        h = c.TYPE;
      if (h) {
        const m = o[h],
          p = i[h] || [];
        i[h] = p;
        const g = c.LANGUAGE,
          y = c["ASSOC-LANGUAGE"],
          b = c.CHANNELS,
          w = c.CHARACTERISTICS,
          S = c["INSTREAM-ID"],
          A = {
            attrs: c,
            bitrate: 0,
            id: l++,
            groupId: c["GROUP-ID"] || "",
            name: c.NAME || g || "",
            type: h,
            default: c.bool("DEFAULT"),
            autoselect: c.bool("AUTOSELECT"),
            forced: c.bool("FORCED"),
            lang: g,
            url: c.URI ? _o.resolve(c.URI, t) : "",
          };
        if (
          (y && (A.assocLang = y),
          b && (A.channels = b),
          w && (A.characteristics = w),
          S && (A.instreamId = S),
          m != null && m.length)
        ) {
          const _ = _o.findGroup(m, A.groupId) || m[0];
          GB(A, _, "audioCodec"), GB(A, _, "textCodec");
        }
        p.push(A);
      }
    }
    return i;
  }
  static parseLevelPlaylist(e, t, s, r, i, a) {
    var o;
    const l = { url: t },
      c = new ike(t),
      h = c.fragments,
      m = [];
    let p = null,
      g = 0,
      y = 0,
      b = 0,
      w = 0,
      S = 0,
      A = null,
      _ = new pA(r, l),
      R,
      C,
      D,
      L = -1,
      P = !1,
      V = null,
      N;
    if (
      ((yA.lastIndex = 0),
      (c.m3u8 = e),
      (c.hasVariableRefs = OB(e)),
      ((o = yA.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
    )
      return (
        (c.playlistParsingError = new Error(
          "Missing format identifier #EXTM3U"
        )),
        c
      );
    for (; (R = yA.exec(e)) !== null; ) {
      P &&
        ((P = !1),
        (_ = new pA(r, l)),
        (_.playlistOffset = b),
        (_.start = b),
        (_.sn = g),
        (_.cc = w),
        S && (_.bitrate = S),
        (_.level = s),
        p &&
          ((_.initSegment = p),
          p.rawProgramDateTime &&
            ((_.rawProgramDateTime = p.rawProgramDateTime),
            (p.rawProgramDateTime = null)),
          V && (_.setByteRange(V), (V = null))));
      const B = R[1];
      if (B) {
        _.duration = parseFloat(B);
        const q = (" " + R[2]).slice(1);
        (_.title = q || null), _.tagList.push(q ? ["INF", B, q] : ["INF", B]);
      } else if (R[3]) {
        if (Qe(_.duration)) {
          (_.playlistOffset = b),
            (_.start = b),
            D && WB(_, D, c),
            (_.sn = g),
            (_.level = s),
            (_.cc = w),
            h.push(_);
          const q = (" " + R[3]).slice(1);
          (_.relurl = iI(c, q)),
            lI(_, A, m),
            (A = _),
            (b += _.duration),
            g++,
            (y = 0),
            (P = !0);
        }
      } else {
        if (((R = R[0].match(pke)), !R)) {
          pn.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (C = 1; C < R.length && R[C] === void 0; C++);
        const q = (" " + R[C]).slice(1),
          O = (" " + R[C + 1]).slice(1),
          U = R[C + 2] ? (" " + R[C + 2]).slice(1) : null;
        switch (q) {
          case "BYTERANGE":
            A ? _.setByteRange(O, A) : _.setByteRange(O);
            break;
          case "PROGRAM-DATE-TIME":
            (_.rawProgramDateTime = O),
              _.tagList.push(["PROGRAM-DATE-TIME", O]),
              L === -1 && (L = h.length);
            break;
          case "PLAYLIST-TYPE":
            c.type && rl(c, q, R), (c.type = O.toUpperCase());
            break;
          case "MEDIA-SEQUENCE":
            c.startSN !== 0 ? rl(c, q, R) : h.length > 0 && KB(c, q, R),
              (g = c.startSN = parseInt(O));
            break;
          case "SKIP": {
            c.skippedSegments && rl(c, q, R);
            const j = new rs(O, c),
              Q = j.decimalInteger("SKIPPED-SEGMENTS");
            if (Qe(Q)) {
              c.skippedSegments += Q;
              for (let I = Q; I--; ) h.push(null);
              g += Q;
            }
            const M = j.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            M &&
              (c.recentlyRemovedDateranges = (
                c.recentlyRemovedDateranges || []
              ).concat(M.split("	")));
            break;
          }
          case "TARGETDURATION":
            c.targetduration !== 0 && rl(c, q, R),
              (c.targetduration = Math.max(parseInt(O), 1));
            break;
          case "VERSION":
            c.version !== null && rl(c, q, R), (c.version = parseInt(O));
            break;
          case "INDEPENDENT-SEGMENTS":
            break;
          case "ENDLIST":
            c.live || rl(c, q, R), (c.live = !1);
            break;
          case "#":
            (O || U) && _.tagList.push(U ? [O, U] : [O]);
            break;
          case "DISCONTINUITY":
            w++, _.tagList.push(["DIS"]);
            break;
          case "GAP":
            (_.gap = !0), _.tagList.push([q]);
            break;
          case "BITRATE":
            _.tagList.push([q, O]),
              (S = parseInt(O) * 1e3),
              Qe(S) ? (_.bitrate = S) : (S = 0);
            break;
          case "DATERANGE": {
            const j = new rs(O, c),
              Q = new TY(j, c.dateRanges[j.ID], c.dateRangeTagCount);
            c.dateRangeTagCount++,
              Q.isValid || c.skippedSegments
                ? (c.dateRanges[Q.id] = Q)
                : pn.warn(`Ignoring invalid DATERANGE tag: "${O}"`),
              _.tagList.push(["EXT-X-DATERANGE", O]);
            break;
          }
          case "DEFINE": {
            {
              const j = new rs(O, c);
              "IMPORT" in j ? JRe(c, j, a) : jB(c, j, t);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            c.startCC !== 0 ? rl(c, q, R) : h.length > 0 && KB(c, q, R),
              (c.startCC = w = parseInt(O));
            break;
          case "KEY": {
            const j = HB(O, t, c);
            if (j.isSupported()) {
              if (j.method === "NONE") {
                D = void 0;
                break;
              }
              D || (D = {});
              const Q = D[j.keyFormat];
              (Q != null && Q.matches(j)) ||
                (Q && (D = Tn({}, D)), (D[j.keyFormat] = j));
            } else pn.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${O}"`);
            break;
          }
          case "START":
            c.startTimeOffset = VB(O);
            break;
          case "MAP": {
            const j = new rs(O, c);
            if (_.duration) {
              const Q = new pA(r, l);
              qB(Q, j, s, D),
                (p = Q),
                (_.initSegment = p),
                p.rawProgramDateTime &&
                  !_.rawProgramDateTime &&
                  (_.rawProgramDateTime = p.rawProgramDateTime);
            } else {
              const Q = _.byteRangeEndOffset;
              if (Q) {
                const M = _.byteRangeStartOffset;
                V = `${Q - M}@${M}`;
              } else V = null;
              qB(_, j, s, D), (p = _), (P = !0);
            }
            p.cc = w;
            break;
          }
          case "SERVER-CONTROL": {
            N && rl(c, q, R),
              (N = new rs(O)),
              (c.canBlockReload = N.bool("CAN-BLOCK-RELOAD")),
              (c.canSkipUntil = N.optionalFloat("CAN-SKIP-UNTIL", 0)),
              (c.canSkipDateRanges =
                c.canSkipUntil > 0 && N.bool("CAN-SKIP-DATERANGES")),
              (c.partHoldBack = N.optionalFloat("PART-HOLD-BACK", 0)),
              (c.holdBack = N.optionalFloat("HOLD-BACK", 0));
            break;
          }
          case "PART-INF": {
            c.partTarget && rl(c, q, R);
            const j = new rs(O);
            c.partTarget = j.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let j = c.partList;
            j || (j = c.partList = []);
            const Q = y > 0 ? j[j.length - 1] : void 0,
              M = y++,
              I = new rs(O, c),
              F = new sRe(I, _, l, M, Q);
            j.push(F), (_.duration += F.duration);
            break;
          }
          case "PRELOAD-HINT": {
            const j = new rs(O, c);
            c.preloadHint = j;
            break;
          }
          case "RENDITION-REPORT": {
            const j = new rs(O, c);
            (c.renditionReports = c.renditionReports || []),
              c.renditionReports.push(j);
            break;
          }
          default:
            pn.warn(`line parsed but not handled: ${R}`);
            break;
        }
      }
    }
    A && !A.relurl
      ? (h.pop(), (b -= A.duration), c.partList && (c.fragmentHint = A))
      : c.partList &&
        (lI(_, A, m), (_.cc = w), (c.fragmentHint = _), D && WB(_, D, c)),
      c.targetduration ||
        (c.playlistParsingError = new Error(
          "#EXT-X-TARGETDURATION is required"
        ));
    const W = h.length,
      H = h[0],
      z = h[W - 1];
    if (((b += c.skippedSegments * c.targetduration), b > 0 && W && z)) {
      c.averagetargetduration = b / W;
      const B = z.sn;
      (c.endSN = B !== "initSegment" ? B : 0),
        c.live || (z.endList = !0),
        H && c.startCC === void 0 && (c.startCC = H.cc),
        L > 0 && (vke(h, L), H && m.unshift(H));
    } else (c.endSN = 0), (c.startCC = 0);
    return (
      c.fragmentHint && (b += c.fragmentHint.duration),
      (c.totalduration = b),
      m.length && c.dateRangeTagCount && H && RY(m, c),
      (c.endCC = w),
      c
    );
  }
}
function RY(n, e) {
  const t = n.length;
  if (!t) return;
  const s = n[t - 1],
    r = e.live ? 1 / 0 : e.totalduration,
    i = Object.keys(e.dateRanges);
  for (let a = i.length; a--; ) {
    const o = e.dateRanges[i[a]],
      l = o.startDate.getTime();
    o.tagAnchor = s.ref;
    for (let c = t; c--; ) {
      const h = gke(e, l, n, c, r);
      if (h !== -1) {
        o.tagAnchor = e.fragments[h].ref;
        break;
      }
    }
  }
}
function gke(n, e, t, s, r) {
  const i = t[s];
  if (i) {
    const o = i.programDateTime;
    if (e >= o || s === 0) {
      var a;
      const l = (((a = t[s + 1]) == null ? void 0 : a.start) || r) - i.start;
      if (e <= o + l * 1e3) {
        const c = t[s].sn - n.startSN,
          h = n.fragments;
        if (h.length > t.length) {
          const p = (t[s + 1] || h[h.length - 1]).sn - n.startSN;
          for (let g = p; g > c; g--) {
            const y = h[g].programDateTime;
            if (e >= y && e < y + h[g].duration * 1e3) return g;
          }
        }
        return c;
      }
    }
  }
  return -1;
}
function HB(n, e, t) {
  var s, r;
  const i = new rs(n, t),
    a = (s = i.METHOD) != null ? s : "",
    o = i.URI,
    l = i.hexadecimalInteger("IV"),
    c = i.KEYFORMATVERSIONS,
    h = (r = i.KEYFORMAT) != null ? r : "identity";
  o && i.IV && !l && pn.error(`Invalid IV: ${i.IV}`);
  const m = o ? _o.resolve(o, e) : "",
    p = (c || "1").split("/").map(Number).filter(Number.isFinite);
  return new fS(a, m, h, p, l, i.KEYID);
}
function VB(n) {
  const t = new rs(n).decimalFloatingPoint("TIME-OFFSET");
  return Qe(t) ? t : null;
}
function zB(n, e) {
  let t = (n || "").split(/[ ,]+/).filter((s) => s);
  ["video", "audio", "text"].forEach((s) => {
    const r = t.filter((i) => GP(i, s));
    r.length &&
      ((e[`${s}Codec`] = r.map((i) => i.split("/")[0]).join(",")),
      (t = t.filter((i) => r.indexOf(i) === -1)));
  }),
    (e.unknownCodecs = t);
}
function GB(n, e, t) {
  const s = e[t];
  s && (n[t] = s);
}
function vke(n, e) {
  let t = n[e];
  for (let s = e; s--; ) {
    const r = n[s];
    if (!r) return;
    (r.programDateTime = t.programDateTime - r.duration * 1e3), (t = r);
  }
}
function lI(n, e, t) {
  n.rawProgramDateTime
    ? t.push(n)
    : e != null &&
      e.programDateTime &&
      (n.programDateTime = e.endProgramDateTime);
}
function qB(n, e, t, s) {
  (n.relurl = e.URI),
    e.BYTERANGE && n.setByteRange(e.BYTERANGE),
    (n.level = t),
    (n.sn = "initSegment"),
    s && (n.levelkeys = s),
    (n.initSegment = null);
}
function WB(n, e, t) {
  n.levelkeys = e;
  const { encryptedFragments: s } = t;
  (!s.length || s[s.length - 1].levelkeys !== e) &&
    Object.keys(e).some((r) => e[r].isCommonEncryption) &&
    s.push(n);
}
function rl(n, e, t) {
  n.playlistParsingError = new Error(
    `#EXT-X-${e} must not appear more than once (${t[0]})`
  );
}
function KB(n, e, t) {
  n.playlistParsingError = new Error(
    `#EXT-X-${e} must appear before the first Media Segment (${t[0]})`
  );
}
function bA(n, e) {
  const t = e.startPTS;
  if (Qe(t)) {
    let s = 0,
      r;
    e.sn > n.sn ? ((s = t - n.start), (r = n)) : ((s = n.start - t), (r = e)),
      r.duration !== s && r.setDuration(s);
  } else
    e.sn > n.sn
      ? n.cc === e.cc && n.minEndPTS
        ? e.setStart(n.start + (n.minEndPTS - n.start))
        : e.setStart(n.start + n.duration)
      : e.setStart(Math.max(n.start - e.duration, 0));
}
function kY(n, e, t, s, r, i) {
  s - t <= 0 &&
    (pn.warn("Fragment should have a positive duration", e),
    (s = t + e.duration),
    (i = r + e.duration));
  let o = t,
    l = s;
  const c = e.startPTS,
    h = e.endPTS;
  if (Qe(c)) {
    const w = Math.abs(c - t);
    Qe(e.deltaPTS) ? (e.deltaPTS = Math.max(w, e.deltaPTS)) : (e.deltaPTS = w),
      (o = Math.max(t, c)),
      (t = Math.min(t, c)),
      (r = Math.min(r, e.startDTS)),
      (l = Math.min(s, h)),
      (s = Math.max(s, h)),
      (i = Math.max(i, e.endDTS));
  }
  const m = t - e.start;
  e.start !== 0 && e.setStart(t),
    e.setDuration(s - e.start),
    (e.startPTS = t),
    (e.maxStartPTS = o),
    (e.startDTS = r),
    (e.endPTS = s),
    (e.minEndPTS = l),
    (e.endDTS = i);
  const p = e.sn;
  if (!n || p < n.startSN || p > n.endSN) return 0;
  let g;
  const y = p - n.startSN,
    b = n.fragments;
  for (b[y] = e, g = y; g > 0; g--) bA(b[g], b[g - 1]);
  for (g = y; g < b.length - 1; g++) bA(b[g], b[g + 1]);
  return (
    n.fragmentHint && bA(b[b.length - 1], n.fragmentHint),
    (n.PTSKnown = n.alignedSliding = !0),
    m
  );
}
function yke(n, e) {
  if (n === e) return;
  let t = null;
  const s = n.fragments;
  for (let c = s.length - 1; c >= 0; c--) {
    const h = s[c].initSegment;
    if (h) {
      t = h;
      break;
    }
  }
  n.fragmentHint && delete n.fragmentHint.endPTS;
  let r;
  wke(n, e, (c, h, m, p) => {
    if ((!e.startCC || e.skippedSegments) && h.cc !== c.cc) {
      const g = c.cc - h.cc;
      for (let y = m; y < p.length; y++) p[y].cc += g;
      e.endCC = p[p.length - 1].cc;
    }
    Qe(c.startPTS) &&
      Qe(c.endPTS) &&
      (h.setStart((h.startPTS = c.startPTS)),
      (h.startDTS = c.startDTS),
      (h.maxStartPTS = c.maxStartPTS),
      (h.endPTS = c.endPTS),
      (h.endDTS = c.endDTS),
      (h.minEndPTS = c.minEndPTS),
      h.setDuration(c.endPTS - c.startPTS),
      h.duration && (r = h),
      (e.PTSKnown = e.alignedSliding = !0)),
      c.hasStreams && (h.elementaryStreams = c.elementaryStreams),
      (h.loader = c.loader),
      c.hasStats && (h.stats = c.stats),
      c.initSegment && ((h.initSegment = c.initSegment), (t = c.initSegment));
  });
  const i = e.fragments,
    a = e.fragmentHint ? i.concat(e.fragmentHint) : i;
  if (
    (t &&
      a.forEach((c) => {
        var h;
        c &&
          (!c.initSegment ||
            c.initSegment.relurl === ((h = t) == null ? void 0 : h.relurl)) &&
          (c.initSegment = t);
      }),
    e.skippedSegments)
  ) {
    if (((e.deltaUpdateFailed = i.some((c) => !c)), e.deltaUpdateFailed)) {
      pn.warn(
        "[level-helper] Previous playlist missing segments skipped in delta playlist"
      );
      for (let c = e.skippedSegments; c--; ) i.shift();
      e.startSN = i[0].sn;
    } else {
      e.canSkipDateRanges && (e.dateRanges = bke(n.dateRanges, e));
      const c = n.fragments.filter((h) => h.rawProgramDateTime);
      if (n.hasProgramDateTime && !e.hasProgramDateTime)
        for (let h = 1; h < a.length; h++)
          a[h].programDateTime === null && lI(a[h], a[h - 1], c);
      RY(c, e);
    }
    e.endCC = i[i.length - 1].cc;
  }
  if (!e.startCC) {
    var o;
    const c = LY(n, e.startSN - 1);
    e.startCC = (o = c?.cc) != null ? o : i[0].cc;
  }
  xke(n.partList, e.partList, (c, h) => {
    (h.elementaryStreams = c.elementaryStreams), (h.stats = c.stats);
  }),
    r ? kY(e, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : CY(n, e),
    i.length && (e.totalduration = e.edge - i[0].start),
    (e.driftStartTime = n.driftStartTime),
    (e.driftStart = n.driftStart);
  const l = e.advancedDateTime;
  if (e.advanced && l) {
    const c = e.edge;
    e.driftStart || ((e.driftStartTime = l), (e.driftStart = c)),
      (e.driftEndTime = l),
      (e.driftEnd = c);
  } else
    (e.driftEndTime = n.driftEndTime),
      (e.driftEnd = n.driftEnd),
      (e.advancedDateTime = n.advancedDateTime);
  e.requestScheduled === -1 && (e.requestScheduled = n.requestScheduled);
}
function bke(n, e) {
  const { dateRanges: t, recentlyRemovedDateranges: s } = e,
    r = Tn({}, n);
  s &&
    s.forEach((o) => {
      delete r[o];
    });
  const a = Object.keys(r).length;
  return (
    a &&
      Object.keys(t).forEach((o) => {
        const l = r[o],
          c = new TY(t[o].attr, l);
        c.isValid
          ? ((r[o] = c), l || (c.tagOrder += a))
          : pn.warn(
              `Ignoring invalid Playlist Delta Update DATERANGE tag: "${Wn(
                t[o].attr
              )}"`
            );
      }),
    r
  );
}
function xke(n, e, t) {
  if (n && e) {
    let s = 0;
    for (let r = 0, i = n.length; r <= i; r++) {
      const a = n[r],
        o = e[r + s];
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn
        ? t(a, o)
        : s--;
    }
  }
}
function wke(n, e, t) {
  const s = e.skippedSegments,
    r = Math.max(n.startSN, e.startSN) - e.startSN,
    i =
      (n.fragmentHint ? 1 : 0) +
      (s ? e.endSN : Math.min(n.endSN, e.endSN)) -
      e.startSN,
    a = e.startSN - n.startSN,
    o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments,
    l = n.fragmentHint ? n.fragments.concat(n.fragmentHint) : n.fragments;
  for (let c = r; c <= i; c++) {
    const h = l[a + c];
    let m = o[c];
    if ((s && !m && h && (m = e.fragments[c] = h), h && m)) {
      if ((t(h, m, c, o), h.url && h.url !== m.url)) {
        e.playlistParsingError = YB(
          `media sequence mismatch ${m.sn}:`,
          n,
          e,
          h,
          m
        );
        return;
      } else if (h.cc !== m.cc) {
        e.playlistParsingError = YB(
          `discontinuity sequence mismatch (${h.cc}!=${m.cc})`,
          n,
          e,
          h,
          m
        );
        return;
      }
    }
  }
}
function YB(n, e, t, s, r) {
  return new Error(`${n} ${r.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`);
}
function CY(n, e, t = !0) {
  const s = e.startSN + e.skippedSegments - n.startSN,
    r = n.fragments,
    i = s >= 0;
  let a = 0;
  if (i && s < r.length) a = r[s].start;
  else if (i && e.startSN === n.endSN + 1) a = n.fragmentEnd;
  else if (i && t) a = n.fragmentStart + s * e.levelTargetDuration;
  else if (!e.skippedSegments && e.fragmentStart === 0) a = n.fragmentStart;
  else return;
  cI(e, a);
}
function cI(n, e) {
  if (e) {
    const t = n.fragments;
    for (let s = n.skippedSegments; s < t.length; s++) t[s].addStart(e);
    n.fragmentHint && n.fragmentHint.addStart(e);
  }
}
function IY(n, e = 1 / 0) {
  let t = 1e3 * n.targetduration;
  if (n.updated) {
    const s = n.fragments;
    if (s.length && t * 4 > e) {
      const i = s[s.length - 1].duration * 1e3;
      i < t && (t = i);
    }
  } else t /= 2;
  return Math.round(t);
}
function LY(n, e, t) {
  if (!n) return null;
  let s = n.fragments[e - n.startSN];
  return s || ((s = n.fragmentHint), s && s.sn === e)
    ? s
    : e < n.startSN && t && t.sn === e
    ? t
    : null;
}
function XB(n, e, t) {
  return n ? DY(n.partList, e, t) : null;
}
function DY(n, e, t) {
  if (n)
    for (let s = n.length; s--; ) {
      const r = n[s];
      if (r.index === t && r.fragment.sn === e) return r;
    }
  return null;
}
function PY(n) {
  n.forEach((e, t) => {
    var s;
    (s = e.details) == null ||
      s.fragments.forEach((r) => {
        (r.level = t), r.initSegment && (r.initSegment.level = t);
      });
  });
}
function mg(n, e) {
  for (let s = 0, r = n.length; s < r; s++) {
    var t;
    if (((t = n[s]) == null ? void 0 : t.cc) === e) return n[s];
  }
  return null;
}
function Eke(n, e) {
  return !!(n && e.startCC < n.endCC && e.endCC > n.startCC);
}
function QB(n, e) {
  if (n) {
    const t = n.start + e;
    (n.start = n.startPTS = t), (n.endPTS = t + n.duration);
  }
}
function MY(n, e) {
  const t = e.fragments;
  for (let s = 0, r = t.length; s < r; s++) QB(t[s], n);
  e.fragmentHint && QB(e.fragmentHint, n), (e.alignedSliding = !0);
}
function Ske(n, e) {
  n &&
    (NY(e, n),
    !e.alignedSliding && n && Jw(e, n),
    !e.alignedSliding && n && !e.skippedSegments && CY(n, e, !1));
}
function NY(n, e) {
  if (!Eke(e, n)) return;
  const t = Math.min(e.endCC, n.endCC),
    s = mg(e.fragments, t),
    r = mg(n.fragments, t);
  if (!s || !r) return;
  pn.log(`Aligning playlist at start of dicontinuity sequence ${t}`);
  const i = s.start - r.start;
  MY(i, n);
}
function Jw(n, e) {
  if (!n.hasProgramDateTime || !e.hasProgramDateTime) return;
  const t = n.fragments,
    s = e.fragments;
  if (!t.length || !s.length) return;
  let r, i;
  const a = Math.min(e.endCC, n.endCC);
  e.startCC < a && n.startCC < a && ((r = mg(s, a)), (i = mg(t, a))),
    (!r || !i) &&
      ((r = s[Math.floor(s.length / 2)]),
      (i = mg(t, r.cc) || t[Math.floor(t.length / 2)]));
  const o = r.programDateTime,
    l = i.programDateTime;
  if (!o || !l) return;
  const c = (l - o) / 1e3 - (i.start - r.start);
  MY(c, n);
}
const Tke = {
    toString: function (n) {
      let e = "";
      const t = n.length;
      for (let s = 0; s < t; s++)
        e += `[${n.start(s).toFixed(3)}-${n.end(s).toFixed(3)}]`;
      return e;
    },
  },
  Me = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL",
  };
class QP extends EY {
  constructor(e, t, s, r, i) {
    super(r, e.logger),
      (this.hls = void 0),
      (this.fragPrevious = null),
      (this.fragCurrent = null),
      (this.fragmentTracker = void 0),
      (this.transmuxer = null),
      (this._state = Me.STOPPED),
      (this.playlistType = void 0),
      (this.media = null),
      (this.mediaBuffer = null),
      (this.config = void 0),
      (this.bitrateTest = !1),
      (this.lastCurrentTime = 0),
      (this.nextLoadPosition = 0),
      (this.startPosition = 0),
      (this.startTimeOffset = null),
      (this.retryDate = 0),
      (this.levels = null),
      (this.fragmentLoader = void 0),
      (this.keyLoader = void 0),
      (this.levelLastLoaded = null),
      (this.startFragRequested = !1),
      (this.decrypter = void 0),
      (this.initPTS = []),
      (this.buffering = !0),
      (this.loadingParts = !1),
      (this.loopSn = void 0),
      (this.onMediaSeeking = () => {
        const {
            config: a,
            fragCurrent: o,
            media: l,
            mediaBuffer: c,
            state: h,
          } = this,
          m = l ? l.currentTime : 0,
          p = Ft.bufferInfo(c || l, m, a.maxBufferHole),
          g = !p.len;
        if (
          (this.log(
            `Media seeking to ${Qe(m) ? m.toFixed(3) : m}, state: ${h}, ${
              g ? "out of" : "in"
            } buffer`
          ),
          this.state === Me.ENDED)
        )
          this.resetLoadingState();
        else if (o) {
          const y = a.maxFragLookUpTolerance,
            b = o.start - y,
            w = o.start + o.duration + y;
          if (g || w < p.start || b > p.end) {
            const S = m > w;
            (m < b || S) &&
              (S &&
                o.loader &&
                (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`),
                o.abortRequests(),
                this.resetLoadingState()),
              (this.fragPrevious = null));
          }
        }
        if (l) {
          this.fragmentTracker.removeFragmentsInRange(
            m,
            1 / 0,
            this.playlistType,
            !0
          );
          const y = this.lastCurrentTime;
          if ((m > y && (this.lastCurrentTime = m), !this.loadingParts)) {
            const b = Math.max(p.end, m),
              w = this.shouldLoadParts(this.getLevelDetails(), b);
            w &&
              (this.log(
                `LL-Part loading ON after seeking to ${m.toFixed(
                  2
                )} with buffer @${b.toFixed(2)}`
              ),
              (this.loadingParts = w));
          }
        }
        this.hls.hasEnoughToStart ||
          (this.log(
            `Setting ${
              g ? "startPosition" : "nextLoadPosition"
            } to ${m} for seek without enough to start`
          ),
          (this.nextLoadPosition = m),
          g && (this.startPosition = m)),
          this.tickImmediate();
      }),
      (this.onMediaEnded = () => {
        this.log("setting startPosition to 0 because media ended"),
          (this.startPosition = this.lastCurrentTime = 0);
      }),
      (this.playlistType = i),
      (this.hls = e),
      (this.fragmentLoader = new QRe(e.config)),
      (this.keyLoader = s),
      (this.fragmentTracker = t),
      (this.config = e.config),
      (this.decrypter = new KP(e.config));
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off($.ERROR, this.onError, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {}
  startLoad(e) {}
  stopLoad() {
    if (this.state === Me.STOPPED) return;
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null &&
      e.loader &&
      (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
      this.resetTransmuxer(),
      (this.fragCurrent = null),
      (this.fragPrevious = null),
      this.clearInterval(),
      this.clearNextTick(),
      (this.state = Me.STOPPED);
  }
  get startPositionValue() {
    const { nextLoadPosition: e, startPosition: t } = this;
    return t === -1 && e ? e : t;
  }
  get bufferingEnabled() {
    return this.buffering;
  }
  pauseBuffering() {
    this.buffering = !1;
  }
  resumeBuffering() {
    this.buffering = !0;
  }
  get inFlightFrag() {
    return { frag: this.fragCurrent, state: this.state };
  }
  _streamEnded(e, t) {
    if (t.live || !this.media) return !1;
    const s = e.end || 0,
      r = this.config.timelineOffset || 0;
    if (s <= r) return !1;
    const i = e.buffered;
    this.config.maxBufferHole &&
      i &&
      i.length > 1 &&
      (e = Ft.bufferedInfo(i, e.start, 0));
    const a = e.nextStart;
    if ((a && a > r && a < t.edge) || this.media.currentTime < e.start)
      return !1;
    const l = t.partList;
    if (l != null && l.length) {
      const h = l[l.length - 1];
      return Ft.isBuffered(this.media, h.start + h.duration / 2);
    }
    const c = t.fragments[t.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(c);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var e;
      return (e = this.levelLastLoaded) == null ? void 0 : e.details;
    }
  }
  get timelineOffset() {
    const e = this.config.timelineOffset;
    if (e) {
      var t;
      return (
        ((t = this.getLevelDetails()) == null
          ? void 0
          : t.appliedTimelineOffset) || e
      );
    }
    return 0;
  }
  onMediaAttached(e, t) {
    const s = (this.media = this.mediaBuffer = t.media);
    s.removeEventListener("seeking", this.onMediaSeeking),
      s.removeEventListener("ended", this.onMediaEnded),
      s.addEventListener("seeking", this.onMediaSeeking),
      s.addEventListener("ended", this.onMediaEnded);
    const r = this.config;
    this.levels &&
      r.autoStartLoad &&
      this.state === Me.STOPPED &&
      this.startLoad(r.startPosition);
  }
  onMediaDetaching(e, t) {
    const s = !!t.transferMedia,
      r = this.media;
    if (r !== null) {
      if (
        (r.ended &&
          (this.log("MSE detaching and video ended, reset startPosition"),
          (this.startPosition = this.lastCurrentTime = 0)),
        r.removeEventListener("seeking", this.onMediaSeeking),
        r.removeEventListener("ended", this.onMediaEnded),
        this.keyLoader && !s && this.keyLoader.detach(),
        (this.media = this.mediaBuffer = null),
        (this.loopSn = void 0),
        s)
      ) {
        this.resetLoadingState(), this.resetTransmuxer();
        return;
      }
      (this.loadingParts = !1),
        this.fragmentTracker.removeAllFragments(),
        this.stopLoad();
    }
  }
  onManifestLoading() {
    (this.initPTS = []),
      (this.levels = this.levelLastLoaded = this.fragCurrent = null),
      (this.lastCurrentTime = this.startPosition = 0),
      (this.startFragRequested = !1);
  }
  onError(e, t) {}
  onManifestLoaded(e, t) {
    this.startTimeOffset = t.startTimeOffset;
  }
  onHandlerDestroying() {
    this.stopLoad(),
      this.transmuxer && (this.transmuxer.destroy(), (this.transmuxer = null)),
      super.onHandlerDestroying(),
      (this.hls = this.onMediaSeeking = this.onMediaEnded = null);
  }
  onHandlerDestroyed() {
    (this.state = Me.STOPPED),
      this.fragmentLoader && this.fragmentLoader.destroy(),
      this.keyLoader && this.keyLoader.destroy(),
      this.decrypter && this.decrypter.destroy(),
      (this.hls =
        this.log =
        this.warn =
        this.decrypter =
        this.keyLoader =
        this.fragmentLoader =
        this.fragmentTracker =
          null),
      super.onHandlerDestroyed();
  }
  loadFragment(e, t, s) {
    (this.startFragRequested = !0), this._loadFragForPlayback(e, t, s);
  }
  _loadFragForPlayback(e, t, s) {
    const r = (i) => {
      const a = i.frag;
      if (this.fragContextChanged(a)) {
        this.warn(
          `${a.type} sn: ${a.sn}${
            i.part ? " part: " + i.part.index : ""
          } of ${this.fragInfo(a, !1, i.part)}) was dropped during download.`
        ),
          this.fragmentTracker.removeFragment(a);
        return;
      }
      a.stats.chunkCount++, this._handleFragmentLoadProgress(i);
    };
    this._doFragLoad(e, t, s, r)
      .then((i) => {
        if (!i) return;
        const a = this.state,
          o = i.frag;
        if (this.fragContextChanged(o)) {
          (a === Me.FRAG_LOADING || (!this.fragCurrent && a === Me.PARSING)) &&
            (this.fragmentTracker.removeFragment(o), (this.state = Me.IDLE));
          return;
        }
        "payload" in i &&
          (this.log(
            `Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`
          ),
          this.hls.trigger($.FRAG_LOADED, i)),
          this._handleFragmentLoadComplete(i);
      })
      .catch((i) => {
        this.state === Me.STOPPED ||
          this.state === Me.ERROR ||
          (this.warn(`Frag error: ${i?.message || i}`),
          this.resetFragmentLoading(e));
      });
  }
  clearTrackerIfNeeded(e) {
    var t;
    const { fragmentTracker: s } = this;
    if (s.getState(e) === qs.APPENDING) {
      const i = e.type,
        a = this.getFwdBufferInfo(this.mediaBuffer, i),
        o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength),
        l = this.backtrackFragment;
      ((l ? e.sn - l.sn : 0) === 1 ||
        this.reduceMaxBufferLength(o, e.duration)) &&
        s.removeFragment(e);
    } else
      ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0
        ? s.removeAllFragments()
        : s.hasParts(e.type) &&
          (s.detectPartialFragments({
            frag: e,
            part: null,
            stats: e.stats,
            id: e.type,
          }),
          s.getState(e) === qs.PARTIAL && s.removeFragment(e));
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const t = e.fragments[e.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: t,
        part: null,
        stats: t.stats,
        id: t.type,
      });
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0);
  }
  waitForLive(e) {
    const t = e.details;
    return (
      t?.live && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired)
    );
  }
  flushMainBuffer(e, t, s = null) {
    if (!(e - t)) return;
    const r = { startOffset: e, endOffset: t, type: s };
    this.hls.trigger($.BUFFER_FLUSHING, r);
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t)
      .then((s) => {
        const r = s?.frag;
        if (!r || this.fragContextChanged(r) || !this.levels)
          throw new Error("init load aborted");
        return s;
      })
      .then((s) => {
        const { hls: r } = this,
          { frag: i, payload: a } = s,
          o = i.decryptdata;
        if (
          a &&
          a.byteLength > 0 &&
          o != null &&
          o.key &&
          o.iv &&
          hf(o.method)
        ) {
          const l = self.performance.now();
          return this.decrypter
            .decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, XP(o.method))
            .catch((c) => {
              throw (
                (r.trigger($.ERROR, {
                  type: gt.MEDIA_ERROR,
                  details: we.FRAG_DECRYPT_ERROR,
                  fatal: !1,
                  error: c,
                  reason: c.message,
                  frag: i,
                }),
                c)
              );
            })
            .then((c) => {
              const h = self.performance.now();
              return (
                r.trigger($.FRAG_DECRYPTED, {
                  frag: i,
                  payload: c,
                  stats: { tstart: l, tdecrypt: h },
                }),
                (s.payload = c),
                this.completeInitSegmentLoad(s)
              );
            });
        }
        return this.completeInitSegmentLoad(s);
      })
      .catch((s) => {
        this.state === Me.STOPPED ||
          this.state === Me.ERROR ||
          (this.warn(s), this.resetFragmentLoading(e));
      });
  }
  completeInitSegmentLoad(e) {
    const { levels: t } = this;
    if (!t) throw new Error("init load aborted, missing levels");
    const s = e.frag.stats;
    this.state !== Me.STOPPED && (this.state = Me.IDLE),
      (e.frag.data = new Uint8Array(e.payload)),
      (s.parsing.start = s.buffering.start = self.performance.now()),
      (s.parsing.end = s.buffering.end = self.performance.now()),
      this.tick();
  }
  fragContextChanged(e) {
    const { fragCurrent: t } = this;
    return !e || !t || e.sn !== t.sn || e.level !== t.level;
  }
  fragBufferedComplete(e, t) {
    const s = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (
      (this.log(
        `Buffered ${e.type} sn: ${e.sn}${
          t ? " part: " + t.index : ""
        } of ${this.fragInfo(e, !1, t)} > buffer:${
          s ? Tke.toString(Ft.getBuffered(s)) : "(detached)"
        })`
      ),
      Os(e))
    ) {
      var r;
      if (e.type !== lt.SUBTITLE) {
        const a = e.elementaryStreams;
        if (!Object.keys(a).some((o) => !!a[o])) {
          this.state = Me.IDLE;
          return;
        }
      }
      const i = (r = this.levels) == null ? void 0 : r[e.level];
      i != null &&
        i.fragmentError &&
        (this.log(
          `Resetting level fragment error count of ${i.fragmentError} on frag buffered`
        ),
        (i.fragmentError = 0));
    }
    this.state = Me.IDLE;
  }
  _handleFragmentLoadComplete(e) {
    const { transmuxer: t } = this;
    if (!t) return;
    const { frag: s, part: r, partsLoaded: i } = e,
      a = !i || i.length === 0 || i.some((l) => !l),
      o = new YP(
        s.level,
        s.sn,
        s.stats.chunkCount + 1,
        0,
        r ? r.index : -1,
        !a
      );
    t.flush(o);
  }
  _handleFragmentLoadProgress(e) {}
  _doFragLoad(e, t, s = null, r) {
    var i;
    this.fragCurrent = e;
    const a = t?.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let o = null;
    e.encrypted && !((i = e.decryptdata) != null && i.key)
      ? (this.log(
          `Loading key for ${e.sn} of [${a.startSN}-${
            a.endSN
          }], ${this.playlistLabel()} ${e.level}`
        ),
        (this.state = Me.KEY_LOADING),
        (this.fragCurrent = e),
        (o = this.keyLoader.load(e).then((m) => {
          if (!this.fragContextChanged(m.frag))
            return (
              this.hls.trigger($.KEY_LOADED, m),
              this.state === Me.KEY_LOADING && (this.state = Me.IDLE),
              m
            );
        })),
        this.hls.trigger($.KEY_LOADING, { frag: e }),
        this.fragCurrent === null &&
          (o = Promise.reject(
            new Error("frag load aborted, context changed in KEY_LOADING")
          )))
      : e.encrypted ||
        ((o = this.keyLoader.loadClear(
          e,
          a.encryptedFragments,
          this.startFragRequested
        )),
        o && this.log("[eme] blocking frag load until media-keys acquired"));
    const l = this.fragPrevious;
    if (Os(e) && (!l || e.sn !== l.sn)) {
      const m = this.shouldLoadParts(t.details, e.end);
      m !== this.loadingParts &&
        (this.log(
          `LL-Part loading ${m ? "ON" : "OFF"} loading sn ${l?.sn}->${e.sn}`
        ),
        (this.loadingParts = m));
    }
    if (((s = Math.max(e.start, s || 0)), this.loadingParts && Os(e))) {
      const m = a.partList;
      if (m && r) {
        s > e.end && a.fragmentHint && (e = a.fragmentHint);
        const p = this.getNextPart(m, e, s);
        if (p > -1) {
          const g = m[p];
          (e = this.fragCurrent = g.fragment),
            this.log(
              `Loading ${e.type} sn: ${e.sn} part: ${g.index} (${p}/${
                m.length - 1
              }) of ${this.fragInfo(e, !1, g)}) cc: ${e.cc} [${a.startSN}-${
                a.endSN
              }], target: ${parseFloat(s.toFixed(3))}`
            ),
            (this.nextLoadPosition = g.start + g.duration),
            (this.state = Me.FRAG_LOADING);
          let y;
          return (
            o
              ? (y = o
                  .then((b) =>
                    !b || this.fragContextChanged(b.frag)
                      ? null
                      : this.doFragPartsLoad(e, g, t, r)
                  )
                  .catch((b) => this.handleFragLoadError(b)))
              : (y = this.doFragPartsLoad(e, g, t, r).catch((b) =>
                  this.handleFragLoadError(b)
                )),
            this.hls.trigger($.FRAG_LOADING, {
              frag: e,
              part: g,
              targetBufferTime: s,
            }),
            this.fragCurrent === null
              ? Promise.reject(
                  new Error(
                    "frag load aborted, context changed in FRAG_LOADING parts"
                  )
                )
              : y
          );
        } else if (!e.url || this.loadedEndOfParts(m, s))
          return Promise.resolve(null);
      }
    }
    if (Os(e) && this.loadingParts)
      this.log(`LL-Part loading OFF after next part miss @${s.toFixed(2)}`),
        (this.loadingParts = !1);
    else if (!e.url) return Promise.resolve(null);
    this.log(
      `Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${
        a ? "[" + a.startSN + "-" + a.endSN + "]" : ""
      }, target: ${parseFloat(s.toFixed(3))}`
    ),
      Qe(e.sn) &&
        !this.bitrateTest &&
        (this.nextLoadPosition = e.start + e.duration),
      (this.state = Me.FRAG_LOADING);
    const c = this.config.progressive;
    let h;
    return (
      c && o
        ? (h = o
            .then((m) =>
              !m || this.fragContextChanged(m?.frag)
                ? null
                : this.fragmentLoader.load(e, r)
            )
            .catch((m) => this.handleFragLoadError(m)))
        : (h = Promise.all([this.fragmentLoader.load(e, c ? r : void 0), o])
            .then(([m]) => (!c && m && r && r(m), m))
            .catch((m) => this.handleFragLoadError(m))),
      this.hls.trigger($.FRAG_LOADING, { frag: e, targetBufferTime: s }),
      this.fragCurrent === null
        ? Promise.reject(
            new Error("frag load aborted, context changed in FRAG_LOADING")
          )
        : h
    );
  }
  doFragPartsLoad(e, t, s, r) {
    return new Promise((i, a) => {
      var o;
      const l = [],
        c = (o = s.details) == null ? void 0 : o.partList,
        h = (m) => {
          this.fragmentLoader
            .loadPart(e, m, r)
            .then((p) => {
              l[m.index] = p;
              const g = p.part;
              this.hls.trigger($.FRAG_LOADED, p);
              const y =
                XB(s.details, e.sn, m.index + 1) || DY(c, e.sn, m.index + 1);
              if (y) h(y);
              else return i({ frag: e, part: g, partsLoaded: l });
            })
            .catch(a);
        };
      h(t);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const t = e.data;
      e.data && t.details === we.INTERNAL_ABORTED
        ? this.handleFragLoadAborted(t.frag, t.part)
        : this.hls.trigger($.ERROR, t);
    } else
      this.hls.trigger($.ERROR, {
        type: gt.OTHER_ERROR,
        details: we.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0,
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e);
    if (!t || this.state !== Me.PARSING) {
      !this.fragCurrent &&
        this.state !== Me.STOPPED &&
        this.state !== Me.ERROR &&
        (this.state = Me.IDLE);
      return;
    }
    const { frag: s, part: r, level: i } = t,
      a = self.performance.now();
    (s.stats.parsing.end = a), r && (r.stats.parsing.end = a);
    const o = this.getLevelDetails(),
      c = (o && s.sn > o.endSN) || this.shouldLoadParts(o, s.end);
    c !== this.loadingParts &&
      (this.log(
        `LL-Part loading ${
          c ? "ON" : "OFF"
        } after parsing segment ending @${s.end.toFixed(2)}`
      ),
      (this.loadingParts = c)),
      this.updateLevelTiming(s, r, i, e.partial);
  }
  shouldLoadParts(e, t) {
    if (this.config.lowLatencyMode) {
      if (!e) return this.loadingParts;
      if (e != null && e.partList) {
        var s;
        const i = e.partList[0],
          a =
            i.end + (((s = e.fragmentHint) == null ? void 0 : s.duration) || 0);
        if (t >= a) {
          var r;
          if (
            (this.hls.hasEnoughToStart
              ? ((r = this.media) == null ? void 0 : r.currentTime) ||
                this.lastCurrentTime
              : this.getLoadPosition()) >
            i.start - i.fragment.duration
          )
            return !0;
        }
      }
    }
    return !1;
  }
  getCurrentContext(e) {
    const { levels: t, fragCurrent: s } = this,
      { level: r, sn: i, part: a } = e;
    if (!(t != null && t[r]))
      return (
        this.warn(
          `Levels object was unset while buffering fragment ${i} of ${this.playlistLabel()} ${r}. The current chunk will not be buffered.`
        ),
        null
      );
    const o = t[r],
      l = o.details,
      c = a > -1 ? XB(l, i, a) : null,
      h = c ? c.fragment : LY(l, i, s);
    return h
      ? (s && s !== h && (h.stats = s.stats), { frag: h, part: c, level: o })
      : null;
  }
  bufferFragmentData(e, t, s, r, i) {
    var a;
    if (!e || this.state !== Me.PARSING) return;
    const { data1: o, data2: l } = e;
    let c = o;
    if ((o && l && (c = da(o, l)), !((a = c) != null && a.length))) return;
    const h = this.initPTS[t.cc],
      m = h ? -h.baseTime / h.timescale : void 0,
      p = {
        type: e.type,
        frag: t,
        part: s,
        chunkMeta: r,
        offset: m,
        parent: t.type,
        data: c,
      };
    if (
      (this.hls.trigger($.BUFFER_APPENDING, p),
      e.dropped && e.independent && !s)
    ) {
      if (i) return;
      this.flushBufferGap(t);
    }
  }
  flushBufferGap(e) {
    const t = this.media;
    if (!t) return;
    if (!Ft.isBuffered(t, t.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const s = t.currentTime,
      r = Ft.bufferInfo(t, s, 0),
      i = e.duration,
      a = Math.min(this.config.maxFragLookUpTolerance * 2, i * 0.25),
      o = Math.max(Math.min(e.start - a, r.end - a), s + a);
    e.start - o > a && this.flushMainBuffer(o, e.start);
  }
  getFwdBufferInfo(e, t) {
    var s;
    const r = this.getLoadPosition();
    if (!Qe(r)) return null;
    const a =
      this.lastCurrentTime > r || ((s = this.media) != null && s.paused)
        ? 0
        : this.config.maxBufferHole;
    return this.getFwdBufferInfoAtPos(e, r, t, a);
  }
  getFwdBufferInfoAtPos(e, t, s, r) {
    const i = Ft.bufferInfo(e, t, r);
    if (i.len === 0 && i.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(t, s);
      if (a && (i.nextStart <= a.end || a.gap)) {
        const o = Math.max(Math.min(i.nextStart, a.end) - t, r);
        return Ft.bufferInfo(e, t, o);
      }
    }
    return i;
  }
  getMaxBufferLength(e) {
    const { config: t } = this;
    let s;
    return (
      e
        ? (s = Math.max((8 * t.maxBufferSize) / e, t.maxBufferLength))
        : (s = t.maxBufferLength),
      Math.min(s, t.maxMaxBufferLength)
    );
  }
  reduceMaxBufferLength(e, t) {
    const s = this.config,
      r = Math.max(Math.min(e - t, s.maxBufferLength), t),
      i = Math.max(e - t * 3, s.maxMaxBufferLength / 2, r);
    return i >= r
      ? ((s.maxMaxBufferLength = i),
        this.warn(`Reduce max buffer length to ${i}s`),
        !0)
      : !1;
  }
  getAppendedFrag(e, t = lt.MAIN) {
    var s;
    const r =
      (s = this.fragmentTracker) == null ? void 0 : s.getAppendedFrag(e, t);
    return r && "fragment" in r ? r.fragment : r;
  }
  getNextFragment(e, t) {
    const s = t.fragments,
      r = s.length;
    if (!r) return null;
    const { config: i } = this,
      a = s[0].start,
      o = i.lowLatencyMode && !!t.partList;
    let l = null;
    if (t.live) {
      const m = i.initialLiveManifestSize;
      if (r < m)
        return (
          this.warn(
            `Not enough fragments to start playback (have: ${r}, need: ${m})`
          ),
          null
        );
      if (
        (!t.PTSKnown &&
          !this.startFragRequested &&
          this.startPosition === -1) ||
        e < a
      ) {
        var c;
        o &&
          !this.loadingParts &&
          (this.log("LL-Part loading ON for initial live fragment"),
          (this.loadingParts = !0)),
          (l = this.getInitialLiveFragment(t));
        const p = this.hls.startPosition,
          g = this.hls.liveSyncPosition,
          y = l ? (p !== -1 && p >= a ? p : g) || l.start : e;
        this.log(
          `Setting startPosition to ${y} to match start frag at live edge. mainStart: ${p} liveSyncPosition: ${g} frag.start: ${
            (c = l) == null ? void 0 : c.start
          }`
        ),
          (this.startPosition = this.nextLoadPosition = y);
      }
    } else e <= a && (l = s[0]);
    if (!l) {
      const m = this.loadingParts ? t.partEnd : t.fragmentEnd;
      l = this.getFragmentAtPosition(e, m, t);
    }
    let h = this.filterReplacedPrimary(l, t);
    if (!h && l) {
      const m = l.sn - t.startSN;
      h = this.filterReplacedPrimary(s[m + 1] || null, t);
    }
    return this.mapToInitFragWhenRequired(h);
  }
  isLoopLoading(e, t) {
    const s = this.fragmentTracker.getState(e);
    return (
      (s === qs.OK || (s === qs.PARTIAL && !!e.gap)) &&
      this.nextLoadPosition > t
    );
  }
  getNextFragmentLoopLoading(e, t, s, r, i) {
    let a = null;
    if (
      e.gap &&
      ((a = this.getNextFragment(this.nextLoadPosition, t)),
      a && !a.gap && s.nextStart)
    ) {
      const o = this.getFwdBufferInfoAtPos(
        this.mediaBuffer ? this.mediaBuffer : this.media,
        s.nextStart,
        r,
        0
      );
      if (o !== null && s.len + o.len >= i) {
        const l = a.sn;
        return (
          this.loopSn !== l &&
            (this.log(
              `buffer full after gaps in "${r}" playlist starting at sn: ${l}`
            ),
            (this.loopSn = l)),
          null
        );
      }
    }
    return (this.loopSn = void 0), a;
  }
  get primaryPrefetch() {
    if (ZB(this.hls.config)) {
      var e, t;
      if (
        (e = this.hls.interstitialsManager) == null ||
        (t = e.playingItem) == null
          ? void 0
          : t.event
      )
        return !0;
    }
    return !1;
  }
  filterReplacedPrimary(e, t) {
    if (!e) return e;
    if (ZB(this.hls.config) && e.type !== lt.SUBTITLE) {
      const s = this.hls.interstitialsManager,
        r = s?.bufferingItem;
      if (r) {
        const a = r.event;
        if (a) {
          if (
            a.appendInPlace ||
            Math.abs(e.start - r.start) > 1 ||
            r.start === 0
          )
            return null;
        } else if (
          (e.end <= r.start && t?.live === !1) ||
          (e.start > r.end &&
            r.nextEvent &&
            (r.nextEvent.appendInPlace || e.start - r.end > 1))
        )
          return null;
      }
      const i = s?.playerQueue;
      if (i)
        for (let a = i.length; a--; ) {
          const o = i[a].interstitial;
          if (
            o.appendInPlace &&
            e.start >= o.startTime &&
            e.end <= o.resumeTime
          )
            return null;
        }
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null &&
      e.initSegment &&
      !(e != null && e.initSegment.data) &&
      !this.bitrateTest
      ? e.initSegment
      : e;
  }
  getNextPart(e, t, s) {
    let r = -1,
      i = !1,
      a = !0;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      if (((a = a && !c.independent), r > -1 && s < c.start)) break;
      const h = c.loaded;
      h ? (r = -1) : (i || c.independent || a) && c.fragment === t && (r = o),
        (i = h);
    }
    return r;
  }
  loadedEndOfParts(e, t) {
    const s = e[e.length - 1];
    return s && t > s.start && s.loaded;
  }
  getInitialLiveFragment(e) {
    const t = e.fragments,
      s = this.fragPrevious;
    let r = null;
    if (s) {
      if (
        (e.hasProgramDateTime &&
          (this.log(
            `Live playlist, switching playlist, load frag with same PDT: ${s.programDateTime}`
          ),
          (r = URe(
            t,
            s.endProgramDateTime,
            this.config.maxFragLookUpTolerance
          ))),
        !r)
      ) {
        const i = s.sn + 1;
        if (i >= e.startSN && i <= e.endSN) {
          const a = t[i - e.startSN];
          s.cc === a.cc &&
            ((r = a),
            this.log(
              `Live playlist, switching playlist, load frag with next SN: ${r.sn}`
            ));
        }
        r ||
          ((r = wY(e, s.cc, s.end)),
          r &&
            this.log(
              `Live playlist, switching playlist, load frag with same CC: ${r.sn}`
            ));
      }
    } else {
      const i = this.hls.liveSyncPosition;
      i !== null &&
        (r = this.getFragmentAtPosition(
          i,
          this.bitrateTest ? e.fragmentEnd : e.edge,
          e
        ));
    }
    return r;
  }
  getFragmentAtPosition(e, t, s) {
    const { config: r } = this;
    let { fragPrevious: i } = this,
      { fragments: a, endSN: o } = s;
    const { fragmentHint: l } = s,
      { maxFragLookUpTolerance: c } = r,
      h = s.partList,
      m = !!(this.loadingParts && h != null && h.length && l);
    m &&
      l &&
      !this.bitrateTest &&
      h[h.length - 1].fragment.sn === l.sn &&
      ((a = a.concat(l)), (o = l.sn));
    let p;
    if (e < t) {
      var g;
      const b =
        e < this.lastCurrentTime ||
        e > t - c ||
        ((g = this.media) != null && g.paused) ||
        !this.startFragRequested
          ? 0
          : c;
      p = id(i, a, e, b);
    } else p = a[a.length - 1];
    if (p) {
      const y = p.sn - s.startSN,
        b = this.fragmentTracker.getState(p);
      if (
        ((b === qs.OK || (b === qs.PARTIAL && p.gap)) && (i = p),
        i &&
          p.sn === i.sn &&
          (!m || h[0].fragment.sn > p.sn || (!s.live && !m)) &&
          i &&
          p.level === i.level)
      ) {
        const S = a[y + 1];
        p.sn < o && this.fragmentTracker.getState(S) !== qs.OK
          ? (p = S)
          : (p = null);
      }
    }
    return p;
  }
  alignPlaylists(e, t, s) {
    const r = e.fragments.length;
    if (!r) return this.warn("No fragments in live playlist"), 0;
    const i = e.fragmentStart,
      a = !t,
      o = e.alignedSliding && Qe(i);
    if (a || (!o && !i)) {
      Ske(s, e);
      const l = e.fragmentStart;
      return (
        this.log(
          `Live playlist sliding: ${l.toFixed(2)} start-sn: ${
            t ? t.startSN : "na"
          }->${e.startSN} fragments: ${r}`
        ),
        l
      );
    }
    return i;
  }
  waitForCdnTuneIn(e) {
    return (
      e.live &&
      e.canBlockReload &&
      e.partTarget &&
      e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3)
    );
  }
  setStartPosition(e, t) {
    let s = this.startPosition;
    s < t && (s = -1);
    const r = this.timelineOffset;
    if (s === -1) {
      const i = this.startTimeOffset !== null,
        a = i ? this.startTimeOffset : e.startTimeOffset;
      a !== null && Qe(a)
        ? ((s = t + a),
          a < 0 && (s += e.edge),
          (s = Math.min(Math.max(t, s), t + e.totalduration)),
          this.log(
            `Setting startPosition to ${s} for start time offset ${a} found in ${
              i ? "multivariant" : "media"
            } playlist`
          ),
          (this.startPosition = s))
        : e.live
        ? ((s = this.hls.liveSyncPosition || t),
          this.log(`Setting startPosition to -1 to start at live edge ${s}`),
          (this.startPosition = -1))
        : (this.log("setting startPosition to 0 by default"),
          (this.startPosition = s = 0)),
        (this.lastCurrentTime = s + r);
    }
    this.nextLoadPosition = s + r;
  }
  getLoadPosition() {
    var e;
    const { media: t } = this;
    let s = 0;
    return (
      (e = this.hls) != null && e.hasEnoughToStart && t
        ? (s = t.currentTime)
        : this.nextLoadPosition >= 0 && (s = this.nextLoadPosition),
      s
    );
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer &&
      e.type === this.playlistType &&
      Os(e) &&
      e.stats.aborted &&
      (this.log(
        `Fragment ${e.sn}${
          t ? " part " + t.index : ""
        } of ${this.playlistLabel()} ${e.level} was aborted`
      ),
      this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent ||
      (!this.fragContextChanged(e) &&
        this.state !== Me.FRAG_LOADING_WAITING_RETRY)) &&
      (this.state = Me.IDLE);
  }
  onFragmentOrKeyLoadError(e, t) {
    if (t.chunkMeta && !t.frag) {
      const y = this.getCurrentContext(t.chunkMeta);
      y && (t.frag = y.frag);
    }
    const s = t.frag;
    if (!s || s.type !== e || !this.levels) return;
    if (this.fragContextChanged(s)) {
      var r;
      this.warn(
        `Frag load error must match current frag to retry ${s.url} > ${
          (r = this.fragCurrent) == null ? void 0 : r.url
        }`
      );
      return;
    }
    const i = t.details === we.FRAG_GAP;
    i && this.fragmentTracker.fragBuffered(s, !0);
    const a = t.errorAction,
      { action: o, flags: l, retryCount: c = 0, retryConfig: h } = a || {},
      m = !!a && !!h,
      p = m && o === kr.RetryRequest,
      g = m && !a.resolved && l === _a.MoveAllAlternatesMatchingHost;
    if (!p && g && Os(s) && !s.endList)
      this.resetFragmentErrors(e), this.treatAsGap(s), (a.resolved = !0);
    else if ((p || g) && c < h.maxNumRetry) {
      this.resetStartWhenNotLoaded(this.levelLastLoaded);
      const y = WP(h, c);
      this.warn(
        `Fragment ${s.sn} of ${e} ${s.level} errored with ${
          t.details
        }, retrying loading ${c + 1}/${h.maxNumRetry} in ${y}ms`
      ),
        (a.resolved = !0),
        (this.retryDate = self.performance.now() + y),
        (this.state = Me.FRAG_LOADING_WAITING_RETRY);
    } else if (h && a)
      if ((this.resetFragmentErrors(e), c < h.maxNumRetry))
        !i && o !== kr.RemoveAlternatePermanently && (a.resolved = !0);
      else {
        this.warn(`${t.details} reached or exceeded max retry (${c})`);
        return;
      }
    else
      o === kr.SendAlternateToPenaltyBox
        ? (this.state = Me.WAITING_LEVEL)
        : (this.state = Me.ERROR);
    this.tickImmediate();
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === Me.PARSING || this.state === Me.PARSED) {
      const t = e.frag,
        s = e.parent,
        r = this.getFwdBufferInfo(this.mediaBuffer, s),
        i = r && r.len > 0.5;
      i && this.reduceMaxBufferLength(r.len, t?.duration || 10);
      const a = !i;
      return (
        a &&
          this.warn(
            `Buffer full error while media.currentTime is not buffered, flush ${s} buffer`
          ),
        t &&
          (this.fragmentTracker.removeFragment(t),
          (this.nextLoadPosition = t.start)),
        this.resetLoadingState(),
        a
      );
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === lt.AUDIO && (this.fragCurrent = null),
      this.hls.hasEnoughToStart || (this.startFragRequested = !1),
      this.state !== Me.STOPPED && (this.state = Me.IDLE);
  }
  afterBufferFlushed(e, t, s) {
    if (!e) return;
    const r = Ft.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(t, r, s),
      this.state === Me.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"),
      (this.fragCurrent = null),
      (this.fragPrevious = null),
      this.state !== Me.STOPPED && (this.state = Me.IDLE);
  }
  resetStartWhenNotLoaded(e) {
    if (!this.hls.hasEnoughToStart) {
      this.startFragRequested = !1;
      const t = e ? e.details : null;
      t != null && t.live
        ? (this.log("resetting startPosition for live start"),
          (this.startPosition = -1),
          this.setStartPosition(t, t.fragmentStart),
          this.resetLoadingState())
        : (this.nextLoadPosition = this.startPosition);
    }
  }
  resetWhenMissingContext(e) {
    this.warn(
      `The loading context changed while buffering fragment ${
        e.sn
      } of ${this.playlistLabel()} ${e.level}. This chunk will not be buffered.`
    ),
      this.removeUnbufferedFrags(),
      this.resetStartWhenNotLoaded(this.levelLastLoaded),
      this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(
      e,
      1 / 0,
      this.playlistType,
      !1,
      !0
    );
  }
  updateLevelTiming(e, t, s, r) {
    const i = s.details;
    if (!i) {
      this.warn("level.details undefined");
      return;
    }
    if (
      !Object.keys(e.elementaryStreams).reduce((l, c) => {
        const h = e.elementaryStreams[c];
        if (h) {
          const m = h.endPTS - h.startPTS;
          if (m <= 0)
            return (
              this.warn(
                `Could not parse fragment ${e.sn} ${c} duration reliably (${m})`
              ),
              l || !1
            );
          const p = r
            ? 0
            : kY(i, e, h.startPTS, h.endPTS, h.startDTS, h.endDTS);
          return (
            this.hls.trigger($.LEVEL_PTS_UPDATED, {
              details: i,
              level: s,
              drift: p,
              type: c,
              frag: e,
              start: h.startPTS,
              end: h.endPTS,
            }),
            !0
          );
        }
        return l;
      }, !1)
    ) {
      var o;
      if (
        (s.fragmentError === 0 && this.treatAsGap(e, s),
        ((o = this.transmuxer) == null ? void 0 : o.error) === null)
      ) {
        const l = new Error(
          `Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${
            e.level
          } resetting transmuxer to fallback to playlist timing`
        );
        if (
          (this.warn(l.message),
          this.hls.trigger($.ERROR, {
            type: gt.MEDIA_ERROR,
            details: we.FRAG_PARSING_ERROR,
            fatal: !1,
            error: l,
            frag: e,
            reason: `Found no media in msn ${
              e.sn
            } of ${this.playlistLabel()} "${s.url}"`,
          }),
          !this.hls)
        )
          return;
        this.resetTransmuxer();
      }
    }
    (this.state = Me.PARSED),
      this.log(
        `Parsed ${e.type} sn: ${e.sn}${
          t ? " part: " + t.index : ""
        } of ${this.fragInfo(e, !1, t)})`
      ),
      this.hls.trigger($.FRAG_PARSED, { frag: e, part: t });
  }
  playlistLabel() {
    return this.playlistType === lt.MAIN ? "level" : "track";
  }
  fragInfo(e, t = !0, s) {
    var r, i;
    return `${this.playlistLabel()} ${e.level} (${s ? "part" : "frag"}:[${((r =
      t && !s ? e.startPTS : (s || e).start) != null
      ? r
      : NaN
    ).toFixed(3)}-${((i = t && !s ? e.endPTS : (s || e).end) != null
      ? i
      : NaN
    ).toFixed(3)}]${
      s && e.type === "main"
        ? "INDEPENDENT=" + (s.independent ? "YES" : "NO")
        : ""
    }`;
  }
  treatAsGap(e, t) {
    t && t.fragmentError++,
      (e.gap = !0),
      this.fragmentTracker.removeFragment(e),
      this.fragmentTracker.fragBuffered(e, !0);
  }
  resetTransmuxer() {
    var e;
    (e = this.transmuxer) == null || e.reset();
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" &&
      (this.fragmentTracker.removeAllFragments(),
      this.transmuxer && (this.transmuxer.destroy(), (this.transmuxer = null)),
      this.resetStartWhenNotLoaded(this.levelLastLoaded),
      this.resetLoadingState());
  }
  set state(e) {
    const t = this._state;
    t !== e && ((this._state = e), this.log(`${t}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function ZB(n) {
  return !!n.interstitialsController && n.enableInterstitialPlayback !== !1;
}
class OY {
  constructor() {
    (this.chunks = []), (this.dataLength = 0);
  }
  push(e) {
    this.chunks.push(e), (this.dataLength += e.length);
  }
  flush() {
    const { chunks: e, dataLength: t } = this;
    let s;
    if (e.length) e.length === 1 ? (s = e[0]) : (s = _ke(e, t));
    else return new Uint8Array(0);
    return this.reset(), s;
  }
  reset() {
    (this.chunks.length = 0), (this.dataLength = 0);
  }
}
function _ke(n, e) {
  const t = new Uint8Array(e);
  let s = 0;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    t.set(i, s), (s += i.length);
  }
  return t;
}
var xA = { exports: {} },
  JB;
function Ake() {
  return (
    JB ||
      ((JB = 1),
      (function (n) {
        var e = Object.prototype.hasOwnProperty,
          t = "~";
        function s() {}
        Object.create &&
          ((s.prototype = Object.create(null)), new s().__proto__ || (t = !1));
        function r(l, c, h) {
          (this.fn = l), (this.context = c), (this.once = h || !1);
        }
        function i(l, c, h, m, p) {
          if (typeof h != "function")
            throw new TypeError("The listener must be a function");
          var g = new r(h, m || l, p),
            y = t ? t + c : c;
          return (
            l._events[y]
              ? l._events[y].fn
                ? (l._events[y] = [l._events[y], g])
                : l._events[y].push(g)
              : ((l._events[y] = g), l._eventsCount++),
            l
          );
        }
        function a(l, c) {
          --l._eventsCount === 0 ? (l._events = new s()) : delete l._events[c];
        }
        function o() {
          (this._events = new s()), (this._eventsCount = 0);
        }
        (o.prototype.eventNames = function () {
          var c = [],
            h,
            m;
          if (this._eventsCount === 0) return c;
          for (m in (h = this._events))
            e.call(h, m) && c.push(t ? m.slice(1) : m);
          return Object.getOwnPropertySymbols
            ? c.concat(Object.getOwnPropertySymbols(h))
            : c;
        }),
          (o.prototype.listeners = function (c) {
            var h = t ? t + c : c,
              m = this._events[h];
            if (!m) return [];
            if (m.fn) return [m.fn];
            for (var p = 0, g = m.length, y = new Array(g); p < g; p++)
              y[p] = m[p].fn;
            return y;
          }),
          (o.prototype.listenerCount = function (c) {
            var h = t ? t + c : c,
              m = this._events[h];
            return m ? (m.fn ? 1 : m.length) : 0;
          }),
          (o.prototype.emit = function (c, h, m, p, g, y) {
            var b = t ? t + c : c;
            if (!this._events[b]) return !1;
            var w = this._events[b],
              S = arguments.length,
              A,
              _;
            if (w.fn) {
              switch ((w.once && this.removeListener(c, w.fn, void 0, !0), S)) {
                case 1:
                  return w.fn.call(w.context), !0;
                case 2:
                  return w.fn.call(w.context, h), !0;
                case 3:
                  return w.fn.call(w.context, h, m), !0;
                case 4:
                  return w.fn.call(w.context, h, m, p), !0;
                case 5:
                  return w.fn.call(w.context, h, m, p, g), !0;
                case 6:
                  return w.fn.call(w.context, h, m, p, g, y), !0;
              }
              for (_ = 1, A = new Array(S - 1); _ < S; _++)
                A[_ - 1] = arguments[_];
              w.fn.apply(w.context, A);
            } else {
              var R = w.length,
                C;
              for (_ = 0; _ < R; _++)
                switch (
                  (w[_].once && this.removeListener(c, w[_].fn, void 0, !0), S)
                ) {
                  case 1:
                    w[_].fn.call(w[_].context);
                    break;
                  case 2:
                    w[_].fn.call(w[_].context, h);
                    break;
                  case 3:
                    w[_].fn.call(w[_].context, h, m);
                    break;
                  case 4:
                    w[_].fn.call(w[_].context, h, m, p);
                    break;
                  default:
                    if (!A)
                      for (C = 1, A = new Array(S - 1); C < S; C++)
                        A[C - 1] = arguments[C];
                    w[_].fn.apply(w[_].context, A);
                }
            }
            return !0;
          }),
          (o.prototype.on = function (c, h, m) {
            return i(this, c, h, m, !1);
          }),
          (o.prototype.once = function (c, h, m) {
            return i(this, c, h, m, !0);
          }),
          (o.prototype.removeListener = function (c, h, m, p) {
            var g = t ? t + c : c;
            if (!this._events[g]) return this;
            if (!h) return a(this, g), this;
            var y = this._events[g];
            if (y.fn)
              y.fn === h &&
                (!p || y.once) &&
                (!m || y.context === m) &&
                a(this, g);
            else {
              for (var b = 0, w = [], S = y.length; b < S; b++)
                (y[b].fn !== h ||
                  (p && !y[b].once) ||
                  (m && y[b].context !== m)) &&
                  w.push(y[b]);
              w.length
                ? (this._events[g] = w.length === 1 ? w[0] : w)
                : a(this, g);
            }
            return this;
          }),
          (o.prototype.removeAllListeners = function (c) {
            var h;
            return (
              c
                ? ((h = t ? t + c : c), this._events[h] && a(this, h))
                : ((this._events = new s()), (this._eventsCount = 0)),
              this
            );
          }),
          (o.prototype.off = o.prototype.removeListener),
          (o.prototype.addListener = o.prototype.on),
          (o.prefixed = t),
          (o.EventEmitter = o),
          (n.exports = o);
      })(xA)),
    xA.exports
  );
}
var Rke = Ake(),
  ZP = tRe(Rke);
const pv = "1.6.7",
  Mf = {};
function kke() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function Cke() {
  const n = Mf[pv];
  if (n) return n.clientCount++, n;
  const e = new self.Blob(
      [
        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`,
      ],
      { type: "text/javascript" }
    ),
    t = self.URL.createObjectURL(e),
    r = { worker: new self.Worker(t), objectURL: t, clientCount: 1 };
  return (Mf[pv] = r), r;
}
function Ike(n) {
  const e = Mf[n];
  if (e) return e.clientCount++, e;
  const t = new self.URL(n, self.location.href).href,
    r = { worker: new self.Worker(t), scriptURL: t, clientCount: 1 };
  return (Mf[n] = r), r;
}
function Lke(n) {
  const e = Mf[n || pv];
  if (e && e.clientCount-- === 1) {
    const { worker: s, objectURL: r } = e;
    delete Mf[n || pv], r && self.URL.revokeObjectURL(r), s.terminate();
  }
}
function jY(n, e) {
  return (
    e + 10 <= n.length &&
    n[e] === 51 &&
    n[e + 1] === 68 &&
    n[e + 2] === 73 &&
    n[e + 3] < 255 &&
    n[e + 4] < 255 &&
    n[e + 6] < 128 &&
    n[e + 7] < 128 &&
    n[e + 8] < 128 &&
    n[e + 9] < 128
  );
}
function JP(n, e) {
  return (
    e + 10 <= n.length &&
    n[e] === 73 &&
    n[e + 1] === 68 &&
    n[e + 2] === 51 &&
    n[e + 3] < 255 &&
    n[e + 4] < 255 &&
    n[e + 6] < 128 &&
    n[e + 7] < 128 &&
    n[e + 8] < 128 &&
    n[e + 9] < 128
  );
}
function mS(n, e) {
  let t = 0;
  return (
    (t = (n[e] & 127) << 21),
    (t |= (n[e + 1] & 127) << 14),
    (t |= (n[e + 2] & 127) << 7),
    (t |= n[e + 3] & 127),
    t
  );
}
function gv(n, e) {
  const t = e;
  let s = 0;
  for (; JP(n, e); ) {
    s += 10;
    const r = mS(n, e + 6);
    (s += r), jY(n, e + 10) && (s += 10), (e += s);
  }
  if (s > 0) return n.subarray(t, t + s);
}
function Dke(n, e, t, s) {
  const r = [
      96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3,
      7350,
    ],
    i = e[t + 2],
    a = (i >> 2) & 15;
  if (a > 12) {
    const g = new Error(`invalid ADTS sampling index:${a}`);
    n.emit($.ERROR, $.ERROR, {
      type: gt.MEDIA_ERROR,
      details: we.FRAG_PARSING_ERROR,
      fatal: !0,
      error: g,
      reason: g.message,
    });
    return;
  }
  const o = ((i >> 6) & 3) + 1,
    l = ((e[t + 3] >> 6) & 3) | ((i & 1) << 2),
    c = "mp4a.40." + o,
    h = r[a];
  let m = a;
  (o === 5 || o === 29) && (m -= 3);
  const p = [(o << 3) | ((m & 14) >> 1), ((m & 1) << 7) | (l << 3)];
  return (
    pn.log(
      `manifest codec:${s}, parsed codec:${c}, channels:${l}, rate:${h} (ADTS object type:${o} sampling index:${a})`
    ),
    {
      config: p,
      samplerate: h,
      channelCount: l,
      codec: c,
      parsedCodec: c,
      manifestCodec: s,
    }
  );
}
function FY(n, e) {
  return n[e] === 255 && (n[e + 1] & 246) === 240;
}
function UY(n, e) {
  return n[e + 1] & 1 ? 7 : 9;
}
function eM(n, e) {
  return ((n[e + 3] & 3) << 11) | (n[e + 4] << 3) | ((n[e + 5] & 224) >>> 5);
}
function Pke(n, e) {
  return e + 5 < n.length;
}
function eE(n, e) {
  return e + 1 < n.length && FY(n, e);
}
function Mke(n, e) {
  return Pke(n, e) && FY(n, e) && eM(n, e) <= n.length - e;
}
function Nke(n, e) {
  if (eE(n, e)) {
    const t = UY(n, e);
    if (e + t >= n.length) return !1;
    const s = eM(n, e);
    if (s <= t) return !1;
    const r = e + s;
    return r === n.length || eE(n, r);
  }
  return !1;
}
function $Y(n, e, t, s, r) {
  if (!n.samplerate) {
    const i = Dke(e, t, s, r);
    if (!i) return;
    Tn(n, i);
  }
}
function BY(n) {
  return (1024 * 9e4) / n;
}
function Oke(n, e) {
  const t = UY(n, e);
  if (e + t <= n.length) {
    const s = eM(n, e) - t;
    if (s > 0) return { headerLength: t, frameLength: s };
  }
}
function HY(n, e, t, s, r) {
  const i = BY(n.samplerate),
    a = s + r * i,
    o = Oke(e, t);
  let l;
  if (o) {
    const { frameLength: m, headerLength: p } = o,
      g = p + m,
      y = Math.max(0, t + g - e.length);
    y
      ? ((l = new Uint8Array(g - p)), l.set(e.subarray(t + p, e.length), 0))
      : (l = e.subarray(t + p, t + g));
    const b = { unit: l, pts: a };
    return y || n.samples.push(b), { sample: b, length: g, missing: y };
  }
  const c = e.length - t;
  return (
    (l = new Uint8Array(c)),
    l.set(e.subarray(t, e.length), 0),
    { sample: { unit: l, pts: a }, length: c, missing: -1 }
  );
}
function jke(n, e) {
  return JP(n, e) && mS(n, e + 6) + 10 <= n.length - e;
}
function Fke(n) {
  return n instanceof ArrayBuffer
    ? n
    : n.byteOffset == 0 && n.byteLength == n.buffer.byteLength
    ? n.buffer
    : new Uint8Array(n).buffer;
}
function wA(n, e = 0, t = 1 / 0) {
  return Uke(n, e, t, Uint8Array);
}
function Uke(n, e, t, s) {
  const r = $ke(n);
  let i = 1;
  "BYTES_PER_ELEMENT" in s && (i = s.BYTES_PER_ELEMENT);
  const a = Bke(n) ? n.byteOffset : 0,
    o = (a + n.byteLength) / i,
    l = (a + e) / i,
    c = Math.floor(Math.max(0, Math.min(l, o))),
    h = Math.floor(Math.min(c + Math.max(t, 0), o));
  return new s(r, c, h - c);
}
function $ke(n) {
  return n instanceof ArrayBuffer ? n : n.buffer;
}
function Bke(n) {
  return (
    n &&
    n.buffer instanceof ArrayBuffer &&
    n.byteLength !== void 0 &&
    n.byteOffset !== void 0
  );
}
function Hke(n) {
  const e = {
      key: n.type,
      description: "",
      data: "",
      mimeType: null,
      pictureType: null,
    },
    t = 3;
  if (n.size < 2 || n.data[0] !== t) return;
  const s = n.data.subarray(1).indexOf(0);
  if (s === -1) return;
  const r = ki(wA(n.data, 1, s)),
    i = n.data[2 + s],
    a = n.data.subarray(3 + s).indexOf(0);
  if (a === -1) return;
  const o = ki(wA(n.data, 3 + s, a));
  let l;
  return (
    r === "-->"
      ? (l = ki(wA(n.data, 4 + s + a)))
      : (l = Fke(n.data.subarray(4 + s + a))),
    (e.mimeType = r),
    (e.pictureType = i),
    (e.description = o),
    (e.data = l),
    e
  );
}
function Vke(n) {
  if (n.size < 2) return;
  const e = ki(n.data, !0),
    t = new Uint8Array(n.data.subarray(e.length + 1));
  return { key: n.type, info: e, data: t.buffer };
}
function zke(n) {
  if (n.size < 2) return;
  if (n.type === "TXXX") {
    let t = 1;
    const s = ki(n.data.subarray(t), !0);
    t += s.length + 1;
    const r = ki(n.data.subarray(t));
    return { key: n.type, info: s, data: r };
  }
  const e = ki(n.data.subarray(1));
  return { key: n.type, info: "", data: e };
}
function Gke(n) {
  if (n.type === "WXXX") {
    if (n.size < 2) return;
    let t = 1;
    const s = ki(n.data.subarray(t), !0);
    t += s.length + 1;
    const r = ki(n.data.subarray(t));
    return { key: n.type, info: s, data: r };
  }
  const e = ki(n.data);
  return { key: n.type, info: "", data: e };
}
function qke(n) {
  return n.type === "PRIV"
    ? Vke(n)
    : n.type[0] === "W"
    ? Gke(n)
    : n.type === "APIC"
    ? Hke(n)
    : zke(n);
}
function Wke(n) {
  const e = String.fromCharCode(n[0], n[1], n[2], n[3]),
    t = mS(n, 4),
    s = 10;
  return { type: e, size: t, data: n.subarray(s, s + t) };
}
const nb = 10,
  Kke = 10;
function VY(n) {
  let e = 0;
  const t = [];
  for (; JP(n, e); ) {
    const s = mS(n, e + 6);
    (n[e + 5] >> 6) & 1 && (e += nb), (e += nb);
    const r = e + s;
    for (; e + Kke < r; ) {
      const i = Wke(n.subarray(e)),
        a = qke(i);
      a && t.push(a), (e += i.size + nb);
    }
    jY(n, e) && (e += nb);
  }
  return t;
}
function zY(n) {
  return (
    n &&
    n.key === "PRIV" &&
    n.info === "com.apple.streaming.transportStreamTimestamp"
  );
}
function Yke(n) {
  if (n.data.byteLength === 8) {
    const e = new Uint8Array(n.data),
      t = e[3] & 1;
    let s = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return (s /= 45), t && (s += 4772185884e-2), Math.round(s);
  }
}
function tM(n) {
  const e = VY(n);
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (zY(s)) return Yke(s);
  }
}
let Si = (function (n) {
  return (
    (n.audioId3 = "org.id3"),
    (n.dateRange = "com.apple.quicktime.HLS"),
    (n.emsg = "https://aomedia.org/emsg/ID3"),
    (n.misbklv = "urn:misb:KLV:bin:1910.1"),
    n
  );
})({});
function mo(n = "", e = 9e4) {
  return {
    type: n,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0,
  };
}
class nM {
  constructor() {
    (this._audioTrack = void 0),
      (this._id3Track = void 0),
      (this.frameIndex = 0),
      (this.cachedData = null),
      (this.basePTS = null),
      (this.initPTS = null),
      (this.lastPTS = null);
  }
  resetInitSegment(e, t, s, r) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
    };
  }
  resetTimeStamp(e) {
    (this.initPTS = e), this.resetContiguity();
  }
  resetContiguity() {
    (this.basePTS = null), (this.lastPTS = null), (this.frameIndex = 0);
  }
  canParse(e, t) {
    return !1;
  }
  appendFrame(e, t, s) {}
  demux(e, t) {
    this.cachedData && ((e = da(this.cachedData, e)), (this.cachedData = null));
    let s = gv(e, 0),
      r = s ? s.length : 0,
      i;
    const a = this._audioTrack,
      o = this._id3Track,
      l = s ? tM(s) : void 0,
      c = e.length;
    for (
      (this.basePTS === null || (this.frameIndex === 0 && Qe(l))) &&
        ((this.basePTS = Xke(l, t, this.initPTS)),
        (this.lastPTS = this.basePTS)),
        this.lastPTS === null && (this.lastPTS = this.basePTS),
        s &&
          s.length > 0 &&
          o.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: s,
            type: Si.audioId3,
            duration: Number.POSITIVE_INFINITY,
          });
      r < c;

    ) {
      if (this.canParse(e, r)) {
        const h = this.appendFrame(a, e, r);
        h
          ? (this.frameIndex++,
            (this.lastPTS = h.sample.pts),
            (r += h.length),
            (i = r))
          : (r = c);
      } else
        jke(e, r)
          ? ((s = gv(e, r)),
            o.samples.push({
              pts: this.lastPTS,
              dts: this.lastPTS,
              data: s,
              type: Si.audioId3,
              duration: Number.POSITIVE_INFINITY,
            }),
            (r += s.length),
            (i = r))
          : r++;
      if (r === c && i !== c) {
        const h = e.slice(i);
        this.cachedData
          ? (this.cachedData = da(this.cachedData, h))
          : (this.cachedData = h);
      }
    }
    return { audioTrack: a, videoTrack: mo(), id3Track: o, textTrack: mo() };
  }
  demuxSampleAes(e, t, s) {
    return Promise.reject(
      new Error(`[${this}] This demuxer does not support Sample-AES decryption`)
    );
  }
  flush(e) {
    const t = this.cachedData;
    return (
      t && ((this.cachedData = null), this.demux(t, 0)),
      {
        audioTrack: this._audioTrack,
        videoTrack: mo(),
        id3Track: this._id3Track,
        textTrack: mo(),
      }
    );
  }
  destroy() {
    (this.cachedData = null), (this._audioTrack = this._id3Track = void 0);
  }
}
const Xke = (n, e, t) => {
  if (Qe(n)) return n * 90;
  const s = t ? (t.baseTime * 9e4) / t.timescale : 0;
  return e * 9e4 + s;
};
let sb = null;
const Qke = [
    32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48,
    56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64,
    80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128,
    144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112,
    128, 144, 160,
  ],
  Zke = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
  Jke = [
    [0, 72, 144, 12],
    [0, 0, 0, 0],
    [0, 72, 144, 12],
    [0, 144, 144, 12],
  ],
  eCe = [0, 1, 1, 4];
function GY(n, e, t, s, r) {
  if (t + 24 > e.length) return;
  const i = qY(e, t);
  if (i && t + i.frameLength <= e.length) {
    const a = (i.samplesPerFrame * 9e4) / i.sampleRate,
      o = s + r * a,
      l = { unit: e.subarray(t, t + i.frameLength), pts: o, dts: o };
    return (
      (n.config = []),
      (n.channelCount = i.channelCount),
      (n.samplerate = i.sampleRate),
      n.samples.push(l),
      { sample: l, length: i.frameLength, missing: 0 }
    );
  }
}
function qY(n, e) {
  const t = (n[e + 1] >> 3) & 3,
    s = (n[e + 1] >> 1) & 3,
    r = (n[e + 2] >> 4) & 15,
    i = (n[e + 2] >> 2) & 3;
  if (t !== 1 && r !== 0 && r !== 15 && i !== 3) {
    const a = (n[e + 2] >> 1) & 1,
      o = n[e + 3] >> 6,
      l = t === 3 ? 3 - s : s === 3 ? 3 : 4,
      c = Qke[l * 14 + r - 1] * 1e3,
      m = Zke[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i],
      p = o === 3 ? 1 : 2,
      g = Jke[t][s],
      y = eCe[s],
      b = g * 8 * y,
      w = Math.floor((g * c) / m + a) * y;
    if (sb === null) {
      const _ = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      sb = _ ? parseInt(_[1]) : 0;
    }
    return (
      !!sb &&
        sb <= 87 &&
        s === 2 &&
        c >= 224e3 &&
        o === 0 &&
        (n[e + 3] = n[e + 3] | 128),
      { sampleRate: m, channelCount: p, frameLength: w, samplesPerFrame: b }
    );
  }
}
function sM(n, e) {
  return n[e] === 255 && (n[e + 1] & 224) === 224 && (n[e + 1] & 6) !== 0;
}
function WY(n, e) {
  return e + 1 < n.length && sM(n, e);
}
function tCe(n, e) {
  return sM(n, e) && 4 <= n.length - e;
}
function KY(n, e) {
  if (e + 1 < n.length && sM(n, e)) {
    const s = qY(n, e);
    let r = 4;
    s != null && s.frameLength && (r = s.frameLength);
    const i = e + r;
    return i === n.length || WY(n, i);
  }
  return !1;
}
class nCe extends nM {
  constructor(e, t) {
    super(),
      (this.observer = void 0),
      (this.config = void 0),
      (this.observer = e),
      (this.config = t);
  }
  resetInitSegment(e, t, s, r) {
    super.resetInitSegment(e, t, s, r),
      (this._audioTrack = {
        container: "audio/adts",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "aac",
        samples: [],
        manifestCodec: t,
        duration: r,
        inputTimeScale: 9e4,
        dropped: 0,
      });
  }
  static probe(e, t) {
    if (!e) return !1;
    const s = gv(e, 0);
    let r = s?.length || 0;
    if (KY(e, r)) return !1;
    for (let i = e.length; r < i; r++)
      if (Nke(e, r)) return t.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return Mke(e, t);
  }
  appendFrame(e, t, s) {
    $Y(e, this.observer, t, s, e.manifestCodec);
    const r = HY(e, t, s, this.basePTS, this.frameIndex);
    if (r && r.missing === 0) return r;
  }
}
const YY = (n, e) => {
  let t = 0,
    s = 5;
  e += s;
  const r = new Uint32Array(1),
    i = new Uint32Array(1),
    a = new Uint8Array(1);
  for (; s > 0; ) {
    a[0] = n[e];
    const o = Math.min(s, 8),
      l = 8 - o;
    (i[0] = (4278190080 >>> (24 + l)) << l),
      (r[0] = (a[0] & i[0]) >> l),
      (t = t ? (t << o) | r[0] : r[0]),
      (e += 1),
      (s -= o);
  }
  return t;
};
class sCe extends nM {
  constructor(e) {
    super(), (this.observer = void 0), (this.observer = e);
  }
  resetInitSegment(e, t, s, r) {
    super.resetInitSegment(e, t, s, r),
      (this._audioTrack = {
        container: "audio/ac-3",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "ac3",
        samples: [],
        manifestCodec: t,
        duration: r,
        inputTimeScale: 9e4,
        dropped: 0,
      });
  }
  canParse(e, t) {
    return t + 64 < e.length;
  }
  appendFrame(e, t, s) {
    const r = XY(e, t, s, this.basePTS, this.frameIndex);
    if (r !== -1)
      return { sample: e.samples[e.samples.length - 1], length: r, missing: 0 };
  }
  static probe(e) {
    if (!e) return !1;
    const t = gv(e, 0);
    if (!t) return !1;
    const s = t.length;
    return e[s] === 11 && e[s + 1] === 119 && tM(t) !== void 0 && YY(e, s) < 16;
  }
}
function XY(n, e, t, s, r) {
  if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119) return -1;
  const i = e[t + 4] >> 6;
  if (i >= 3) return -1;
  const o = [48e3, 44100, 32e3][i],
    l = e[t + 4] & 63,
    h =
      [
        64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105,
        144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160,
        174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336,
        224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349,
        480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512,
        557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152,
        768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024,
        1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280,
        1394, 1920,
      ][l * 3 + i] * 2;
  if (t + h > e.length) return -1;
  const m = e[t + 6] >> 5;
  let p = 0;
  m === 2 ? (p += 2) : (m & 1 && m !== 1 && (p += 2), m & 4 && (p += 2));
  const g = (((e[t + 6] << 8) | e[t + 7]) >> (12 - p)) & 1,
    b = [2, 1, 2, 3, 3, 4, 4, 5][m] + g,
    w = e[t + 5] >> 3,
    S = e[t + 5] & 7,
    A = new Uint8Array([
      (i << 6) | (w << 1) | (S >> 2),
      ((S & 3) << 6) | (m << 3) | (g << 2) | (l >> 4),
      (l << 4) & 224,
    ]),
    _ = (1536 / o) * 9e4,
    R = s + r * _,
    C = e.subarray(t, t + h);
  return (
    (n.config = A),
    (n.channelCount = b),
    (n.samplerate = o),
    n.samples.push({ unit: C, pts: R }),
    h
  );
}
class rCe extends nM {
  resetInitSegment(e, t, s, r) {
    super.resetInitSegment(e, t, s, r),
      (this._audioTrack = {
        container: "audio/mpeg",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "mp3",
        samples: [],
        manifestCodec: t,
        duration: r,
        inputTimeScale: 9e4,
        dropped: 0,
      });
  }
  static probe(e) {
    if (!e) return !1;
    const t = gv(e, 0);
    let s = t?.length || 0;
    if (
      t &&
      e[s] === 11 &&
      e[s + 1] === 119 &&
      tM(t) !== void 0 &&
      YY(e, s) <= 16
    )
      return !1;
    for (let r = e.length; s < r; s++)
      if (KY(e, s)) return pn.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, t) {
    return tCe(e, t);
  }
  appendFrame(e, t, s) {
    if (this.basePTS !== null)
      return GY(e, t, s, this.basePTS, this.frameIndex);
  }
}
const iCe = /\/emsg[-/]ID3/i;
class aCe {
  constructor(e, t) {
    (this.remainderData = null),
      (this.timeOffset = 0),
      (this.config = void 0),
      (this.videoTrack = void 0),
      (this.audioTrack = void 0),
      (this.id3Track = void 0),
      (this.txtTrack = void 0),
      (this.config = t);
  }
  resetTimeStamp() {}
  resetInitSegment(e, t, s, r) {
    const i = (this.videoTrack = mo("video", 1)),
      a = (this.audioTrack = mo("audio", 1)),
      o = (this.txtTrack = mo("text", 1));
    if (
      ((this.id3Track = mo("id3", 1)),
      (this.timeOffset = 0),
      !(e != null && e.byteLength))
    )
      return;
    const l = hY(e);
    if (l.video) {
      const { id: c, timescale: h, codec: m, supplemental: p } = l.video;
      (i.id = c),
        (i.timescale = o.timescale = h),
        (i.codec = m),
        (i.supplemental = p);
    }
    if (l.audio) {
      const { id: c, timescale: h, codec: m } = l.audio;
      (a.id = c), (a.timescale = h), (a.codec = m);
    }
    (o.id = cY.text), (i.sampleDuration = 0), (i.duration = a.duration = r);
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return aRe(e);
  }
  demux(e, t) {
    this.timeOffset = t;
    let s = e;
    const r = this.videoTrack,
      i = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (s = da(this.remainderData, e));
      const o = fRe(s);
      (this.remainderData = o.remainder),
        (r.samples = o.valid || new Uint8Array());
    } else r.samples = s;
    const a = this.extractID3Track(r, t);
    return (
      (i.samples = bB(t, r)),
      {
        videoTrack: r,
        audioTrack: this.audioTrack,
        id3Track: a,
        textTrack: this.txtTrack,
      }
    );
  }
  flush() {
    const e = this.timeOffset,
      t = this.videoTrack,
      s = this.txtTrack;
    (t.samples = this.remainderData || new Uint8Array()),
      (this.remainderData = null);
    const r = this.extractID3Track(t, this.timeOffset);
    return (
      (s.samples = bB(e, t)),
      { videoTrack: t, audioTrack: mo(), id3Track: r, textTrack: mo() }
    );
  }
  extractID3Track(e, t) {
    const s = this.id3Track;
    if (e.samples.length) {
      const r = Qt(e.samples, ["emsg"]);
      r &&
        r.forEach((i) => {
          const a = pRe(i);
          if (iCe.test(a.schemeIdUri)) {
            const o = e5(a, t);
            let l =
              a.eventDuration === 4294967295
                ? Number.POSITIVE_INFINITY
                : a.eventDuration / a.timeScale;
            l <= 0.001 && (l = Number.POSITIVE_INFINITY);
            const c = a.payload;
            s.samples.push({
              data: c,
              len: c.byteLength,
              dts: o,
              pts: o,
              type: Si.emsg,
              duration: l,
            });
          } else if (
            this.config.enableEmsgKLVMetadata &&
            a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")
          ) {
            const o = e5(a, t);
            s.samples.push({
              data: a.payload,
              len: a.payload.byteLength,
              dts: o,
              pts: o,
              type: Si.misbklv,
              duration: Number.POSITIVE_INFINITY,
            });
          }
        });
    }
    return s;
  }
  demuxSampleAes(e, t, s) {
    return Promise.reject(
      new Error("The MP4 demuxer does not support SAMPLE-AES decryption")
    );
  }
  destroy() {
    (this.config = null),
      (this.remainderData = null),
      (this.videoTrack =
        this.audioTrack =
        this.id3Track =
        this.txtTrack =
          void 0);
  }
}
function e5(n, e) {
  return Qe(n.presentationTime)
    ? n.presentationTime / n.timeScale
    : e + n.presentationTimeDelta / n.timeScale;
}
class oCe {
  constructor(e, t, s) {
    (this.keyData = void 0),
      (this.decrypter = void 0),
      (this.keyData = s),
      (this.decrypter = new KP(t, { removePKCS7Padding: !1 }));
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(
      e,
      this.keyData.key.buffer,
      this.keyData.iv.buffer,
      Hc.cbc
    );
  }
  decryptAacSample(e, t, s) {
    const r = e[t].unit;
    if (r.length <= 16) return;
    const i = r.subarray(16, r.length - (r.length % 16)),
      a = i.buffer.slice(i.byteOffset, i.byteOffset + i.length);
    this.decryptBuffer(a).then((o) => {
      const l = new Uint8Array(o);
      r.set(l, 16),
        this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, s);
    });
  }
  decryptAacSamples(e, t, s) {
    for (; ; t++) {
      if (t >= e.length) {
        s();
        return;
      }
      if (
        !(e[t].unit.length < 32) &&
        (this.decryptAacSample(e, t, s), !this.decrypter.isSync())
      )
        return;
    }
  }
  getAvcEncryptedData(e) {
    const t = Math.floor((e.length - 48) / 160) * 16 + 16,
      s = new Int8Array(t);
    let r = 0;
    for (let i = 32; i < e.length - 16; i += 160, r += 16)
      s.set(e.subarray(i, i + 16), r);
    return s;
  }
  getAvcDecryptedUnit(e, t) {
    const s = new Uint8Array(t);
    let r = 0;
    for (let i = 32; i < e.length - 16; i += 160, r += 16)
      e.set(s.subarray(r, r + 16), i);
    return e;
  }
  decryptAvcSample(e, t, s, r, i) {
    const a = fY(i.data),
      o = this.getAvcEncryptedData(a);
    this.decryptBuffer(o.buffer).then((l) => {
      (i.data = this.getAvcDecryptedUnit(a, l)),
        this.decrypter.isSync() || this.decryptAvcSamples(e, t, s + 1, r);
    });
  }
  decryptAvcSamples(e, t, s, r) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; t++, s = 0) {
      if (t >= e.length) {
        r();
        return;
      }
      const i = e[t].units;
      for (; !(s >= i.length); s++) {
        const a = i[s];
        if (
          !(a.data.length <= 48 || (a.type !== 1 && a.type !== 5)) &&
          (this.decryptAvcSample(e, t, s, r, a), !this.decrypter.isSync())
        )
          return;
      }
    }
  }
}
class QY {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(e, t, s) {
    return { key: e, frame: !1, pts: t, dts: s, units: [], length: 0 };
  }
  getLastNalUnit(e) {
    var t;
    let s = this.VideoSample,
      r;
    if (
      ((!s || s.units.length === 0) && (s = e[e.length - 1]),
      (t = s) != null && t.units)
    ) {
      const i = s.units;
      r = i[i.length - 1];
    }
    return r;
  }
  pushAccessUnit(e, t) {
    if (e.units.length && e.frame) {
      if (e.pts === void 0) {
        const s = t.samples,
          r = s.length;
        if (r) {
          const i = s[r - 1];
          (e.pts = i.pts), (e.dts = i.dts);
        } else {
          t.dropped++;
          return;
        }
      }
      t.samples.push(e);
    }
  }
  parseNALu(e, t, s) {
    const r = t.byteLength;
    let i = e.naluState || 0;
    const a = i,
      o = [];
    let l = 0,
      c,
      h,
      m,
      p = -1,
      g = 0;
    for (
      i === -1 && ((p = 0), (g = this.getNALuType(t, 0)), (i = 0), (l = 1));
      l < r;

    ) {
      if (((c = t[l++]), !i)) {
        i = c ? 0 : 1;
        continue;
      }
      if (i === 1) {
        i = c ? 0 : 2;
        continue;
      }
      if (!c) i = 3;
      else if (c === 1) {
        if (((h = l - i - 1), p >= 0)) {
          const y = { data: t.subarray(p, h), type: g };
          o.push(y);
        } else {
          const y = this.getLastNalUnit(e.samples);
          y &&
            (a &&
              l <= 4 - a &&
              y.state &&
              (y.data = y.data.subarray(0, y.data.byteLength - a)),
            h > 0 && ((y.data = da(y.data, t.subarray(0, h))), (y.state = 0)));
        }
        l < r
          ? ((m = this.getNALuType(t, l)), (p = l), (g = m), (i = 0))
          : (i = -1);
      } else i = 0;
    }
    if (p >= 0 && i >= 0) {
      const y = { data: t.subarray(p, r), type: g, state: i };
      o.push(y);
    }
    if (o.length === 0) {
      const y = this.getLastNalUnit(e.samples);
      y && (y.data = da(y.data, t));
    }
    return (e.naluState = i), o;
  }
}
class pg {
  constructor(e) {
    (this.data = void 0),
      (this.bytesAvailable = void 0),
      (this.word = void 0),
      (this.bitsAvailable = void 0),
      (this.data = e),
      (this.bytesAvailable = e.byteLength),
      (this.word = 0),
      (this.bitsAvailable = 0);
  }
  loadWord() {
    const e = this.data,
      t = this.bytesAvailable,
      s = e.byteLength - t,
      r = new Uint8Array(4),
      i = Math.min(4, t);
    if (i === 0) throw new Error("no bytes available");
    r.set(e.subarray(s, s + i)),
      (this.word = new DataView(r.buffer).getUint32(0)),
      (this.bitsAvailable = i * 8),
      (this.bytesAvailable -= i);
  }
  skipBits(e) {
    let t;
    (e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable)),
      this.bitsAvailable > e
        ? ((this.word <<= e), (this.bitsAvailable -= e))
        : ((e -= this.bitsAvailable),
          (t = e >> 3),
          (e -= t << 3),
          (this.bytesAvailable -= t),
          this.loadWord(),
          (this.word <<= e),
          (this.bitsAvailable -= e));
  }
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e);
    const s = this.word >>> (32 - t);
    if (
      (e > 32 && pn.error("Cannot read more than 32 bits at a time"),
      (this.bitsAvailable -= t),
      this.bitsAvailable > 0)
    )
      this.word <<= t;
    else if (this.bytesAvailable > 0) this.loadWord();
    else throw new Error("no bits available");
    return (
      (t = e - t), t > 0 && this.bitsAvailable ? (s << t) | this.readBits(t) : s
    );
  }
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if ((this.word & (2147483648 >>> e)) !== 0)
        return (this.word <<= e), (this.bitsAvailable -= e), e;
    return this.loadWord(), e + this.skipLZ();
  }
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  readEG() {
    const e = this.readUEG();
    return 1 & e ? (1 + e) >>> 1 : -1 * (e >>> 1);
  }
  readBoolean() {
    return this.readBits(1) === 1;
  }
  readUByte() {
    return this.readBits(8);
  }
  readUShort() {
    return this.readBits(16);
  }
  readUInt() {
    return this.readBits(32);
  }
}
class t5 extends QY {
  parsePES(e, t, s, r) {
    const i = this.parseNALu(e, s.data, r);
    let a = this.VideoSample,
      o,
      l = !1;
    (s.data = null),
      a &&
        i.length &&
        !e.audFound &&
        (this.pushAccessUnit(a, e),
        (a = this.VideoSample = this.createVideoSample(!1, s.pts, s.dts))),
      i.forEach((c) => {
        var h, m;
        switch (c.type) {
          case 1: {
            let b = !1;
            o = !0;
            const w = c.data;
            if (l && w.length > 4) {
              const S = this.readSliceType(w);
              (S === 2 || S === 4 || S === 7 || S === 9) && (b = !0);
            }
            if (b) {
              var p;
              (p = a) != null &&
                p.frame &&
                !a.key &&
                (this.pushAccessUnit(a, e), (a = this.VideoSample = null));
            }
            a ||
              (a = this.VideoSample = this.createVideoSample(!0, s.pts, s.dts)),
              (a.frame = !0),
              (a.key = b);
            break;
          }
          case 5:
            (o = !0),
              (h = a) != null &&
                h.frame &&
                !a.key &&
                (this.pushAccessUnit(a, e), (a = this.VideoSample = null)),
              a ||
                (a = this.VideoSample =
                  this.createVideoSample(!0, s.pts, s.dts)),
              (a.key = !0),
              (a.frame = !0);
            break;
          case 6: {
            (o = !0), zP(c.data, 1, s.pts, t.samples);
            break;
          }
          case 7: {
            var g, y;
            (o = !0), (l = !0);
            const b = c.data,
              w = this.readSPS(b);
            if (
              !e.sps ||
              e.width !== w.width ||
              e.height !== w.height ||
              ((g = e.pixelRatio) == null ? void 0 : g[0]) !==
                w.pixelRatio[0] ||
              ((y = e.pixelRatio) == null ? void 0 : y[1]) !== w.pixelRatio[1]
            ) {
              (e.width = w.width),
                (e.height = w.height),
                (e.pixelRatio = w.pixelRatio),
                (e.sps = [b]);
              const S = b.subarray(1, 4);
              let A = "avc1.";
              for (let _ = 0; _ < 3; _++) {
                let R = S[_].toString(16);
                R.length < 2 && (R = "0" + R), (A += R);
              }
              e.codec = A;
            }
            break;
          }
          case 8:
            (o = !0), (e.pps = [c.data]);
            break;
          case 9:
            (o = !0),
              (e.audFound = !0),
              (m = a) != null &&
                m.frame &&
                (this.pushAccessUnit(a, e), (a = null)),
              a ||
                (a = this.VideoSample =
                  this.createVideoSample(!1, s.pts, s.dts));
            break;
          case 12:
            o = !0;
            break;
          default:
            o = !1;
            break;
        }
        a && o && a.units.push(c);
      }),
      r && a && (this.pushAccessUnit(a, e), (this.VideoSample = null));
  }
  getNALuType(e, t) {
    return e[t] & 31;
  }
  readSliceType(e) {
    const t = new pg(e);
    return t.readUByte(), t.readUEG(), t.readUEG();
  }
  skipScalingList(e, t) {
    let s = 8,
      r = 8,
      i;
    for (let a = 0; a < e; a++)
      r !== 0 && ((i = t.readEG()), (r = (s + i + 256) % 256)),
        (s = r === 0 ? s : r);
  }
  readSPS(e) {
    const t = new pg(e);
    let s = 0,
      r = 0,
      i = 0,
      a = 0,
      o,
      l,
      c;
    const h = t.readUByte.bind(t),
      m = t.readBits.bind(t),
      p = t.readUEG.bind(t),
      g = t.readBoolean.bind(t),
      y = t.skipBits.bind(t),
      b = t.skipEG.bind(t),
      w = t.skipUEG.bind(t),
      S = this.skipScalingList.bind(this);
    h();
    const A = h();
    if (
      (m(5),
      y(3),
      h(),
      w(),
      A === 100 ||
        A === 110 ||
        A === 122 ||
        A === 244 ||
        A === 44 ||
        A === 83 ||
        A === 86 ||
        A === 118 ||
        A === 128)
    ) {
      const P = p();
      if ((P === 3 && y(1), w(), w(), y(1), g()))
        for (l = P !== 3 ? 8 : 12, c = 0; c < l; c++)
          g() && (c < 6 ? S(16, t) : S(64, t));
    }
    w();
    const _ = p();
    if (_ === 0) p();
    else if (_ === 1) for (y(1), b(), b(), o = p(), c = 0; c < o; c++) b();
    w(), y(1);
    const R = p(),
      C = p(),
      D = m(1);
    D === 0 && y(1), y(1), g() && ((s = p()), (r = p()), (i = p()), (a = p()));
    let L = [1, 1];
    if (g() && g())
      switch (h()) {
        case 1:
          L = [1, 1];
          break;
        case 2:
          L = [12, 11];
          break;
        case 3:
          L = [10, 11];
          break;
        case 4:
          L = [16, 11];
          break;
        case 5:
          L = [40, 33];
          break;
        case 6:
          L = [24, 11];
          break;
        case 7:
          L = [20, 11];
          break;
        case 8:
          L = [32, 11];
          break;
        case 9:
          L = [80, 33];
          break;
        case 10:
          L = [18, 11];
          break;
        case 11:
          L = [15, 11];
          break;
        case 12:
          L = [64, 33];
          break;
        case 13:
          L = [160, 99];
          break;
        case 14:
          L = [4, 3];
          break;
        case 15:
          L = [3, 2];
          break;
        case 16:
          L = [2, 1];
          break;
        case 255: {
          L = [(h() << 8) | h(), (h() << 8) | h()];
          break;
        }
      }
    return {
      width: Math.ceil((R + 1) * 16 - s * 2 - r * 2),
      height: (2 - D) * (C + 1) * 16 - (D ? 2 : 4) * (i + a),
      pixelRatio: L,
    };
  }
}
class n5 extends QY {
  constructor(...e) {
    super(...e), (this.initVPS = null);
  }
  parsePES(e, t, s, r) {
    const i = this.parseNALu(e, s.data, r);
    let a = this.VideoSample,
      o,
      l = !1;
    (s.data = null),
      a &&
        i.length &&
        !e.audFound &&
        (this.pushAccessUnit(a, e),
        (a = this.VideoSample = this.createVideoSample(!1, s.pts, s.dts))),
      i.forEach((c) => {
        var h, m;
        switch (c.type) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            a ||
              (a = this.VideoSample = this.createVideoSample(!1, s.pts, s.dts)),
              (a.frame = !0),
              (o = !0);
            break;
          case 16:
          case 17:
          case 18:
          case 21:
            if (((o = !0), l)) {
              var p;
              (p = a) != null &&
                p.frame &&
                !a.key &&
                (this.pushAccessUnit(a, e), (a = this.VideoSample = null));
            }
            a ||
              (a = this.VideoSample = this.createVideoSample(!0, s.pts, s.dts)),
              (a.key = !0),
              (a.frame = !0);
            break;
          case 19:
          case 20:
            (o = !0),
              (h = a) != null &&
                h.frame &&
                !a.key &&
                (this.pushAccessUnit(a, e), (a = this.VideoSample = null)),
              a ||
                (a = this.VideoSample =
                  this.createVideoSample(!0, s.pts, s.dts)),
              (a.key = !0),
              (a.frame = !0);
            break;
          case 39:
            (o = !0), zP(c.data, 2, s.pts, t.samples);
            break;
          case 32:
            (o = !0),
              e.vps ||
                (typeof e.params != "object" && (e.params = {}),
                (e.params = Tn(e.params, this.readVPS(c.data))),
                (this.initVPS = c.data)),
              (e.vps = [c.data]);
            break;
          case 33:
            if (
              ((o = !0),
              (l = !0),
              e.vps !== void 0 &&
                e.vps[0] !== this.initVPS &&
                e.sps !== void 0 &&
                !this.matchSPS(e.sps[0], c.data) &&
                ((this.initVPS = e.vps[0]), (e.sps = e.pps = void 0)),
              !e.sps)
            ) {
              const g = this.readSPS(c.data);
              (e.width = g.width),
                (e.height = g.height),
                (e.pixelRatio = g.pixelRatio),
                (e.codec = g.codecString),
                (e.sps = []),
                typeof e.params != "object" && (e.params = {});
              for (const y in g.params) e.params[y] = g.params[y];
            }
            this.pushParameterSet(e.sps, c.data, e.vps),
              a ||
                (a = this.VideoSample =
                  this.createVideoSample(!0, s.pts, s.dts)),
              (a.key = !0);
            break;
          case 34:
            if (((o = !0), typeof e.params == "object")) {
              if (!e.pps) {
                e.pps = [];
                const g = this.readPPS(c.data);
                for (const y in g) e.params[y] = g[y];
              }
              this.pushParameterSet(e.pps, c.data, e.vps);
            }
            break;
          case 35:
            (o = !0),
              (e.audFound = !0),
              (m = a) != null &&
                m.frame &&
                (this.pushAccessUnit(a, e), (a = null)),
              a ||
                (a = this.VideoSample =
                  this.createVideoSample(!1, s.pts, s.dts));
            break;
          default:
            o = !1;
            break;
        }
        a && o && a.units.push(c);
      }),
      r && a && (this.pushAccessUnit(a, e), (this.VideoSample = null));
  }
  pushParameterSet(e, t, s) {
    ((s && s[0] === this.initVPS) || (!s && !e.length)) && e.push(t);
  }
  getNALuType(e, t) {
    return (e[t] & 126) >>> 1;
  }
  ebsp2rbsp(e) {
    const t = new Uint8Array(e.byteLength);
    let s = 0;
    for (let r = 0; r < e.byteLength; r++)
      (r >= 2 && e[r] === 3 && e[r - 1] === 0 && e[r - 2] === 0) ||
        ((t[s] = e[r]), s++);
    return new Uint8Array(t.buffer, 0, s);
  }
  pushAccessUnit(e, t) {
    super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null);
  }
  readVPS(e) {
    const t = new pg(e);
    t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);
    const s = t.readBits(3),
      r = t.readBoolean();
    return { numTemporalLayers: s + 1, temporalIdNested: r };
  }
  readSPS(e) {
    const t = new pg(this.ebsp2rbsp(e));
    t.readUByte(), t.readUByte(), t.readBits(4);
    const s = t.readBits(3);
    t.readBoolean();
    const r = t.readBits(2),
      i = t.readBoolean(),
      a = t.readBits(5),
      o = t.readUByte(),
      l = t.readUByte(),
      c = t.readUByte(),
      h = t.readUByte(),
      m = t.readUByte(),
      p = t.readUByte(),
      g = t.readUByte(),
      y = t.readUByte(),
      b = t.readUByte(),
      w = t.readUByte(),
      S = t.readUByte(),
      A = [],
      _ = [];
    for (let ge = 0; ge < s; ge++)
      A.push(t.readBoolean()), _.push(t.readBoolean());
    if (s > 0) for (let ge = s; ge < 8; ge++) t.readBits(2);
    for (let ge = 0; ge < s; ge++)
      A[ge] &&
        (t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte(),
        t.readUByte()),
        _[ge] && t.readUByte();
    t.readUEG();
    const R = t.readUEG();
    R == 3 && t.skipBits(1);
    const C = t.readUEG(),
      D = t.readUEG(),
      L = t.readBoolean();
    let P = 0,
      V = 0,
      N = 0,
      W = 0;
    L &&
      ((P += t.readUEG()),
      (V += t.readUEG()),
      (N += t.readUEG()),
      (W += t.readUEG()));
    const H = t.readUEG(),
      z = t.readUEG(),
      B = t.readUEG(),
      q = t.readBoolean();
    for (let ge = q ? 0 : s; ge <= s; ge++)
      t.skipUEG(), t.skipUEG(), t.skipUEG();
    if (
      (t.skipUEG(),
      t.skipUEG(),
      t.skipUEG(),
      t.skipUEG(),
      t.skipUEG(),
      t.skipUEG(),
      t.readBoolean() && t.readBoolean())
    )
      for (let re = 0; re < 4; re++)
        for (let fe = 0; fe < (re === 3 ? 2 : 6); fe++)
          if (!t.readBoolean()) t.readUEG();
          else {
            const ne = Math.min(64, 1 << (4 + (re << 1)));
            re > 1 && t.readEG();
            for (let ie = 0; ie < ne; ie++) t.readEG();
          }
    t.readBoolean(),
      t.readBoolean(),
      t.readBoolean() &&
        (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());
    const j = t.readUEG();
    let Q = 0;
    for (let ge = 0; ge < j; ge++) {
      let re = !1;
      if ((ge !== 0 && (re = t.readBoolean()), re)) {
        ge === j && t.readUEG(), t.readBoolean(), t.readUEG();
        let fe = 0;
        for (let ke = 0; ke <= Q; ke++) {
          const ne = t.readBoolean();
          let ie = !1;
          ne || (ie = t.readBoolean()), (ne || ie) && fe++;
        }
        Q = fe;
      } else {
        const fe = t.readUEG(),
          ke = t.readUEG();
        Q = fe + ke;
        for (let ne = 0; ne < fe; ne++) t.readUEG(), t.readBoolean();
        for (let ne = 0; ne < ke; ne++) t.readUEG(), t.readBoolean();
      }
    }
    if (t.readBoolean()) {
      const ge = t.readUEG();
      for (let re = 0; re < ge; re++) {
        for (let fe = 0; fe < B + 4; fe++) t.readBits(1);
        t.readBits(1);
      }
    }
    let I = 0,
      F = 1,
      Y = 1,
      J = !0,
      X = 1,
      Z = 0;
    t.readBoolean(), t.readBoolean();
    let te = !1;
    if (t.readBoolean()) {
      if (t.readBoolean()) {
        const Ne = t.readUByte(),
          $e = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2],
          ot = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
        Ne > 0 && Ne < 16
          ? ((F = $e[Ne - 1]), (Y = ot[Ne - 1]))
          : Ne === 255 && ((F = t.readBits(16)), (Y = t.readBits(16)));
      }
      if (
        (t.readBoolean() && t.readBoolean(),
        t.readBoolean() &&
          (t.readBits(3),
          t.readBoolean(),
          t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte())),
        t.readBoolean() && (t.readUEG(), t.readUEG()),
        t.readBoolean(),
        t.readBoolean(),
        t.readBoolean(),
        (te = t.readBoolean()),
        te &&
          ((P += t.readUEG()),
          (V += t.readUEG()),
          (N += t.readUEG()),
          (W += t.readUEG())),
        t.readBoolean() &&
          ((X = t.readBits(32)),
          (Z = t.readBits(32)),
          t.readBoolean() && t.readUEG(),
          t.readBoolean()))
      ) {
        const ot = t.readBoolean(),
          st = t.readBoolean();
        let ht = !1;
        (ot || st) &&
          ((ht = t.readBoolean()),
          ht && (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)),
          t.readBits(4),
          t.readBits(4),
          ht && t.readBits(4),
          t.readBits(5),
          t.readBits(5),
          t.readBits(5));
        for (let xt = 0; xt <= s; xt++) {
          J = t.readBoolean();
          const _e = J || t.readBoolean();
          let Ue = !1;
          _e ? t.readEG() : (Ue = t.readBoolean());
          const He = Ue ? 1 : t.readUEG() + 1;
          if (ot)
            for (let Ve = 0; Ve < He; Ve++)
              t.readUEG(),
                t.readUEG(),
                ht && (t.readUEG(), t.readUEG()),
                t.skipBits(1);
          if (st)
            for (let Ve = 0; Ve < He; Ve++)
              t.readUEG(),
                t.readUEG(),
                ht && (t.readUEG(), t.readUEG()),
                t.skipBits(1);
        }
      }
      t.readBoolean() &&
        (t.readBoolean(), t.readBoolean(), t.readBoolean(), (I = t.readUEG()));
    }
    let pe = C,
      se = D;
    if (L || te) {
      let ge = 1,
        re = 1;
      R === 1 ? (ge = re = 2) : R == 2 && (ge = 2),
        (pe = C - ge * V - ge * P),
        (se = D - re * W - re * N);
    }
    const be = r ? ["A", "B", "C"][r] : "",
      K = (o << 24) | (l << 16) | (c << 8) | h;
    let ve = 0;
    for (let ge = 0; ge < 32; ge++)
      ve = (ve | (((K >> ge) & 1) << (31 - ge))) >>> 0;
    let Ee = ve.toString(16);
    return (
      a === 1 && Ee === "2" && (Ee = "6"),
      {
        codecString: `hvc1.${be}${a}.${Ee}.${i ? "H" : "L"}${S}.B0`,
        params: {
          general_tier_flag: i,
          general_profile_idc: a,
          general_profile_space: r,
          general_profile_compatibility_flags: [o, l, c, h],
          general_constraint_indicator_flags: [m, p, g, y, b, w],
          general_level_idc: S,
          bit_depth: H + 8,
          bit_depth_luma_minus8: H,
          bit_depth_chroma_minus8: z,
          min_spatial_segmentation_idc: I,
          chroma_format_idc: R,
          frame_rate: { fixed: J, fps: Z / X },
        },
        width: pe,
        height: se,
        pixelRatio: [F, Y],
      }
    );
  }
  readPPS(e) {
    const t = new pg(this.ebsp2rbsp(e));
    t.readUByte(),
      t.readUByte(),
      t.skipUEG(),
      t.skipUEG(),
      t.skipBits(2),
      t.skipBits(3),
      t.skipBits(2),
      t.skipUEG(),
      t.skipUEG(),
      t.skipEG(),
      t.skipBits(2),
      t.readBoolean() && t.skipUEG(),
      t.skipEG(),
      t.skipEG(),
      t.skipBits(4);
    const r = t.readBoolean(),
      i = t.readBoolean();
    let a = 1;
    return (
      i && r ? (a = 0) : i ? (a = 3) : r && (a = 2), { parallelismType: a }
    );
  }
  matchSPS(e, t) {
    return (
      String.fromCharCode.apply(null, e).substr(3) ===
      String.fromCharCode.apply(null, t).substr(3)
    );
  }
}
const Js = 188;
class wc {
  constructor(e, t, s, r) {
    (this.logger = void 0),
      (this.observer = void 0),
      (this.config = void 0),
      (this.typeSupported = void 0),
      (this.sampleAes = null),
      (this.pmtParsed = !1),
      (this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this._pmtId = -1),
      (this._videoTrack = void 0),
      (this._audioTrack = void 0),
      (this._id3Track = void 0),
      (this._txtTrack = void 0),
      (this.aacOverFlow = null),
      (this.remainderData = null),
      (this.videoParser = void 0),
      (this.observer = e),
      (this.config = t),
      (this.typeSupported = s),
      (this.logger = r),
      (this.videoParser = null);
  }
  static probe(e, t) {
    const s = wc.syncOffset(e);
    return (
      s > 0 &&
        t.warn(`MPEG2-TS detected but first sync word found @ offset ${s}`),
      s !== -1
    );
  }
  static syncOffset(e) {
    const t = e.length;
    let s = Math.min(Js * 5, t - Js) + 1,
      r = 0;
    for (; r < s; ) {
      let i = !1,
        a = -1,
        o = 0;
      for (let l = r; l < t; l += Js)
        if (e[l] === 71 && (t - l === Js || e[l + Js] === 71)) {
          if (
            (o++,
            a === -1 &&
              ((a = l),
              a !== 0 && (s = Math.min(a + Js * 99, e.length - Js) + 1)),
            i || (i = uI(e, l) === 0),
            i && o > 1 && ((a === 0 && o > 2) || l + Js > s))
          )
            return a;
        } else {
          if (o) return -1;
          break;
        }
      r++;
    }
    return -1;
  }
  static createTrack(e, t) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: cY[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? t : void 0,
    };
  }
  resetInitSegment(e, t, s, r) {
    (this.pmtParsed = !1),
      (this._pmtId = -1),
      (this._videoTrack = wc.createTrack("video")),
      (this._videoTrack.duration = r),
      (this._audioTrack = wc.createTrack("audio", r)),
      (this._id3Track = wc.createTrack("id3")),
      (this._txtTrack = wc.createTrack("text")),
      (this._audioTrack.segmentCodec = "aac"),
      (this.aacOverFlow = null),
      (this.remainderData = null),
      (this.audioCodec = t),
      (this.videoCodec = s);
  }
  resetTimeStamp() {}
  resetContiguity() {
    const { _audioTrack: e, _videoTrack: t, _id3Track: s } = this;
    e && (e.pesData = null),
      t && (t.pesData = null),
      s && (s.pesData = null),
      (this.aacOverFlow = null),
      (this.remainderData = null);
  }
  demux(e, t, s = !1, r = !1) {
    s || (this.sampleAes = null);
    let i;
    const a = this._videoTrack,
      o = this._audioTrack,
      l = this._id3Track,
      c = this._txtTrack;
    let h = a.pid,
      m = a.pesData,
      p = o.pid,
      g = l.pid,
      y = o.pesData,
      b = l.pesData,
      w = null,
      S = this.pmtParsed,
      A = this._pmtId,
      _ = e.length;
    if (
      (this.remainderData &&
        ((e = da(this.remainderData, e)),
        (_ = e.length),
        (this.remainderData = null)),
      _ < Js && !r)
    )
      return (
        (this.remainderData = e),
        { audioTrack: o, videoTrack: a, id3Track: l, textTrack: c }
      );
    const R = Math.max(0, wc.syncOffset(e));
    (_ -= (_ - R) % Js),
      _ < e.byteLength &&
        !r &&
        (this.remainderData = new Uint8Array(
          e.buffer,
          _,
          e.buffer.byteLength - _
        ));
    let C = 0;
    for (let L = R; L < _; L += Js)
      if (e[L] === 71) {
        const P = !!(e[L + 1] & 64),
          V = uI(e, L),
          N = (e[L + 3] & 48) >> 4;
        let W;
        if (N > 1) {
          if (((W = L + 5 + e[L + 4]), W === L + Js)) continue;
        } else W = L + 4;
        switch (V) {
          case h:
            if (P) {
              if (m && (i = xh(m, this.logger))) {
                if (this.videoParser === null)
                  switch (a.segmentCodec) {
                    case "avc":
                      this.videoParser = new t5();
                      break;
                    case "hevc":
                      this.videoParser = new n5();
                      break;
                  }
                this.videoParser !== null &&
                  this.videoParser.parsePES(a, c, i, !1);
              }
              m = { data: [], size: 0 };
            }
            m && (m.data.push(e.subarray(W, L + Js)), (m.size += L + Js - W));
            break;
          case p:
            if (P) {
              if (y && (i = xh(y, this.logger)))
                switch (o.segmentCodec) {
                  case "aac":
                    this.parseAACPES(o, i);
                    break;
                  case "mp3":
                    this.parseMPEGPES(o, i);
                    break;
                  case "ac3":
                    this.parseAC3PES(o, i);
                    break;
                }
              y = { data: [], size: 0 };
            }
            y && (y.data.push(e.subarray(W, L + Js)), (y.size += L + Js - W));
            break;
          case g:
            P &&
              (b && (i = xh(b, this.logger)) && this.parseID3PES(l, i),
              (b = { data: [], size: 0 })),
              b && (b.data.push(e.subarray(W, L + Js)), (b.size += L + Js - W));
            break;
          case 0:
            P && (W += e[W] + 1), (A = this._pmtId = lCe(e, W));
            break;
          case A: {
            P && (W += e[W] + 1);
            const H = cCe(
              e,
              W,
              this.typeSupported,
              s,
              this.observer,
              this.logger
            );
            (h = H.videoPid),
              h > 0 && ((a.pid = h), (a.segmentCodec = H.segmentVideoCodec)),
              (p = H.audioPid),
              p > 0 && ((o.pid = p), (o.segmentCodec = H.segmentAudioCodec)),
              (g = H.id3Pid),
              g > 0 && (l.pid = g),
              w !== null &&
                !S &&
                (this.logger.warn(
                  `MPEG-TS PMT found at ${L} after unknown PID '${w}'. Backtracking to sync byte @${R} to parse all TS packets.`
                ),
                (w = null),
                (L = R - 188)),
              (S = this.pmtParsed = !0);
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            w = V;
            break;
        }
      } else C++;
    C > 0 &&
      dI(
        this.observer,
        new Error(`Found ${C} TS packet/s that do not start with 0x47`),
        void 0,
        this.logger
      ),
      (a.pesData = m),
      (o.pesData = y),
      (l.pesData = b);
    const D = { audioTrack: o, videoTrack: a, id3Track: l, textTrack: c };
    return r && this.extractRemainingSamples(D), D;
  }
  flush() {
    const { remainderData: e } = this;
    this.remainderData = null;
    let t;
    return (
      e
        ? (t = this.demux(e, -1, !1, !0))
        : (t = {
            videoTrack: this._videoTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack,
          }),
      this.extractRemainingSamples(t),
      this.sampleAes ? this.decrypt(t, this.sampleAes) : t
    );
  }
  extractRemainingSamples(e) {
    const { audioTrack: t, videoTrack: s, id3Track: r, textTrack: i } = e,
      a = s.pesData,
      o = t.pesData,
      l = r.pesData;
    let c;
    if (a && (c = xh(a, this.logger))) {
      if (this.videoParser === null)
        switch (s.segmentCodec) {
          case "avc":
            this.videoParser = new t5();
            break;
          case "hevc":
            this.videoParser = new n5();
            break;
        }
      this.videoParser !== null &&
        (this.videoParser.parsePES(s, i, c, !0), (s.pesData = null));
    } else s.pesData = a;
    if (o && (c = xh(o, this.logger))) {
      switch (t.segmentCodec) {
        case "aac":
          this.parseAACPES(t, c);
          break;
        case "mp3":
          this.parseMPEGPES(t, c);
          break;
        case "ac3":
          this.parseAC3PES(t, c);
          break;
      }
      t.pesData = null;
    } else
      o != null &&
        o.size &&
        this.logger.log(
          "last AAC PES packet truncated,might overlap between fragments"
        ),
        (t.pesData = o);
    l && (c = xh(l, this.logger))
      ? (this.parseID3PES(r, c), (r.pesData = null))
      : (r.pesData = l);
  }
  demuxSampleAes(e, t, s) {
    const r = this.demux(e, s, !0, !this.config.progressive),
      i = (this.sampleAes = new oCe(this.observer, this.config, t));
    return this.decrypt(r, i);
  }
  decrypt(e, t) {
    return new Promise((s) => {
      const { audioTrack: r, videoTrack: i } = e;
      r.samples && r.segmentCodec === "aac"
        ? t.decryptAacSamples(r.samples, 0, () => {
            i.samples
              ? t.decryptAvcSamples(i.samples, 0, 0, () => {
                  s(e);
                })
              : s(e);
          })
        : i.samples &&
          t.decryptAvcSamples(i.samples, 0, 0, () => {
            s(e);
          });
    });
  }
  destroy() {
    this.observer && this.observer.removeAllListeners(),
      (this.config = this.logger = this.observer = null),
      (this.aacOverFlow =
        this.videoParser =
        this.remainderData =
        this.sampleAes =
          null),
      (this._videoTrack =
        this._audioTrack =
        this._id3Track =
        this._txtTrack =
          void 0);
  }
  parseAACPES(e, t) {
    let s = 0;
    const r = this.aacOverFlow;
    let i = t.data;
    if (r) {
      this.aacOverFlow = null;
      const m = r.missing,
        p = r.sample.unit.byteLength;
      if (m === -1) i = da(r.sample.unit, i);
      else {
        const g = p - m;
        r.sample.unit.set(i.subarray(0, m), g),
          e.samples.push(r.sample),
          (s = r.missing);
      }
    }
    let a, o;
    for (a = s, o = i.length; a < o - 1 && !eE(i, a); a++);
    if (a !== s) {
      let m;
      const p = a < o - 1;
      if (
        (p
          ? (m = `AAC PES did not start with ADTS header,offset:${a}`)
          : (m = "No ADTS header found in AAC PES"),
        dI(this.observer, new Error(m), p, this.logger),
        !p)
      )
        return;
    }
    $Y(e, this.observer, i, a, this.audioCodec);
    let l;
    if (t.pts !== void 0) l = t.pts;
    else if (r) {
      const m = BY(e.samplerate);
      l = r.sample.pts + m;
    } else {
      this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let c = 0,
      h;
    for (; a < o; )
      if (((h = HY(e, i, a, l, c)), (a += h.length), h.missing)) {
        this.aacOverFlow = h;
        break;
      } else for (c++; a < o - 1 && !eE(i, a); a++);
  }
  parseMPEGPES(e, t) {
    const s = t.data,
      r = s.length;
    let i = 0,
      a = 0;
    const o = t.pts;
    if (o === void 0) {
      this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; a < r; )
      if (WY(s, a)) {
        const l = GY(e, s, a, o, i);
        if (l) (a += l.length), i++;
        else break;
      } else a++;
  }
  parseAC3PES(e, t) {
    {
      const s = t.data,
        r = t.pts;
      if (r === void 0) {
        this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const i = s.length;
      let a = 0,
        o = 0,
        l;
      for (; o < i && (l = XY(e, s, o, r, a++)) > 0; ) o += l;
    }
  }
  parseID3PES(e, t) {
    if (t.pts === void 0) {
      this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const s = Tn({}, t, {
      type: this._videoTrack ? Si.emsg : Si.audioId3,
      duration: Number.POSITIVE_INFINITY,
    });
    e.samples.push(s);
  }
}
function uI(n, e) {
  return ((n[e + 1] & 31) << 8) + n[e + 2];
}
function lCe(n, e) {
  return ((n[e + 10] & 31) << 8) | n[e + 11];
}
function cCe(n, e, t, s, r, i) {
  const a = {
      audioPid: -1,
      videoPid: -1,
      id3Pid: -1,
      segmentVideoCodec: "avc",
      segmentAudioCodec: "aac",
    },
    o = ((n[e + 1] & 15) << 8) | n[e + 2],
    l = e + 3 + o - 4,
    c = ((n[e + 10] & 15) << 8) | n[e + 11];
  for (e += 12 + c; e < l; ) {
    const h = uI(n, e),
      m = ((n[e + 3] & 15) << 8) | n[e + 4];
    switch (n[e]) {
      case 207:
        if (!s) {
          EA("ADTS AAC", i);
          break;
        }
      case 15:
        a.audioPid === -1 && (a.audioPid = h);
        break;
      case 21:
        a.id3Pid === -1 && (a.id3Pid = h);
        break;
      case 219:
        if (!s) {
          EA("H.264", i);
          break;
        }
      case 27:
        a.videoPid === -1 && (a.videoPid = h);
        break;
      case 3:
      case 4:
        !t.mpeg && !t.mp3
          ? i.log("MPEG audio found, not supported in this browser")
          : a.audioPid === -1 &&
            ((a.audioPid = h), (a.segmentAudioCodec = "mp3"));
        break;
      case 193:
        if (!s) {
          EA("AC-3", i);
          break;
        }
      case 129:
        t.ac3
          ? a.audioPid === -1 &&
            ((a.audioPid = h), (a.segmentAudioCodec = "ac3"))
          : i.log("AC-3 audio found, not supported in this browser");
        break;
      case 6:
        if (a.audioPid === -1 && m > 0) {
          let p = e + 5,
            g = m;
          for (; g > 2; ) {
            switch (n[p]) {
              case 106:
                t.ac3 !== !0
                  ? i.log(
                      "AC-3 audio found, not supported in this browser for now"
                    )
                  : ((a.audioPid = h), (a.segmentAudioCodec = "ac3"));
                break;
            }
            const b = n[p + 1] + 2;
            (p += b), (g -= b);
          }
        }
        break;
      case 194:
      case 135:
        return dI(r, new Error("Unsupported EC-3 in M2TS found"), void 0, i), a;
      case 36:
        a.videoPid === -1 &&
          ((a.videoPid = h),
          (a.segmentVideoCodec = "hevc"),
          i.log("HEVC in M2TS found"));
        break;
    }
    e += m + 5;
  }
  return a;
}
function dI(n, e, t, s) {
  s.warn(`parsing error: ${e.message}`),
    n.emit($.ERROR, $.ERROR, {
      type: gt.MEDIA_ERROR,
      details: we.FRAG_PARSING_ERROR,
      fatal: !1,
      levelRetry: t,
      error: e,
      reason: e.message,
    });
}
function EA(n, e) {
  e.log(`${n} with AES-128-CBC encryption found in unencrypted stream`);
}
function xh(n, e) {
  let t = 0,
    s,
    r,
    i,
    a,
    o;
  const l = n.data;
  if (!n || n.size === 0) return null;
  for (; l[0].length < 19 && l.length > 1; )
    (l[0] = da(l[0], l[1])), l.splice(1, 1);
  if (((s = l[0]), (s[0] << 16) + (s[1] << 8) + s[2] === 1)) {
    if (((r = (s[4] << 8) + s[5]), r && r > n.size - 6)) return null;
    const h = s[7];
    h & 192 &&
      ((a =
        (s[9] & 14) * 536870912 +
        (s[10] & 255) * 4194304 +
        (s[11] & 254) * 16384 +
        (s[12] & 255) * 128 +
        (s[13] & 254) / 2),
      h & 64
        ? ((o =
            (s[14] & 14) * 536870912 +
            (s[15] & 255) * 4194304 +
            (s[16] & 254) * 16384 +
            (s[17] & 255) * 128 +
            (s[18] & 254) / 2),
          a - o > 60 * 9e4 &&
            (e.warn(
              `${Math.round(
                (a - o) / 9e4
              )}s delta between PTS and DTS, align them`
            ),
            (a = o)))
        : (o = a)),
      (i = s[8]);
    let m = i + 9;
    if (n.size <= m) return null;
    n.size -= m;
    const p = new Uint8Array(n.size);
    for (let g = 0, y = l.length; g < y; g++) {
      s = l[g];
      let b = s.byteLength;
      if (m)
        if (m > b) {
          m -= b;
          continue;
        } else (s = s.subarray(m)), (b -= m), (m = 0);
      p.set(s, t), (t += b);
    }
    return r && (r -= i + 3), { data: p, pts: a, dts: o, len: r };
  }
  return null;
}
class uCe {
  static getSilentFrame(e, t) {
    switch (e) {
      case "mp4a.40.2":
        if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (t === 3)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142,
          ]);
        if (t === 4)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2,
            56,
          ]);
        if (t === 5)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0,
            33, 144, 2, 56,
          ]);
        if (t === 6)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0,
            33, 144, 2, 0, 178, 0, 32, 8, 224,
          ]);
        break;
      default:
        if (t === 1)
          return new Uint8Array([
            1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193,
            10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 94,
          ]);
        if (t === 2)
          return new Uint8Array([
            1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6,
            241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 94,
          ]);
        if (t === 3)
          return new Uint8Array([
            1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6,
            241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 94,
          ]);
        break;
    }
  }
}
const cc = Math.pow(2, 32) - 1;
class ye {
  static init() {
    ye.types = {
      avc1: [],
      avcC: [],
      hvc1: [],
      hvcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: [],
    };
    let e;
    for (e in ye.types)
      ye.types.hasOwnProperty(e) &&
        (ye.types[e] = [
          e.charCodeAt(0),
          e.charCodeAt(1),
          e.charCodeAt(2),
          e.charCodeAt(3),
        ]);
    const t = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0,
      ]),
      s = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0,
      ]);
    ye.HDLR_TYPES = { video: t, audio: s };
    const r = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1,
      ]),
      i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
    (ye.STTS = ye.STSC = ye.STCO = i),
      (ye.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
      (ye.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])),
      (ye.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
      (ye.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]));
    const a = new Uint8Array([105, 115, 111, 109]),
      o = new Uint8Array([97, 118, 99, 49]),
      l = new Uint8Array([0, 0, 0, 1]);
    (ye.FTYP = ye.box(ye.types.ftyp, a, l, a, o)),
      (ye.DINF = ye.box(ye.types.dinf, ye.box(ye.types.dref, r)));
  }
  static box(e, ...t) {
    let s = 8,
      r = t.length;
    const i = r;
    for (; r--; ) s += t[r].byteLength;
    const a = new Uint8Array(s);
    for (
      a[0] = (s >> 24) & 255,
        a[1] = (s >> 16) & 255,
        a[2] = (s >> 8) & 255,
        a[3] = s & 255,
        a.set(e, 4),
        r = 0,
        s = 8;
      r < i;
      r++
    )
      a.set(t[r], s), (s += t[r].byteLength);
    return a;
  }
  static hdlr(e) {
    return ye.box(ye.types.hdlr, ye.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return ye.box(ye.types.mdat, e);
  }
  static mdhd(e, t) {
    t *= e;
    const s = Math.floor(t / (cc + 1)),
      r = Math.floor(t % (cc + 1));
    return ye.box(
      ye.types.mdhd,
      new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (e >> 24) & 255,
        (e >> 16) & 255,
        (e >> 8) & 255,
        e & 255,
        s >> 24,
        (s >> 16) & 255,
        (s >> 8) & 255,
        s & 255,
        r >> 24,
        (r >> 16) & 255,
        (r >> 8) & 255,
        r & 255,
        85,
        196,
        0,
        0,
      ])
    );
  }
  static mdia(e) {
    return ye.box(
      ye.types.mdia,
      ye.mdhd(e.timescale || 0, e.duration || 0),
      ye.hdlr(e.type),
      ye.minf(e)
    );
  }
  static mfhd(e) {
    return ye.box(
      ye.types.mfhd,
      new Uint8Array([
        0,
        0,
        0,
        0,
        e >> 24,
        (e >> 16) & 255,
        (e >> 8) & 255,
        e & 255,
      ])
    );
  }
  static minf(e) {
    return e.type === "audio"
      ? ye.box(
          ye.types.minf,
          ye.box(ye.types.smhd, ye.SMHD),
          ye.DINF,
          ye.stbl(e)
        )
      : ye.box(
          ye.types.minf,
          ye.box(ye.types.vmhd, ye.VMHD),
          ye.DINF,
          ye.stbl(e)
        );
  }
  static moof(e, t, s) {
    return ye.box(ye.types.moof, ye.mfhd(e), ye.traf(s, t));
  }
  static moov(e) {
    let t = e.length;
    const s = [];
    for (; t--; ) s[t] = ye.trak(e[t]);
    return ye.box.apply(
      null,
      [ye.types.moov, ye.mvhd(e[0].timescale || 0, e[0].duration || 0)]
        .concat(s)
        .concat(ye.mvex(e))
    );
  }
  static mvex(e) {
    let t = e.length;
    const s = [];
    for (; t--; ) s[t] = ye.trex(e[t]);
    return ye.box.apply(null, [ye.types.mvex, ...s]);
  }
  static mvhd(e, t) {
    t *= e;
    const s = Math.floor(t / (cc + 1)),
      r = Math.floor(t % (cc + 1)),
      i = new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (e >> 24) & 255,
        (e >> 16) & 255,
        (e >> 8) & 255,
        e & 255,
        s >> 24,
        (s >> 16) & 255,
        (s >> 8) & 255,
        s & 255,
        r >> 24,
        (r >> 16) & 255,
        (r >> 8) & 255,
        r & 255,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255,
      ]);
    return ye.box(ye.types.mvhd, i);
  }
  static sdtp(e) {
    const t = e.samples || [],
      s = new Uint8Array(4 + t.length);
    let r, i;
    for (r = 0; r < t.length; r++)
      (i = t[r].flags),
        (s[r + 4] =
          (i.dependsOn << 4) | (i.isDependedOn << 2) | i.hasRedundancy);
    return ye.box(ye.types.sdtp, s);
  }
  static stbl(e) {
    return ye.box(
      ye.types.stbl,
      ye.stsd(e),
      ye.box(ye.types.stts, ye.STTS),
      ye.box(ye.types.stsc, ye.STSC),
      ye.box(ye.types.stsz, ye.STSZ),
      ye.box(ye.types.stco, ye.STCO)
    );
  }
  static avc1(e) {
    let t = [],
      s = [],
      r,
      i,
      a;
    for (r = 0; r < e.sps.length; r++)
      (i = e.sps[r]),
        (a = i.byteLength),
        t.push((a >>> 8) & 255),
        t.push(a & 255),
        (t = t.concat(Array.prototype.slice.call(i)));
    for (r = 0; r < e.pps.length; r++)
      (i = e.pps[r]),
        (a = i.byteLength),
        s.push((a >>> 8) & 255),
        s.push(a & 255),
        (s = s.concat(Array.prototype.slice.call(i)));
    const o = ye.box(
        ye.types.avcC,
        new Uint8Array(
          [1, t[3], t[4], t[5], 255, 224 | e.sps.length]
            .concat(t)
            .concat([e.pps.length])
            .concat(s)
        )
      ),
      l = e.width,
      c = e.height,
      h = e.pixelRatio[0],
      m = e.pixelRatio[1];
    return ye.box(
      ye.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        (l >> 8) & 255,
        l & 255,
        (c >> 8) & 255,
        c & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        18,
        100,
        97,
        105,
        108,
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17,
      ]),
      o,
      ye.box(
        ye.types.btrt,
        new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])
      ),
      ye.box(
        ye.types.pasp,
        new Uint8Array([
          h >> 24,
          (h >> 16) & 255,
          (h >> 8) & 255,
          h & 255,
          m >> 24,
          (m >> 16) & 255,
          (m >> 8) & 255,
          m & 255,
        ])
      )
    );
  }
  static esds(e) {
    const t = e.config;
    return new Uint8Array([
      0,
      0,
      0,
      0,
      3,
      25,
      0,
      1,
      0,
      4,
      17,
      64,
      21,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      2,
      ...t,
      6,
      1,
      2,
    ]);
  }
  static audioStsd(e) {
    const t = e.samplerate || 0;
    return new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      e.channelCount || 0,
      0,
      16,
      0,
      0,
      0,
      0,
      (t >> 8) & 255,
      t & 255,
      0,
      0,
    ]);
  }
  static mp4a(e) {
    return ye.box(
      ye.types.mp4a,
      ye.audioStsd(e),
      ye.box(ye.types.esds, ye.esds(e))
    );
  }
  static mp3(e) {
    return ye.box(ye.types[".mp3"], ye.audioStsd(e));
  }
  static ac3(e) {
    return ye.box(
      ye.types["ac-3"],
      ye.audioStsd(e),
      ye.box(ye.types.dac3, e.config)
    );
  }
  static stsd(e) {
    const { segmentCodec: t } = e;
    if (e.type === "audio") {
      if (t === "aac") return ye.box(ye.types.stsd, ye.STSD, ye.mp4a(e));
      if (t === "ac3" && e.config)
        return ye.box(ye.types.stsd, ye.STSD, ye.ac3(e));
      if (t === "mp3" && e.codec === "mp3")
        return ye.box(ye.types.stsd, ye.STSD, ye.mp3(e));
    } else if (e.pps && e.sps) {
      if (t === "avc") return ye.box(ye.types.stsd, ye.STSD, ye.avc1(e));
      if (t === "hevc" && e.vps)
        return ye.box(ye.types.stsd, ye.STSD, ye.hvc1(e));
    } else throw new Error("video track missing pps or sps");
    throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);
  }
  static tkhd(e) {
    const t = e.id,
      s = (e.duration || 0) * (e.timescale || 0),
      r = e.width || 0,
      i = e.height || 0,
      a = Math.floor(s / (cc + 1)),
      o = Math.floor(s % (cc + 1));
    return ye.box(
      ye.types.tkhd,
      new Uint8Array([
        1,
        0,
        0,
        7,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (t >> 24) & 255,
        (t >> 16) & 255,
        (t >> 8) & 255,
        t & 255,
        0,
        0,
        0,
        0,
        a >> 24,
        (a >> 16) & 255,
        (a >> 8) & 255,
        a & 255,
        o >> 24,
        (o >> 16) & 255,
        (o >> 8) & 255,
        o & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        (r >> 8) & 255,
        r & 255,
        0,
        0,
        (i >> 8) & 255,
        i & 255,
        0,
        0,
      ])
    );
  }
  static traf(e, t) {
    const s = ye.sdtp(e),
      r = e.id,
      i = Math.floor(t / (cc + 1)),
      a = Math.floor(t % (cc + 1));
    return ye.box(
      ye.types.traf,
      ye.box(
        ye.types.tfhd,
        new Uint8Array([
          0,
          0,
          0,
          0,
          r >> 24,
          (r >> 16) & 255,
          (r >> 8) & 255,
          r & 255,
        ])
      ),
      ye.box(
        ye.types.tfdt,
        new Uint8Array([
          1,
          0,
          0,
          0,
          i >> 24,
          (i >> 16) & 255,
          (i >> 8) & 255,
          i & 255,
          a >> 24,
          (a >> 16) & 255,
          (a >> 8) & 255,
          a & 255,
        ])
      ),
      ye.trun(e, s.length + 16 + 20 + 8 + 16 + 8 + 8),
      s
    );
  }
  static trak(e) {
    return (
      (e.duration = e.duration || 4294967295),
      ye.box(ye.types.trak, ye.tkhd(e), ye.mdia(e))
    );
  }
  static trex(e) {
    const t = e.id;
    return ye.box(
      ye.types.trex,
      new Uint8Array([
        0,
        0,
        0,
        0,
        t >> 24,
        (t >> 16) & 255,
        (t >> 8) & 255,
        t & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
      ])
    );
  }
  static trun(e, t) {
    const s = e.samples || [],
      r = s.length,
      i = 12 + 16 * r,
      a = new Uint8Array(i);
    let o, l, c, h, m, p;
    for (
      t += 8 + i,
        a.set(
          [
            e.type === "video" ? 1 : 0,
            0,
            15,
            1,
            (r >>> 24) & 255,
            (r >>> 16) & 255,
            (r >>> 8) & 255,
            r & 255,
            (t >>> 24) & 255,
            (t >>> 16) & 255,
            (t >>> 8) & 255,
            t & 255,
          ],
          0
        ),
        o = 0;
      o < r;
      o++
    )
      (l = s[o]),
        (c = l.duration),
        (h = l.size),
        (m = l.flags),
        (p = l.cts),
        a.set(
          [
            (c >>> 24) & 255,
            (c >>> 16) & 255,
            (c >>> 8) & 255,
            c & 255,
            (h >>> 24) & 255,
            (h >>> 16) & 255,
            (h >>> 8) & 255,
            h & 255,
            (m.isLeading << 2) | m.dependsOn,
            (m.isDependedOn << 6) |
              (m.hasRedundancy << 4) |
              (m.paddingValue << 1) |
              m.isNonSync,
            m.degradPrio & 61440,
            m.degradPrio & 15,
            (p >>> 24) & 255,
            (p >>> 16) & 255,
            (p >>> 8) & 255,
            p & 255,
          ],
          12 + 16 * o
        );
    return ye.box(ye.types.trun, a);
  }
  static initSegment(e) {
    ye.types || ye.init();
    const t = ye.moov(e);
    return da(ye.FTYP, t);
  }
  static hvc1(e) {
    const t = e.params,
      s = [e.vps, e.sps, e.pps],
      r = 4,
      i = new Uint8Array([
        1,
        (t.general_profile_space << 6) |
          (t.general_tier_flag ? 32 : 0) |
          t.general_profile_idc,
        t.general_profile_compatibility_flags[0],
        t.general_profile_compatibility_flags[1],
        t.general_profile_compatibility_flags[2],
        t.general_profile_compatibility_flags[3],
        t.general_constraint_indicator_flags[0],
        t.general_constraint_indicator_flags[1],
        t.general_constraint_indicator_flags[2],
        t.general_constraint_indicator_flags[3],
        t.general_constraint_indicator_flags[4],
        t.general_constraint_indicator_flags[5],
        t.general_level_idc,
        240 | (t.min_spatial_segmentation_idc >> 8),
        255 & t.min_spatial_segmentation_idc,
        252 | t.parallelismType,
        252 | t.chroma_format_idc,
        248 | t.bit_depth_luma_minus8,
        248 | t.bit_depth_chroma_minus8,
        0,
        parseInt(t.frame_rate.fps),
        (r - 1) |
          (t.temporal_id_nested << 2) |
          (t.num_temporal_layers << 3) |
          (t.frame_rate.fixed ? 64 : 0),
        s.length,
      ]);
    let a = i.length;
    for (let y = 0; y < s.length; y += 1) {
      a += 3;
      for (let b = 0; b < s[y].length; b += 1) a += 2 + s[y][b].length;
    }
    const o = new Uint8Array(a);
    o.set(i, 0), (a = i.length);
    const l = s.length - 1;
    for (let y = 0; y < s.length; y += 1) {
      o.set(
        new Uint8Array([(32 + y) | (y === l ? 128 : 0), 0, s[y].length]),
        a
      ),
        (a += 3);
      for (let b = 0; b < s[y].length; b += 1)
        o.set(new Uint8Array([s[y][b].length >> 8, s[y][b].length & 255]), a),
          (a += 2),
          o.set(s[y][b], a),
          (a += s[y][b].length);
    }
    const c = ye.box(ye.types.hvcC, o),
      h = e.width,
      m = e.height,
      p = e.pixelRatio[0],
      g = e.pixelRatio[1];
    return ye.box(
      ye.types.hvc1,
      new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        (h >> 8) & 255,
        h & 255,
        (m >> 8) & 255,
        m & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        18,
        100,
        97,
        105,
        108,
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17,
      ]),
      c,
      ye.box(
        ye.types.btrt,
        new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])
      ),
      ye.box(
        ye.types.pasp,
        new Uint8Array([
          p >> 24,
          (p >> 16) & 255,
          (p >> 8) & 255,
          p & 255,
          g >> 24,
          (g >> 16) & 255,
          (g >> 8) & 255,
          g & 255,
        ])
      )
    );
  }
}
ye.types = void 0;
ye.HDLR_TYPES = void 0;
ye.STTS = void 0;
ye.STSC = void 0;
ye.STCO = void 0;
ye.STSZ = void 0;
ye.VMHD = void 0;
ye.SMHD = void 0;
ye.STSD = void 0;
ye.FTYP = void 0;
ye.DINF = void 0;
const ZY = 9e4;
function rM(n, e, t = 1, s = !1) {
  const r = n * e * t;
  return s ? Math.round(r) : r;
}
function dCe(n, e, t = 1, s = !1) {
  return rM(n, e, 1 / t, s);
}
function vp(n, e = !1) {
  return rM(n, 1e3, 1 / ZY, e);
}
function hCe(n, e = 1) {
  return rM(n, ZY, 1 / e);
}
const fCe = 10 * 1e3,
  mCe = 1024,
  pCe = 1152,
  gCe = 1536;
let wh = null,
  SA = null;
function s5(n, e, t, s) {
  return {
    duration: e,
    size: t,
    cts: s,
    flags: {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: n ? 2 : 1,
      isNonSync: n ? 0 : 1,
    },
  };
}
class rx extends za {
  constructor(e, t, s, r) {
    if (
      (super("mp4-remuxer", r),
      (this.observer = void 0),
      (this.config = void 0),
      (this.typeSupported = void 0),
      (this.ISGenerated = !1),
      (this._initPTS = null),
      (this._initDTS = null),
      (this.nextVideoTs = null),
      (this.nextAudioTs = null),
      (this.videoSampleDuration = null),
      (this.isAudioContiguous = !1),
      (this.isVideoContiguous = !1),
      (this.videoTrackConfig = void 0),
      (this.observer = e),
      (this.config = t),
      (this.typeSupported = s),
      (this.ISGenerated = !1),
      wh === null)
    ) {
      const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      wh = a ? parseInt(a[1]) : 0;
    }
    if (SA === null) {
      const i = navigator.userAgent.match(/Safari\/(\d+)/i);
      SA = i ? parseInt(i[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(e) {
    this.log("initPTS & initDTS reset"), (this._initPTS = this._initDTS = e);
  }
  resetNextTimestamp() {
    this.log("reset next timestamp"),
      (this.isVideoContiguous = !1),
      (this.isAudioContiguous = !1);
  }
  resetInitSegment() {
    this.log("ISGenerated flag reset"),
      (this.ISGenerated = !1),
      (this.videoTrackConfig = void 0);
  }
  getVideoStartPts(e) {
    let t = !1;
    const s = e[0].pts,
      r = e.reduce((i, a) => {
        let o = a.pts,
          l = o - i;
        return (
          l < -4294967296 && ((t = !0), (o = Xi(o, s)), (l = o - i)),
          l > 0 ? i : o
        );
      }, s);
    return t && this.debug("PTS rollover detected"), r;
  }
  remux(e, t, s, r, i, a, o, l) {
    let c,
      h,
      m,
      p,
      g,
      y,
      b = i,
      w = i;
    const S = e.pid > -1,
      A = t.pid > -1,
      _ = t.samples.length,
      R = e.samples.length > 0,
      C = (o && _ > 0) || _ > 1;
    if (((!S || R) && (!A || C)) || this.ISGenerated || o) {
      if (this.ISGenerated) {
        var L, P, V, N;
        const B = this.videoTrackConfig;
        ((B &&
          (t.width !== B.width ||
            t.height !== B.height ||
            ((L = t.pixelRatio) == null ? void 0 : L[0]) !==
              ((P = B.pixelRatio) == null ? void 0 : P[0]) ||
            ((V = t.pixelRatio) == null ? void 0 : V[1]) !==
              ((N = B.pixelRatio) == null ? void 0 : N[1]))) ||
          (!B && C) ||
          (this.nextAudioTs === null && R)) &&
          this.resetInitSegment();
      }
      this.ISGenerated || (m = this.generateIS(e, t, i, a));
      const W = this.isVideoContiguous;
      let H = -1,
        z;
      if (
        C &&
        ((H = vCe(t.samples)), !W && this.config.forceKeyFrameOnDiscontinuity)
      )
        if (((y = !0), H > 0)) {
          this.warn(
            `Dropped ${H} out of ${_} video samples due to a missing keyframe`
          );
          const B = this.getVideoStartPts(t.samples);
          (t.samples = t.samples.slice(H)),
            (t.dropped += H),
            (w += (t.samples[0].pts - B) / t.inputTimeScale),
            (z = w);
        } else
          H === -1 &&
            (this.warn(`No keyframe found out of ${_} video samples`),
            (y = !1));
      if (this.ISGenerated) {
        if (R && C) {
          const B = this.getVideoStartPts(t.samples),
            O = (Xi(e.samples[0].pts, B) - B) / t.inputTimeScale;
          (b += Math.max(0, O)), (w += Math.max(0, -O));
        }
        if (R) {
          if (
            (e.samplerate ||
              (this.warn("regenerate InitSegment as audio detected"),
              (m = this.generateIS(e, t, i, a))),
            (h = this.remuxAudio(
              e,
              b,
              this.isAudioContiguous,
              a,
              A || C || l === lt.AUDIO ? w : void 0
            )),
            C)
          ) {
            const B = h ? h.endPTS - h.startPTS : 0;
            t.inputTimeScale ||
              (this.warn("regenerate InitSegment as video detected"),
              (m = this.generateIS(e, t, i, a))),
              (c = this.remuxVideo(t, w, W, B));
          }
        } else C && (c = this.remuxVideo(t, w, W, 0));
        c &&
          ((c.firstKeyFrame = H),
          (c.independent = H !== -1),
          (c.firstKeyFramePTS = z));
      }
    }
    return (
      this.ISGenerated &&
        this._initPTS &&
        this._initDTS &&
        (s.samples.length && (g = JY(s, i, this._initPTS, this._initDTS)),
        r.samples.length && (p = eX(r, i, this._initPTS))),
      { audio: h, video: c, initSegment: m, independent: y, text: p, id3: g }
    );
  }
  generateIS(e, t, s, r) {
    const i = e.samples,
      a = t.samples,
      o = this.typeSupported,
      l = {},
      c = this._initPTS;
    let h = !c || r,
      m = "audio/mp4",
      p,
      g,
      y,
      b;
    if ((h && (p = g = 1 / 0), e.config && i.length)) {
      switch (((e.timescale = e.samplerate), e.segmentCodec)) {
        case "mp3":
          o.mpeg
            ? ((m = "audio/mpeg"), (e.codec = ""))
            : o.mp3 && (e.codec = "mp3");
          break;
        case "ac3":
          e.codec = "ac-3";
          break;
      }
      (l.audio = {
        id: "audio",
        container: m,
        codec: e.codec,
        initSegment:
          e.segmentCodec === "mp3" && o.mpeg
            ? new Uint8Array(0)
            : ye.initSegment([e]),
        metadata: { channelCount: e.channelCount },
      }),
        h &&
          ((b = e.id),
          (y = e.inputTimeScale),
          !c || y !== c.timescale
            ? (p = g = i[0].pts - Math.round(y * s))
            : (h = !1));
    }
    if (t.sps && t.pps && a.length) {
      if (
        ((t.timescale = t.inputTimeScale),
        (l.video = {
          id: "main",
          container: "video/mp4",
          codec: t.codec,
          initSegment: ye.initSegment([t]),
          metadata: { width: t.width, height: t.height },
        }),
        h)
      )
        if (((b = t.id), (y = t.inputTimeScale), !c || y !== c.timescale)) {
          const w = this.getVideoStartPts(a),
            S = Math.round(y * s);
          (g = Math.min(g, Xi(a[0].dts, w) - S)), (p = Math.min(p, w - S));
        } else h = !1;
      this.videoTrackConfig = {
        width: t.width,
        height: t.height,
        pixelRatio: t.pixelRatio,
      };
    }
    if (Object.keys(l).length)
      return (
        (this.ISGenerated = !0),
        h
          ? ((this._initPTS = { baseTime: p, timescale: y }),
            (this._initDTS = { baseTime: g, timescale: y }))
          : (p = y = void 0),
        { tracks: l, initPTS: p, timescale: y, trackId: b }
      );
  }
  remuxVideo(e, t, s, r) {
    const i = e.inputTimeScale,
      a = e.samples,
      o = [],
      l = a.length,
      c = this._initPTS,
      h = (c.baseTime * i) / c.timescale;
    let m = this.nextVideoTs,
      p = 8,
      g = this.videoSampleDuration,
      y,
      b,
      w = Number.POSITIVE_INFINITY,
      S = Number.NEGATIVE_INFINITY,
      A = !1;
    if (!s || m === null) {
      const I = h + t * i,
        F = a[0].pts - Xi(a[0].dts, a[0].pts);
      wh && m !== null && Math.abs(I - F - (m + h)) < 15e3
        ? (s = !0)
        : (m = I - F - h);
    }
    const _ = m + h;
    for (let I = 0; I < l; I++) {
      const F = a[I];
      (F.pts = Xi(F.pts, _)),
        (F.dts = Xi(F.dts, _)),
        F.dts < a[I > 0 ? I - 1 : I].dts && (A = !0);
    }
    A &&
      a.sort(function (I, F) {
        const Y = I.dts - F.dts,
          J = I.pts - F.pts;
        return Y || J;
      }),
      (y = a[0].dts),
      (b = a[a.length - 1].dts);
    const R = b - y,
      C = R ? Math.round(R / (l - 1)) : g || e.inputTimeScale / 30;
    if (s) {
      const I = y - _,
        F = I > C,
        Y = I < -1;
      if (
        (F || Y) &&
        (F
          ? this.warn(
              `${(e.segmentCodec || "").toUpperCase()}: ${vp(
                I,
                !0
              )} ms (${I}dts) hole between fragments detected at ${t.toFixed(
                3
              )}`
            )
          : this.warn(
              `${(e.segmentCodec || "").toUpperCase()}: ${vp(
                -I,
                !0
              )} ms (${I}dts) overlapping between fragments detected at ${t.toFixed(
                3
              )}`
            ),
        !Y || _ >= a[0].pts || wh)
      ) {
        y = _;
        const J = a[0].pts - I;
        if (F) (a[0].dts = y), (a[0].pts = J);
        else {
          let X = !0;
          for (let Z = 0; Z < a.length && !(a[Z].dts > J && X); Z++) {
            const te = a[Z].pts;
            if (((a[Z].dts -= I), (a[Z].pts -= I), Z < a.length - 1)) {
              const ce = a[Z + 1].pts,
                pe = a[Z].pts,
                se = ce <= pe,
                be = ce <= te;
              X = se == be;
            }
          }
        }
        this.log(
          `Video: Initial PTS/DTS adjusted: ${vp(J, !0)}/${vp(
            y,
            !0
          )}, delta: ${vp(I, !0)} ms`
        );
      }
    }
    y = Math.max(0, y);
    let D = 0,
      L = 0,
      P = y;
    for (let I = 0; I < l; I++) {
      const F = a[I],
        Y = F.units,
        J = Y.length;
      let X = 0;
      for (let Z = 0; Z < J; Z++) X += Y[Z].data.length;
      (L += X),
        (D += J),
        (F.length = X),
        F.dts < P ? ((F.dts = P), (P += (C / 4) | 0 || 1)) : (P = F.dts),
        (w = Math.min(F.pts, w)),
        (S = Math.max(F.pts, S));
    }
    b = a[l - 1].dts;
    const V = L + 4 * D + 8;
    let N;
    try {
      N = new Uint8Array(V);
    } catch (I) {
      this.observer.emit($.ERROR, $.ERROR, {
        type: gt.MUX_ERROR,
        details: we.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: I,
        bytes: V,
        reason: `fail allocating video mdat ${V}`,
      });
      return;
    }
    const W = new DataView(N.buffer);
    W.setUint32(0, V), N.set(ye.types.mdat, 4);
    let H = !1,
      z = Number.POSITIVE_INFINITY,
      B = Number.POSITIVE_INFINITY,
      q = Number.NEGATIVE_INFINITY,
      O = Number.NEGATIVE_INFINITY;
    for (let I = 0; I < l; I++) {
      const F = a[I],
        Y = F.units;
      let J = 0;
      for (let te = 0, ce = Y.length; te < ce; te++) {
        const pe = Y[te],
          se = pe.data,
          be = pe.data.byteLength;
        W.setUint32(p, be), (p += 4), N.set(se, p), (p += be), (J += 4 + be);
      }
      let X;
      if (I < l - 1) (g = a[I + 1].dts - F.dts), (X = a[I + 1].pts - F.pts);
      else {
        const te = this.config,
          ce = I > 0 ? F.dts - a[I - 1].dts : C;
        if (
          ((X = I > 0 ? F.pts - a[I - 1].pts : C),
          te.stretchShortVideoTrack && this.nextAudioTs !== null)
        ) {
          const pe = Math.floor(te.maxBufferHole * i),
            se = (r ? w + r * i : this.nextAudioTs + h) - F.pts;
          se > pe
            ? ((g = se - ce),
              g < 0 ? (g = ce) : (H = !0),
              this.log(
                `It is approximately ${
                  se / 90
                } ms to the next segment; using duration ${
                  g / 90
                } ms for the last video frame.`
              ))
            : (g = ce);
        } else g = ce;
      }
      const Z = Math.round(F.pts - F.dts);
      (z = Math.min(z, g)),
        (q = Math.max(q, g)),
        (B = Math.min(B, X)),
        (O = Math.max(O, X)),
        o.push(s5(F.key, g, J, Z));
    }
    if (o.length) {
      if (wh) {
        if (wh < 70) {
          const I = o[0].flags;
          (I.dependsOn = 2), (I.isNonSync = 0);
        }
      } else if (SA && O - B < q - z && C / q < 0.025 && o[0].cts === 0) {
        this.warn(
          "Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."
        );
        let I = y;
        for (let F = 0, Y = o.length; F < Y; F++) {
          const J = I + o[F].duration,
            X = I + o[F].cts;
          if (F < Y - 1) {
            const Z = J + o[F + 1].cts;
            o[F].duration = Z - X;
          } else o[F].duration = F ? o[F - 1].duration : C;
          (o[F].cts = 0), (I = J);
        }
      }
    }
    g = H || !g ? C : g;
    const U = b + g;
    (this.nextVideoTs = m = U - h),
      (this.videoSampleDuration = g),
      (this.isVideoContiguous = !0);
    const M = {
      data1: ye.moof(e.sequenceNumber++, y, Tn(e, { samples: o })),
      data2: N,
      startPTS: (w - h) / i,
      endPTS: (S + g - h) / i,
      startDTS: (y - h) / i,
      endDTS: m / i,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: o.length,
      dropped: e.dropped,
    };
    return (e.samples = []), (e.dropped = 0), M;
  }
  getSamplesPerFrame(e) {
    switch (e.segmentCodec) {
      case "mp3":
        return pCe;
      case "ac3":
        return gCe;
      default:
        return mCe;
    }
  }
  remuxAudio(e, t, s, r, i) {
    const a = e.inputTimeScale,
      o = e.samplerate ? e.samplerate : a,
      l = a / o,
      c = this.getSamplesPerFrame(e),
      h = c * l,
      m = this._initPTS,
      p = e.segmentCodec === "mp3" && this.typeSupported.mpeg,
      g = [],
      y = i !== void 0;
    let b = e.samples,
      w = p ? 0 : 8,
      S = this.nextAudioTs || -1;
    const A = (m.baseTime * a) / m.timescale,
      _ = A + t * a;
    if (
      ((this.isAudioContiguous = s =
        s ||
        (b.length &&
          S > 0 &&
          ((r && Math.abs(_ - (S + A)) < 9e3) ||
            Math.abs(Xi(b[0].pts, _) - (S + A)) < 20 * h))),
      b.forEach(function (O) {
        O.pts = Xi(O.pts, _);
      }),
      !s || S < 0)
    ) {
      if (((b = b.filter((O) => O.pts >= 0)), !b.length)) return;
      i === 0
        ? (S = 0)
        : r && !y
        ? (S = Math.max(0, _ - A))
        : (S = b[0].pts - A);
    }
    if (e.segmentCodec === "aac") {
      const O = this.config.maxAudioFramesDrift;
      for (let U = 0, j = S + A; U < b.length; U++) {
        const Q = b[U],
          M = Q.pts,
          I = M - j,
          F = Math.abs((1e3 * I) / a);
        if (I <= -O * h && y)
          U === 0 &&
            (this.warn(
              `Audio frame @ ${(M / a).toFixed(
                3
              )}s overlaps marker by ${Math.round((1e3 * I) / a)} ms.`
            ),
            (this.nextAudioTs = S = M - A),
            (j = M));
        else if (I >= O * h && F < fCe && y) {
          let Y = Math.round(I / h);
          for (j = M - Y * h; j < 0 && Y && h; ) Y--, (j += h);
          U === 0 && (this.nextAudioTs = S = j - A),
            this.warn(
              `Injecting ${Y} audio frames @ ${((j - A) / a).toFixed(
                3
              )}s due to ${Math.round((1e3 * I) / a)} ms gap.`
            );
          for (let J = 0; J < Y; J++) {
            let X = uCe.getSilentFrame(
              e.parsedCodec || e.manifestCodec || e.codec,
              e.channelCount
            );
            X ||
              (this.log(
                "Unable to get silent frame for given audio codec; duplicating last frame instead."
              ),
              (X = Q.unit.subarray())),
              b.splice(U, 0, { unit: X, pts: j }),
              (j += h),
              U++;
          }
        }
        (Q.pts = j), (j += h);
      }
    }
    let R = null,
      C = null,
      D,
      L = 0,
      P = b.length;
    for (; P--; ) L += b[P].unit.byteLength;
    for (let O = 0, U = b.length; O < U; O++) {
      const j = b[O],
        Q = j.unit;
      let M = j.pts;
      if (C !== null) {
        const F = g[O - 1];
        F.duration = Math.round((M - C) / l);
      } else if (
        (s && e.segmentCodec === "aac" && (M = S + A), (R = M), L > 0)
      ) {
        L += w;
        try {
          D = new Uint8Array(L);
        } catch (F) {
          this.observer.emit($.ERROR, $.ERROR, {
            type: gt.MUX_ERROR,
            details: we.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: F,
            bytes: L,
            reason: `fail allocating audio mdat ${L}`,
          });
          return;
        }
        p || (new DataView(D.buffer).setUint32(0, L), D.set(ye.types.mdat, 4));
      } else return;
      D.set(Q, w);
      const I = Q.byteLength;
      (w += I), g.push(s5(!0, c, I, 0)), (C = M);
    }
    const V = g.length;
    if (!V) return;
    const N = g[g.length - 1];
    (S = C - A), (this.nextAudioTs = S + l * N.duration);
    const W = p
      ? new Uint8Array(0)
      : ye.moof(e.sequenceNumber++, R / l, Tn({}, e, { samples: g }));
    e.samples = [];
    const H = (R - A) / a,
      z = S / a,
      q = {
        data1: W,
        data2: D,
        startPTS: H,
        endPTS: z,
        startDTS: H,
        endDTS: z,
        type: "audio",
        hasAudio: !0,
        hasVideo: !1,
        nb: V,
      };
    return (this.isAudioContiguous = !0), q;
  }
}
function Xi(n, e) {
  let t;
  if (e === null) return n;
  for (
    e < n ? (t = -8589934592) : (t = 8589934592);
    Math.abs(n - e) > 4294967296;

  )
    n += t;
  return n;
}
function vCe(n) {
  for (let e = 0; e < n.length; e++) if (n[e].key) return e;
  return -1;
}
function JY(n, e, t, s) {
  const r = n.samples.length;
  if (!r) return;
  const i = n.inputTimeScale;
  for (let o = 0; o < r; o++) {
    const l = n.samples[o];
    (l.pts = Xi(l.pts - (t.baseTime * i) / t.timescale, e * i) / i),
      (l.dts = Xi(l.dts - (s.baseTime * i) / s.timescale, e * i) / i);
  }
  const a = n.samples;
  return (n.samples = []), { samples: a };
}
function eX(n, e, t) {
  const s = n.samples.length;
  if (!s) return;
  const r = n.inputTimeScale;
  for (let a = 0; a < s; a++) {
    const o = n.samples[a];
    o.pts = Xi(o.pts - (t.baseTime * r) / t.timescale, e * r) / r;
  }
  n.samples.sort((a, o) => a.pts - o.pts);
  const i = n.samples;
  return (n.samples = []), { samples: i };
}
class yCe extends za {
  constructor(e, t, s, r) {
    super("passthrough-remuxer", r),
      (this.emitInitSegment = !1),
      (this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this.initData = void 0),
      (this.initPTS = null),
      (this.initTracks = void 0),
      (this.lastEndTime = null),
      (this.isVideoContiguous = !1);
  }
  destroy() {}
  resetTimeStamp(e) {
    this.lastEndTime = null;
    const t = this.initPTS;
    (t && e && t.baseTime === e.baseTime && t.timescale === e.timescale) ||
      (this.initPTS = e);
  }
  resetNextTimestamp() {
    (this.isVideoContiguous = !1), (this.lastEndTime = null);
  }
  resetInitSegment(e, t, s, r) {
    (this.audioCodec = t),
      (this.videoCodec = s),
      this.generateInitSegment(uRe(e, r)),
      (this.emitInitSegment = !0);
  }
  generateInitSegment(e) {
    let { audioCodec: t, videoCodec: s } = this;
    if (!(e != null && e.byteLength)) {
      (this.initTracks = void 0), (this.initData = void 0);
      return;
    }
    const r = (this.initData = hY(e));
    r.audio && (t = r5(r.audio, On.AUDIO, this)),
      r.video && (s = r5(r.video, On.VIDEO, this));
    const i = {};
    r.audio && r.video
      ? (i.audiovideo = {
          container: "video/mp4",
          codec: t + "," + s,
          supplemental: r.video.supplemental,
          initSegment: e,
          id: "main",
        })
      : r.audio
      ? (i.audio = {
          container: "audio/mp4",
          codec: t,
          initSegment: e,
          id: "audio",
        })
      : r.video
      ? (i.video = {
          container: "video/mp4",
          codec: s,
          supplemental: r.video.supplemental,
          initSegment: e,
          id: "main",
        })
      : this.warn("initSegment does not contain moov or trak boxes."),
      (this.initTracks = i);
  }
  remux(e, t, s, r, i, a) {
    var o, l;
    let { initPTS: c, lastEndTime: h } = this;
    const m = {
      audio: void 0,
      video: void 0,
      text: r,
      id3: s,
      initSegment: void 0,
    };
    Qe(h) || (h = this.lastEndTime = i || 0);
    const p = t.samples;
    if (!(p != null && p.length)) return m;
    const g = { initPTS: void 0, timescale: void 0, trackId: void 0 };
    let y = this.initData;
    if (
      (((o = y) != null && o.length) ||
        (this.generateInitSegment(p), (y = this.initData)),
      !((l = y) != null && l.length))
    )
      return this.warn("Failed to generate initSegment."), m;
    this.emitInitSegment &&
      ((g.tracks = this.initTracks), (this.emitInitSegment = !1));
    const b = hRe(p, y, this),
      w = y.audio ? b[y.audio.id] : null,
      S = y.video ? b[y.video.id] : null,
      A = rb(S, 1 / 0),
      _ = rb(w, 1 / 0),
      R = rb(S, 0, !0),
      C = rb(w, 0, !0);
    let D,
      L = i,
      P = 0;
    if (
      (w && (!S || (!c && _ < A) || (c && c.trackId === y.audio.id))
        ? ((g.trackId = y.audio.id), (D = w), (P = C - _))
        : S && ((g.trackId = y.video.id), (D = S), (P = R - A)),
      D)
    ) {
      const O = D.timescale;
      (L = D.start / O),
        (g.initPTS = D.start - i * O),
        (g.timescale = O),
        c ||
          (this.initPTS = c =
            { baseTime: g.initPTS, timescale: O, trackId: g.trackId });
    }
    (a || !c) &&
      (bCe(c, L, i, P) || g.timescale !== c.timescale) &&
      ((g.initPTS = L - i),
      (g.timescale = 1),
      c &&
        c.timescale === 1 &&
        this.warn(
          `Adjusting initPTS @${i} from ${c.baseTime / c.timescale} to ${
            g.initPTS
          }`
        ),
      (this.initPTS = c = { baseTime: g.initPTS, timescale: 1 }));
    const V = e ? L - c.baseTime / c.timescale : h,
      N = V + P;
    P > 0
      ? (this.lastEndTime = N)
      : (this.warn("Duration parsed from mp4 should be greater than zero"),
        this.resetNextTimestamp());
    const W = !!y.audio,
      H = !!y.video;
    let z = "";
    W && (z += "audio"), H && (z += "video");
    const B = {
      data1: p,
      startPTS: V,
      startDTS: V,
      endPTS: N,
      endDTS: N,
      type: z,
      hasAudio: W,
      hasVideo: H,
      nb: 1,
      dropped: 0,
    };
    (m.audio = W && !H ? B : void 0), (m.video = H ? B : void 0);
    const q = S?.sampleCount;
    if (q) {
      const O = S.keyFrameIndex,
        U = O !== -1;
      (B.nb = q),
        (B.dropped = O === 0 || this.isVideoContiguous ? 0 : U ? O : q),
        (B.independent = U),
        (B.firstKeyFrame = O),
        U &&
          S.keyFrameStart &&
          (B.firstKeyFramePTS = (S.keyFrameStart - c.baseTime) / c.timescale),
        this.isVideoContiguous || (m.independent = U),
        this.isVideoContiguous || (this.isVideoContiguous = U),
        B.dropped &&
          this.warn(
            `fmp4 does not start with IDR: firstIDR ${O}/${q} dropped: ${
              B.dropped
            } start: ${B.firstKeyFramePTS || "NA"}`
          );
    }
    return (
      (m.initSegment = g),
      (m.id3 = JY(s, i, c, c)),
      r.samples.length && (m.text = eX(r, i, c)),
      m
    );
  }
}
function rb(n, e, t = !1) {
  return n?.start !== void 0
    ? (n.start + (t ? n.duration : 0)) / n.timescale
    : e;
}
function bCe(n, e, t, s) {
  if (n === null) return !0;
  const r = Math.max(s, 1),
    i = e - n.baseTime / n.timescale;
  return Math.abs(i - t) > r;
}
function r5(n, e, t) {
  const s = n?.codec;
  return s && s.length > 4
    ? s
    : e === On.AUDIO
    ? s === "ec-3" || s === "ac-3" || s === "alac"
      ? s
      : s === "fLaC" || s === "Opus"
      ? Ww(s, !1)
      : (t.warn(`Unhandled audio codec "${s}" in mp4 MAP`), s || "mp4a")
    : (t.warn(`Unhandled video codec "${s}" in mp4 MAP`), s || "avc1");
}
let gl;
try {
  gl = self.performance.now.bind(self.performance);
} catch {
  gl = Date.now;
}
const ix = [
  { demux: aCe, remux: yCe },
  { demux: wc, remux: rx },
  { demux: nCe, remux: rx },
  { demux: rCe, remux: rx },
];
ix.splice(2, 0, { demux: sCe, remux: rx });
class i5 {
  constructor(e, t, s, r, i, a) {
    (this.asyncResult = !1),
      (this.logger = void 0),
      (this.observer = void 0),
      (this.typeSupported = void 0),
      (this.config = void 0),
      (this.id = void 0),
      (this.demuxer = void 0),
      (this.remuxer = void 0),
      (this.decrypter = void 0),
      (this.probe = void 0),
      (this.decryptionPromise = null),
      (this.transmuxConfig = void 0),
      (this.currentTransmuxState = void 0),
      (this.observer = e),
      (this.typeSupported = t),
      (this.config = s),
      (this.id = i),
      (this.logger = a);
  }
  configure(e) {
    (this.transmuxConfig = e), this.decrypter && this.decrypter.reset();
  }
  push(e, t, s, r) {
    const i = s.transmuxing;
    i.executeStart = gl();
    let a = new Uint8Array(e);
    const { currentTransmuxState: o, transmuxConfig: l } = this;
    r && (this.currentTransmuxState = r);
    const {
        contiguous: c,
        discontinuity: h,
        trackSwitch: m,
        accurateTimeOffset: p,
        timeOffset: g,
        initSegmentChange: y,
      } = r || o,
      {
        audioCodec: b,
        videoCodec: w,
        defaultInitPts: S,
        duration: A,
        initSegmentData: _,
      } = l,
      R = xCe(a, t);
    if (R && hf(R.method)) {
      const P = this.getDecrypter(),
        V = XP(R.method);
      if (P.isSync()) {
        let N = P.softwareDecrypt(a, R.key.buffer, R.iv.buffer, V);
        if (s.part > -1) {
          const H = P.flush();
          N = H && H.buffer;
        }
        if (!N) return (i.executeEnd = gl()), TA(s);
        a = new Uint8Array(N);
      } else
        return (
          (this.asyncResult = !0),
          (this.decryptionPromise = P.webCryptoDecrypt(
            a,
            R.key.buffer,
            R.iv.buffer,
            V
          ).then((N) => {
            const W = this.push(N, null, s);
            return (this.decryptionPromise = null), W;
          })),
          this.decryptionPromise
        );
    }
    const C = this.needsProbing(h, m);
    if (C) {
      const P = this.configureTransmuxer(a);
      if (P)
        return (
          this.logger.warn(`[transmuxer] ${P.message}`),
          this.observer.emit($.ERROR, $.ERROR, {
            type: gt.MEDIA_ERROR,
            details: we.FRAG_PARSING_ERROR,
            fatal: !1,
            error: P,
            reason: P.message,
          }),
          (i.executeEnd = gl()),
          TA(s)
        );
    }
    (h || m || y || C) && this.resetInitSegment(_, b, w, A, t),
      (h || y || C) && this.resetInitialTimestamp(S),
      c || this.resetContiguity();
    const D = this.transmux(a, R, g, p, s);
    this.asyncResult = vv(D);
    const L = this.currentTransmuxState;
    return (
      (L.contiguous = !0),
      (L.discontinuity = !1),
      (L.trackSwitch = !1),
      (i.executeEnd = gl()),
      D
    );
  }
  flush(e) {
    const t = e.transmuxing;
    t.executeStart = gl();
    const {
      decrypter: s,
      currentTransmuxState: r,
      decryptionPromise: i,
    } = this;
    if (i) return (this.asyncResult = !0), i.then(() => this.flush(e));
    const a = [],
      { timeOffset: o } = r;
    if (s) {
      const m = s.flush();
      m && a.push(this.push(m.buffer, null, e));
    }
    const { demuxer: l, remuxer: c } = this;
    if (!l || !c) {
      t.executeEnd = gl();
      const m = [TA(e)];
      return this.asyncResult ? Promise.resolve(m) : m;
    }
    const h = l.flush(o);
    return vv(h)
      ? ((this.asyncResult = !0), h.then((m) => (this.flushRemux(a, m, e), a)))
      : (this.flushRemux(a, h, e), this.asyncResult ? Promise.resolve(a) : a);
  }
  flushRemux(e, t, s) {
    const { audioTrack: r, videoTrack: i, id3Track: a, textTrack: o } = t,
      { accurateTimeOffset: l, timeOffset: c } = this.currentTransmuxState;
    this.logger.log(
      `[transmuxer.ts]: Flushed ${this.id} sn: ${s.sn}${
        s.part > -1 ? " part: " + s.part : ""
      } of ${this.id === lt.MAIN ? "level" : "track"} ${s.level}`
    );
    const h = this.remuxer.remux(r, i, a, o, c, l, !0, this.id);
    e.push({ remuxResult: h, chunkMeta: s }), (s.transmuxing.executeEnd = gl());
  }
  resetInitialTimestamp(e) {
    const { demuxer: t, remuxer: s } = this;
    !t || !s || (t.resetTimeStamp(e), s.resetTimeStamp(e));
  }
  resetContiguity() {
    const { demuxer: e, remuxer: t } = this;
    !e || !t || (e.resetContiguity(), t.resetNextTimestamp());
  }
  resetInitSegment(e, t, s, r, i) {
    const { demuxer: a, remuxer: o } = this;
    !a ||
      !o ||
      (a.resetInitSegment(e, t, s, r), o.resetInitSegment(e, t, s, i));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), (this.demuxer = void 0)),
      this.remuxer && (this.remuxer.destroy(), (this.remuxer = void 0));
  }
  transmux(e, t, s, r, i) {
    let a;
    return (
      t && t.method === "SAMPLE-AES"
        ? (a = this.transmuxSampleAes(e, t, s, r, i))
        : (a = this.transmuxUnencrypted(e, s, r, i)),
      a
    );
  }
  transmuxUnencrypted(e, t, s, r) {
    const {
      audioTrack: i,
      videoTrack: a,
      id3Track: o,
      textTrack: l,
    } = this.demuxer.demux(e, t, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(i, a, o, l, t, s, !1, this.id),
      chunkMeta: r,
    };
  }
  transmuxSampleAes(e, t, s, r, i) {
    return this.demuxer
      .demuxSampleAes(e, t, s)
      .then((a) => ({
        remuxResult: this.remuxer.remux(
          a.audioTrack,
          a.videoTrack,
          a.id3Track,
          a.textTrack,
          s,
          r,
          !1,
          this.id
        ),
        chunkMeta: i,
      }));
  }
  configureTransmuxer(e) {
    const { config: t, observer: s, typeSupported: r } = this;
    let i;
    for (let m = 0, p = ix.length; m < p; m++) {
      var a;
      if ((a = ix[m].demux) != null && a.probe(e, this.logger)) {
        i = ix[m];
        break;
      }
    }
    if (!i) return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer,
      l = this.remuxer,
      c = i.remux,
      h = i.demux;
    (!l || !(l instanceof c)) && (this.remuxer = new c(s, t, r, this.logger)),
      (!o || !(o instanceof h)) &&
        ((this.demuxer = new h(s, t, r, this.logger)), (this.probe = h.probe));
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new KP(this.config)), e;
  }
}
function xCe(n, e) {
  let t = null;
  return (
    n.byteLength > 0 &&
      e?.key != null &&
      e.iv !== null &&
      e.method != null &&
      (t = e),
    t
  );
}
const TA = (n) => ({ remuxResult: {}, chunkMeta: n });
function vv(n) {
  return "then" in n && n.then instanceof Function;
}
class wCe {
  constructor(e, t, s, r, i) {
    (this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this.initSegmentData = void 0),
      (this.duration = void 0),
      (this.defaultInitPts = void 0),
      (this.audioCodec = e),
      (this.videoCodec = t),
      (this.initSegmentData = s),
      (this.duration = r),
      (this.defaultInitPts = i || null);
  }
}
class ECe {
  constructor(e, t, s, r, i, a) {
    (this.discontinuity = void 0),
      (this.contiguous = void 0),
      (this.accurateTimeOffset = void 0),
      (this.trackSwitch = void 0),
      (this.timeOffset = void 0),
      (this.initSegmentChange = void 0),
      (this.discontinuity = e),
      (this.contiguous = t),
      (this.accurateTimeOffset = s),
      (this.trackSwitch = r),
      (this.timeOffset = i),
      (this.initSegmentChange = a);
  }
}
let a5 = 0;
class tX {
  constructor(e, t, s, r) {
    (this.error = null),
      (this.hls = void 0),
      (this.id = void 0),
      (this.instanceNo = a5++),
      (this.observer = void 0),
      (this.frag = null),
      (this.part = null),
      (this.useWorker = void 0),
      (this.workerContext = null),
      (this.transmuxer = null),
      (this.onTransmuxComplete = void 0),
      (this.onFlush = void 0),
      (this.onWorkerMessage = (l) => {
        const c = l.data,
          h = this.hls;
        if (
          !(!h || !(c != null && c.event) || c.instanceNo !== this.instanceNo)
        )
          switch (c.event) {
            case "init": {
              var m;
              const p = (m = this.workerContext) == null ? void 0 : m.objectURL;
              p && self.URL.revokeObjectURL(p);
              break;
            }
            case "transmuxComplete": {
              this.handleTransmuxComplete(c.data);
              break;
            }
            case "flush": {
              this.onFlush(c.data);
              break;
            }
            case "workerLog": {
              h.logger[c.data.logType] &&
                h.logger[c.data.logType](c.data.message);
              break;
            }
            default: {
              (c.data = c.data || {}),
                (c.data.frag = this.frag),
                (c.data.part = this.part),
                (c.data.id = this.id),
                h.trigger(c.event, c.data);
              break;
            }
          }
      }),
      (this.onWorkerError = (l) => {
        if (!this.hls) return;
        const c = new Error(`${l.message}  (${l.filename}:${l.lineno})`);
        (this.hls.config.enableWorker = !1),
          this.hls.logger.warn(
            `Error in "${this.id}" Web Worker, fallback to inline`
          ),
          this.hls.trigger($.ERROR, {
            type: gt.OTHER_ERROR,
            details: we.INTERNAL_EXCEPTION,
            fatal: !1,
            event: "demuxerWorker",
            error: c,
          });
      });
    const i = e.config;
    (this.hls = e),
      (this.id = t),
      (this.useWorker = !!i.enableWorker),
      (this.onTransmuxComplete = s),
      (this.onFlush = r);
    const a = (l, c) => {
      (c = c || {}),
        (c.frag = this.frag || void 0),
        l === $.ERROR &&
          ((c = c),
          (c.parent = this.id),
          (c.part = this.part),
          (this.error = c.error)),
        this.hls.trigger(l, c);
    };
    (this.observer = new ZP()),
      this.observer.on($.FRAG_DECRYPTED, a),
      this.observer.on($.ERROR, a);
    const o = EB(i.preferManagedMediaSource);
    if (this.useWorker && typeof Worker < "u") {
      const l = this.hls.logger;
      if (i.workerPath || kke()) {
        try {
          i.workerPath
            ? (l.log(`loading Web Worker ${i.workerPath} for "${t}"`),
              (this.workerContext = Ike(i.workerPath)))
            : (l.log(`injecting Web Worker for "${t}"`),
              (this.workerContext = Cke()));
          const { worker: h } = this.workerContext;
          h.addEventListener("message", this.onWorkerMessage),
            h.addEventListener("error", this.onWorkerError),
            h.postMessage({
              instanceNo: this.instanceNo,
              cmd: "init",
              typeSupported: o,
              id: t,
              config: Wn(i),
            });
        } catch (h) {
          l.warn(`Error setting up "${t}" Web Worker, fallback to inline`, h),
            this.terminateWorker(),
            (this.error = null),
            (this.transmuxer = new i5(this.observer, o, i, "", t, e.logger));
        }
        return;
      }
    }
    this.transmuxer = new i5(this.observer, o, i, "", t, e.logger);
  }
  reset() {
    if (((this.frag = null), (this.part = null), this.workerContext)) {
      const e = this.instanceNo;
      this.instanceNo = a5++;
      const t = this.hls.config,
        s = EB(t.preferManagedMediaSource);
      this.workerContext.worker.postMessage({
        instanceNo: this.instanceNo,
        cmd: "reset",
        resetNo: e,
        typeSupported: s,
        id: this.id,
        config: Wn(t),
      });
    }
  }
  terminateWorker() {
    if (this.workerContext) {
      const { worker: e } = this.workerContext;
      (this.workerContext = null),
        e.removeEventListener("message", this.onWorkerMessage),
        e.removeEventListener("error", this.onWorkerError),
        Lke(this.hls.config.workerPath);
    }
  }
  destroy() {
    if (this.workerContext)
      this.terminateWorker(),
        (this.onWorkerMessage = this.onWorkerError = null);
    else {
      const t = this.transmuxer;
      t && (t.destroy(), (this.transmuxer = null));
    }
    const e = this.observer;
    e && e.removeAllListeners(),
      (this.frag = null),
      (this.part = null),
      (this.observer = null),
      (this.hls = null);
  }
  push(e, t, s, r, i, a, o, l, c, h) {
    var m, p;
    c.transmuxing.start = self.performance.now();
    const { instanceNo: g, transmuxer: y } = this,
      b = a ? a.start : i.start,
      w = i.decryptdata,
      S = this.frag,
      A = !(S && i.cc === S.cc),
      _ = !(S && c.level === S.level),
      R = S ? c.sn - S.sn : -1,
      C = this.part ? c.part - this.part.index : -1,
      D = R === 0 && c.id > 1 && c.id === S?.stats.chunkCount,
      L = !_ && (R === 1 || (R === 0 && (C === 1 || (D && C <= 0)))),
      P = self.performance.now();
    (_ || R || i.stats.parsing.start === 0) && (i.stats.parsing.start = P),
      a && (C || !L) && (a.stats.parsing.start = P);
    const V = !(
        S &&
        ((m = i.initSegment) == null ? void 0 : m.url) ===
          ((p = S.initSegment) == null ? void 0 : p.url)
      ),
      N = new ECe(A, L, l, _, b, V);
    if (!L || A || V) {
      this.hls.logger
        .log(`[transmuxer-interface]: Starting new transmux session for ${
        i.type
      } sn: ${c.sn}${c.part > -1 ? " part: " + c.part : ""} ${
        this.id === lt.MAIN ? "level" : "track"
      }: ${c.level} id: ${c.id}
        discontinuity: ${A}
        trackSwitch: ${_}
        contiguous: ${L}
        accurateTimeOffset: ${l}
        timeOffset: ${b}
        initSegmentChange: ${V}`);
      const W = new wCe(s, r, t, o, h);
      this.configureTransmuxer(W);
    }
    if (((this.frag = i), (this.part = a), this.workerContext))
      this.workerContext.worker.postMessage(
        {
          instanceNo: g,
          cmd: "demux",
          data: e,
          decryptdata: w,
          chunkMeta: c,
          state: N,
        },
        e instanceof ArrayBuffer ? [e] : []
      );
    else if (y) {
      const W = y.push(e, w, c, N);
      vv(W)
        ? W.then((H) => {
            this.handleTransmuxComplete(H);
          }).catch((H) => {
            this.transmuxerError(H, c, "transmuxer-interface push error");
          })
        : this.handleTransmuxComplete(W);
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const { instanceNo: t, transmuxer: s } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: t,
        cmd: "flush",
        chunkMeta: e,
      });
    else if (s) {
      const r = s.flush(e);
      vv(r)
        ? r
            .then((i) => {
              this.handleFlushResult(i, e);
            })
            .catch((i) => {
              this.transmuxerError(i, e, "transmuxer-interface flush error");
            })
        : this.handleFlushResult(r, e);
    }
  }
  transmuxerError(e, t, s) {
    this.hls &&
      ((this.error = e),
      this.hls.trigger($.ERROR, {
        type: gt.MEDIA_ERROR,
        details: we.FRAG_PARSING_ERROR,
        chunkMeta: t,
        frag: this.frag || void 0,
        part: this.part || void 0,
        fatal: !1,
        error: e,
        err: e,
        reason: s,
      }));
  }
  handleFlushResult(e, t) {
    e.forEach((s) => {
      this.handleTransmuxComplete(s);
    }),
      this.onFlush(t);
  }
  configureTransmuxer(e) {
    const { instanceNo: t, transmuxer: s } = this;
    this.workerContext
      ? this.workerContext.worker.postMessage({
          instanceNo: t,
          cmd: "configure",
          config: e,
        })
      : s && s.configure(e);
  }
  handleTransmuxComplete(e) {
    (e.chunkMeta.transmuxing.end = self.performance.now()),
      this.onTransmuxComplete(e);
  }
}
const o5 = 100;
class SCe extends QP {
  constructor(e, t, s) {
    super(e, t, s, "audio-stream-controller", lt.AUDIO),
      (this.mainAnchor = null),
      (this.mainFragLoading = null),
      (this.audioOnly = !1),
      (this.bufferedTrack = null),
      (this.switchingTrack = null),
      (this.trackId = -1),
      (this.waitingData = null),
      (this.mainDetails = null),
      (this.flushing = !1),
      (this.bufferFlushed = !1),
      (this.cachedTrackLoadedData = null),
      this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
  }
  resetItem() {
    this.mainDetails =
      this.mainAnchor =
      this.mainFragLoading =
      this.bufferedTrack =
      this.switchingTrack =
      this.waitingData =
      this.cachedTrackLoadedData =
        null;
  }
  registerListeners() {
    super.registerListeners();
    const { hls: e } = this;
    e.on($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on($.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
      e.on($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.on($.BUFFER_RESET, this.onBufferReset, this),
      e.on($.BUFFER_CREATED, this.onBufferCreated, this),
      e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on($.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.on($.FRAG_LOADING, this.onFragLoading, this),
      e.on($.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e &&
      (super.unregisterListeners(),
      e.off($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off($.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
      e.off($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.off($.BUFFER_RESET, this.onBufferReset, this),
      e.off($.BUFFER_CREATED, this.onBufferCreated, this),
      e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off($.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.off($.FRAG_LOADING, this.onFragLoading, this),
      e.off($.FRAG_BUFFERED, this.onFragBuffered, this));
  }
  onInitPtsFound(e, { frag: t, id: s, initPTS: r, timescale: i }) {
    if (s === lt.MAIN) {
      const a = t.cc,
        o = this.fragCurrent;
      if (
        ((this.initPTS[a] = { baseTime: r, timescale: i }),
        this.log(`InitPTS for cc: ${a} found from main: ${r}/${i}`),
        (this.mainAnchor = t),
        this.state === Me.WAITING_INIT_PTS)
      ) {
        const l = this.waitingData;
        ((!l && !this.loadingParts) || (l && l.frag.cc !== a)) &&
          this.syncWithAnchor(t, l?.frag);
      } else
        !this.hls.hasEnoughToStart && o && o.cc !== a
          ? (o.abortRequests(), this.syncWithAnchor(t, o))
          : this.state === Me.IDLE && this.tick();
    }
  }
  getLoadPosition() {
    return !this.startFragRequested && this.nextLoadPosition >= 0
      ? this.nextLoadPosition
      : super.getLoadPosition();
  }
  syncWithAnchor(e, t) {
    var s;
    const r = ((s = this.mainFragLoading) == null ? void 0 : s.frag) || null;
    if (t && r?.cc === t.cc) return;
    const i = (r || e).cc,
      a = this.getLevelDetails(),
      o = this.getLoadPosition(),
      l = wY(a, i, o);
    l &&
      (this.log(`Syncing with main frag at ${l.start} cc ${l.cc}`),
      (this.startFragRequested = !1),
      (this.nextLoadPosition = l.start),
      this.resetLoadingState(),
      this.state === Me.IDLE && this.doTickIdle());
  }
  startLoad(e, t) {
    if (!this.levels) {
      (this.startPosition = e), (this.state = Me.STOPPED);
      return;
    }
    const s = this.lastCurrentTime;
    this.stopLoad(),
      this.setInterval(o5),
      s > 0 && e === -1
        ? (this.log(
            `Override startPosition with lastCurrentTime @${s.toFixed(3)}`
          ),
          (e = s),
          (this.state = Me.IDLE))
        : (this.state = Me.WAITING_TRACK),
      (this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset),
      (this.startPosition = t ? -1 : e),
      this.tick();
  }
  doTick() {
    switch (this.state) {
      case Me.IDLE:
        this.doTickIdle();
        break;
      case Me.WAITING_TRACK: {
        const { levels: t, trackId: s } = this,
          r = t?.[s],
          i = r?.details;
        if (i && !this.waitForLive(r)) {
          if (this.waitForCdnTuneIn(i)) break;
          this.state = Me.WAITING_INIT_PTS;
        }
        break;
      }
      case Me.FRAG_LOADING_WAITING_RETRY: {
        var e;
        const t = performance.now(),
          s = this.retryDate;
        if (!s || t >= s || ((e = this.media) != null && e.seeking)) {
          const { levels: r, trackId: i } = this;
          this.log("RetryDate reached, switch back to IDLE state"),
            this.resetStartWhenNotLoaded(r?.[i] || null),
            (this.state = Me.IDLE);
        }
        break;
      }
      case Me.WAITING_INIT_PTS: {
        const t = this.waitingData;
        if (t) {
          const { frag: s, part: r, cache: i, complete: a } = t,
            o = this.mainAnchor;
          if (this.initPTS[s.cc] !== void 0) {
            (this.waitingData = null), (this.state = Me.FRAG_LOADING);
            const l = i.flush().buffer,
              c = { frag: s, part: r, payload: l, networkDetails: null };
            this._handleFragmentLoadProgress(c),
              a && super._handleFragmentLoadComplete(c);
          } else o && o.cc !== t.frag.cc && this.syncWithAnchor(o, t.frag);
        } else this.state = Me.IDLE;
      }
    }
    this.onTickEnd();
  }
  resetLoadingState() {
    const e = this.waitingData;
    e &&
      (this.fragmentTracker.removeFragment(e.frag), (this.waitingData = null)),
      super.resetLoadingState();
  }
  onTickEnd() {
    const { media: e } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    var e;
    const { hls: t, levels: s, media: r, trackId: i } = this,
      a = t.config;
    if (
      !this.buffering ||
      (!r &&
        !this.primaryPrefetch &&
        (this.startFragRequested || !a.startFragPrefetch)) ||
      !(s != null && s[i])
    )
      return;
    const o = s[i],
      l = o.details;
    if (!l || this.waitForLive(o) || this.waitForCdnTuneIn(l)) {
      (this.state = Me.WAITING_TRACK), (this.startFragRequested = !1);
      return;
    }
    const c = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed &&
      c &&
      ((this.bufferFlushed = !1),
      this.afterBufferFlushed(c, On.AUDIO, lt.AUDIO));
    const h = this.getFwdBufferInfo(c, lt.AUDIO);
    if (h === null) return;
    if (!this.switchingTrack && this._streamEnded(h, l)) {
      t.trigger($.BUFFER_EOS, { type: "audio" }), (this.state = Me.ENDED);
      return;
    }
    const m = h.len,
      p = t.maxBufferLength,
      g = l.fragments,
      y = g[0].start,
      b = this.getLoadPosition(),
      w = this.flushing ? b : h.end;
    if (this.switchingTrack && r) {
      const _ = b;
      l.PTSKnown &&
        _ < y &&
        (h.end > y || h.nextStart) &&
        (this.log(
          "Alt audio track ahead of main track, seek to start of alt audio track"
        ),
        (r.currentTime = y + 0.05));
    }
    if (m >= p && !this.switchingTrack && w < g[g.length - 1].start) return;
    let S = this.getNextFragment(w, l);
    if (
      (S &&
        this.isLoopLoading(S, w) &&
        (S = this.getNextFragmentLoopLoading(S, l, h, lt.MAIN, p)),
      !S)
    ) {
      this.bufferFlushed = !0;
      return;
    }
    let A = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
    if (
      !this.audioOnly &&
      this.startFragRequested &&
      A &&
      Os(S) &&
      !S.endList &&
      (!l.live || (!this.loadingParts && w < this.hls.liveSyncPosition)) &&
      (this.fragmentTracker.getState(A) === qs.OK &&
        (this.mainFragLoading = A = null),
      A && Os(A))
    ) {
      if (S.start > A.end) {
        const R = this.fragmentTracker.getFragAtPos(w, lt.MAIN);
        R &&
          R.end > A.end &&
          ((A = R),
          (this.mainFragLoading = { frag: R, targetBufferTime: null }));
      }
      if (S.start > A.end) return;
    }
    this.loadFragment(S, o, w);
  }
  onMediaDetaching(e, t) {
    (this.bufferFlushed = this.flushing = !1), super.onMediaDetaching(e, t);
  }
  onAudioTracksUpdated(e, { audioTracks: t }) {
    this.resetTransmuxer(), (this.levels = t.map((s) => new fv(s)));
  }
  onAudioTrackSwitching(e, t) {
    const s = !!t.url;
    this.trackId = t.id;
    const { fragCurrent: r } = this;
    r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)),
      this.resetLoadingState(),
      s
        ? ((this.switchingTrack = t),
          this.flushAudioIfNeeded(t),
          this.state !== Me.STOPPED &&
            (this.setInterval(o5), (this.state = Me.IDLE), this.tick()))
        : (this.resetTransmuxer(),
          (this.switchingTrack = null),
          (this.bufferedTrack = t),
          this.clearInterval());
  }
  onManifestLoading() {
    super.onManifestLoading(),
      (this.bufferFlushed = this.flushing = this.audioOnly = !1),
      this.resetItem(),
      (this.trackId = -1);
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
    const s = this.cachedTrackLoadedData;
    s &&
      ((this.cachedTrackLoadedData = null),
      this.onAudioTrackLoaded($.AUDIO_TRACK_LOADED, s));
  }
  onAudioTrackLoaded(e, t) {
    var s;
    const { levels: r } = this,
      { details: i, id: a, groupId: o, track: l } = t;
    if (!r) {
      this.warn(
        `Audio tracks reset while loading track ${a} "${l.name}" of "${o}"`
      );
      return;
    }
    const c = this.mainDetails;
    if (!c || i.endCC > c.endCC || c.expired) {
      (this.cachedTrackLoadedData = t),
        this.state !== Me.STOPPED && (this.state = Me.WAITING_TRACK);
      return;
    }
    (this.cachedTrackLoadedData = null),
      this.log(
        `Audio track ${a} "${l.name}" of "${o}" loaded [${i.startSN},${
          i.endSN
        }]${
          i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ""
        },duration:${i.totalduration}`
      );
    const h = r[a];
    let m = 0;
    if (i.live || ((s = h.details) != null && s.live)) {
      if ((this.checkLiveUpdate(i), i.deltaUpdateFailed)) return;
      if (h.details) {
        var p;
        m = this.alignPlaylists(
          i,
          h.details,
          (p = this.levelLastLoaded) == null ? void 0 : p.details
        );
      }
      i.alignedSliding ||
        (NY(i, c), i.alignedSliding || Jw(i, c), (m = i.fragmentStart));
    }
    (h.details = i),
      (this.levelLastLoaded = h),
      this.startFragRequested || this.setStartPosition(c, m),
      this.hls.trigger($.AUDIO_TRACK_UPDATED, {
        details: i,
        id: a,
        groupId: t.groupId,
      }),
      this.state === Me.WAITING_TRACK &&
        !this.waitForCdnTuneIn(i) &&
        (this.state = Me.IDLE),
      this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const s = e.frag,
      { part: r, payload: i } = e,
      { config: a, trackId: o, levels: l } = this;
    if (!l) {
      this.warn(
        `Audio tracks were reset while fragment load was in progress. Fragment ${s.sn} of level ${s.level} will not be buffered`
      );
      return;
    }
    const c = l[o];
    if (!c) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const h = c.details;
    if (!h) {
      this.warn("Audio track details undefined on fragment load progress"),
        this.removeUnbufferedFrags(s.start);
      return;
    }
    const m = a.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
    let p = this.transmuxer;
    p ||
      (p = this.transmuxer =
        new tX(
          this.hls,
          lt.AUDIO,
          this._handleTransmuxComplete.bind(this),
          this._handleTransmuxerFlush.bind(this)
        ));
    const g = this.initPTS[s.cc],
      y = (t = s.initSegment) == null ? void 0 : t.data;
    if (g !== void 0) {
      const w = r ? r.index : -1,
        S = w !== -1,
        A = new YP(s.level, s.sn, s.stats.chunkCount, i.byteLength, w, S);
      p.push(i, y, m, "", s, r, h.totalduration, !1, A, g);
    } else {
      this.log(
        `Unknown video PTS for cc ${s.cc}, waiting for video PTS before demuxing audio frag ${s.sn} of [${h.startSN} ,${h.endSN}],track ${o}`
      );
      const { cache: b } = (this.waitingData = this.waitingData || {
        frag: s,
        part: r,
        cache: new OY(),
        complete: !1,
      });
      b.push(new Uint8Array(i)),
        this.state !== Me.STOPPED && (this.state = Me.WAITING_INIT_PTS);
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = null;
  }
  onBufferCreated(e, t) {
    this.bufferFlushed = this.flushing = !1;
    const s = t.tracks.audio;
    s && (this.mediaBuffer = s.buffer || null);
  }
  onFragLoading(e, t) {
    !this.audioOnly &&
      t.frag.type === lt.MAIN &&
      Os(t.frag) &&
      ((this.mainFragLoading = t), this.state === Me.IDLE && this.tick());
  }
  onFragBuffered(e, t) {
    const { frag: s, part: r } = t;
    if (s.type !== lt.AUDIO) {
      !this.audioOnly &&
        s.type === lt.MAIN &&
        !s.elementaryStreams.video &&
        !s.elementaryStreams.audiovideo &&
        ((this.audioOnly = !0), (this.mainFragLoading = null));
      return;
    }
    if (this.fragContextChanged(s)) {
      this.warn(
        `Fragment ${s.sn}${r ? " p: " + r.index : ""} of level ${
          s.level
        } finished buffering, but was aborted. state: ${
          this.state
        }, audioSwitch: ${
          this.switchingTrack ? this.switchingTrack.name : "false"
        }`
      );
      return;
    }
    if (Os(s)) {
      this.fragPrevious = s;
      const i = this.switchingTrack;
      i &&
        ((this.bufferedTrack = i),
        (this.switchingTrack = null),
        this.hls.trigger($.AUDIO_TRACK_SWITCHED, In({}, i)));
    }
    this.fragBufferedComplete(s, r), this.media && this.tick();
  }
  onError(e, t) {
    var s;
    if (t.fatal) {
      this.state = Me.ERROR;
      return;
    }
    switch (t.details) {
      case we.FRAG_GAP:
      case we.FRAG_PARSING_ERROR:
      case we.FRAG_DECRYPT_ERROR:
      case we.FRAG_LOAD_ERROR:
      case we.FRAG_LOAD_TIMEOUT:
      case we.KEY_LOAD_ERROR:
      case we.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(lt.AUDIO, t);
        break;
      case we.AUDIO_TRACK_LOAD_ERROR:
      case we.AUDIO_TRACK_LOAD_TIMEOUT:
      case we.LEVEL_PARSING_ERROR:
        !t.levelRetry &&
          this.state === Me.WAITING_TRACK &&
          ((s = t.context) == null ? void 0 : s.type) === en.AUDIO_TRACK &&
          (this.state = Me.IDLE);
        break;
      case we.BUFFER_ADD_CODEC_ERROR:
      case we.BUFFER_APPEND_ERROR:
        if (t.parent !== "audio") return;
        this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();
        break;
      case we.BUFFER_FULL_ERROR:
        if (t.parent !== "audio") return;
        this.reduceLengthAndFlushBuffer(t) &&
          ((this.bufferedTrack = null),
          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case we.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onBufferFlushing(e, { type: t }) {
    t !== On.VIDEO && (this.flushing = !0);
  }
  onBufferFlushed(e, { type: t }) {
    if (t !== On.VIDEO) {
      (this.flushing = !1),
        (this.bufferFlushed = !0),
        this.state === Me.ENDED && (this.state = Me.IDLE);
      const s = this.mediaBuffer || this.media;
      s && (this.afterBufferFlushed(s, t, lt.AUDIO), this.tick());
    }
  }
  _handleTransmuxComplete(e) {
    var t;
    const s = "audio",
      { hls: r } = this,
      { remuxResult: i, chunkMeta: a } = e,
      o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const { frag: l, part: c, level: h } = o,
      { details: m } = h,
      { audio: p, text: g, id3: y, initSegment: b } = i;
    if (this.fragContextChanged(l) || !m) {
      this.fragmentTracker.removeFragment(l);
      return;
    }
    if (
      ((this.state = Me.PARSING),
      this.switchingTrack && p && this.completeAudioSwitch(this.switchingTrack),
      b != null && b.tracks)
    ) {
      const w = l.initSegment || l;
      this._bufferInitSegment(h, b.tracks, w, a),
        r.trigger($.FRAG_PARSING_INIT_SEGMENT, {
          frag: w,
          id: s,
          tracks: b.tracks,
        });
    }
    if (p) {
      const { startPTS: w, endPTS: S, startDTS: A, endDTS: _ } = p;
      c &&
        (c.elementaryStreams[On.AUDIO] = {
          startPTS: w,
          endPTS: S,
          startDTS: A,
          endDTS: _,
        }),
        l.setElementaryStreamInfo(On.AUDIO, w, S, A, _),
        this.bufferFragmentData(p, l, c, a);
    }
    if (y != null && (t = y.samples) != null && t.length) {
      const w = Tn({ id: s, frag: l, details: m }, y);
      r.trigger($.FRAG_PARSING_METADATA, w);
    }
    if (g) {
      const w = Tn({ id: s, frag: l, details: m }, g);
      r.trigger($.FRAG_PARSING_USERDATA, w);
    }
  }
  _bufferInitSegment(e, t, s, r) {
    if (
      this.state !== Me.PARSING ||
      (t.video && delete t.video, t.audiovideo && delete t.audiovideo, !t.audio)
    )
      return;
    const i = t.audio;
    i.id = lt.AUDIO;
    const a = e.audioCodec;
    this.log(
      `Init audio buffer, container:${i.container}, codecs[level/parsed]=[${a}/${i.codec}]`
    ),
      a && a.split(",").length === 1 && (i.levelCodec = a),
      this.hls.trigger($.BUFFER_CODECS, t);
    const o = i.initSegment;
    if (o != null && o.byteLength) {
      const l = {
        type: "audio",
        frag: s,
        part: null,
        chunkMeta: r,
        parent: s.type,
        data: o,
      };
      this.hls.trigger($.BUFFER_APPENDING, l);
    }
    this.tickImmediate();
  }
  loadFragment(e, t, s) {
    const r = this.fragmentTracker.getState(e);
    if (this.switchingTrack || r === qs.NOT_LOADED || r === qs.PARTIAL) {
      var i;
      if (!Os(e)) this._loadInitSegment(e, t);
      else if ((i = t.details) != null && i.live && !this.initPTS[e.cc]) {
        this.log(
          `Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`
        ),
          (this.state = Me.WAITING_INIT_PTS);
        const a = this.mainDetails;
        a && a.fragmentStart !== t.details.fragmentStart && Jw(t.details, a);
      } else super.loadFragment(e, t, s);
    } else this.clearTrackerIfNeeded(e);
  }
  flushAudioIfNeeded(e) {
    if (this.media && this.bufferedTrack) {
      const {
        name: t,
        lang: s,
        assocLang: r,
        characteristics: i,
        audioCodec: a,
        channels: o,
      } = this.bufferedTrack;
      qu(
        {
          name: t,
          lang: s,
          assocLang: r,
          characteristics: i,
          audioCodec: a,
          channels: o,
        },
        e,
        Du
      ) ||
        (Yw(e.url, this.hls)
          ? (this.log("Switching audio track : flushing all audio"),
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"),
            (this.bufferedTrack = null))
          : (this.bufferedTrack = e));
    }
  }
  completeAudioSwitch(e) {
    const { hls: t } = this;
    this.flushAudioIfNeeded(e),
      (this.bufferedTrack = e),
      (this.switchingTrack = null),
      t.trigger($.AUDIO_TRACK_SWITCHED, In({}, e));
  }
}
class iM extends za {
  constructor(e, t) {
    super(t, e.logger),
      (this.hls = void 0),
      (this.canLoad = !1),
      (this.timer = -1),
      (this.hls = e);
  }
  destroy() {
    this.clearTimer(), (this.hls = this.log = this.warn = null);
  }
  clearTimer() {
    this.timer !== -1 && (self.clearTimeout(this.timer), (this.timer = -1));
  }
  startLoad() {
    (this.canLoad = !0), this.loadPlaylist();
  }
  stopLoad() {
    (this.canLoad = !1), this.clearTimer();
  }
  switchParams(e, t, s) {
    const r = t?.renditionReports;
    if (r) {
      let i = -1;
      for (let a = 0; a < r.length; a++) {
        const o = r[a];
        let l;
        try {
          l = new self.URL(o.URI, t.url).href;
        } catch (c) {
          this.warn(`Could not construct new URL for Rendition Report: ${c}`),
            (l = o.URI || "");
        }
        if (l === e) {
          i = a;
          break;
        } else l === e.substring(0, l.length) && (i = a);
      }
      if (i !== -1) {
        const a = r[i],
          o = parseInt(a["LAST-MSN"]) || t?.lastPartSn;
        let l = parseInt(a["LAST-PART"]) || t?.lastPartIndex;
        if (this.hls.config.lowLatencyMode) {
          const h = Math.min(t.age - t.partTarget, t.targetduration);
          l >= 0 && h > t.partTarget && (l += 1);
        }
        const c = s && SB(s);
        return new TB(o, l >= 0 ? l : void 0, c);
      }
    }
  }
  loadPlaylist(e) {
    this.clearTimer();
  }
  loadingPlaylist(e, t) {
    this.clearTimer();
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  getUrlWithDirectives(e, t) {
    if (t)
      try {
        return t.addDirectives(e);
      } catch (s) {
        this.warn(
          `Could not construct new URL with HLS Delivery Directives: ${s}`
        );
      }
    return e;
  }
  playlistLoaded(e, t, s) {
    const { details: r, stats: i } = t,
      a = self.performance.now(),
      o = i.loading.first ? Math.max(0, a - i.loading.first) : 0;
    r.advancedDateTime = Date.now() - o;
    const l = this.hls.config.timelineOffset;
    if (l !== r.appliedTimelineOffset) {
      const h = Math.max(l || 0, 0);
      (r.appliedTimelineOffset = h),
        r.fragments.forEach((m) => {
          m.start = m.playlistOffset + h;
        });
    }
    if (r.live || (s != null && s.live)) {
      const h = "levelInfo" in t ? t.levelInfo : t.track;
      if ((r.reloaded(s), s && r.fragments.length > 0)) {
        yke(s, r);
        const A = r.playlistParsingError;
        if (A) {
          this.warn(A);
          const _ = this.hls;
          if (!_.config.ignorePlaylistParsingErrors) {
            var c;
            const { networkDetails: R } = t;
            _.trigger($.ERROR, {
              type: gt.NETWORK_ERROR,
              details: we.LEVEL_PARSING_ERROR,
              fatal: !1,
              url: r.url,
              error: A,
              reason: A.message,
              level: t.level || void 0,
              parent: (c = r.fragments[0]) == null ? void 0 : c.type,
              networkDetails: R,
              stats: i,
            });
            return;
          }
          r.playlistParsingError = null;
        }
      }
      r.requestScheduled === -1 && (r.requestScheduled = i.loading.start);
      const m = this.hls.mainForwardBufferInfo,
        p = m ? m.end - m.len : 0,
        g = (r.edge - p) * 1e3,
        y = IY(r, g);
      if (
        (r.requestScheduled + y < a
          ? (r.requestScheduled = a)
          : (r.requestScheduled += y),
        this.log(
          `live playlist ${e} ${
            r.advanced
              ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex
              : r.updated
              ? "UPDATED"
              : "MISSED"
          }`
        ),
        !this.canLoad || !r.live)
      )
        return;
      let b, w, S;
      if (r.canBlockReload && r.endSN && r.advanced) {
        const A = this.hls.config.lowLatencyMode,
          _ = r.lastPartSn,
          R = r.endSN,
          C = r.lastPartIndex,
          D = C !== -1,
          L = _ === R;
        D
          ? L
            ? ((w = R + 1), (S = A ? 0 : C))
            : ((w = _), (S = A ? C + 1 : r.maxPartIndex))
          : (w = R + 1);
        const P = r.age,
          V = P + r.ageHeader;
        let N = Math.min(V - r.partTarget, r.targetduration * 1.5);
        if (N > 0) {
          if (V > r.targetduration * 3)
            this.log(
              `Playlist last advanced ${P.toFixed(
                2
              )}s ago. Omitting segment and part directives.`
            ),
              (w = void 0),
              (S = void 0);
          else if (s != null && s.tuneInGoal && V - r.partTarget > s.tuneInGoal)
            this.warn(
              `CDN Tune-in goal increased from: ${s.tuneInGoal} to: ${N} with playlist age: ${r.age}`
            ),
              (N = 0);
          else {
            const W = Math.floor(N / r.targetduration);
            if (((w += W), S !== void 0)) {
              const H = Math.round((N % r.targetduration) / r.partTarget);
              S += H;
            }
            this.log(
              `CDN Tune-in age: ${r.ageHeader}s last advanced ${P.toFixed(
                2
              )}s goal: ${N} skip sn ${W} to part ${S}`
            );
          }
          r.tuneInGoal = N;
        }
        if (
          ((b = this.getDeliveryDirectives(r, t.deliveryDirectives, w, S)),
          A || !L)
        ) {
          (r.requestScheduled = a), this.loadingPlaylist(h, b);
          return;
        }
      } else
        (r.canBlockReload || r.canSkipUntil) &&
          (b = this.getDeliveryDirectives(r, t.deliveryDirectives, w, S));
      b &&
        w !== void 0 &&
        r.canBlockReload &&
        (r.requestScheduled = i.loading.first + Math.max(y - o * 2, y / 2)),
        this.scheduleLoading(h, b, r);
    } else this.clearTimer();
  }
  scheduleLoading(e, t, s) {
    const r = s || e.details;
    if (!r) {
      this.loadingPlaylist(e, t);
      return;
    }
    const i = self.performance.now(),
      a = r.requestScheduled;
    if (i >= a) {
      this.loadingPlaylist(e, t);
      return;
    }
    const o = a - i;
    this.log(
      `reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(
        o
      )} ms`
    ),
      this.clearTimer(),
      (this.timer = self.setTimeout(() => this.loadingPlaylist(e, t), o));
  }
  getDeliveryDirectives(e, t, s, r) {
    let i = SB(e);
    return (
      t != null &&
        t.skip &&
        e.deltaUpdateFailed &&
        ((s = t.msn), (r = t.part), (i = nx.No)),
      new TB(s, r, i)
    );
  }
  checkRetry(e) {
    const t = e.details,
      s = Xw(e),
      r = e.errorAction,
      { action: i, retryCount: a = 0, retryConfig: o } = r || {},
      l =
        !!r &&
        !!o &&
        (i === kr.RetryRequest ||
          (!r.resolved && i === kr.SendAlternateToPenaltyBox));
    if (l) {
      var c;
      if (a >= o.maxNumRetry) return !1;
      if (s && (c = e.context) != null && c.deliveryDirectives)
        this.warn(
          `Retrying playlist loading ${a + 1}/${
            o.maxNumRetry
          } after "${t}" without delivery-directives`
        ),
          this.loadPlaylist();
      else {
        const h = WP(o, a);
        this.clearTimer(),
          (this.timer = self.setTimeout(() => this.loadPlaylist(), h)),
          this.warn(
            `Retrying playlist loading ${a + 1}/${
              o.maxNumRetry
            } after "${t}" in ${h}ms`
          );
      }
      (e.levelRetry = !0), (r.resolved = !0);
    }
    return l;
  }
}
function nX(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0; t < n.length; t++) if (!yv(n[t].attrs, e[t].attrs)) return !1;
  return !0;
}
function yv(n, e, t) {
  const s = n["STABLE-RENDITION-ID"];
  return s && !t
    ? s === e["STABLE-RENDITION-ID"]
    : !(
        t || [
          "LANGUAGE",
          "NAME",
          "CHARACTERISTICS",
          "AUTOSELECT",
          "DEFAULT",
          "FORCED",
          "ASSOC-LANGUAGE",
        ]
      ).some((r) => n[r] !== e[r]);
}
function hI(n, e) {
  return (
    e.label.toLowerCase() === n.name.toLowerCase() &&
    (!e.language || e.language.toLowerCase() === (n.lang || "").toLowerCase())
  );
}
class TCe extends iM {
  constructor(e) {
    super(e, "audio-track-controller"),
      (this.tracks = []),
      (this.groupIds = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.currentTrack = null),
      (this.selectDefaultTrack = !0),
      this.registerListeners();
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.LEVEL_LOADING, this.onLevelLoading, this),
      e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.LEVEL_LOADING, this.onLevelLoading, this),
      e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off($.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.off($.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(),
      (this.tracks.length = 0),
      (this.tracksInGroup.length = 0),
      (this.currentTrack = null),
      super.destroy();
  }
  onManifestLoading() {
    (this.tracks = []),
      (this.tracksInGroup = []),
      (this.groupIds = null),
      (this.currentTrack = null),
      (this.trackId = -1),
      (this.selectDefaultTrack = !0);
  }
  onManifestParsed(e, t) {
    this.tracks = t.audioTracks || [];
  }
  onAudioTrackLoaded(e, t) {
    const { id: s, groupId: r, details: i } = t,
      a = this.tracksInGroup[s];
    if (!a || a.groupId !== r) {
      this.warn(
        `Audio track with id:${s} and group:${r} not found in active group ${a?.groupId}`
      );
      return;
    }
    const o = a.details;
    (a.details = t.details),
      this.log(
        `Audio track ${s} "${a.name}" lang:${a.lang} group:${r} loaded [${i.startSN}-${i.endSN}]`
      ),
      s === this.trackId && this.playlistLoaded(s, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t) return;
    const s = t.audioGroups || null,
      r = this.groupIds;
    let i = this.currentTrack;
    if (
      !s ||
      r?.length !== s?.length ||
      (s != null && s.some((o) => r?.indexOf(o) === -1))
    ) {
      (this.groupIds = s), (this.trackId = -1), (this.currentTrack = null);
      const o = this.tracks.filter((p) => !s || s.indexOf(p.groupId) !== -1);
      if (o.length)
        this.selectDefaultTrack &&
          !o.some((p) => p.default) &&
          (this.selectDefaultTrack = !1),
          o.forEach((p, g) => {
            p.id = g;
          });
      else if (!i && !this.tracksInGroup.length) return;
      this.tracksInGroup = o;
      const l = this.hls.config.audioPreference;
      if (!i && l) {
        const p = To(l, o, Du);
        if (p > -1) i = o[p];
        else {
          const g = To(l, this.tracks);
          i = this.tracks[g];
        }
      }
      let c = this.findTrackId(i);
      c === -1 && i && (c = this.findTrackId(null));
      const h = { audioTracks: o };
      this.log(
        `Updating audio tracks, ${
          o.length
        } track(s) found in group(s): ${s?.join(",")}`
      ),
        this.hls.trigger($.AUDIO_TRACKS_UPDATED, h);
      const m = this.trackId;
      if (c !== -1 && m === -1) this.setAudioTrack(c);
      else if (o.length && m === -1) {
        var a;
        const p = new Error(
          `No audio track selected for current audio group-ID(s): ${
            (a = this.groupIds) == null ? void 0 : a.join(",")
          } track count: ${o.length}`
        );
        this.warn(p.message),
          this.hls.trigger($.ERROR, {
            type: gt.MEDIA_ERROR,
            details: we.AUDIO_TRACK_LOAD_ERROR,
            fatal: !0,
            error: p,
          });
      }
    }
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === en.AUDIO_TRACK &&
        t.context.id === this.trackId &&
        (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) &&
        this.checkRetry(t));
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    (this.selectDefaultTrack = !1), this.setAudioTrack(e);
  }
  setAudioOption(e) {
    const t = this.hls;
    if (((t.config.audioPreference = e), e)) {
      const s = this.allAudioTracks;
      if (((this.selectDefaultTrack = !1), s.length)) {
        const r = this.currentTrack;
        if (r && qu(e, r, Du)) return r;
        const i = To(e, this.tracksInGroup, Du);
        if (i > -1) {
          const a = this.tracksInGroup[i];
          return this.setAudioTrack(i), a;
        } else if (r) {
          let a = t.loadLevel;
          a === -1 && (a = t.firstAutoLevel);
          const o = jRe(e, t.levels, s, a, Du);
          if (o === -1) return null;
          t.nextLoadLevel = o;
        }
        if (e.channels || e.audioCodec) {
          const a = To(e, s);
          if (a > -1) return s[a];
        }
      }
    }
    return null;
  }
  setAudioTrack(e) {
    const t = this.tracksInGroup;
    if (e < 0 || e >= t.length) {
      this.warn(`Invalid audio track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const s = this.currentTrack,
      r = t[e],
      i = r.details && !r.details.live;
    if (
      (e === this.trackId && r === s && i) ||
      (this.log(
        `Switching to audio-track ${e} "${r.name}" lang:${r.lang} group:${r.groupId} channels:${r.channels}`
      ),
      (this.trackId = e),
      (this.currentTrack = r),
      this.hls.trigger($.AUDIO_TRACK_SWITCHING, In({}, r)),
      i)
    )
      return;
    const a = this.switchParams(r.url, s?.details, r.details);
    this.loadPlaylist(a);
  }
  findTrackId(e) {
    const t = this.tracksInGroup;
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      if (!(this.selectDefaultTrack && !r.default) && (!e || qu(e, r, Du)))
        return s;
    }
    if (e) {
      const {
        name: s,
        lang: r,
        assocLang: i,
        characteristics: a,
        audioCodec: o,
        channels: l,
      } = e;
      for (let c = 0; c < t.length; c++) {
        const h = t[c];
        if (
          qu(
            {
              name: s,
              lang: r,
              assocLang: i,
              characteristics: a,
              audioCodec: o,
              channels: l,
            },
            h,
            Du
          )
        )
          return c;
      }
      for (let c = 0; c < t.length; c++) {
        const h = t[c];
        if (
          yv(e.attrs, h.attrs, [
            "LANGUAGE",
            "ASSOC-LANGUAGE",
            "CHARACTERISTICS",
          ])
        )
          return c;
      }
      for (let c = 0; c < t.length; c++) {
        const h = t[c];
        if (yv(e.attrs, h.attrs, ["LANGUAGE"])) return c;
      }
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.currentTrack;
    this.shouldLoadPlaylist(t) &&
      Yw(t.url, this.hls) &&
      this.scheduleLoading(t, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const s = e.id,
      r = e.groupId,
      i = this.getUrlWithDirectives(e.url, t),
      a = e.details,
      o = a?.age;
    this.log(
      `Loading audio-track ${s} "${e.name}" lang:${e.lang} group:${r}${
        t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""
      }${
        o && a.live
          ? " age " + o.toFixed(1) + ((a.type && " " + a.type) || "")
          : ""
      } ${i}`
    ),
      this.hls.trigger($.AUDIO_TRACK_LOADING, {
        url: i,
        id: s,
        groupId: r,
        deliveryDirectives: t || null,
        track: e,
      });
  }
}
class _Ce {
  constructor(e) {
    (this.tracks = void 0),
      (this.queues = { video: [], audio: [], audiovideo: [] }),
      (this.tracks = e);
  }
  destroy() {
    this.tracks = this.queues = null;
  }
  append(e, t, s) {
    if (this.queues === null || this.tracks === null) return;
    const r = this.queues[t];
    r.push(e), r.length === 1 && !s && this.executeNext(t);
  }
  appendBlocker(e) {
    return new Promise((t) => {
      const s = {
        label: "async-blocker",
        execute: t,
        onStart: () => {},
        onComplete: () => {},
        onError: () => {},
      };
      this.append(s, e);
    });
  }
  prependBlocker(e) {
    return new Promise((t) => {
      if (this.queues) {
        const s = {
          label: "async-blocker-prepend",
          execute: t,
          onStart: () => {},
          onComplete: () => {},
          onError: () => {},
        };
        this.queues[e].unshift(s);
      }
    });
  }
  removeBlockers() {
    this.queues !== null &&
      [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(
        (e) => {
          var t;
          const s = (t = e[0]) == null ? void 0 : t.label;
          (s === "async-blocker" || s === "async-blocker-prepend") &&
            (e[0].execute(), e.splice(0, 1));
        }
      );
  }
  unblockAudio(e) {
    if (this.queues === null) return;
    this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
  }
  executeNext(e) {
    if (this.queues === null || this.tracks === null) return;
    const t = this.queues[e];
    if (t.length) {
      const r = t[0];
      try {
        r.execute();
      } catch (i) {
        var s;
        if ((r.onError(i), this.queues === null || this.tracks === null))
          return;
        const a = (s = this.tracks[e]) == null ? void 0 : s.buffer;
        (a != null && a.updating) || this.shiftAndExecuteNext(e);
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
  }
  current(e) {
    var t;
    return ((t = this.queues) == null ? void 0 : t[e][0]) || null;
  }
  toString() {
    const { queues: e, tracks: t } = this;
    return e === null || t === null
      ? "<destroyed>"
      : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
  }
  list(e) {
    var t, s;
    return ((t = this.queues) != null && t[e]) ||
      ((s = this.tracks) != null && s[e])
      ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}`
      : "";
  }
  listSbInfo(e) {
    var t;
    const s = (t = this.tracks) == null ? void 0 : t[e],
      r = s?.buffer;
    return r
      ? `SourceBuffer${r.updating ? " updating" : ""}${
          s.ended ? " ended" : ""
        }${s.ending ? " ending" : ""}`
      : "none";
  }
  listOps(e) {
    var t;
    return (
      ((t = this.queues) == null
        ? void 0
        : t[e].map((s) => s.label).join(", ")) || ""
    );
  }
}
const l5 = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/,
  sX = "HlsJsTrackRemovedError";
class ACe extends Error {
  constructor(e) {
    super(e), (this.name = sX);
  }
}
class RCe extends za {
  constructor(e, t) {
    super("buffer-controller", e.logger),
      (this.hls = void 0),
      (this.fragmentTracker = void 0),
      (this.details = null),
      (this._objectUrl = null),
      (this.operationQueue = null),
      (this.bufferCodecEventsTotal = 0),
      (this.media = null),
      (this.mediaSource = null),
      (this.lastMpegAudioChunk = null),
      (this.blockedAudioAppend = null),
      (this.lastVideoAppendEnd = 0),
      (this.appendSource = void 0),
      (this.transferData = void 0),
      (this.overrides = void 0),
      (this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }),
      (this.tracks = {}),
      (this.sourceBuffers = [
        [null, null],
        [null, null],
      ]),
      (this._onEndStreaming = (s) => {
        var r;
        this.hls &&
          ((r = this.mediaSource) == null ? void 0 : r.readyState) === "open" &&
          this.hls.pauseBuffering();
      }),
      (this._onStartStreaming = (s) => {
        this.hls && this.hls.resumeBuffering();
      }),
      (this._onMediaSourceOpen = (s) => {
        const { media: r, mediaSource: i } = this;
        s && this.log("Media source opened"),
          !(!r || !i) &&
            (i.removeEventListener("sourceopen", this._onMediaSourceOpen),
            r.removeEventListener("emptied", this._onMediaEmptied),
            this.updateDuration(),
            this.hls.trigger($.MEDIA_ATTACHED, { media: r, mediaSource: i }),
            this.mediaSource !== null && this.checkPendingTracks());
      }),
      (this._onMediaSourceClose = () => {
        this.log("Media source closed");
      }),
      (this._onMediaSourceEnded = () => {
        this.log("Media source ended");
      }),
      (this._onMediaEmptied = () => {
        const { mediaSrc: s, _objectUrl: r } = this;
        s !== r &&
          this.error(
            `Media element src was set while attaching MediaSource (${r} > ${s})`
          );
      }),
      (this.hls = e),
      (this.fragmentTracker = t),
      (this.appendSource = eRe(Bc(e.config.preferManagedMediaSource))),
      this.initTracks(),
      this.registerListeners();
  }
  hasSourceTypes() {
    return Object.keys(this.tracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(),
      (this.details = null),
      (this.lastMpegAudioChunk = this.blockedAudioAppend = null),
      (this.transferData = this.overrides = void 0),
      this.operationQueue &&
        (this.operationQueue.destroy(), (this.operationQueue = null)),
      (this.hls = this.fragmentTracker = null),
      (this._onMediaSourceOpen = this._onMediaSourceClose = null),
      (this._onMediaSourceEnded = null),
      (this._onStartStreaming = this._onEndStreaming = null);
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.BUFFER_RESET, this.onBufferReset, this),
      e.on($.BUFFER_APPENDING, this.onBufferAppending, this),
      e.on($.BUFFER_CODECS, this.onBufferCodecs, this),
      e.on($.BUFFER_EOS, this.onBufferEos, this),
      e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.on($.FRAG_PARSED, this.onFragParsed, this),
      e.on($.FRAG_CHANGED, this.onFragChanged, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.BUFFER_RESET, this.onBufferReset, this),
      e.off($.BUFFER_APPENDING, this.onBufferAppending, this),
      e.off($.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off($.BUFFER_EOS, this.onBufferEos, this),
      e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.off($.FRAG_PARSED, this.onFragParsed, this),
      e.off($.FRAG_CHANGED, this.onFragChanged, this),
      e.off($.ERROR, this.onError, this);
  }
  transferMedia() {
    const { media: e, mediaSource: t } = this;
    if (!e) return null;
    const s = {};
    if (this.operationQueue) {
      const i = this.isUpdating();
      i || this.operationQueue.removeBlockers();
      const a = this.isQueued();
      (i || a) &&
        this.warn(
          `Transfering MediaSource with${a ? " operations in queue" : ""}${
            i ? " updating SourceBuffer(s)" : ""
          } ${this.operationQueue}`
        ),
        this.operationQueue.destroy();
    }
    const r = this.transferData;
    return (
      !this.sourceBufferCount && r && r.mediaSource === t
        ? Tn(s, r.tracks)
        : this.sourceBuffers.forEach((i) => {
            const [a] = i;
            a && ((s[a] = Tn({}, this.tracks[a])), this.removeBuffer(a)),
              (i[0] = i[1] = null);
          }),
      { media: e, mediaSource: t, tracks: s }
    );
  }
  initTracks() {
    const e = {};
    (this.sourceBuffers = [
      [null, null],
      [null, null],
    ]),
      (this.tracks = e),
      this.resetQueue(),
      this.resetAppendErrors(),
      (this.lastMpegAudioChunk = this.blockedAudioAppend = null),
      (this.lastVideoAppendEnd = 0);
  }
  onManifestLoading() {
    (this.bufferCodecEventsTotal = 0), (this.details = null);
  }
  onManifestParsed(e, t) {
    var s;
    let r = 2;
    ((t.audio && !t.video) || !t.altAudio) && (r = 1),
      (this.bufferCodecEventsTotal = r),
      this.log(`${r} bufferCodec event(s) expected.`),
      (s = this.transferData) != null &&
        s.mediaSource &&
        this.sourceBufferCount &&
        r &&
        this.bufferCreated();
  }
  onMediaAttaching(e, t) {
    const s = (this.media = t.media),
      r = Bc(this.appendSource);
    if (((this.transferData = this.overrides = void 0), s && r)) {
      const i = !!t.mediaSource;
      (i || t.overrides) &&
        ((this.transferData = t), (this.overrides = t.overrides));
      const a = (this.mediaSource = t.mediaSource || new r());
      if ((this.assignMediaSource(a), i))
        (this._objectUrl = s.src), this.attachTransferred();
      else {
        const o = (this._objectUrl = self.URL.createObjectURL(a));
        if (this.appendSource)
          try {
            s.removeAttribute("src");
            const l = self.ManagedMediaSource;
            (s.disableRemotePlayback =
              s.disableRemotePlayback || (l && a instanceof l)),
              c5(s),
              kCe(s, o),
              s.load();
          } catch {
            s.src = o;
          }
        else s.src = o;
      }
      s.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  assignMediaSource(e) {
    var t, s;
    this.log(
      `${
        ((t = this.transferData) == null ? void 0 : t.mediaSource) === e
          ? "transferred"
          : "created"
      } media source: ${(s = e.constructor) == null ? void 0 : s.name}`
    ),
      e.addEventListener("sourceopen", this._onMediaSourceOpen),
      e.addEventListener("sourceended", this._onMediaSourceEnded),
      e.addEventListener("sourceclose", this._onMediaSourceClose),
      this.appendSource &&
        (e.addEventListener("startstreaming", this._onStartStreaming),
        e.addEventListener("endstreaming", this._onEndStreaming));
  }
  attachTransferred() {
    const e = this.media,
      t = this.transferData;
    if (!t || !e) return;
    const s = this.tracks,
      r = t.tracks,
      i = r ? Object.keys(r) : null,
      a = i ? i.length : 0,
      o = () => {
        this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
      };
    if (r && i && a) {
      if (!this.tracksReady) {
        (this.hls.config.startFragPrefetch = !0),
          this.log("attachTransferred: waiting for SourceBuffer track info");
        return;
      }
      if (
        (this.log(`attachTransferred: (bufferCodecEventsTotal ${
          this.bufferCodecEventsTotal
        })
required tracks: ${Wn(s, (l, c) => (l === "initSegment" ? void 0 : c))};
transfer tracks: ${Wn(r, (l, c) => (l === "initSegment" ? void 0 : c))}}`),
        !iY(r, s))
      ) {
        (t.mediaSource = null), (t.tracks = void 0);
        const l = e.currentTime,
          c = this.details,
          h = Math.max(l, c?.fragments[0].start || 0);
        if (h - l > 1) {
          this.log(
            `attachTransferred: waiting for playback to reach new tracks start time ${l} -> ${h}`
          );
          return;
        }
        this.warn(
          `attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(
            r
          )}"->"${Object.keys(s)}") start time: ${h} currentTime: ${l}`
        ),
          this.onMediaDetaching($.MEDIA_DETACHING, {}),
          this.onMediaAttaching($.MEDIA_ATTACHING, t),
          (e.currentTime = h);
        return;
      }
      (this.transferData = void 0),
        i.forEach((l) => {
          const c = l,
            h = r[c];
          if (h) {
            const m = h.buffer;
            if (m) {
              const p = this.fragmentTracker,
                g = h.id;
              if (p.hasFragments(g) || p.hasParts(g)) {
                const w = Ft.getBuffered(m);
                p.detectEvictedFragments(c, w, g, null, !0);
              }
              const y = _A(c),
                b = [c, m];
              (this.sourceBuffers[y] = b),
                m.updating &&
                  this.operationQueue &&
                  this.operationQueue.prependBlocker(c),
                this.trackSourceBuffer(c, h);
            }
          }
        }),
        o(),
        this.bufferCreated();
    } else this.log("attachTransferred: MediaSource w/o SourceBuffers"), o();
  }
  get mediaSourceOpenOrEnded() {
    var e;
    const t = (e = this.mediaSource) == null ? void 0 : e.readyState;
    return t === "open" || t === "ended";
  }
  onMediaDetaching(e, t) {
    const s = !!t.transferMedia;
    this.transferData = this.overrides = void 0;
    const { media: r, mediaSource: i, _objectUrl: a } = this;
    if (i) {
      if ((this.log(`media source ${s ? "transferring" : "detaching"}`), s))
        this.sourceBuffers.forEach(([o]) => {
          o && this.removeBuffer(o);
        }),
          this.resetQueue();
      else {
        if (this.mediaSourceOpenOrEnded) {
          const o = i.readyState === "open";
          try {
            const l = i.sourceBuffers;
            for (let c = l.length; c--; )
              o && l[c].abort(), i.removeSourceBuffer(l[c]);
            o && i.endOfStream();
          } catch (l) {
            this.warn(
              `onMediaDetaching: ${l.message} while calling endOfStream`
            );
          }
        }
        this.sourceBufferCount && this.onBufferReset();
      }
      i.removeEventListener("sourceopen", this._onMediaSourceOpen),
        i.removeEventListener("sourceended", this._onMediaSourceEnded),
        i.removeEventListener("sourceclose", this._onMediaSourceClose),
        this.appendSource &&
          (i.removeEventListener("startstreaming", this._onStartStreaming),
          i.removeEventListener("endstreaming", this._onEndStreaming)),
        (this.mediaSource = null),
        (this._objectUrl = null);
    }
    r &&
      (r.removeEventListener("emptied", this._onMediaEmptied),
      s ||
        (a && self.URL.revokeObjectURL(a),
        this.mediaSrc === a
          ? (r.removeAttribute("src"), this.appendSource && c5(r), r.load())
          : this.warn(
              "media|source.src was changed by a third party - skip cleanup"
            )),
      (this.media = null)),
      this.hls.trigger($.MEDIA_DETACHED, t);
  }
  onBufferReset() {
    this.sourceBuffers.forEach(([e]) => {
      e && this.resetBuffer(e);
    }),
      this.initTracks();
  }
  resetBuffer(e) {
    var t;
    const s = (t = this.tracks[e]) == null ? void 0 : t.buffer;
    if ((this.removeBuffer(e), s))
      try {
        var r;
        (r = this.mediaSource) != null &&
          r.sourceBuffers.length &&
          this.mediaSource.removeSourceBuffer(s);
      } catch (i) {
        this.warn(`onBufferReset ${e}`, i);
      }
    delete this.tracks[e];
  }
  removeBuffer(e) {
    this.removeBufferListeners(e), (this.sourceBuffers[_A(e)] = [null, null]);
    const t = this.tracks[e];
    t && (t.buffer = void 0);
  }
  resetQueue() {
    this.operationQueue && this.operationQueue.destroy(),
      (this.operationQueue = new _Ce(this.tracks));
  }
  onBufferCodecs(e, t) {
    const s = this.tracks,
      r = Object.keys(t);
    this.log(
      `BUFFER_CODECS: "${r}" (current SB count ${this.sourceBufferCount})`
    );
    const i =
        ("audiovideo" in t && (s.audio || s.video)) ||
        (s.audiovideo && ("audio" in t || "video" in t)),
      a = !i && this.sourceBufferCount && this.media && r.some((o) => !s[o]);
    if (i || a) {
      this.warn(
        `Unsupported transition between "${Object.keys(
          s
        )}" and "${r}" SourceBuffers`
      );
      return;
    }
    r.forEach((o) => {
      var l, c, h;
      const m = t[o],
        {
          id: p,
          codec: g,
          levelCodec: y,
          container: b,
          metadata: w,
          supplemental: S,
        } = m;
      let A = s[o];
      const _ =
          (l = this.transferData) == null || (c = l.tracks) == null
            ? void 0
            : c[o],
        R = _ != null && _.buffer ? _ : A,
        C = R?.pendingCodec || R?.codec,
        D = R?.levelCodec;
      A ||
        (A = s[o] =
          {
            buffer: void 0,
            listeners: [],
            codec: g,
            supplemental: S,
            container: b,
            levelCodec: y,
            metadata: w,
            id: p,
          });
      const L = tx(C, D),
        P = L?.replace(l5, "$1");
      let V = tx(g, y);
      const N = (h = V) == null ? void 0 : h.replace(l5, "$1");
      V &&
        L &&
        P !== N &&
        (o.slice(0, 5) === "audio" && (V = Ww(V, this.appendSource)),
        this.log(`switching codec ${C} to ${V}`),
        V !== (A.pendingCodec || A.codec) && (A.pendingCodec = V),
        (A.container = b),
        this.appendChangeType(o, b, V));
    }),
      (this.tracksReady || this.sourceBufferCount) &&
        (t.tracks = this.sourceBufferTracks),
      !this.sourceBufferCount &&
        this.mediaSourceOpenOrEnded &&
        this.checkPendingTracks();
  }
  get sourceBufferTracks() {
    return Object.keys(this.tracks).reduce((e, t) => {
      const s = this.tracks[t];
      return (
        (e[t] = {
          id: s.id,
          container: s.container,
          codec: s.codec,
          levelCodec: s.levelCodec,
        }),
        e
      );
    }, {});
  }
  appendChangeType(e, t, s) {
    const r = `${t};codecs=${s}`,
      i = {
        label: `change-type=${r}`,
        execute: () => {
          const a = this.tracks[e];
          if (a) {
            const o = a.buffer;
            o != null &&
              o.changeType &&
              (this.log(`changing ${e} sourceBuffer type to ${r}`),
              o.changeType(r),
              (a.codec = s),
              (a.container = t));
          }
          this.shiftAndExecuteNext(e);
        },
        onStart: () => {},
        onComplete: () => {},
        onError: (a) => {
          this.warn(`Failed to change ${e} SourceBuffer type`, a);
        },
      };
    this.append(i, e, this.isPending(this.tracks[e]));
  }
  blockAudio(e) {
    var t;
    const s = e.start,
      r = s + e.duration * 0.05;
    if (
      ((t = this.fragmentTracker.getAppendedFrag(s, lt.MAIN)) == null
        ? void 0
        : t.gap) === !0
    )
      return;
    const a = {
      label: "block-audio",
      execute: () => {
        var o;
        const l = this.tracks.video;
        (this.lastVideoAppendEnd > r ||
          (l != null && l.buffer && Ft.isBuffered(l.buffer, r)) ||
          ((o = this.fragmentTracker.getAppendedFrag(r, lt.MAIN)) == null
            ? void 0
            : o.gap) === !0) &&
          ((this.blockedAudioAppend = null), this.shiftAndExecuteNext("audio"));
      },
      onStart: () => {},
      onComplete: () => {},
      onError: (o) => {
        this.warn("Error executing block-audio operation", o);
      },
    };
    (this.blockedAudioAppend = { op: a, frag: e }), this.append(a, "audio", !0);
  }
  unblockAudio() {
    const { blockedAudioAppend: e, operationQueue: t } = this;
    e && t && ((this.blockedAudioAppend = null), t.unblockAudio(e.op));
  }
  onBufferAppending(e, t) {
    const { tracks: s } = this,
      {
        data: r,
        type: i,
        parent: a,
        frag: o,
        part: l,
        chunkMeta: c,
        offset: h,
      } = t,
      m = c.buffering[i],
      { sn: p, cc: g } = o,
      y = self.performance.now();
    m.start = y;
    const b = o.stats.buffering,
      w = l ? l.stats.buffering : null;
    b.start === 0 && (b.start = y), w && w.start === 0 && (w.start = y);
    const S = s.audio;
    let A = !1;
    i === "audio" &&
      S?.container === "audio/mpeg" &&
      ((A =
        !this.lastMpegAudioChunk ||
        c.id === 1 ||
        this.lastMpegAudioChunk.sn !== c.sn),
      (this.lastMpegAudioChunk = c));
    const _ = s.video,
      R = _?.buffer;
    if (R && p !== "initSegment") {
      const L = l || o,
        P = this.blockedAudioAppend;
      if (i === "audio" && a !== "main" && !this.blockedAudioAppend) {
        const N = L.start + L.duration * 0.05,
          W = R.buffered,
          H = this.currentOp("video");
        !W.length && !H
          ? this.blockAudio(L)
          : !H &&
            !Ft.isBuffered(R, N) &&
            this.lastVideoAppendEnd < N &&
            this.blockAudio(L);
      } else if (i === "video") {
        const V = L.end;
        if (P) {
          const N = P.frag.start;
          (V > N || V < this.lastVideoAppendEnd || Ft.isBuffered(R, N)) &&
            this.unblockAudio();
        }
        this.lastVideoAppendEnd = V;
      }
    }
    const C = (l || o).start,
      D = {
        label: `append-${i}`,
        execute: () => {
          var L;
          m.executeStart = self.performance.now();
          const P = (L = this.tracks[i]) == null ? void 0 : L.buffer;
          P &&
            (A
              ? this.updateTimestampOffset(P, C, 0.1, i, p, g)
              : h !== void 0 &&
                Qe(h) &&
                this.updateTimestampOffset(P, h, 1e-6, i, p, g)),
            this.appendExecutor(r, i);
        },
        onStart: () => {},
        onComplete: () => {
          const L = self.performance.now();
          (m.executeEnd = m.end = L),
            b.first === 0 && (b.first = L),
            w && w.first === 0 && (w.first = L);
          const P = {};
          this.sourceBuffers.forEach(([V, N]) => {
            V && (P[V] = Ft.getBuffered(N));
          }),
            (this.appendErrors[i] = 0),
            i === "audio" || i === "video"
              ? (this.appendErrors.audiovideo = 0)
              : ((this.appendErrors.audio = 0), (this.appendErrors.video = 0)),
            this.hls.trigger($.BUFFER_APPENDED, {
              type: i,
              frag: o,
              part: l,
              chunkMeta: c,
              parent: o.type,
              timeRanges: P,
            });
        },
        onError: (L) => {
          var P;
          const V = {
              type: gt.MEDIA_ERROR,
              parent: o.type,
              details: we.BUFFER_APPEND_ERROR,
              sourceBufferName: i,
              frag: o,
              part: l,
              chunkMeta: c,
              error: L,
              err: L,
              fatal: !1,
            },
            N = (P = this.media) == null ? void 0 : P.error;
          if (
            L.code === DOMException.QUOTA_EXCEEDED_ERR ||
            L.name == "QuotaExceededError" ||
            "quota" in L
          )
            V.details = we.BUFFER_FULL_ERROR;
          else if (
            L.code === DOMException.INVALID_STATE_ERR &&
            this.mediaSourceOpenOrEnded &&
            !N
          )
            V.errorAction = mv(!0);
          else if (L.name === sX && this.sourceBufferCount === 0)
            V.errorAction = mv(!0);
          else {
            const W = ++this.appendErrors[i];
            this.warn(
              `Failed ${W}/${
                this.hls.config.appendErrorMaxRetry
              } times to append segment in "${i}" sourceBuffer (${
                N || "no media error"
              })`
            ),
              (W >= this.hls.config.appendErrorMaxRetry || N) && (V.fatal = !0);
          }
          this.hls.trigger($.ERROR, V);
        },
      };
    this.append(D, i, this.isPending(this.tracks[i]));
  }
  getFlushOp(e, t, s) {
    return (
      this.log(`queuing "${e}" remove ${t}-${s}`),
      {
        label: "remove",
        execute: () => {
          this.removeExecutor(e, t, s);
        },
        onStart: () => {},
        onComplete: () => {
          this.hls.trigger($.BUFFER_FLUSHED, { type: e });
        },
        onError: (r) => {
          this.warn(`Failed to remove ${t}-${s} from "${e}" SourceBuffer`, r);
        },
      }
    );
  }
  onBufferFlushing(e, t) {
    const { type: s, startOffset: r, endOffset: i } = t;
    s
      ? this.append(this.getFlushOp(s, r, i), s)
      : this.sourceBuffers.forEach(([a]) => {
          a && this.append(this.getFlushOp(a, r, i), a);
        });
  }
  onFragParsed(e, t) {
    const { frag: s, part: r } = t,
      i = [],
      a = r ? r.elementaryStreams : s.elementaryStreams;
    a[On.AUDIOVIDEO]
      ? i.push("audiovideo")
      : (a[On.AUDIO] && i.push("audio"), a[On.VIDEO] && i.push("video"));
    const o = () => {
      const l = self.performance.now();
      (s.stats.buffering.end = l), r && (r.stats.buffering.end = l);
      const c = r ? r.stats : s.stats;
      this.hls.trigger($.FRAG_BUFFERED, {
        frag: s,
        part: r,
        stats: c,
        id: s.type,
      });
    };
    i.length === 0 &&
      this.warn(
        `Fragments must have at least one ElementaryStreamType set. type: ${s.type} level: ${s.level} sn: ${s.sn}`
      ),
      this.blockBuffers(o, i).catch((l) => {
        this.warn(`Fragment buffered callback ${l}`),
          this.stepOperationQueue(this.sourceBufferTypes);
      });
  }
  onFragChanged(e, t) {
    this.trimBuffers();
  }
  get bufferedToEnd() {
    return (
      this.sourceBufferCount > 0 &&
      !this.sourceBuffers.some(([e]) => {
        var t, s;
        return (
          e &&
          (!((t = this.tracks[e]) != null && t.ended) ||
            ((s = this.tracks[e]) == null ? void 0 : s.ending))
        );
      })
    );
  }
  onBufferEos(e, t) {
    var s;
    this.sourceBuffers.forEach(([a]) => {
      if (a) {
        const o = this.tracks[a];
        (!t.type || t.type === a) &&
          ((o.ending = !0),
          o.ended || ((o.ended = !0), this.log(`${a} buffer reached EOS`)));
      }
    });
    const r = ((s = this.overrides) == null ? void 0 : s.endOfStream) !== !1;
    this.sourceBufferCount > 0 &&
      !this.sourceBuffers.some(([a]) => {
        var o;
        return a && !((o = this.tracks[a]) != null && o.ended);
      }) &&
      (r
        ? (this.log("Queueing EOS"),
          this.blockUntilOpen(() => {
            this.tracksEnded();
            const { mediaSource: a } = this;
            if (!a || a.readyState !== "open") {
              a &&
                this.log(
                  `Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`
                );
              return;
            }
            this.log("Calling mediaSource.endOfStream()"),
              a.endOfStream(),
              this.hls.trigger($.BUFFERED_TO_END, void 0);
          }))
        : (this.tracksEnded(), this.hls.trigger($.BUFFERED_TO_END, void 0)));
  }
  tracksEnded() {
    this.sourceBuffers.forEach(([e]) => {
      if (e !== null) {
        const t = this.tracks[e];
        t && (t.ending = !1);
      }
    });
  }
  onLevelUpdated(e, { details: t }) {
    t.fragments.length && ((this.details = t), this.updateDuration());
  }
  updateDuration() {
    this.blockUntilOpen(() => {
      const e = this.getDurationAndRange();
      e && this.updateMediaSource(e);
    });
  }
  onError(e, t) {
    if (t.details === we.BUFFER_APPEND_ERROR && t.frag) {
      var s;
      const r = (s = t.errorAction) == null ? void 0 : s.nextAutoLevel;
      Qe(r) && r !== t.frag.level && this.resetAppendErrors();
    }
  }
  resetAppendErrors() {
    this.appendErrors = { audio: 0, video: 0, audiovideo: 0 };
  }
  trimBuffers() {
    const { hls: e, details: t, media: s } = this;
    if (!s || t === null || !this.sourceBufferCount) return;
    const r = e.config,
      i = s.currentTime,
      a = t.levelTargetDuration,
      o =
        t.live && r.liveBackBufferLength !== null
          ? r.liveBackBufferLength
          : r.backBufferLength;
    if (Qe(o) && o >= 0) {
      const l = Math.max(o, a),
        c = Math.floor(i / a) * a - l;
      this.flushBackBuffer(i, a, c);
    }
    if (Qe(r.frontBufferFlushThreshold) && r.frontBufferFlushThreshold > 0) {
      const l = Math.max(r.maxBufferLength, r.frontBufferFlushThreshold),
        c = Math.max(l, a),
        h = Math.floor(i / a) * a + c;
      this.flushFrontBuffer(i, a, h);
    }
  }
  flushBackBuffer(e, t, s) {
    this.sourceBuffers.forEach(([r, i]) => {
      if (i) {
        const o = Ft.getBuffered(i);
        if (o.length > 0 && s > o.start(0)) {
          var a;
          this.hls.trigger($.BACK_BUFFER_REACHED, { bufferEnd: s });
          const l = this.tracks[r];
          if ((a = this.details) != null && a.live)
            this.hls.trigger($.LIVE_BACK_BUFFER_REACHED, { bufferEnd: s });
          else if (l != null && l.ended) {
            this.log(
              `Cannot flush ${r} back buffer while SourceBuffer is in ended state`
            );
            return;
          }
          this.hls.trigger($.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: s,
            type: r,
          });
        }
      }
    });
  }
  flushFrontBuffer(e, t, s) {
    this.sourceBuffers.forEach(([r, i]) => {
      if (i) {
        const a = Ft.getBuffered(i),
          o = a.length;
        if (o < 2) return;
        const l = a.start(o - 1),
          c = a.end(o - 1);
        if (s > l || (e >= l && e <= c)) return;
        this.hls.trigger($.BUFFER_FLUSHING, {
          startOffset: l,
          endOffset: 1 / 0,
          type: r,
        });
      }
    });
  }
  getDurationAndRange() {
    var e;
    const { details: t, mediaSource: s } = this;
    if (!t || !this.media || s?.readyState !== "open") return null;
    const r = t.edge;
    if (t.live && this.hls.config.liveDurationInfinity) {
      if (t.fragments.length && t.live && s.setLiveSeekableRange) {
        const c = Math.max(0, t.fragmentStart),
          h = Math.max(c, r);
        return { duration: 1 / 0, start: c, end: h };
      }
      return { duration: 1 / 0 };
    }
    const i = (e = this.overrides) == null ? void 0 : e.duration;
    if (i) return Qe(i) ? { duration: i } : null;
    const a = this.media.duration,
      o = Qe(s.duration) ? s.duration : 0;
    return (r > o && r > a) || !Qe(a) ? { duration: r } : null;
  }
  updateMediaSource({ duration: e, start: t, end: s }) {
    const r = this.mediaSource;
    !this.media ||
      !r ||
      r.readyState !== "open" ||
      (r.duration !== e &&
        (Qe(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`),
        (r.duration = e)),
      t !== void 0 &&
        s !== void 0 &&
        (this.log(
          `MediaSource duration is set to ${r.duration}. Setting seekable range to ${t}-${s}.`
        ),
        r.setLiveSeekableRange(t, s)));
  }
  get tracksReady() {
    const e = this.pendingTrackCount;
    return (
      e > 0 &&
      (e >= this.bufferCodecEventsTotal ||
        this.isPending(this.tracks.audiovideo))
    );
  }
  checkPendingTracks() {
    const { bufferCodecEventsTotal: e, pendingTrackCount: t, tracks: s } = this;
    if (
      (this.log(
        `checkPendingTracks (pending: ${t} codec events expected: ${e}) ${Wn(
          s
        )}`
      ),
      this.tracksReady)
    ) {
      var r;
      const i = (r = this.transferData) == null ? void 0 : r.tracks;
      i && Object.keys(i).length
        ? this.attachTransferred()
        : this.createSourceBuffers();
    }
  }
  bufferCreated() {
    if (this.sourceBufferCount) {
      const e = {};
      this.sourceBuffers.forEach(([t, s]) => {
        if (t) {
          const r = this.tracks[t];
          e[t] = {
            buffer: s,
            container: r.container,
            codec: r.codec,
            supplemental: r.supplemental,
            levelCodec: r.levelCodec,
            id: r.id,
            metadata: r.metadata,
          };
        }
      }),
        this.hls.trigger($.BUFFER_CREATED, { tracks: e }),
        this.log(
          `SourceBuffers created. Running queue: ${this.operationQueue}`
        ),
        this.sourceBuffers.forEach(([t]) => {
          this.executeNext(t);
        });
    } else {
      const e = new Error("could not create source buffer for media codec(s)");
      this.hls.trigger($.ERROR, {
        type: gt.MEDIA_ERROR,
        details: we.BUFFER_INCOMPATIBLE_CODECS_ERROR,
        fatal: !0,
        error: e,
        reason: e.message,
      });
    }
  }
  createSourceBuffers() {
    const { tracks: e, sourceBuffers: t, mediaSource: s } = this;
    if (!s)
      throw new Error("createSourceBuffers called when mediaSource was null");
    for (const i in e) {
      const a = i,
        o = e[a];
      if (this.isPending(o)) {
        const l = this.getTrackCodec(o, a),
          c = `${o.container};codecs=${l}`;
        (o.codec = l),
          this.log(
            `creating sourceBuffer(${c})${
              this.currentOp(a) ? " Queued" : ""
            } ${Wn(o)}`
          );
        try {
          const h = s.addSourceBuffer(c),
            m = _A(a),
            p = [a, h];
          (t[m] = p), (o.buffer = h);
        } catch (h) {
          var r;
          this.error(`error while trying to add sourceBuffer: ${h.message}`),
            this.shiftAndExecuteNext(a),
            (r = this.operationQueue) == null || r.removeBlockers(),
            delete this.tracks[a],
            this.hls.trigger($.ERROR, {
              type: gt.MEDIA_ERROR,
              details: we.BUFFER_ADD_CODEC_ERROR,
              fatal: !1,
              error: h,
              sourceBufferName: a,
              mimeType: c,
              parent: o.id,
            });
          return;
        }
        this.trackSourceBuffer(a, o);
      }
    }
    this.bufferCreated();
  }
  getTrackCodec(e, t) {
    const s = e.supplemental;
    let r = e.codec;
    s &&
      (t === "video" || t === "audiovideo") &&
      nI(s, "video") &&
      (r = xRe(r, s));
    const i = tx(r, e.levelCodec);
    return i ? (t.slice(0, 5) === "audio" ? Ww(i, this.appendSource) : i) : "";
  }
  trackSourceBuffer(e, t) {
    const s = t.buffer;
    if (!s) return;
    const r = this.getTrackCodec(t, e);
    (this.tracks[e] = {
      buffer: s,
      codec: r,
      container: t.container,
      levelCodec: t.levelCodec,
      supplemental: t.supplemental,
      metadata: t.metadata,
      id: t.id,
      listeners: [],
    }),
      this.removeBufferListeners(e),
      this.addBufferListener(e, "updatestart", this.onSBUpdateStart),
      this.addBufferListener(e, "updateend", this.onSBUpdateEnd),
      this.addBufferListener(e, "error", this.onSBUpdateError),
      this.appendSource &&
        this.addBufferListener(e, "bufferedchange", (i, a) => {
          const o = a.removedRanges;
          o != null &&
            o.length &&
            this.hls.trigger($.BUFFER_FLUSHED, { type: i });
        });
  }
  get mediaSrc() {
    var e, t;
    const s =
      ((e = this.media) == null || (t = e.querySelector) == null
        ? void 0
        : t.call(e, "source")) || this.media;
    return s?.src;
  }
  onSBUpdateStart(e) {
    const t = this.currentOp(e);
    t && t.onStart();
  }
  onSBUpdateEnd(e) {
    var t;
    if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
      this.resetBuffer(e);
      return;
    }
    const s = this.currentOp(e);
    s && (s.onComplete(), this.shiftAndExecuteNext(e));
  }
  onSBUpdateError(e, t) {
    var s;
    const r = new Error(
      `${e} SourceBuffer error. MediaSource readyState: ${
        (s = this.mediaSource) == null ? void 0 : s.readyState
      }`
    );
    this.error(`${r}`, t),
      this.hls.trigger($.ERROR, {
        type: gt.MEDIA_ERROR,
        details: we.BUFFER_APPENDING_ERROR,
        sourceBufferName: e,
        error: r,
        fatal: !1,
      });
    const i = this.currentOp(e);
    i && i.onError(r);
  }
  updateTimestampOffset(e, t, s, r, i, a) {
    const o = t - e.timestampOffset;
    Math.abs(o) >= s &&
      (this.log(
        `Updating ${r} SourceBuffer timestampOffset to ${t} (sn: ${i} cc: ${a})`
      ),
      (e.timestampOffset = t));
  }
  removeExecutor(e, t, s) {
    const { media: r, mediaSource: i } = this,
      a = this.tracks[e],
      o = a?.buffer;
    if (!r || !i || !o) {
      this.warn(
        `Attempting to remove from the ${e} SourceBuffer, but it does not exist`
      ),
        this.shiftAndExecuteNext(e);
      return;
    }
    const l = Qe(r.duration) ? r.duration : 1 / 0,
      c = Qe(i.duration) ? i.duration : 1 / 0,
      h = Math.max(0, t),
      m = Math.min(s, l, c);
    m > h && (!a.ending || a.ended)
      ? ((a.ended = !1),
        this.log(`Removing [${h},${m}] from the ${e} SourceBuffer`),
        o.remove(h, m))
      : this.shiftAndExecuteNext(e);
  }
  appendExecutor(e, t) {
    const s = this.tracks[t],
      r = s?.buffer;
    if (!r)
      throw new ACe(
        `Attempting to append to the ${t} SourceBuffer, but it does not exist`
      );
    (s.ending = !1), (s.ended = !1), r.appendBuffer(e);
  }
  blockUntilOpen(e) {
    if (this.isUpdating() || this.isQueued())
      this.blockBuffers(e).catch((t) => {
        this.warn(`SourceBuffer blocked callback ${t}`),
          this.stepOperationQueue(this.sourceBufferTypes);
      });
    else
      try {
        e();
      } catch (t) {
        this.warn(`Callback run without blocking ${this.operationQueue} ${t}`);
      }
  }
  isUpdating() {
    return this.sourceBuffers.some(([e, t]) => e && t.updating);
  }
  isQueued() {
    return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
  }
  isPending(e) {
    return !!e && !e.buffer;
  }
  blockBuffers(e, t = this.sourceBufferTypes) {
    if (!t.length)
      return (
        this.log("Blocking operation requested, but no SourceBuffers exist"),
        Promise.resolve().then(e)
      );
    const { operationQueue: s } = this,
      r = t.map((a) => this.appendBlocker(a));
    return (
      t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(),
      Promise.all(r).then((a) => {
        s === this.operationQueue &&
          (e(), this.stepOperationQueue(this.sourceBufferTypes));
      })
    );
  }
  stepOperationQueue(e) {
    e.forEach((t) => {
      var s;
      const r = (s = this.tracks[t]) == null ? void 0 : s.buffer;
      !r || r.updating || this.shiftAndExecuteNext(t);
    });
  }
  append(e, t, s) {
    this.operationQueue && this.operationQueue.append(e, t, s);
  }
  appendBlocker(e) {
    if (this.operationQueue) return this.operationQueue.appendBlocker(e);
  }
  currentOp(e) {
    return this.operationQueue ? this.operationQueue.current(e) : null;
  }
  executeNext(e) {
    e && this.operationQueue && this.operationQueue.executeNext(e);
  }
  shiftAndExecuteNext(e) {
    this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
  }
  get pendingTrackCount() {
    return Object.keys(this.tracks).reduce(
      (e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0),
      0
    );
  }
  get sourceBufferCount() {
    return this.sourceBuffers.reduce((e, [t]) => e + (t ? 1 : 0), 0);
  }
  get sourceBufferTypes() {
    return this.sourceBuffers.map(([e]) => e).filter((e) => !!e);
  }
  addBufferListener(e, t, s) {
    const r = this.tracks[e];
    if (!r) return;
    const i = r.buffer;
    if (!i) return;
    const a = s.bind(this, e);
    r.listeners.push({ event: t, listener: a }), i.addEventListener(t, a);
  }
  removeBufferListeners(e) {
    const t = this.tracks[e];
    if (!t) return;
    const s = t.buffer;
    s &&
      (t.listeners.forEach((r) => {
        s.removeEventListener(r.event, r.listener);
      }),
      (t.listeners.length = 0));
  }
}
function c5(n) {
  const e = n.querySelectorAll("source");
  [].slice.call(e).forEach((t) => {
    n.removeChild(t);
  });
}
function kCe(n, e) {
  const t = self.document.createElement("source");
  (t.type = "video/mp4"), (t.src = e), n.appendChild(t);
}
function _A(n) {
  return n === "audio" ? 1 : 0;
}
class aM {
  constructor(e) {
    (this.hls = void 0),
      (this.autoLevelCapping = void 0),
      (this.firstLevel = void 0),
      (this.media = void 0),
      (this.restrictedLevels = void 0),
      (this.timer = void 0),
      (this.clientRect = void 0),
      (this.streamController = void 0),
      (this.hls = e),
      (this.autoLevelCapping = Number.POSITIVE_INFINITY),
      (this.firstLevel = -1),
      (this.media = null),
      (this.restrictedLevels = []),
      (this.timer = void 0),
      (this.clientRect = null),
      this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.hls && this.unregisterListener(),
      this.timer && this.stopCapping(),
      (this.media = null),
      (this.clientRect = null),
      (this.hls = this.streamController = null);
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on($.BUFFER_CODECS, this.onBufferCodecs, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const { hls: e } = this;
    e.off($.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off($.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, t) {
    const s = this.hls.levels[t.droppedLevel];
    this.isLevelAllowed(s) &&
      this.restrictedLevels.push({
        bitrate: s.bitrate,
        height: s.height,
        width: s.width,
      });
  }
  onMediaAttaching(e, t) {
    (this.media = t.media instanceof HTMLVideoElement ? t.media : null),
      (this.clientRect = null),
      this.timer && this.hls.levels.length && this.detectPlayerSize();
  }
  onManifestParsed(e, t) {
    const s = this.hls;
    (this.restrictedLevels = []),
      (this.firstLevel = t.firstLevel),
      s.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onLevelsUpdated(e, t) {
    this.timer && Qe(this.autoLevelCapping) && this.detectPlayerSize();
  }
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping(), (this.media = null);
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const e = this.hls.levels;
      if (e.length) {
        const t = this.hls,
          s = this.getMaxLevel(e.length - 1);
        s !== this.autoLevelCapping &&
          t.logger.log(
            `Setting autoLevelCapping to ${s}: ${e[s].height}p@${e[s].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`
          ),
          (t.autoLevelCapping = s),
          t.autoLevelEnabled &&
            t.autoLevelCapping > this.autoLevelCapping &&
            this.streamController &&
            this.streamController.nextLevelSwitch(),
          (this.autoLevelCapping = t.autoLevelCapping);
      }
    }
  }
  getMaxLevel(e) {
    const t = this.hls.levels;
    if (!t.length) return -1;
    const s = t.filter((r, i) => this.isLevelAllowed(r) && i <= e);
    return (
      (this.clientRect = null),
      aM.getMaxLevelByMediaSize(s, this.mediaWidth, this.mediaHeight)
    );
  }
  startCapping() {
    this.timer ||
      ((this.autoLevelCapping = Number.POSITIVE_INFINITY),
      self.clearInterval(this.timer),
      (this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3)),
      this.detectPlayerSize());
  }
  stopCapping() {
    (this.restrictedLevels = []),
      (this.firstLevel = -1),
      (this.autoLevelCapping = Number.POSITIVE_INFINITY),
      this.timer && (self.clearInterval(this.timer), (this.timer = void 0));
  }
  getDimensions() {
    if (this.clientRect) return this.clientRect;
    const e = this.media,
      t = { width: 0, height: 0 };
    if (e) {
      const s = e.getBoundingClientRect();
      (t.width = s.width),
        (t.height = s.height),
        !t.width &&
          !t.height &&
          ((t.width = s.right - s.left || e.width || 0),
          (t.height = s.bottom - s.top || e.height || 0));
    }
    return (this.clientRect = t), t;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {}
    return Math.min(e, this.hls.config.maxDevicePixelRatio);
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some(
      (s) =>
        e.bitrate === s.bitrate && e.width === s.width && e.height === s.height
    );
  }
  static getMaxLevelByMediaSize(e, t, s) {
    if (!(e != null && e.length)) return -1;
    const r = (o, l) => (l ? o.width !== l.width || o.height !== l.height : !0);
    let i = e.length - 1;
    const a = Math.max(t, s);
    for (let o = 0; o < e.length; o += 1) {
      const l = e[o];
      if ((l.width >= a || l.height >= a) && r(l, e[o + 1])) {
        i = o;
        break;
      }
    }
    return i;
  }
}
const CCe = {
    MANIFEST: "m",
    AUDIO: "a",
    VIDEO: "v",
    MUXED: "av",
    INIT: "i",
    CAPTION: "c",
    TIMED_TEXT: "tt",
    KEY: "k",
    OTHER: "o",
  },
  Kr = CCe,
  ICe = { HLS: "h" },
  LCe = ICe,
  DCe = "CMCD-Object",
  PCe = "CMCD-Request",
  MCe = "CMCD-Session",
  NCe = "CMCD-Status",
  Bp = { OBJECT: DCe, REQUEST: PCe, SESSION: MCe, STATUS: NCe },
  OCe = {
    [Bp.OBJECT]: [
      "br",
      "ab",
      "d",
      "ot",
      "tb",
      "tpb",
      "lb",
      "tab",
      "lab",
      "url",
    ],
    [Bp.REQUEST]: [
      "pb",
      "bl",
      "tbl",
      "dl",
      "ltc",
      "mtp",
      "nor",
      "nrr",
      "rc",
      "sn",
      "sta",
      "su",
      "ttfb",
      "ttfbb",
      "ttlb",
      "cmsdd",
      "cmsds",
      "smrt",
      "df",
      "cs",
    ],
    [Bp.SESSION]: ["cid", "pr", "sf", "sid", "st", "v", "msd"],
    [Bp.STATUS]: ["bs", "bsd", "cdn", "rtp", "bg", "pt", "ec", "e"],
  };
class Nf {
  constructor(e, t) {
    Array.isArray(e) && (e = e.map((s) => (s instanceof Nf ? s : new Nf(s)))),
      (this.value = e),
      (this.params = t);
  }
}
const jCe = "Dict";
function FCe(n) {
  return Array.isArray(n)
    ? JSON.stringify(n)
    : n instanceof Map
    ? "Map{}"
    : n instanceof Set
    ? "Set{}"
    : typeof n == "object"
    ? JSON.stringify(n)
    : String(n);
}
function UCe(n, e, t, s) {
  return new Error(`failed to ${n} "${FCe(e)}" as ${t}`, { cause: s });
}
function No(n, e, t) {
  return UCe("serialize", n, e, t);
}
class rX {
  constructor(e) {
    this.description = e;
  }
}
const u5 = "Bare Item",
  $Ce = "Boolean";
function BCe(n) {
  if (typeof n != "boolean") throw No(n, $Ce);
  return n ? "?1" : "?0";
}
function HCe(n) {
  return btoa(String.fromCharCode(...n));
}
const VCe = "Byte Sequence";
function zCe(n) {
  if (ArrayBuffer.isView(n) === !1) throw No(n, VCe);
  return `:${HCe(n)}:`;
}
const GCe = "Integer";
function qCe(n) {
  return n < -999999999999999 || 999999999999999 < n;
}
function iX(n) {
  if (qCe(n)) throw No(n, GCe);
  return n.toString();
}
function WCe(n) {
  return `@${iX(n.getTime() / 1e3)}`;
}
function aX(n, e) {
  if (n < 0) return -aX(-n, e);
  const t = Math.pow(10, e);
  if (Math.abs(((n * t) % 1) - 0.5) < Number.EPSILON) {
    const r = Math.floor(n * t);
    return (r % 2 === 0 ? r : r + 1) / t;
  } else return Math.round(n * t) / t;
}
const KCe = "Decimal";
function YCe(n) {
  const e = aX(n, 3);
  if (Math.floor(Math.abs(e)).toString().length > 12) throw No(n, KCe);
  const t = e.toString();
  return t.includes(".") ? t : `${t}.0`;
}
const XCe = "String",
  QCe = /[\x00-\x1f\x7f]+/;
function ZCe(n) {
  if (QCe.test(n)) throw No(n, XCe);
  return `"${n.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function JCe(n) {
  return n.description || n.toString().slice(7, -1);
}
const eIe = "Token";
function d5(n) {
  const e = JCe(n);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1) throw No(e, eIe);
  return e;
}
function fI(n) {
  switch (typeof n) {
    case "number":
      if (!Qe(n)) throw No(n, u5);
      return Number.isInteger(n) ? iX(n) : YCe(n);
    case "string":
      return ZCe(n);
    case "symbol":
      return d5(n);
    case "boolean":
      return BCe(n);
    case "object":
      if (n instanceof Date) return WCe(n);
      if (n instanceof Uint8Array) return zCe(n);
      if (n instanceof rX) return d5(n);
    default:
      throw No(n, u5);
  }
}
const tIe = "Key";
function mI(n) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(n) === !1) throw No(n, tIe);
  return n;
}
function oM(n) {
  return n == null
    ? ""
    : Object.entries(n)
        .map(([e, t]) => (t === !0 ? `;${mI(e)}` : `;${mI(e)}=${fI(t)}`))
        .join("");
}
function oX(n) {
  return n instanceof Nf ? `${fI(n.value)}${oM(n.params)}` : fI(n);
}
function nIe(n) {
  return `(${n.value.map(oX).join(" ")})${oM(n.params)}`;
}
function sIe(n, e = { whitespace: !0 }) {
  if (typeof n != "object") throw No(n, jCe);
  const t = n instanceof Map ? n.entries() : Object.entries(n),
    s = e?.whitespace ? " " : "";
  return Array.from(t)
    .map(([r, i]) => {
      i instanceof Nf || (i = new Nf(i));
      let a = mI(r);
      return (
        i.value === !0
          ? (a += oM(i.params))
          : ((a += "="), Array.isArray(i.value) ? (a += nIe(i)) : (a += oX(i))),
        a
      );
    })
    .join(`,${s}`);
}
function rIe(n, e) {
  return sIe(n, e);
}
function iIe(n) {
  return ["ot", "sf", "st", "e", "sta"].includes(n);
}
function aIe(n) {
  return typeof n == "number" ? Qe(n) : n != null && n !== "" && n !== !1;
}
function oIe(n, e) {
  const t = new URL(n),
    s = new URL(e);
  if (t.origin !== s.origin) return n;
  const r = t.pathname.split("/").slice(1),
    i = s.pathname.split("/").slice(1, -1);
  for (; r[0] === i[0]; ) r.shift(), i.shift();
  for (; i.length; ) i.shift(), r.unshift("..");
  return r.join("/");
}
const ax = (n) => Math.round(n),
  lIe = (n, e) => (
    e?.baseUrl && (n = oIe(n, e.baseUrl)), encodeURIComponent(n)
  ),
  ib = (n) => ax(n / 100) * 100,
  cIe = { br: ax, d: ax, bl: ib, dl: ib, mtp: ib, nor: lIe, rtp: ib, tb: ax };
function uIe(n, e) {
  const t = {};
  if (n == null || typeof n != "object") return t;
  const s = Object.keys(n).sort(),
    r = Tn({}, cIe, e?.formatters),
    i = e?.filter;
  return (
    s.forEach((a) => {
      if (i?.(a) === !1) return;
      let o = n[a];
      const l = r[a];
      l && (o = l(o, e)),
        !(a === "v" && o === 1) &&
          ((a == "pr" && o === 1) ||
            (aIe(o) &&
              (iIe(a) && typeof o == "string" && (o = new rX(o)), (t[a] = o))));
    }),
    t
  );
}
function lX(n, e = {}) {
  return n ? rIe(uIe(n, e), Tn({ whitespace: !1 }, e)) : "";
}
function dIe(n, e = {}) {
  const t = {};
  if (!n) return t;
  const s = Object.entries(n),
    r = Object.entries(OCe).concat(Object.entries(e?.customHeaderMap || {})),
    i = s.reduce((a, o) => {
      var l, c;
      const [h, m] = o,
        p =
          ((l = r.find((g) => g[1].includes(h))) === null || l === void 0
            ? void 0
            : l[0]) || Bp.REQUEST;
      return (
        ((c = a[p]) !== null && c !== void 0) || (a[p] = {}), (a[p][h] = m), a
      );
    }, {});
  return Object.entries(i).reduce((a, [o, l]) => ((a[o] = lX(l, e)), a), t);
}
function hIe(n, e, t) {
  return Tn(n, dIe(e, t));
}
const fIe = "CMCD";
function mIe(n, e = {}) {
  if (!n) return "";
  const t = lX(n, e);
  return `${fIe}=${encodeURIComponent(t)}`;
}
const h5 = /CMCD=[^&#]+/;
function pIe(n, e, t) {
  const s = mIe(e, t);
  if (!s) return n;
  if (h5.test(n)) return n.replace(h5, s);
  const r = n.includes("?") ? "&" : "?";
  return `${n}${r}${s}`;
}
class gIe {
  constructor(e) {
    (this.hls = void 0),
      (this.config = void 0),
      (this.media = void 0),
      (this.sid = void 0),
      (this.cid = void 0),
      (this.useHeaders = !1),
      (this.includeKeys = void 0),
      (this.initialized = !1),
      (this.starved = !1),
      (this.buffering = !0),
      (this.audioBuffer = void 0),
      (this.videoBuffer = void 0),
      (this.onWaiting = () => {
        this.initialized && (this.starved = !0), (this.buffering = !0);
      }),
      (this.onPlaying = () => {
        this.initialized || (this.initialized = !0), (this.buffering = !1);
      }),
      (this.applyPlaylistData = (r) => {
        try {
          this.apply(r, { ot: Kr.MANIFEST, su: !this.initialized });
        } catch (i) {
          this.hls.logger.warn("Could not generate manifest CMCD data.", i);
        }
      }),
      (this.applyFragmentData = (r) => {
        try {
          const { frag: i, part: a } = r,
            o = this.hls.levels[i.level],
            l = this.getObjectType(i),
            c = { d: (a || i).duration * 1e3, ot: l };
          (l === Kr.VIDEO || l === Kr.AUDIO || l == Kr.MUXED) &&
            ((c.br = o.bitrate / 1e3),
            (c.tb = this.getTopBandwidth(l) / 1e3),
            (c.bl = this.getBufferLength(l)));
          const h = a ? this.getNextPart(a) : this.getNextFrag(i);
          h != null && h.url && h.url !== i.url && (c.nor = h.url),
            this.apply(r, c);
        } catch (i) {
          this.hls.logger.warn("Could not generate segment CMCD data.", i);
        }
      }),
      (this.hls = e);
    const t = (this.config = e.config),
      { cmcd: s } = t;
    s != null &&
      ((t.pLoader = this.createPlaylistLoader()),
      (t.fLoader = this.createFragmentLoader()),
      (this.sid = s.sessionId || e.sessionId),
      (this.cid = s.contentId),
      (this.useHeaders = s.useHeaders === !0),
      (this.includeKeys = s.includeKeys),
      this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHED, this.onMediaDetached, this),
      e.on($.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHED, this.onMediaDetached, this),
      e.off($.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetached(),
      (this.hls = this.config = this.audioBuffer = this.videoBuffer = null),
      (this.onWaiting = this.onPlaying = this.media = null);
  }
  onMediaAttached(e, t) {
    (this.media = t.media),
      this.media.addEventListener("waiting", this.onWaiting),
      this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media &&
      (this.media.removeEventListener("waiting", this.onWaiting),
      this.media.removeEventListener("playing", this.onPlaying),
      (this.media = null));
  }
  onBufferCreated(e, t) {
    var s, r;
    (this.audioBuffer = (s = t.tracks.audio) == null ? void 0 : s.buffer),
      (this.videoBuffer = (r = t.tracks.video) == null ? void 0 : r.buffer);
  }
  createData() {
    var e;
    return {
      v: 1,
      sf: LCe.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3,
    };
  }
  apply(e, t = {}) {
    Tn(t, this.createData());
    const s = t.ot === Kr.INIT || t.ot === Kr.VIDEO || t.ot === Kr.MUXED;
    this.starved && s && ((t.bs = !0), (t.su = !0), (this.starved = !1)),
      t.su == null && (t.su = this.buffering);
    const { includeKeys: r } = this;
    r &&
      (t = Object.keys(t).reduce(
        (a, o) => (r.includes(o) && (a[o] = t[o]), a),
        {}
      ));
    const i = { baseUrl: e.url };
    this.useHeaders
      ? (e.headers || (e.headers = {}), hIe(e.headers, t, i))
      : (e.url = pIe(e.url, t, i));
  }
  getNextFrag(e) {
    var t;
    const s = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;
    if (s) {
      const r = e.sn - s.startSN;
      return s.fragments[r + 1];
    }
  }
  getNextPart(e) {
    var t, s;
    const { index: r, fragment: i } = e,
      a =
        (t = this.hls.levels[i.level]) == null || (s = t.details) == null
          ? void 0
          : s.partList;
    if (a) {
      const { sn: o } = i;
      for (let l = a.length - 1; l >= 0; l--) {
        const c = a[l];
        if (c.index === r && c.fragment.sn === o) return a[l + 1];
      }
    }
  }
  getObjectType(e) {
    const { type: t } = e;
    if (t === "subtitle") return Kr.TIMED_TEXT;
    if (e.sn === "initSegment") return Kr.INIT;
    if (t === "audio") return Kr.AUDIO;
    if (t === "main") return this.hls.audioTracks.length ? Kr.VIDEO : Kr.MUXED;
  }
  getTopBandwidth(e) {
    let t = 0,
      s;
    const r = this.hls;
    if (e === Kr.AUDIO) s = r.audioTracks;
    else {
      const i = r.maxAutoLevel,
        a = i > -1 ? i + 1 : r.levels.length;
      s = r.levels.slice(0, a);
    }
    return (
      s.forEach((i) => {
        i.bitrate > t && (t = i.bitrate);
      }),
      t > 0 ? t : NaN
    );
  }
  getBufferLength(e) {
    const t = this.media,
      s = e === Kr.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !s || !t
      ? NaN
      : Ft.bufferInfo(s, t.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  createPlaylistLoader() {
    const { pLoader: e } = this.config,
      t = this.applyPlaylistData,
      s = e || this.config.loader;
    return class {
      constructor(i) {
        (this.loader = void 0), (this.loader = new s(i));
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(i, a, o) {
        t(i), this.loader.load(i, a, o);
      }
    };
  }
  createFragmentLoader() {
    const { fLoader: e } = this.config,
      t = this.applyFragmentData,
      s = e || this.config.loader;
    return class {
      constructor(i) {
        (this.loader = void 0), (this.loader = new s(i));
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(i, a, o) {
        t(i), this.loader.load(i, a, o);
      }
    };
  }
}
const vIe = 3e5;
class yIe extends za {
  constructor(e) {
    super("content-steering", e.logger),
      (this.hls = void 0),
      (this.loader = null),
      (this.uri = null),
      (this.pathwayId = "."),
      (this._pathwayPriority = null),
      (this.timeToLoad = 300),
      (this.reloadTimer = -1),
      (this.updated = 0),
      (this.started = !1),
      (this.enabled = !0),
      (this.levels = null),
      (this.audioTracks = null),
      (this.subtitleTracks = null),
      (this.penalizedPathways = {}),
      (this.hls = e),
      this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e &&
      (e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.ERROR, this.onError, this));
  }
  pathways() {
    return (this.levels || []).reduce(
      (e, t) => (e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId), e),
      []
    );
  }
  get pathwayPriority() {
    return this._pathwayPriority;
  }
  set pathwayPriority(e) {
    this.updatePathwayPriority(e);
  }
  startLoad() {
    if (((this.started = !0), this.clearTimeout(), this.enabled && this.uri)) {
      if (this.updated) {
        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
        if (e > 0) {
          this.scheduleRefresh(this.uri, e);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    (this.started = !1),
      this.loader && (this.loader.destroy(), (this.loader = null)),
      this.clearTimeout();
  }
  clearTimeout() {
    this.reloadTimer !== -1 &&
      (self.clearTimeout(this.reloadTimer), (this.reloadTimer = -1));
  }
  destroy() {
    this.unregisterListeners(),
      this.stopLoad(),
      (this.hls = null),
      (this.levels = this.audioTracks = this.subtitleTracks = null);
  }
  removeLevel(e) {
    const t = this.levels;
    t && (this.levels = t.filter((s) => s !== e));
  }
  onManifestLoading() {
    this.stopLoad(),
      (this.enabled = !0),
      (this.timeToLoad = 300),
      (this.updated = 0),
      (this.uri = null),
      (this.pathwayId = "."),
      (this.levels = this.audioTracks = this.subtitleTracks = null);
  }
  onManifestLoaded(e, t) {
    const { contentSteering: s } = t;
    s !== null &&
      ((this.pathwayId = s.pathwayId),
      (this.uri = s.uri),
      this.started && this.startLoad());
  }
  onManifestParsed(e, t) {
    (this.audioTracks = t.audioTracks),
      (this.subtitleTracks = t.subtitleTracks);
  }
  onError(e, t) {
    const { errorAction: s } = t;
    if (
      s?.action === kr.SendAlternateToPenaltyBox &&
      s.flags === _a.MoveAllAlternatesMatchingHost
    ) {
      const r = this.levels;
      let i = this._pathwayPriority,
        a = this.pathwayId;
      if (t.context) {
        const { groupId: o, pathwayId: l, type: c } = t.context;
        o && r ? (a = this.getPathwayForGroupId(o, c, a)) : l && (a = l);
      }
      a in this.penalizedPathways ||
        (this.penalizedPathways[a] = performance.now()),
        !i && r && (i = this.pathways()),
        i &&
          i.length > 1 &&
          (this.updatePathwayPriority(i), (s.resolved = this.pathwayId !== a)),
        t.details === we.BUFFER_APPEND_ERROR && !t.fatal
          ? (s.resolved = !0)
          : s.resolved ||
            this.warn(
              `Could not resolve ${t.details} ("${
                t.error.message
              }") with content-steering for Pathway: ${a} levels: ${
                r && r.length
              } priorities: ${Wn(i)} penalized: ${Wn(this.penalizedPathways)}`
            );
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let t = this.getLevelsForPathway(this.pathwayId);
    if (t.length === 0) {
      const s = e[0].pathwayId;
      this.log(
        `No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${s}"`
      ),
        (t = this.getLevelsForPathway(s)),
        (this.pathwayId = s);
    }
    return (
      t.length !== e.length &&
        this.log(
          `Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`
        ),
      t
    );
  }
  getLevelsForPathway(e) {
    return this.levels === null
      ? []
      : this.levels.filter((t) => e === t.pathwayId);
  }
  updatePathwayPriority(e) {
    this._pathwayPriority = e;
    let t;
    const s = this.penalizedPathways,
      r = performance.now();
    Object.keys(s).forEach((i) => {
      r - s[i] > vIe && delete s[i];
    });
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      if (a in s) continue;
      if (a === this.pathwayId) return;
      const o = this.hls.nextLoadLevel,
        l = this.hls.levels[o];
      if (((t = this.getLevelsForPathway(a)), t.length > 0)) {
        this.log(`Setting Pathway to "${a}"`),
          (this.pathwayId = a),
          PY(t),
          this.hls.trigger($.LEVELS_UPDATED, { levels: t });
        const c = this.hls.levels[o];
        l &&
          c &&
          this.levels &&
          (c.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] &&
            c.bitrate !== l.bitrate &&
            this.log(
              `Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`
            ),
          (this.hls.nextLoadLevel = o));
        break;
      }
    }
  }
  getPathwayForGroupId(e, t, s) {
    const r = this.getLevelsForPathway(s).concat(this.levels || []);
    for (let i = 0; i < r.length; i++)
      if (
        (t === en.AUDIO_TRACK && r[i].hasAudioGroup(e)) ||
        (t === en.SUBTITLE_TRACK && r[i].hasSubtitleGroup(e))
      )
        return r[i].pathwayId;
    return s;
  }
  clonePathways(e) {
    const t = this.levels;
    if (!t) return;
    const s = {},
      r = {};
    e.forEach((i) => {
      const { ID: a, "BASE-ID": o, "URI-REPLACEMENT": l } = i;
      if (t.some((h) => h.pathwayId === a)) return;
      const c = this.getLevelsForPathway(o).map((h) => {
        const m = new rs(h.attrs);
        m["PATHWAY-ID"] = a;
        const p = m.AUDIO && `${m.AUDIO}_clone_${a}`,
          g = m.SUBTITLES && `${m.SUBTITLES}_clone_${a}`;
        p && ((s[m.AUDIO] = p), (m.AUDIO = p)),
          g && ((r[m.SUBTITLES] = g), (m.SUBTITLES = g));
        const y = cX(h.uri, m["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l),
          b = new fv({
            attrs: m,
            audioCodec: h.audioCodec,
            bitrate: h.bitrate,
            height: h.height,
            name: h.name,
            url: y,
            videoCodec: h.videoCodec,
            width: h.width,
          });
        if (h.audioGroups)
          for (let w = 1; w < h.audioGroups.length; w++)
            b.addGroupId("audio", `${h.audioGroups[w]}_clone_${a}`);
        if (h.subtitleGroups)
          for (let w = 1; w < h.subtitleGroups.length; w++)
            b.addGroupId("text", `${h.subtitleGroups[w]}_clone_${a}`);
        return b;
      });
      t.push(...c),
        f5(this.audioTracks, s, l, a),
        f5(this.subtitleTracks, r, l, a);
    });
  }
  loadSteeringManifest(e) {
    const t = this.hls.config,
      s = t.loader;
    this.loader && this.loader.destroy(), (this.loader = new s(t));
    let r;
    try {
      r = new self.URL(e);
    } catch {
      (this.enabled = !1),
        this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (r.protocol !== "data:") {
      const h = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
      r.searchParams.set("_HLS_pathway", this.pathwayId),
        r.searchParams.set("_HLS_throughput", "" + h);
    }
    const i = { responseType: "json", url: r.href },
      a = t.steeringManifestLoadPolicy.default,
      o = a.errorRetry || a.timeoutRetry || {},
      l = {
        loadPolicy: a,
        timeout: a.maxLoadTimeMs,
        maxRetry: o.maxNumRetry || 0,
        retryDelay: o.retryDelayMs || 0,
        maxRetryDelay: o.maxRetryDelayMs || 0,
      },
      c = {
        onSuccess: (h, m, p, g) => {
          this.log(`Loaded steering manifest: "${r}"`);
          const y = h.data;
          if (y?.VERSION !== 1) {
            this.log(`Steering VERSION ${y.VERSION} not supported!`);
            return;
          }
          (this.updated = performance.now()), (this.timeToLoad = y.TTL);
          const {
            "RELOAD-URI": b,
            "PATHWAY-CLONES": w,
            "PATHWAY-PRIORITY": S,
          } = y;
          if (b)
            try {
              this.uri = new self.URL(b, r).href;
            } catch {
              (this.enabled = !1),
                this.log(`Failed to parse Steering Manifest RELOAD-URI: ${b}`);
              return;
            }
          this.scheduleRefresh(this.uri || p.url), w && this.clonePathways(w);
          const A = { steeringManifest: y, url: r.toString() };
          this.hls.trigger($.STEERING_MANIFEST_LOADED, A),
            S && this.updatePathwayPriority(S);
        },
        onError: (h, m, p, g) => {
          if (
            (this.log(
              `Error loading steering manifest: ${h.code} ${h.text} (${m.url})`
            ),
            this.stopLoad(),
            h.code === 410)
          ) {
            (this.enabled = !1),
              this.log(`Steering manifest ${m.url} no longer available`);
            return;
          }
          let y = this.timeToLoad * 1e3;
          if (h.code === 429) {
            const b = this.loader;
            if (typeof b?.getResponseHeader == "function") {
              const w = b.getResponseHeader("Retry-After");
              w && (y = parseFloat(w) * 1e3);
            }
            this.log(`Steering manifest ${m.url} rate limited`);
            return;
          }
          this.scheduleRefresh(this.uri || m.url, y);
        },
        onTimeout: (h, m, p) => {
          this.log(`Timeout loading steering manifest (${m.url})`),
            this.scheduleRefresh(this.uri || m.url);
        },
      };
    this.log(`Requesting steering manifest: ${r}`), this.loader.load(i, l, c);
  }
  scheduleRefresh(e, t = this.timeToLoad * 1e3) {
    this.clearTimeout(),
      (this.reloadTimer = self.setTimeout(() => {
        var s;
        const r = (s = this.hls) == null ? void 0 : s.media;
        if (r && !r.ended) {
          this.loadSteeringManifest(e);
          return;
        }
        this.scheduleRefresh(e, this.timeToLoad * 1e3);
      }, t));
  }
}
function f5(n, e, t, s) {
  n &&
    Object.keys(e).forEach((r) => {
      const i = n
        .filter((a) => a.groupId === r)
        .map((a) => {
          const o = Tn({}, a);
          return (
            (o.details = void 0),
            (o.attrs = new rs(o.attrs)),
            (o.url = o.attrs.URI =
              cX(
                a.url,
                a.attrs["STABLE-RENDITION-ID"],
                "PER-RENDITION-URIS",
                t
              )),
            (o.groupId = o.attrs["GROUP-ID"] = e[r]),
            (o.attrs["PATHWAY-ID"] = s),
            o
          );
        });
      n.push(...i);
    });
}
function cX(n, e, t, s) {
  const { HOST: r, PARAMS: i, [t]: a } = s;
  let o;
  e && ((o = a?.[e]), o && (n = o));
  const l = new self.URL(n);
  return (
    r && !o && (l.host = r),
    i &&
      Object.keys(i)
        .sort()
        .forEach((c) => {
          c && l.searchParams.set(c, i[c]);
        }),
    l.href
  );
}
function na(n, e, t) {
  La(n, e, t), n.addEventListener(e, t);
}
function La(n, e, t) {
  n.removeEventListener(e, t);
}
class ff extends za {
  constructor(e) {
    super("eme", e.logger),
      (this.hls = void 0),
      (this.config = void 0),
      (this.media = null),
      (this.keyFormatPromise = null),
      (this.keySystemAccessPromises = {}),
      (this._requestLicenseFailureCount = 0),
      (this.mediaKeySessions = []),
      (this.keyIdToKeySessionPromise = {}),
      (this.mediaKeys = null),
      (this.setMediaKeysQueue = ff.CDMCleanupPromise
        ? [ff.CDMCleanupPromise]
        : []),
      (this.onWaitingForKey = (t) => {
        this.log(`"${t.type}" event`);
      }),
      (this.hls = e),
      (this.config = e.config),
      this.registerListeners();
  }
  destroy() {
    this.onDestroying(), this.onMediaDetached();
    const e = this.config;
    (e.requestMediaKeySystemAccessFunc = null),
      (e.licenseXhrSetup = e.licenseResponseCallback = void 0),
      (e.drmSystems = e.drmSystemOptions = {}),
      (this.hls = this.config = this.keyIdToKeySessionPromise = null),
      (this.onWaitingForKey = null);
  }
  registerListeners() {
    this.hls.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.on($.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.on($.MANIFEST_LOADED, this.onManifestLoaded, this),
      this.hls.on($.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    this.hls.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.off($.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.off($.MANIFEST_LOADED, this.onManifestLoaded, this),
      this.hls.off($.DESTROYING, this.onDestroying, this);
  }
  getLicenseServerUrl(e) {
    const { drmSystems: t, widevineLicenseUrl: s } = this.config,
      r = t[e];
    if (r) return r.licenseUrl;
    if (e === Rs.WIDEVINE && s) return s;
  }
  getLicenseServerUrlOrThrow(e) {
    const t = this.getLicenseServerUrl(e);
    if (t === void 0)
      throw new Error(`no license server URL configured for key-system "${e}"`);
    return t;
  }
  getServerCertificateUrl(e) {
    const { drmSystems: t } = this.config,
      s = t[e];
    if (s) return s.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels,
      s = (a, o, l) => !!a && l.indexOf(a) === o,
      r = t.map((a) => a.audioCodec).filter(s),
      i = t.map((a) => a.videoCodec).filter(s);
    return (
      r.length + i.length === 0 && i.push("avc1.42e01e"),
      new Promise((a, o) => {
        const l = (c) => {
          const h = c.shift();
          this.getMediaKeysPromise(h, r, i)
            .then((m) => a({ keySystem: h, mediaKeys: m }))
            .catch((m) => {
              c.length
                ? l(c)
                : m instanceof qi
                ? o(m)
                : o(
                    new qi(
                      {
                        type: gt.KEY_SYSTEM_ERROR,
                        details: we.KEY_SYSTEM_NO_ACCESS,
                        error: m,
                        fatal: !0,
                      },
                      m.message
                    )
                  );
            });
        };
        l(e);
      })
    );
  }
  requestMediaKeySystemAccess(e, t) {
    const { requestMediaKeySystemAccessFunc: s } = this.config;
    if (typeof s != "function") {
      let r = `Configured requestMediaKeySystemAccess is not a function ${s}`;
      return (
        AY === null &&
          self.location.protocol === "http:" &&
          (r = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
        Promise.reject(new Error(r))
      );
    }
    return s(e, t);
  }
  getMediaKeysPromise(e, t, s) {
    const r = cke(e, t, s, this.config.drmSystemOptions),
      i = this.keySystemAccessPromises[e];
    let a = i?.keySystemAccess;
    if (!a) {
      this.log(
        `Requesting encrypted media "${e}" key-system access with config: ${Wn(
          r
        )}`
      ),
        (a = this.requestMediaKeySystemAccess(e, r));
      const o = (this.keySystemAccessPromises[e] = { keySystemAccess: a });
      return (
        a.catch((l) => {
          this.log(`Failed to obtain access to key-system "${e}": ${l}`);
        }),
        a.then((l) => {
          this.log(`Access for key-system "${l.keySystem}" obtained`);
          const c = this.fetchServerCertificate(e);
          return (
            this.log(`Create media-keys for "${e}"`),
            (o.mediaKeys = l
              .createMediaKeys()
              .then(
                (h) => (
                  this.log(`Media-keys created for "${e}"`),
                  (o.hasMediaKeys = !0),
                  c.then((m) =>
                    m ? this.setMediaKeysServerCertificate(h, e, m) : h
                  )
                )
              )),
            o.mediaKeys.catch((h) => {
              this.error(`Failed to create media-keys for "${e}"}: ${h}`);
            }),
            o.mediaKeys
          );
        })
      );
    }
    return a.then(() => i.mediaKeys);
  }
  createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: s }) {
    this.log(
      `Creating key-system session "${t}" keyId: ${Nu.hexDump(e.keyId || [])}`
    );
    const r = s.createSession(),
      i = {
        decryptdata: e,
        keySystem: t,
        mediaKeys: s,
        mediaKeysSession: r,
        keyStatus: "status-pending",
      };
    return this.mediaKeySessions.push(i), i;
  }
  renewKeySession(e) {
    const t = e.decryptdata;
    if (t.pssh) {
      const s = this.createMediaKeySessionContext(e),
        r = this.getKeyIdString(t),
        i = "cenc";
      this.keyIdToKeySessionPromise[r] =
        this.generateRequestWithPreferredKeySession(
          s,
          i,
          t.pssh.buffer,
          "expired"
        );
    } else this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  getKeyIdString(e) {
    if (!e) throw new Error("Could not read keyId of undefined decryptdata");
    if (e.keyId === null) throw new Error("keyId is null");
    return Nu.hexDump(e.keyId);
  }
  updateKeySession(e, t) {
    var s;
    const r = e.mediaKeysSession;
    return (
      this.log(`Updating key-session "${r.sessionId}" for keyID ${Nu.hexDump(
        ((s = e.decryptdata) == null ? void 0 : s.keyId) || []
      )}
      } (data length: ${t && t.byteLength})`),
      r.update(t)
    );
  }
  getSelectedKeySystemFormats() {
    return Object.keys(this.keySystemAccessPromises)
      .map((e) => ({
        keySystem: e,
        hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys,
      }))
      .filter(({ hasMediaKeys: e }) => !!e)
      .map(({ keySystem: e }) => UB(e))
      .filter((e) => !!e);
  }
  getKeySystemAccess(e) {
    return this.getKeySystemSelectionPromise(e).then(
      ({ keySystem: t, mediaKeys: s }) => this.attemptSetMediaKeys(t, s)
    );
  }
  selectKeySystem(e) {
    return new Promise((t, s) =>
      this.getKeySystemSelectionPromise(e)
        .then(({ keySystem: r }) => {
          const i = UB(r);
          i
            ? t(i)
            : s(new Error(`Unable to find format for key-system "${r}"`));
        })
        .catch(s)
    );
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {});
    return (
      this.keyFormatPromise ||
        (this.log(
          `Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${
            e.level
          }) key formats ${t.join(", ")}`
        ),
        (this.keyFormatPromise = this.getKeyFormatPromise(t))),
      this.keyFormatPromise
    );
  }
  getKeyFormatPromise(e) {
    const t = sx(this.config),
      s = e.map(oI).filter((r) => !!r && t.indexOf(r) !== -1);
    return this.selectKeySystem(s);
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata,
      s = this.getKeyIdString(t),
      r = `(keyId: ${s} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
    this.log(`Starting session for key ${r}`);
    let i = this.keyIdToKeySessionPromise[s];
    return (
      i ||
        ((i = this.getKeySystemForKeyPromise(t).then(
          ({ keySystem: o, mediaKeys: l }) => (
            this.throwIfDestroyed(),
            this.log(
              `Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`
            ),
            this.attemptSetMediaKeys(o, l).then(
              () => (
                this.throwIfDestroyed(),
                this.createMediaKeySessionContext({
                  keySystem: o,
                  mediaKeys: l,
                  decryptdata: t,
                })
              )
            )
          )
        )),
        (this.keyIdToKeySessionPromise[s] = i.then((o) => {
          const l = "cenc",
            c = t.pssh ? t.pssh.buffer : null;
          return this.generateRequestWithPreferredKeySession(
            o,
            l,
            c,
            "playlist-key"
          );
        })).catch((o) => this.handleError(o))),
      i
    );
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls) throw new Error("invalid state");
  }
  handleError(e) {
    this.hls &&
      (this.error(e.message),
      e instanceof qi
        ? this.hls.trigger($.ERROR, e.data)
        : this.hls.trigger($.ERROR, {
            type: gt.KEY_SYSTEM_ERROR,
            details: we.KEY_SYSTEM_NO_KEYS,
            error: e,
            fatal: !0,
          }));
  }
  getKeySystemForKeyPromise(e) {
    const t = this.getKeyIdString(e),
      s = this.keyIdToKeySessionPromise[t];
    if (!s) {
      const r = oI(e.keyFormat),
        i = r ? [r] : sx(this.config);
      return this.attemptKeySystemAccess(i);
    }
    return s;
  }
  getKeySystemSelectionPromise(e) {
    if ((e.length || (e = sx(this.config)), e.length === 0))
      throw new qi(
        {
          type: gt.KEY_SYSTEM_ERROR,
          details: we.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
          fatal: !0,
        },
        `Missing key-system license configuration options ${Wn({
          drmSystems: this.config.drmSystems,
        })}`
      );
    return this.attemptKeySystemAccess(e);
  }
  attemptSetMediaKeys(e, t) {
    if (this.mediaKeys === t) return Promise.resolve();
    const s = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const r = Promise.all(s).then(() => {
      if (!this.media)
        throw (
          ((this.mediaKeys = null),
          new Error(
            "Attempted to set mediaKeys without media element attached"
          ))
        );
      return this.media.setMediaKeys(t);
    });
    return (
      (this.mediaKeys = t),
      this.setMediaKeysQueue.push(r),
      r.then(() => {
        this.log(`Media-keys set for "${e}"`),
          s.push(r),
          (this.setMediaKeysQueue = this.setMediaKeysQueue.filter(
            (i) => s.indexOf(i) === -1
          ));
      })
    );
  }
  generateRequestWithPreferredKeySession(e, t, s, r) {
    var i, a;
    const o =
      (i = this.config.drmSystems) == null || (a = i[e.keySystem]) == null
        ? void 0
        : a.generateRequest;
    if (o)
      try {
        const y = o.call(this.hls, t, s, e);
        if (!y)
          throw new Error(
            "Invalid response from configured generateRequest filter"
          );
        (t = y.initDataType),
          (s = y.initData ? y.initData : null),
          (e.decryptdata.pssh = s ? new Uint8Array(s) : null);
      } catch (y) {
        var l;
        if ((this.warn(y.message), (l = this.hls) != null && l.config.debug))
          throw y;
      }
    if (s === null)
      return (
        this.log(`Skipping key-session request for "${r}" (no initData)`),
        Promise.resolve(e)
      );
    const c = this.getKeyIdString(e.decryptdata);
    this.log(
      `Generating key-session request for "${r}": ${c} (init data type: ${t} length: ${
        s ? s.byteLength : null
      })`
    );
    const h = new ZP(),
      m = (e._onmessage = (y) => {
        const b = e.mediaKeysSession;
        if (!b) {
          h.emit("error", new Error("invalid state"));
          return;
        }
        const { messageType: w, message: S } = y;
        this.log(
          `"${w}" message event for session "${b.sessionId}" message size: ${S.byteLength}`
        ),
          w === "license-request" || w === "license-renewal"
            ? this.renewLicense(e, S).catch((A) => {
                h.eventNames().length
                  ? h.emit("error", A)
                  : this.handleError(A);
              })
            : w === "license-release"
            ? e.keySystem === Rs.FAIRPLAY &&
              (this.updateKeySession(e, aI("acknowledged")),
              this.removeSession(e))
            : this.warn(`unhandled media key message type "${w}"`);
      }),
      p = (e._onkeystatuseschange = (y) => {
        if (!e.mediaKeysSession) {
          h.emit("error", new Error("invalid state"));
          return;
        }
        this.onKeyStatusChange(e);
        const w = e.keyStatus;
        h.emit("keyStatus", w),
          w === "expired" &&
            (this.warn(`${e.keySystem} expired for key ${c}`),
            this.renewKeySession(e));
      });
    na(e.mediaKeysSession, "message", m),
      na(e.mediaKeysSession, "keystatuseschange", p);
    const g = new Promise((y, b) => {
      h.on("error", b),
        h.on("keyStatus", (w) => {
          w.startsWith("usable")
            ? y()
            : w === "output-restricted"
            ? b(
                new qi(
                  {
                    type: gt.KEY_SYSTEM_ERROR,
                    details: we.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                    fatal: !1,
                  },
                  "HDCP level output restricted"
                )
              )
            : w === "internal-error"
            ? b(
                new qi(
                  {
                    type: gt.KEY_SYSTEM_ERROR,
                    details: we.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                    fatal: !0,
                  },
                  `key status changed to "${w}"`
                )
              )
            : w === "expired"
            ? b(new Error("key expired while generating request"))
            : this.warn(`unhandled key status change "${w}"`);
        });
    });
    return e.mediaKeysSession
      .generateRequest(t, s)
      .then(() => {
        var y;
        this.log(
          `Request generated for key-session "${
            (y = e.mediaKeysSession) == null ? void 0 : y.sessionId
          }" keyId: ${c}`
        );
      })
      .catch((y) => {
        throw new qi(
          {
            type: gt.KEY_SYSTEM_ERROR,
            details: we.KEY_SYSTEM_NO_SESSION,
            error: y,
            fatal: !1,
          },
          `Error generating key-session request: ${y}`
        );
      })
      .then(() => g)
      .catch((y) => {
        throw (h.removeAllListeners(), this.removeSession(e), y);
      })
      .then(() => (h.removeAllListeners(), e));
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach((t, s) => {
      if (typeof s == "string" && typeof t == "object") {
        const r = s;
        (s = t), (t = r);
      }
      this.log(
        `key status change "${t}" for keyStatuses keyId: ${Nu.hexDump(
          "buffer" in s
            ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength)
            : new Uint8Array(s)
        )} session keyId: ${Nu.hexDump(
          new Uint8Array(e.decryptdata.keyId || [])
        )} uri: ${e.decryptdata.uri}`
      ),
        (e.keyStatus = t);
    });
  }
  fetchServerCertificate(e) {
    const t = this.config,
      s = t.loader,
      r = new s(t),
      i = this.getServerCertificateUrl(e);
    return i
      ? (this.log(`Fetching server certificate for "${e}"`),
        new Promise((a, o) => {
          const l = { responseType: "arraybuffer", url: i },
            c = t.certLoadPolicy.default,
            h = {
              loadPolicy: c,
              timeout: c.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0,
            },
            m = {
              onSuccess: (p, g, y, b) => {
                a(p.data);
              },
              onError: (p, g, y, b) => {
                o(
                  new qi(
                    {
                      type: gt.KEY_SYSTEM_ERROR,
                      details: we.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: y,
                      response: In({ url: l.url, data: void 0 }, p),
                    },
                    `"${e}" certificate request failed (${i}). Status: ${p.code} (${p.text})`
                  )
                );
              },
              onTimeout: (p, g, y) => {
                o(
                  new qi(
                    {
                      type: gt.KEY_SYSTEM_ERROR,
                      details: we.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: y,
                      response: { url: l.url, data: void 0 },
                    },
                    `"${e}" certificate request timed out (${i})`
                  )
                );
              },
              onAbort: (p, g, y) => {
                o(new Error("aborted"));
              },
            };
          r.load(l, h, m);
        }))
      : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, t, s) {
    return new Promise((r, i) => {
      e.setServerCertificate(s)
        .then((a) => {
          this.log(
            `setServerCertificate ${a ? "success" : "not supported by CDM"} (${
              s?.byteLength
            }) on "${t}"`
          ),
            r(e);
        })
        .catch((a) => {
          i(
            new qi(
              {
                type: gt.KEY_SYSTEM_ERROR,
                details: we.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                error: a,
                fatal: !0,
              },
              a.message
            )
          );
        });
    });
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((s) =>
      this.updateKeySession(e, new Uint8Array(s)).catch((r) => {
        throw new qi(
          {
            type: gt.KEY_SYSTEM_ERROR,
            details: we.KEY_SYSTEM_SESSION_UPDATE_FAILED,
            error: r,
            fatal: !0,
          },
          r.message
        );
      })
    );
  }
  unpackPlayReadyKeyMessage(e, t) {
    const s = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
    if (!s.includes("PlayReadyKeyMessage"))
      return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t;
    const r = new DOMParser().parseFromString(s, "application/xml"),
      i = r.querySelectorAll("HttpHeader");
    if (i.length > 0) {
      let h;
      for (let m = 0, p = i.length; m < p; m++) {
        var a, o;
        h = i[m];
        const g =
            (a = h.querySelector("name")) == null ? void 0 : a.textContent,
          y = (o = h.querySelector("value")) == null ? void 0 : o.textContent;
        g && y && e.setRequestHeader(g, y);
      }
    }
    const l = r.querySelector("Challenge"),
      c = l?.textContent;
    if (!c) throw new Error("Cannot find <Challenge> in key message");
    return aI(atob(c));
  }
  setupLicenseXHR(e, t, s, r) {
    const i = this.config.licenseXhrSetup;
    return i
      ? Promise.resolve()
          .then(() => {
            if (!s.decryptdata) throw new Error("Key removed");
            return i.call(this.hls, e, t, s, r);
          })
          .catch((a) => {
            if (!s.decryptdata) throw a;
            return e.open("POST", t, !0), i.call(this.hls, e, t, s, r);
          })
          .then(
            (a) => (
              e.readyState || e.open("POST", t, !0),
              { xhr: e, licenseChallenge: a || r }
            )
          )
      : (e.open("POST", t, !0),
        Promise.resolve({ xhr: e, licenseChallenge: r }));
  }
  requestLicense(e, t) {
    const s = this.config.keyLoadPolicy.default;
    return new Promise((r, i) => {
      const a = this.getLicenseServerUrlOrThrow(e.keySystem);
      this.log(`Sending license request to URL: ${a}`);
      const o = new XMLHttpRequest();
      (o.responseType = "arraybuffer"),
        (o.onreadystatechange = () => {
          if (!this.hls || !e.mediaKeysSession)
            return i(new Error("invalid state"));
          if (o.readyState === 4)
            if (o.status === 200) {
              this._requestLicenseFailureCount = 0;
              let l = o.response;
              this.log(
                `License received ${
                  l instanceof ArrayBuffer ? l.byteLength : l
                }`
              );
              const c = this.config.licenseResponseCallback;
              if (c)
                try {
                  l = c.call(this.hls, o, a, e);
                } catch (h) {
                  this.error(h);
                }
              r(l);
            } else {
              const l = s.errorRetry,
                c = l ? l.maxNumRetry : 0;
              if (
                (this._requestLicenseFailureCount++,
                this._requestLicenseFailureCount > c ||
                  (o.status >= 400 && o.status < 500))
              )
                i(
                  new qi(
                    {
                      type: gt.KEY_SYSTEM_ERROR,
                      details: we.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: o,
                      response: {
                        url: a,
                        data: void 0,
                        code: o.status,
                        text: o.statusText,
                      },
                    },
                    `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`
                  )
                );
              else {
                const h = c - this._requestLicenseFailureCount + 1;
                this.warn(`Retrying license request, ${h} attempts left`),
                  this.requestLicense(e, t).then(r, i);
              }
            }
        }),
        e.licenseXhr &&
          e.licenseXhr.readyState !== XMLHttpRequest.DONE &&
          e.licenseXhr.abort(),
        (e.licenseXhr = o),
        this.setupLicenseXHR(o, a, e, t).then(
          ({ xhr: l, licenseChallenge: c }) => {
            e.keySystem == Rs.PLAYREADY &&
              (c = this.unpackPlayReadyKeyMessage(l, c)),
              l.send(c);
          }
        );
    });
  }
  onDestroying() {
    this.unregisterListeners(), this._clear();
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled) return;
    const s = t.media;
    (this.media = s), na(s, "waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const e = this.media;
    e &&
      (La(e, "waitingforkey", this.onWaitingForKey),
      (this.media = null),
      (this.mediaKeys = null));
  }
  _clear() {
    var e;
    if (
      ((this._requestLicenseFailureCount = 0),
      (this.keyIdToKeySessionPromise = {}),
      !this.mediaKeys && !this.mediaKeySessions.length)
    )
      return;
    const t = this.media,
      s = this.mediaKeySessions.slice();
    (this.mediaKeySessions = []),
      (this.mediaKeys = null),
      fS.clearKeyUriToKeyIdMap();
    const r = s.length;
    ff.CDMCleanupPromise = Promise.all(
      s
        .map((i) => this.removeSession(i))
        .concat(
          t == null || (e = t.setMediaKeys(null)) == null
            ? void 0
            : e.catch((i) => {
                var a;
                this.log(`Could not clear media keys: ${i}`),
                  (a = this.hls) == null ||
                    a.trigger($.ERROR, {
                      type: gt.OTHER_ERROR,
                      details: we.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
                      fatal: !1,
                      error: new Error(`Could not clear media keys: ${i}`),
                    });
              })
        )
    )
      .catch((i) => {
        var a;
        this.log(`Could not close sessions and clear media keys: ${i}`),
          (a = this.hls) == null ||
            a.trigger($.ERROR, {
              type: gt.OTHER_ERROR,
              details: we.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
              fatal: !1,
              error: new Error(
                `Could not close sessions and clear media keys: ${i}`
              ),
            });
      })
      .then(() => {
        r && this.log("finished closing key sessions and clearing media keys");
      });
  }
  onManifestLoading() {
    this.keyFormatPromise = null;
  }
  onManifestLoaded(e, { sessionKeys: t }) {
    if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const s = t.reduce(
        (r, i) => (r.indexOf(i.keyFormat) === -1 && r.push(i.keyFormat), r),
        []
      );
      this.log(`Selecting key-system from session-keys ${s.join(", ")}`),
        (this.keyFormatPromise = this.getKeyFormatPromise(s));
    }
  }
  removeSession(e) {
    const { mediaKeysSession: t, licenseXhr: s } = e;
    if (t) {
      this.log(`Remove licenses and keys and close session ${t.sessionId}`),
        e._onmessage &&
          (t.removeEventListener("message", e._onmessage),
          (e._onmessage = void 0)),
        e._onkeystatuseschange &&
          (t.removeEventListener("keystatuseschange", e._onkeystatuseschange),
          (e._onkeystatuseschange = void 0)),
        s && s.readyState !== XMLHttpRequest.DONE && s.abort(),
        (e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0);
      const r = this.mediaKeySessions.indexOf(e);
      r > -1 && this.mediaKeySessions.splice(r, 1);
      const { drmSystemOptions: i } = this.config;
      return (
        dke(i)
          ? new Promise((o, l) => {
              self.setTimeout(
                () => l(new Error("MediaKeySession.remove() timeout")),
                8e3
              ),
                t.remove().then(o);
            })
          : Promise.resolve()
      )
        .catch((o) => {
          var l;
          this.log(`Could not remove session: ${o}`),
            (l = this.hls) == null ||
              l.trigger($.ERROR, {
                type: gt.OTHER_ERROR,
                details: we.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
                fatal: !1,
                error: new Error(`Could not remove session: ${o}`),
              });
        })
        .then(() => t.close())
        .catch((o) => {
          var l;
          this.log(`Could not close session: ${o}`),
            (l = this.hls) == null ||
              l.trigger($.ERROR, {
                type: gt.OTHER_ERROR,
                details: we.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                fatal: !1,
                error: new Error(`Could not close session: ${o}`),
              });
        });
    }
  }
}
ff.CDMCleanupPromise = void 0;
class qi extends Error {
  constructor(e, t) {
    super(t),
      (this.data = void 0),
      e.error || (e.error = new Error(t)),
      (this.data = e),
      (e.err = e.error);
  }
}
class bIe {
  constructor(e) {
    (this.hls = void 0),
      (this.isVideoPlaybackQualityAvailable = !1),
      (this.timer = void 0),
      (this.media = null),
      (this.lastTime = void 0),
      (this.lastDroppedFrames = 0),
      (this.lastDecodedFrames = 0),
      (this.streamController = void 0),
      (this.hls = e),
      this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      this.hls.on($.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListeners() {
    this.hls.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      this.hls.off($.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer),
      this.unregisterListeners(),
      (this.isVideoPlaybackQualityAvailable = !1),
      (this.media = null);
  }
  onMediaAttaching(e, t) {
    const s = this.hls.config;
    if (s.capLevelOnFPSDrop) {
      const r = t.media instanceof self.HTMLVideoElement ? t.media : null;
      (this.media = r),
        r &&
          typeof r.getVideoPlaybackQuality == "function" &&
          (this.isVideoPlaybackQualityAvailable = !0),
        self.clearInterval(this.timer),
        (this.timer = self.setInterval(
          this.checkFPSInterval.bind(this),
          s.fpsDroppedMonitoringPeriod
        ));
    }
  }
  onMediaDetaching() {
    this.media = null;
  }
  checkFPS(e, t, s) {
    const r = performance.now();
    if (t) {
      if (this.lastTime) {
        const i = r - this.lastTime,
          a = s - this.lastDroppedFrames,
          o = t - this.lastDecodedFrames,
          l = (1e3 * a) / i,
          c = this.hls;
        if (
          (c.trigger($.FPS_DROP, {
            currentDropped: a,
            currentDecoded: o,
            totalDroppedFrames: s,
          }),
          l > 0 && a > c.config.fpsDroppedMonitoringThreshold * o)
        ) {
          let h = c.currentLevel;
          c.logger.warn(
            "drop FPS ratio greater than max allowed value for currentLevel: " +
              h
          ),
            h > 0 &&
              (c.autoLevelCapping === -1 || c.autoLevelCapping >= h) &&
              ((h = h - 1),
              c.trigger($.FPS_DROP_LEVEL_CAPPING, {
                level: h,
                droppedLevel: c.currentLevel,
              }),
              (c.autoLevelCapping = h),
              this.streamController.nextLevelSwitch());
        }
      }
      (this.lastTime = r),
        (this.lastDroppedFrames = s),
        (this.lastDecodedFrames = t);
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const t = e.getVideoPlaybackQuality();
        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
function uX(n, e) {
  let t;
  try {
    t = new Event("addtrack");
  } catch {
    (t = document.createEvent("Event")), t.initEvent("addtrack", !1, !1);
  }
  (t.track = n), e.dispatchEvent(t);
}
function dX(n, e) {
  const t = n.mode;
  if (
    (t === "disabled" && (n.mode = "hidden"),
    n.cues && !n.cues.getCueById(e.id))
  )
    try {
      if ((n.addCue(e), !n.cues.getCueById(e.id)))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (s) {
      pn.debug(`[texttrack-utils]: ${s}`);
      try {
        const r = new self.TextTrackCue(e.startTime, e.endTime, e.text);
        (r.id = e.id), n.addCue(r);
      } catch (r) {
        pn.debug(
          `[texttrack-utils]: Legacy TextTrackCue fallback failed: ${r}`
        );
      }
    }
  t === "disabled" && (n.mode = t);
}
function Qh(n, e) {
  const t = n.mode;
  if ((t === "disabled" && (n.mode = "hidden"), n.cues))
    for (let s = n.cues.length; s--; )
      e && n.cues[s].removeEventListener("enter", e), n.removeCue(n.cues[s]);
  t === "disabled" && (n.mode = t);
}
function pI(n, e, t, s) {
  const r = n.mode;
  if ((r === "disabled" && (n.mode = "hidden"), n.cues && n.cues.length > 0)) {
    const i = wIe(n.cues, e, t);
    for (let a = 0; a < i.length; a++) (!s || s(i[a])) && n.removeCue(i[a]);
  }
  r === "disabled" && (n.mode = r);
}
function xIe(n, e) {
  if (e <= n[0].startTime) return 0;
  const t = n.length - 1;
  if (e > n[t].endTime) return -1;
  let s = 0,
    r = t,
    i;
  for (; s <= r; )
    if (((i = Math.floor((r + s) / 2)), e < n[i].startTime)) r = i - 1;
    else if (e > n[i].startTime && s < t) s = i + 1;
    else return i;
  return n[s].startTime - e < e - n[r].startTime ? s : r;
}
function wIe(n, e, t) {
  const s = [],
    r = xIe(n, e);
  if (r > -1)
    for (let i = r, a = n.length; i < a; i++) {
      const o = n[i];
      if (o.startTime >= e && o.endTime <= t) s.push(o);
      else if (o.startTime > t) return s;
    }
  return s;
}
function ox(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) {
    const s = n[t];
    (s.kind === "subtitles" || s.kind === "captions") &&
      s.label &&
      e.push(n[t]);
  }
  return e;
}
class EIe extends iM {
  constructor(e) {
    super(e, "subtitle-track-controller"),
      (this.media = null),
      (this.tracks = []),
      (this.groupIds = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.currentTrack = null),
      (this.selectDefaultTrack = !0),
      (this.queuedDefaultTrack = -1),
      (this.useTextTrackPolling = !1),
      (this.subtitlePollingInterval = -1),
      (this._subtitleDisplay = !0),
      (this.asyncPollTrackChange = () => this.pollTrackChange(0)),
      (this.onTextTracksChanged = () => {
        if (
          (this.useTextTrackPolling ||
            self.clearInterval(this.subtitlePollingInterval),
          !this.media || !this.hls.config.renderTextTracksNatively)
        )
          return;
        let t = null;
        const s = ox(this.media.textTracks);
        for (let i = 0; i < s.length; i++)
          if (s[i].mode === "hidden") t = s[i];
          else if (s[i].mode === "showing") {
            t = s[i];
            break;
          }
        const r = this.findTrackForTextTrack(t);
        this.subtitleTrack !== r && this.setSubtitleTrack(r);
      }),
      this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(),
      (this.tracks.length = 0),
      (this.tracksInGroup.length = 0),
      (this.currentTrack = null),
      (this.onTextTracksChanged = this.asyncPollTrackChange = null),
      super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    (this._subtitleDisplay = e), this.trackId > -1 && this.toggleTrackModes();
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.LEVEL_LOADING, this.onLevelLoading, this),
      e.on($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.on($.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.LEVEL_LOADING, this.onLevelLoading, this),
      e.off($.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.off($.ERROR, this.onError, this);
  }
  onMediaAttached(e, t) {
    (this.media = t.media),
      this.media &&
        (this.queuedDefaultTrack > -1 &&
          ((this.subtitleTrack = this.queuedDefaultTrack),
          (this.queuedDefaultTrack = -1)),
        (this.useTextTrackPolling = !(
          this.media.textTracks && "onchange" in this.media.textTracks
        )),
        this.useTextTrackPolling
          ? this.pollTrackChange(500)
          : this.media.textTracks.addEventListener(
              "change",
              this.asyncPollTrackChange
            ));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval),
      (this.subtitlePollingInterval = self.setInterval(
        this.onTextTracksChanged,
        e
      ));
  }
  onMediaDetaching(e, t) {
    const s = this.media;
    if (!s) return;
    const r = !!t.transferMedia;
    if (
      (self.clearInterval(this.subtitlePollingInterval),
      this.useTextTrackPolling ||
        s.textTracks.removeEventListener("change", this.asyncPollTrackChange),
      this.trackId > -1 && (this.queuedDefaultTrack = this.trackId),
      (this.subtitleTrack = -1),
      (this.media = null),
      r)
    )
      return;
    ox(s.textTracks).forEach((a) => {
      Qh(a);
    });
  }
  onManifestLoading() {
    (this.tracks = []),
      (this.groupIds = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.currentTrack = null),
      (this.selectDefaultTrack = !0);
  }
  onManifestParsed(e, t) {
    this.tracks = t.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, t) {
    const { id: s, groupId: r, details: i } = t,
      a = this.tracksInGroup[s];
    if (!a || a.groupId !== r) {
      this.warn(
        `Subtitle track with id:${s} and group:${r} not found in active group ${a?.groupId}`
      );
      return;
    }
    const o = a.details;
    (a.details = t.details),
      this.log(
        `Subtitle track ${s} "${a.name}" lang:${a.lang} group:${r} loaded [${i.startSN}-${i.endSN}]`
      ),
      s === this.trackId && this.playlistLoaded(s, t, o);
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level);
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level);
  }
  switchLevel(e) {
    const t = this.hls.levels[e];
    if (!t) return;
    const s = t.subtitleGroups || null,
      r = this.groupIds;
    let i = this.currentTrack;
    if (
      !s ||
      r?.length !== s?.length ||
      (s != null && s.some((a) => r?.indexOf(a) === -1))
    ) {
      (this.groupIds = s), (this.trackId = -1), (this.currentTrack = null);
      const a = this.tracks.filter((h) => !s || s.indexOf(h.groupId) !== -1);
      if (a.length)
        this.selectDefaultTrack &&
          !a.some((h) => h.default) &&
          (this.selectDefaultTrack = !1),
          a.forEach((h, m) => {
            h.id = m;
          });
      else if (!i && !this.tracksInGroup.length) return;
      this.tracksInGroup = a;
      const o = this.hls.config.subtitlePreference;
      if (!i && o) {
        this.selectDefaultTrack = !1;
        const h = To(o, a);
        if (h > -1) i = a[h];
        else {
          const m = To(o, this.tracks);
          i = this.tracks[m];
        }
      }
      let l = this.findTrackId(i);
      l === -1 && i && (l = this.findTrackId(null));
      const c = { subtitleTracks: a };
      this.log(
        `Updating subtitle tracks, ${a.length} track(s) found in "${s?.join(
          ","
        )}" group-id`
      ),
        this.hls.trigger($.SUBTITLE_TRACKS_UPDATED, c),
        l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l);
    }
  }
  findTrackId(e) {
    const t = this.tracksInGroup,
      s = this.selectDefaultTrack;
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      if (!((s && !i.default) || (!s && !e)) && (!e || qu(i, e))) return r;
    }
    if (e) {
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (
          yv(e.attrs, i.attrs, [
            "LANGUAGE",
            "ASSOC-LANGUAGE",
            "CHARACTERISTICS",
          ])
        )
          return r;
      }
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (yv(e.attrs, i.attrs, ["LANGUAGE"])) return r;
      }
    }
    return -1;
  }
  findTrackForTextTrack(e) {
    if (e) {
      const t = this.tracksInGroup;
      for (let s = 0; s < t.length; s++) {
        const r = t[s];
        if (hI(r, e)) return s;
      }
    }
    return -1;
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === en.SUBTITLE_TRACK &&
        t.context.id === this.trackId &&
        (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) &&
        this.checkRetry(t));
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    (this.selectDefaultTrack = !1), this.setSubtitleTrack(e);
  }
  setSubtitleOption(e) {
    if (((this.hls.config.subtitlePreference = e), e)) {
      if (e.id === -1) return this.setSubtitleTrack(-1), null;
      const t = this.allSubtitleTracks;
      if (((this.selectDefaultTrack = !1), t.length)) {
        const s = this.currentTrack;
        if (s && qu(e, s)) return s;
        const r = To(e, this.tracksInGroup);
        if (r > -1) {
          const i = this.tracksInGroup[r];
          return this.setSubtitleTrack(r), i;
        } else {
          if (s) return null;
          {
            const i = To(e, t);
            if (i > -1) return t[i];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(e) {
    super.loadPlaylist(),
      this.shouldLoadPlaylist(this.currentTrack) &&
        this.scheduleLoading(this.currentTrack, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const s = e.id,
      r = e.groupId,
      i = this.getUrlWithDirectives(e.url, t),
      a = e.details,
      o = a?.age;
    this.log(
      `Loading subtitle ${s} "${e.name}" lang:${e.lang} group:${r}${
        t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""
      }${
        o && a.live
          ? " age " + o.toFixed(1) + ((a.type && " " + a.type) || "")
          : ""
      } ${i}`
    ),
      this.hls.trigger($.SUBTITLE_TRACK_LOADING, {
        url: i,
        id: s,
        groupId: r,
        deliveryDirectives: t || null,
        track: e,
      });
  }
  toggleTrackModes() {
    const { media: e } = this;
    if (!e) return;
    const t = ox(e.textTracks),
      s = this.currentTrack;
    let r;
    if (
      (s &&
        ((r = t.filter((i) => hI(s, i))[0]),
        r ||
          this.warn(
            `Unable to find subtitle TextTrack with name "${s.name}" and language "${s.lang}"`
          )),
      [].slice.call(t).forEach((i) => {
        i.mode !== "disabled" && i !== r && (i.mode = "disabled");
      }),
      r)
    ) {
      const i = this.subtitleDisplay ? "showing" : "hidden";
      r.mode !== i && (r.mode = i);
    }
  }
  setSubtitleTrack(e) {
    const t = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (e < -1 || e >= t.length || !Qe(e)) {
      this.warn(`Invalid subtitle track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const s = this.currentTrack,
      r = t[e] || null;
    if (
      ((this.trackId = e), (this.currentTrack = r), this.toggleTrackModes(), !r)
    ) {
      this.hls.trigger($.SUBTITLE_TRACK_SWITCH, { id: e });
      return;
    }
    const i = !!r.details && !r.details.live;
    if (e === this.trackId && r === s && i) return;
    this.log(
      `Switching to subtitle-track ${e}` +
        (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : "")
    );
    const { id: a, groupId: o = "", name: l, type: c, url: h } = r;
    this.hls.trigger($.SUBTITLE_TRACK_SWITCH, {
      id: a,
      groupId: o,
      name: l,
      type: c,
      url: h,
    });
    const m = this.switchParams(r.url, s?.details, r.details);
    this.loadPlaylist(m);
  }
}
function SIe() {
  try {
    return crypto.randomUUID();
  } catch {
    try {
      const e = URL.createObjectURL(new Blob()),
        t = e.toString();
      return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1);
    } catch {
      let t = new Date().getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
        const i = (t + Math.random() * 16) % 16 | 0;
        return (
          (t = Math.floor(t / 16)), (r == "x" ? i : (i & 3) | 8).toString(16)
        );
      });
    }
  }
}
function gg(n) {
  let e = 5381,
    t = n.length;
  for (; t; ) e = (e * 33) ^ n.charCodeAt(--t);
  return (e >>> 0).toString();
}
const mf = 0.025;
let tE = (function (n) {
  return (n[(n.Point = 0)] = "Point"), (n[(n.Range = 1)] = "Range"), n;
})({});
function TIe(n, e, t) {
  return `${n.identifier}-${t + 1}-${gg(e)}`;
}
class _Ie {
  constructor(e, t) {
    (this.base = void 0),
      (this._duration = null),
      (this._timelineStart = null),
      (this.appendInPlaceDisabled = void 0),
      (this.appendInPlaceStarted = void 0),
      (this.dateRange = void 0),
      (this.hasPlayed = !1),
      (this.cumulativeDuration = 0),
      (this.resumeOffset = NaN),
      (this.playoutLimit = NaN),
      (this.restrictions = { skip: !1, jump: !1 }),
      (this.snapOptions = { out: !1, in: !1 }),
      (this.assetList = []),
      (this.assetListLoader = void 0),
      (this.assetListResponse = null),
      (this.resumeAnchor = void 0),
      (this.error = void 0),
      (this.resetOnResume = void 0),
      (this.base = t),
      (this.dateRange = e),
      this.setDateRange(e);
  }
  setDateRange(e) {
    (this.dateRange = e),
      (this.resumeOffset = e.attr.optionalFloat(
        "X-RESUME-OFFSET",
        this.resumeOffset
      )),
      (this.playoutLimit = e.attr.optionalFloat(
        "X-PLAYOUT-LIMIT",
        this.playoutLimit
      )),
      (this.restrictions = e.attr.enumeratedStringList(
        "X-RESTRICT",
        this.restrictions
      )),
      (this.snapOptions = e.attr.enumeratedStringList(
        "X-SNAP",
        this.snapOptions
      ));
  }
  reset() {
    var e;
    (this.appendInPlaceStarted = !1),
      (e = this.assetListLoader) == null || e.destroy(),
      (this.assetListLoader = void 0),
      this.supplementsPrimary ||
        ((this.assetListResponse = null),
        (this.assetList = []),
        (this._duration = null));
  }
  isAssetPastPlayoutLimit(e) {
    var t;
    if (e > 0 && e >= this.assetList.length) return !0;
    const s = this.playoutLimit;
    return e <= 0 || isNaN(s)
      ? !1
      : s === 0
      ? !0
      : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > s;
  }
  findAssetIndex(e) {
    return this.assetList.indexOf(e);
  }
  get identifier() {
    return this.dateRange.id;
  }
  get startDate() {
    return this.dateRange.startDate;
  }
  get startTime() {
    const e = this.dateRange.startTime;
    if (this.snapOptions.out) {
      const t = this.dateRange.tagAnchor;
      if (t) return AA(e, t);
    }
    return e;
  }
  get startOffset() {
    return this.cue.pre ? 0 : this.startTime;
  }
  get startIsAligned() {
    if (this.startTime === 0 || this.snapOptions.out) return !0;
    const e = this.dateRange.tagAnchor;
    if (e) {
      const t = this.dateRange.startTime,
        s = AA(t, e);
      return t - s < 0.1;
    }
    return !1;
  }
  get resumptionOffset() {
    const e = this.resumeOffset,
      t = Qe(e) ? e : this.duration;
    return this.cumulativeDuration + t;
  }
  get resumeTime() {
    const e = this.startOffset + this.resumptionOffset;
    if (this.snapOptions.in) {
      const t = this.resumeAnchor;
      if (t) return AA(e, t);
    }
    return e;
  }
  get appendInPlace() {
    return this.appendInPlaceStarted
      ? !0
      : this.appendInPlaceDisabled
      ? !1
      : !!(
          !this.cue.once &&
          !this.cue.pre &&
          this.startIsAligned &&
          ((isNaN(this.playoutLimit) && isNaN(this.resumeOffset)) ||
            (this.resumeOffset &&
              this.duration &&
              Math.abs(this.resumeOffset - this.duration) < mf))
        );
  }
  set appendInPlace(e) {
    if (this.appendInPlaceStarted) {
      this.resetOnResume = !e;
      return;
    }
    this.appendInPlaceDisabled = !e;
  }
  get timelineStart() {
    return this._timelineStart !== null ? this._timelineStart : this.startTime;
  }
  set timelineStart(e) {
    this._timelineStart = e;
  }
  get duration() {
    const e = this.playoutLimit;
    let t;
    return (
      this._duration !== null
        ? (t = this._duration)
        : this.dateRange.duration
        ? (t = this.dateRange.duration)
        : (t = this.dateRange.plannedDuration || 0),
      !isNaN(e) && e < t && (t = e),
      t
    );
  }
  set duration(e) {
    this._duration = e;
  }
  get cue() {
    return this.dateRange.cue;
  }
  get timelineOccupancy() {
    return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE"
      ? tE.Range
      : tE.Point;
  }
  get supplementsPrimary() {
    return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
  }
  get contentMayVary() {
    return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
  }
  get assetUrl() {
    return this.dateRange.attr["X-ASSET-URI"];
  }
  get assetListUrl() {
    return this.dateRange.attr["X-ASSET-LIST"];
  }
  get baseUrl() {
    return this.base.url;
  }
  get assetListLoaded() {
    return this.assetList.length > 0 || this.assetListResponse !== null;
  }
  toString() {
    return AIe(this);
  }
}
function AA(n, e) {
  return n - e.start < e.duration / 2 &&
    !(Math.abs(n - (e.start + e.duration)) < mf)
    ? e.start
    : e.start + e.duration;
}
function hX(n, e, t) {
  const s = new self.URL(n, t);
  return s.protocol !== "data:" && s.searchParams.set("_HLS_primary_id", e), s;
}
function RA(n, e) {
  for (; (t = n.assetList[++e]) != null && t.error; ) var t;
  return e;
}
function AIe(n) {
  return `["${n.identifier}" ${
    n.cue.pre ? "<pre>" : n.cue.post ? "<post>" : ""
  }${n.timelineStart.toFixed(2)}-${n.resumeTime.toFixed(2)}]`;
}
function Uh(n) {
  const e = n.timelineStart,
    t = n.duration || 0;
  return `["${n.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`;
}
class RIe {
  constructor(e, t, s, r) {
    (this.hls = void 0),
      (this.interstitial = void 0),
      (this.assetItem = void 0),
      (this.tracks = null),
      (this.hasDetails = !1),
      (this.mediaAttached = null),
      (this._currentTime = void 0),
      (this._bufferedEosTime = void 0),
      (this.checkPlayout = () => {
        this.reachedPlayout(this.currentTime) &&
          this.hls.trigger($.PLAYOUT_LIMIT_REACHED, {});
      });
    const i = (this.hls = new e(t));
    (this.interstitial = s), (this.assetItem = r);
    let a = r.uri;
    try {
      a = hX(a, t.primarySessionId).href;
    } catch {}
    i.loadSource(a);
    const o = () => {
      this.hasDetails = !0;
    };
    i.once($.LEVEL_LOADED, o),
      i.once($.AUDIO_TRACK_LOADED, o),
      i.once($.SUBTITLE_TRACK_LOADED, o),
      i.on($.MEDIA_ATTACHING, (l, { media: c }) => {
        this.removeMediaListeners(),
          (this.mediaAttached = c),
          this.interstitial.playoutLimit &&
            (c.addEventListener("timeupdate", this.checkPlayout),
            this.appendInPlace &&
              i.on($.BUFFER_APPENDED, () => {
                const m = this.bufferedEnd;
                this.reachedPlayout(m) &&
                  ((this._bufferedEosTime = m),
                  i.trigger($.BUFFERED_TO_END, void 0));
              }));
      });
  }
  get appendInPlace() {
    var e;
    return ((e = this.interstitial) == null ? void 0 : e.appendInPlace) || !1;
  }
  bufferedInPlaceToEnd(e) {
    var t;
    if (!this.appendInPlace) return !1;
    if ((t = this.hls) != null && t.bufferedToEnd) return !0;
    if (!e || !this._bufferedEosTime) return !1;
    const s = this.timelineOffset,
      r = Ft.bufferInfo(e, s, 0);
    return this.getAssetTime(r.end) >= this._bufferedEosTime - 0.02;
  }
  reachedPlayout(e) {
    const s = this.interstitial.playoutLimit;
    return this.startOffset + e >= s;
  }
  get destroyed() {
    var e;
    return !((e = this.hls) != null && e.userConfig);
  }
  get assetId() {
    return this.assetItem.identifier;
  }
  get interstitialId() {
    return this.assetItem.parentIdentifier;
  }
  get media() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.media) || null;
  }
  get bufferedEnd() {
    const e = this.media || this.mediaAttached;
    if (!e)
      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
    const t = Ft.bufferInfo(e, e.currentTime, 0.001);
    return this.getAssetTime(t.end);
  }
  get currentTime() {
    const e = this.media || this.mediaAttached;
    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
  }
  get duration() {
    const e = this.assetItem.duration;
    return e || 0;
  }
  get remaining() {
    const e = this.duration;
    return e ? Math.max(0, e - this.currentTime) : 0;
  }
  get startOffset() {
    return this.assetItem.startOffset;
  }
  get timelineOffset() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
  }
  set timelineOffset(e) {
    const t = this.timelineOffset;
    if (e !== t) {
      const s = e - t;
      if (Math.abs(s) > 1 / 9e4) {
        if (this.hasDetails)
          throw new Error(
            "Cannot set timelineOffset after playlists are loaded"
          );
        this.hls.config.timelineOffset = e;
      }
    }
  }
  getAssetTime(e) {
    const t = this.timelineOffset,
      s = this.duration;
    return Math.min(Math.max(0, e - t), s);
  }
  removeMediaListeners() {
    const e = this.mediaAttached;
    e &&
      ((this._currentTime = e.currentTime),
      this.bufferSnapShot(),
      e.removeEventListener("timeupdate", this.checkPlayout));
  }
  bufferSnapShot() {
    if (this.mediaAttached) {
      var e;
      (e = this.hls) != null &&
        e.bufferedToEnd &&
        (this._bufferedEosTime = this.bufferedEnd);
    }
  }
  destroy() {
    this.removeMediaListeners(),
      this.hls.destroy(),
      (this.hls = this.interstitial = null),
      (this.tracks = this.mediaAttached = this.checkPlayout = null);
  }
  attachMedia(e) {
    this.hls.attachMedia(e);
  }
  detachMedia() {
    this.removeMediaListeners(),
      (this.mediaAttached = null),
      this.hls.detachMedia();
  }
  resumeBuffering() {
    this.hls.resumeBuffering();
  }
  pauseBuffering() {
    this.hls.pauseBuffering();
  }
  transferMedia() {
    return this.bufferSnapShot(), this.hls.transferMedia();
  }
  resetDetails() {
    const e = this.hls;
    if (this.hasDetails) {
      e.stopLoad();
      const t = (s) => delete s.details;
      e.levels.forEach(t),
        e.allAudioTracks.forEach(t),
        e.allSubtitleTracks.forEach(t),
        (this.hasDetails = !1);
    }
  }
  on(e, t, s) {
    this.hls.on(e, t);
  }
  once(e, t, s) {
    this.hls.once(e, t);
  }
  off(e, t, s) {
    this.hls.off(e, t);
  }
  toString() {
    var e;
    return `HlsAssetPlayer: ${Uh(this.assetItem)} ${
      (e = this.hls) == null ? void 0 : e.sessionId
    } ${this.appendInPlace ? "append-in-place" : ""}`;
  }
}
const m5 = 0.033;
class kIe extends za {
  constructor(e, t) {
    super("interstitials-sched", t),
      (this.onScheduleUpdate = void 0),
      (this.eventMap = {}),
      (this.events = null),
      (this.items = null),
      (this.durations = { primary: 0, playout: 0, integrated: 0 }),
      (this.onScheduleUpdate = e);
  }
  destroy() {
    this.reset(), (this.onScheduleUpdate = null);
  }
  reset() {
    (this.eventMap = {}),
      this.setDurations(0, 0, 0),
      this.events && this.events.forEach((e) => e.reset()),
      (this.events = this.items = null);
  }
  resetErrorsInRange(e, t) {
    return this.events
      ? this.events.reduce(
          (s, r) =>
            e <= r.startOffset && t > r.startOffset
              ? (delete r.error, s + 1)
              : s,
          0
        )
      : 0;
  }
  get duration() {
    const e = this.items;
    return e ? e[e.length - 1].end : 0;
  }
  get length() {
    return this.items ? this.items.length : 0;
  }
  getEvent(e) {
    return (e && this.eventMap[e]) || null;
  }
  hasEvent(e) {
    return e in this.eventMap;
  }
  findItemIndex(e, t) {
    if (e.event) return this.findEventIndex(e.event.identifier);
    let s = -1;
    e.nextEvent
      ? (s = this.findEventIndex(e.nextEvent.identifier) - 1)
      : e.previousEvent &&
        (s = this.findEventIndex(e.previousEvent.identifier) + 1);
    const r = this.items;
    if (r)
      for (
        r[s] ||
        (t === void 0 && (t = e.start), (s = this.findItemIndexAtTime(t)));
        s >= 0 && (i = r[s]) != null && i.event;

      ) {
        var i;
        s--;
      }
    return s;
  }
  findItemIndexAtTime(e, t) {
    const s = this.items;
    if (s)
      for (let r = 0; r < s.length; r++) {
        let i = s[r];
        if (
          (t && t !== "primary" && (i = i[t]),
          e === i.start || (e > i.start && e < i.end))
        )
          return r;
      }
    return -1;
  }
  findJumpRestrictedIndex(e, t) {
    const s = this.items;
    if (s)
      for (let r = e; r <= t && s[r]; r++) {
        const i = s[r].event;
        if (i != null && i.restrictions.jump && !i.appendInPlace) return r;
      }
    return -1;
  }
  findEventIndex(e) {
    const t = this.items;
    if (t)
      for (let r = t.length; r--; ) {
        var s;
        if (((s = t[r].event) == null ? void 0 : s.identifier) === e) return r;
      }
    return -1;
  }
  findAssetIndex(e, t) {
    const s = e.assetList,
      r = s.length;
    if (r > 1)
      for (let i = 0; i < r; i++) {
        const a = s[i];
        if (!a.error) {
          const o = a.timelineStart;
          if (t === o || (t > o && t < o + (a.duration || 0))) return i;
        }
      }
    return 0;
  }
  get assetIdAtEnd() {
    var e, t;
    const s =
      (e = this.items) == null || (t = e[this.length - 1]) == null
        ? void 0
        : t.event;
    if (s) {
      const r = s.assetList,
        i = r[r.length - 1];
      if (i) return i.identifier;
    }
    return null;
  }
  parseInterstitialDateRanges(e, t) {
    const s = e.main.details,
      { dateRanges: r } = s,
      i = this.events,
      a = this.parseDateRanges(r, { url: s.url }, t),
      o = Object.keys(r),
      l = i ? i.filter((c) => !o.includes(c.identifier)) : [];
    a.length &&
      a.sort((c, h) => {
        const m = c.cue.pre,
          p = c.cue.post,
          g = h.cue.pre,
          y = h.cue.post;
        if (m && !g) return -1;
        if ((g && !m) || (p && !y)) return 1;
        if (y && !p) return -1;
        if (!m && !g && !p && !y) {
          const b = c.startTime,
            w = h.startTime;
          if (b !== w) return b - w;
        }
        return c.dateRange.tagOrder - h.dateRange.tagOrder;
      }),
      (this.events = a),
      l.forEach((c) => {
        this.removeEvent(c);
      }),
      this.updateSchedule(e, l);
  }
  updateSchedule(e, t = []) {
    const s = this.events || [];
    if (s.length || t.length || this.length < 2) {
      const r = this.items,
        i = this.parseSchedule(s, e);
      (t.length ||
        r?.length !== i.length ||
        i.some(
          (o, l) =>
            Math.abs(o.playout.start - r[l].playout.start) > 0.005 ||
            Math.abs(o.playout.end - r[l].playout.end) > 0.005
        )) &&
        ((this.items = i), this.onScheduleUpdate(t, r));
    }
  }
  parseDateRanges(e, t, s) {
    const r = [],
      i = Object.keys(e);
    for (let a = 0; a < i.length; a++) {
      const o = i[a],
        l = e[o];
      if (l.isInterstitial) {
        let c = this.eventMap[o];
        c
          ? c.setDateRange(l)
          : ((c = new _Ie(l, t)),
            (this.eventMap[o] = c),
            s === !1 && (c.appendInPlace = s)),
          r.push(c);
      }
    }
    return r;
  }
  parseSchedule(e, t) {
    const s = [],
      r = t.main.details,
      i = r.live ? 1 / 0 : r.edge;
    let a = 0;
    if (
      ((e = e.filter((l) => !l.error && !(l.cue.once && l.hasPlayed))),
      e.length)
    ) {
      this.resolveOffsets(e, t);
      let l = 0,
        c = 0;
      if (
        (e.forEach((h, m) => {
          const p = h.cue.pre,
            g = h.cue.post,
            y = e[m - 1] || null,
            b = h.appendInPlace,
            w = g ? i : h.startOffset,
            S = h.duration,
            A = h.timelineOccupancy === tE.Range ? S : 0,
            _ = h.resumptionOffset,
            R = y?.startTime === w,
            C = w + h.cumulativeDuration;
          let D = b ? C + S : w + _;
          if (p || (!g && w <= 0)) {
            const P = c;
            (c += A), (h.timelineStart = C);
            const V = a;
            (a += S),
              s.push({
                event: h,
                start: C,
                end: D,
                playout: { start: V, end: a },
                integrated: { start: P, end: c },
              });
          } else if (w <= i) {
            if (!R) {
              const N = w - l;
              if (N > m5) {
                const W = l,
                  H = c;
                c += N;
                const z = a;
                a += N;
                const B = {
                  previousEvent: e[m - 1] || null,
                  nextEvent: h,
                  start: W,
                  end: W + N,
                  playout: { start: z, end: a },
                  integrated: { start: H, end: c },
                };
                s.push(B);
              } else
                N > 0 &&
                  y &&
                  ((y.cumulativeDuration += N), (s[s.length - 1].end = w));
            }
            g && (D = C), (h.timelineStart = C);
            const P = c;
            c += A;
            const V = a;
            (a += S),
              s.push({
                event: h,
                start: C,
                end: D,
                playout: { start: V, end: a },
                integrated: { start: P, end: c },
              });
          } else return;
          const L = h.resumeTime;
          g || L > i ? (l = i) : (l = L);
        }),
        l < i)
      ) {
        var o;
        const h = l,
          m = c,
          p = i - l;
        c += p;
        const g = a;
        (a += p),
          s.push({
            previousEvent:
              ((o = s[s.length - 1]) == null ? void 0 : o.event) || null,
            nextEvent: null,
            start: l,
            end: h + p,
            playout: { start: g, end: a },
            integrated: { start: m, end: c },
          });
      }
      this.setDurations(i, a, c);
    } else
      s.push({
        previousEvent: null,
        nextEvent: null,
        start: 0,
        end: i,
        playout: { start: 0, end: i },
        integrated: { start: 0, end: i },
      }),
        this.setDurations(i, i, i);
    return s;
  }
  setDurations(e, t, s) {
    this.durations = { primary: e, playout: t, integrated: s };
  }
  resolveOffsets(e, t) {
    const s = t.main.details,
      r = s.live ? 1 / 0 : s.edge;
    let i = 0,
      a = -1;
    e.forEach((o, l) => {
      const c = o.cue.pre,
        h = o.cue.post,
        m = c ? 0 : h ? r : o.startTime;
      this.updateAssetDurations(o),
        a === m ? (o.cumulativeDuration = i) : ((i = 0), (a = m)),
        !h &&
          o.snapOptions.in &&
          (o.resumeAnchor =
            id(null, s.fragments, o.startOffset + o.resumptionOffset, 0, 0) ||
            void 0),
        o.appendInPlace &&
          !o.appendInPlaceStarted &&
          (this.primaryCanResumeInPlaceAt(o, t) || (o.appendInPlace = !1)),
        !o.appendInPlace &&
          l + 1 < e.length &&
          e[l + 1].startTime - e[l].resumeTime < m5 &&
          ((e[l + 1].appendInPlace = !1),
          e[l + 1].appendInPlace &&
            this.warn(
              `Could not change append strategy for abutting event ${o}`
            ));
      const g = Qe(o.resumeOffset) ? o.resumeOffset : o.duration;
      i += g;
    });
  }
  primaryCanResumeInPlaceAt(e, t) {
    const s = e.resumeTime,
      r = e.startTime + e.resumptionOffset;
    return Math.abs(s - r) > mf
      ? (this.log(
          `"${e.identifier}" resumption ${s} not aligned with estimated timeline end ${r}`
        ),
        !1)
      : t
      ? !Object.keys(t).some((a) => {
          const o = t[a].details,
            l = o.edge;
          if (s >= l)
            return (
              this.log(
                `"${e.identifier}" resumption ${s} past ${a} playlist end ${l}`
              ),
              !1
            );
          const c = id(null, o.fragments, s);
          if (!c)
            return (
              this.log(
                `"${e.identifier}" resumption ${s} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`
              ),
              !0
            );
          const h = a === "audio" ? 0.175 : 0;
          return Math.abs(c.start - s) < mf + h || Math.abs(c.end - s) < mf + h
            ? !1
            : (this.log(
                `"${e.identifier}" resumption ${s} not aligned with ${a} fragment bounds (${c.start}-${c.end} sn: ${c.sn} cc: ${c.cc})`
              ),
              !0);
        })
      : (this.log(
          `"${e.identifier}" resumption ${s} can not be aligned with media (none selected)`
        ),
        !1);
  }
  updateAssetDurations(e) {
    if (!e.assetListLoaded) return;
    const t = e.timelineStart;
    let s = 0,
      r = !1,
      i = !1;
    e.assetList.forEach((a, o) => {
      const l = t + s;
      (a.startOffset = s),
        (a.timelineStart = l),
        r || (r = a.duration === null),
        i || (i = !!a.error);
      const c = a.error ? 0 : a.duration || 0;
      s += c;
    }),
      r && !i ? (e.duration = Math.max(s, e.duration)) : (e.duration = s);
  }
  removeEvent(e) {
    e.reset(), delete this.eventMap[e.identifier];
  }
}
function uc(n) {
  return `[${
    n.event ? '"' + n.event.identifier + '"' : "primary"
  }: ${n.start.toFixed(2)}-${n.end.toFixed(2)}]`;
}
class CIe {
  constructor(e) {
    (this.hls = void 0), (this.hls = e);
  }
  destroy() {
    this.hls = null;
  }
  loadAssetList(e, t) {
    const s = e.assetListUrl;
    let r;
    try {
      r = hX(s, this.hls.sessionId, e.baseUrl);
    } catch (p) {
      const g = this.assignAssetListError(e, we.ASSET_LIST_LOAD_ERROR, p, s);
      this.hls.trigger($.ERROR, g);
      return;
    }
    t &&
      r.protocol !== "data:" &&
      r.searchParams.set("_HLS_start_offset", "" + t);
    const i = this.hls.config,
      a = i.loader,
      o = new a(i),
      l = { responseType: "json", url: r.href },
      c = i.interstitialAssetListLoadPolicy.default,
      h = {
        loadPolicy: c,
        timeout: c.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
      },
      m = {
        onSuccess: (p, g, y, b) => {
          const w = p.data,
            S = w?.ASSETS;
          if (!Array.isArray(S)) {
            const A = this.assignAssetListError(
              e,
              we.ASSET_LIST_PARSING_ERROR,
              new Error("Invalid interstitial asset list"),
              y.url,
              g,
              b
            );
            this.hls.trigger($.ERROR, A);
            return;
          }
          (e.assetListResponse = w),
            this.hls.trigger($.ASSET_LIST_LOADED, {
              event: e,
              assetListResponse: w,
              networkDetails: b,
            });
        },
        onError: (p, g, y, b) => {
          const w = this.assignAssetListError(
            e,
            we.ASSET_LIST_LOAD_ERROR,
            new Error(
              `Error loading X-ASSET-LIST: HTTP status ${p.code} ${p.text} (${g.url})`
            ),
            g.url,
            b,
            y
          );
          this.hls.trigger($.ERROR, w);
        },
        onTimeout: (p, g, y) => {
          const b = this.assignAssetListError(
            e,
            we.ASSET_LIST_LOAD_TIMEOUT,
            new Error(`Timeout loading X-ASSET-LIST (${g.url})`),
            g.url,
            p,
            y
          );
          this.hls.trigger($.ERROR, b);
        },
      };
    return (
      o.load(l, h, m), this.hls.trigger($.ASSET_LIST_LOADING, { event: e }), o
    );
  }
  assignAssetListError(e, t, s, r, i, a) {
    return (
      (e.error = s),
      {
        type: gt.NETWORK_ERROR,
        details: t,
        fatal: !1,
        interstitial: e,
        url: r,
        error: s,
        networkDetails: a,
        stats: i,
      }
    );
  }
}
function p5(n) {
  n?.play().catch(() => {});
}
class IIe extends za {
  constructor(e, t) {
    super("interstitials", e.logger),
      (this.HlsPlayerClass = void 0),
      (this.hls = void 0),
      (this.assetListLoader = void 0),
      (this.mediaSelection = null),
      (this.altSelection = null),
      (this.media = null),
      (this.detachedData = null),
      (this.requiredTracks = null),
      (this.manager = null),
      (this.playerQueue = []),
      (this.bufferedPos = -1),
      (this.timelinePos = -1),
      (this.schedule = void 0),
      (this.playingItem = null),
      (this.bufferingItem = null),
      (this.waitingItem = null),
      (this.endedItem = null),
      (this.playingAsset = null),
      (this.endedAsset = null),
      (this.bufferingAsset = null),
      (this.shouldPlay = !1),
      (this.onPlay = () => {
        this.shouldPlay = !0;
      }),
      (this.onPause = () => {
        this.shouldPlay = !1;
      }),
      (this.onSeeking = () => {
        const s = this.currentTime;
        if (s === void 0 || this.playbackDisabled) return;
        const r = s - this.timelinePos;
        if (Math.abs(r) < 1 / 7056e5) return;
        const a = r <= -0.01;
        (this.timelinePos = s), (this.bufferedPos = s);
        const o = this.playingItem;
        if (!o) {
          this.checkBuffer();
          return;
        }
        if (
          (a &&
            this.schedule.resetErrorsInRange(s, s - r) &&
            this.updateSchedule(),
          this.checkBuffer(),
          (a && s < o.start) || s >= o.end)
        ) {
          var l;
          const p = this.schedule.findItemIndexAtTime(this.timelinePos);
          if (
            (!this.isInterstitial(o) &&
              (l = this.media) != null &&
              l.paused &&
              (this.shouldPlay = !1),
            !a)
          ) {
            const g = this.findItemIndex(o);
            if (p > g) {
              const y = this.schedule.findJumpRestrictedIndex(g + 1, p);
              if (y > g) {
                this.setSchedulePosition(y);
                return;
              }
            }
          }
          this.setSchedulePosition(p);
          return;
        }
        const c = this.playingAsset;
        if (!c) {
          if (this.playingLastItem && this.isInterstitial(o)) {
            const p = o.event.assetList[0];
            p &&
              ((this.endedItem = this.playingItem),
              (this.playingItem = null),
              this.setScheduleToAssetAtTime(s, p));
          }
          return;
        }
        const h = c.timelineStart,
          m = c.duration || 0;
        ((a && s < h) || s >= h + m) && this.setScheduleToAssetAtTime(s, c);
      }),
      (this.onTimeupdate = () => {
        const s = this.currentTime;
        if (s === void 0 || this.playbackDisabled) return;
        if (s > this.timelinePos)
          (this.timelinePos = s), s > this.bufferedPos && this.checkBuffer();
        else return;
        const r = this.playingItem;
        if (!r || this.playingLastItem) return;
        if (s >= r.end) {
          this.timelinePos = r.end;
          const o = this.findItemIndex(r);
          this.setSchedulePosition(o + 1);
        }
        const i = this.playingAsset;
        if (!i) return;
        const a = i.timelineStart + (i.duration || 0);
        s >= a && this.setScheduleToAssetAtTime(s, i);
      }),
      (this.onScheduleUpdate = (s, r) => {
        const i = this.schedule,
          a = this.playingItem,
          o = i.events || [],
          l = i.items || [],
          c = i.durations,
          h = s.map((y) => y.identifier),
          m = !!(o.length || h.length);
        (m || r) &&
          this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${l.map((y) => uc(y))} pos: ${this.timelinePos}`),
          h.length && this.log(`Removed events ${h}`),
          this.playerQueue.forEach((y) => {
            if (y.interstitial.appendInPlace) {
              const b = y.assetItem.timelineStart,
                w = y.timelineOffset - b;
              if (w)
                try {
                  y.timelineOffset = b;
                } catch (S) {
                  Math.abs(w) > mf &&
                    this.warn(
                      `${S} ("${y.assetId}" ${y.timelineOffset}->${b})`
                    );
                }
            }
          });
        let p = null;
        if (a) {
          const y = this.updateItem(a, this.timelinePos);
          this.itemsMatch(a, y) &&
            ((this.playingItem = y),
            (this.waitingItem = this.endedItem = null),
            (p = () => this.trimInPlace(y, a)));
        } else
          (this.waitingItem = this.updateItem(this.waitingItem)),
            (this.endedItem = this.updateItem(this.endedItem));
        const g = this.bufferingItem;
        if (g) {
          const y = this.updateItem(g, this.bufferedPos);
          this.itemsMatch(g, y)
            ? ((this.bufferingItem = y),
              p || (p = () => this.trimInPlace(y, g)))
            : g.event &&
              ((this.bufferingItem = this.playingItem),
              this.clearInterstitial(g.event, null));
        }
        if (
          (s.forEach((y) => {
            y.assetList.forEach((b) => {
              this.clearAssetPlayer(b.identifier, null);
            });
          }),
          m || r)
        ) {
          if (
            (this.hls.trigger($.INTERSTITIALS_UPDATED, {
              events: o.slice(0),
              schedule: l.slice(0),
              durations: c,
              removedIds: h,
            }),
            this.isInterstitial(a) && h.includes(a.event.identifier))
          ) {
            this.warn(
              `Interstitial "${a.event.identifier}" removed while playing`
            ),
              this.primaryFallback(a.event);
            return;
          }
          p && p(), this.checkBuffer();
        }
      }),
      (this.hls = e),
      (this.HlsPlayerClass = t),
      (this.assetListLoader = new CIe(e)),
      (this.schedule = new kIe(this.onScheduleUpdate, e.logger)),
      this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.on($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on($.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
      e.on($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.on($.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
      e.on($.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
      e.on($.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
      e.on($.BUFFER_APPENDED, this.onBufferAppended, this),
      e.on($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on($.BUFFERED_TO_END, this.onBufferedToEnd, this),
      e.on($.MEDIA_ENDED, this.onMediaEnded, this),
      e.on($.ERROR, this.onError, this),
      e.on($.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e &&
      (e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.off($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off($.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
      e.off($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.off($.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
      e.off($.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
      e.off($.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
      e.off($.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off($.BUFFER_APPENDED, this.onBufferAppended, this),
      e.off($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off($.BUFFERED_TO_END, this.onBufferedToEnd, this),
      e.off($.MEDIA_ENDED, this.onMediaEnded, this),
      e.off($.ERROR, this.onError, this),
      e.off($.DESTROYING, this.onDestroying, this));
  }
  startLoad() {
    this.resumeBuffering();
  }
  stopLoad() {
    this.pauseBuffering();
  }
  resumeBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
  }
  destroy() {
    this.unregisterListeners(),
      this.stopLoad(),
      this.assetListLoader && this.assetListLoader.destroy(),
      this.emptyPlayerQueue(),
      this.clearScheduleState(),
      this.schedule && this.schedule.destroy(),
      (this.media =
        this.detachedData =
        this.mediaSelection =
        this.requiredTracks =
        this.altSelection =
        this.manager =
          null),
      (this.hls = this.HlsPlayerClass = this.schedule = this.log = null),
      (this.assetListLoader = null),
      (this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null),
      (this.onScheduleUpdate = null);
  }
  onDestroying() {
    const e = this.primaryMedia || this.media;
    e && this.removeMediaListeners(e);
  }
  removeMediaListeners(e) {
    La(e, "play", this.onPlay),
      La(e, "pause", this.onPause),
      La(e, "seeking", this.onSeeking),
      La(e, "timeupdate", this.onTimeupdate);
  }
  onMediaAttaching(e, t) {
    const s = (this.media = t.media);
    na(s, "seeking", this.onSeeking),
      na(s, "timeupdate", this.onTimeupdate),
      na(s, "play", this.onPlay),
      na(s, "pause", this.onPause);
  }
  onMediaAttached(e, t) {
    const s = this.effectivePlayingItem,
      r = this.detachedData;
    if (((this.detachedData = null), s === null)) this.checkStart();
    else if (!r) {
      this.clearScheduleState();
      const i = this.findItemIndex(s);
      this.setSchedulePosition(i);
    }
  }
  clearScheduleState() {
    this.playingItem =
      this.bufferingItem =
      this.waitingItem =
      this.endedItem =
      this.playingAsset =
      this.endedAsset =
      this.bufferingAsset =
        null;
  }
  onMediaDetaching(e, t) {
    const s = !!t.transferMedia,
      r = this.media;
    if (
      ((this.media = null),
      !s && (r && this.removeMediaListeners(r), this.detachedData))
    ) {
      const i = this.getBufferingPlayer();
      i &&
        ((this.playingAsset =
          this.endedAsset =
          this.bufferingAsset =
          this.bufferingItem =
          this.waitingItem =
          this.detachedData =
            null),
        i.detachMedia()),
        (this.shouldPlay = !1);
    }
  }
  get interstitialsManager() {
    if (!this.manager) {
      if (!this.hls) return null;
      const e = this,
        t = () => e.bufferingItem || e.waitingItem,
        s = (m) => m && e.getAssetPlayer(m.identifier),
        r = (m, p, g, y, b) => {
          if (m) {
            let w = m[p].start;
            const S = m.event;
            if (S) {
              if (p === "playout" || S.timelineOccupancy !== tE.Point) {
                const A = s(g);
                A?.interstitial === S && (w += A.assetItem.startOffset + A[b]);
              }
            } else {
              const A = y === "bufferedPos" ? a() : e[y];
              w += A - m.start;
            }
            return w;
          }
          return 0;
        },
        i = (m, p) => {
          if (m !== 0 && p !== "primary" && e.schedule.length) {
            var g;
            const y = e.schedule.findItemIndexAtTime(m),
              b = (g = e.schedule.items) == null ? void 0 : g[y];
            if (b) {
              const w = b[p].start - b.start;
              return m + w;
            }
          }
          return m;
        },
        a = () => {
          const m = e.bufferedPos;
          return m === Number.MAX_VALUE ? o("primary") : Math.max(m, 0);
        },
        o = (m) => {
          var p;
          return (p = e.primaryDetails) != null && p.live
            ? e.primaryDetails.edge
            : e.schedule.durations[m];
        },
        l = (m, p) => {
          var g, y;
          const b = e.effectivePlayingItem;
          if (b != null && (g = b.event) != null && g.restrictions.skip) return;
          e.log(`seek to ${m} "${p}"`);
          const w = e.effectivePlayingItem,
            S = e.schedule.findItemIndexAtTime(m, p),
            A = (y = e.schedule.items) == null ? void 0 : y[S],
            _ = e.getBufferingPlayer(),
            R = _?.interstitial,
            C = R?.appendInPlace,
            D = w && e.itemsMatch(w, A);
          if (w && (C || D)) {
            const P = s(e.playingAsset),
              V = P?.media || e.primaryMedia;
            if (V) {
              const N =
                  p === "primary"
                    ? V.currentTime
                    : r(w, p, e.playingAsset, "timelinePos", "currentTime"),
                W = m - N,
                H = (C ? N : V.currentTime) + W;
              if (H >= 0 && (!P || C || H <= P.duration)) {
                V.currentTime = H;
                return;
              }
            }
          }
          if (A) {
            let P = m;
            if (p !== "primary") {
              const N = A[p].start,
                W = m - N;
              P = A.start + W;
            }
            const V = !e.isInterstitial(A);
            if (
              (!e.isInterstitial(w) || w.event.appendInPlace) &&
              (V || A.event.appendInPlace)
            ) {
              const N = e.media || (C ? _?.media : null);
              N && (N.currentTime = P);
            } else if (w) {
              const N = e.findItemIndex(w);
              if (S > N) {
                const H = e.schedule.findJumpRestrictedIndex(N + 1, S);
                if (H > N) {
                  e.setSchedulePosition(H);
                  return;
                }
              }
              let W = 0;
              if (V) (e.timelinePos = P), e.checkBuffer();
              else {
                var L;
                const H =
                  A == null || (L = A.event) == null ? void 0 : L.assetList;
                if (H) {
                  const z = m - (A[p] || A).start;
                  for (let B = H.length; B--; ) {
                    const q = H[B];
                    if (
                      q.duration &&
                      z >= q.startOffset &&
                      z < q.startOffset + q.duration
                    ) {
                      W = B;
                      break;
                    }
                  }
                }
              }
              e.setSchedulePosition(S, W);
            }
          }
        },
        c = () => {
          const m = e.effectivePlayingItem;
          if (e.isInterstitial(m)) return m;
          const p = t();
          return e.isInterstitial(p) ? p : null;
        },
        h = {
          get currentTime() {
            const m = c(),
              p = e.effectivePlayingItem;
            return p && p === m
              ? r(
                  p,
                  "playout",
                  e.effectivePlayingAsset,
                  "timelinePos",
                  "currentTime"
                ) - p.playout.start
              : 0;
          },
          set currentTime(m) {
            const p = c(),
              g = e.effectivePlayingItem;
            g && g === p && l(m + g.playout.start, "playout");
          },
          get duration() {
            const m = c();
            return m ? m.playout.end - m.playout.start : 0;
          },
          get assetPlayers() {
            var m;
            const p = (m = c()) == null ? void 0 : m.event.assetList;
            return p ? p.map((g) => e.getAssetPlayer(g.identifier)) : [];
          },
          get playingIndex() {
            var m;
            const p = (m = c()) == null ? void 0 : m.event;
            return p && e.effectivePlayingAsset
              ? p.findAssetIndex(e.effectivePlayingAsset)
              : -1;
          },
          get scheduleItem() {
            return c();
          },
        };
      this.manager = {
        get events() {
          var m, p;
          return (
            ((m = e.schedule) == null || (p = m.events) == null
              ? void 0
              : p.slice(0)) || []
          );
        },
        get schedule() {
          var m, p;
          return (
            ((m = e.schedule) == null || (p = m.items) == null
              ? void 0
              : p.slice(0)) || []
          );
        },
        get interstitialPlayer() {
          return c() ? h : null;
        },
        get playerQueue() {
          return e.playerQueue.slice(0);
        },
        get bufferingAsset() {
          return e.bufferingAsset;
        },
        get bufferingItem() {
          return t();
        },
        get bufferingIndex() {
          const m = t();
          return e.findItemIndex(m);
        },
        get playingAsset() {
          return e.effectivePlayingAsset;
        },
        get playingItem() {
          return e.effectivePlayingItem;
        },
        get playingIndex() {
          const m = e.effectivePlayingItem;
          return e.findItemIndex(m);
        },
        primary: {
          get bufferedEnd() {
            return a();
          },
          get currentTime() {
            const m = e.timelinePos;
            return m > 0 ? m : 0;
          },
          set currentTime(m) {
            l(m, "primary");
          },
          get duration() {
            return o("primary");
          },
          get seekableStart() {
            var m;
            return (
              ((m = e.primaryDetails) == null ? void 0 : m.fragmentStart) || 0
            );
          },
        },
        integrated: {
          get bufferedEnd() {
            return r(
              t(),
              "integrated",
              e.bufferingAsset,
              "bufferedPos",
              "bufferedEnd"
            );
          },
          get currentTime() {
            return r(
              e.effectivePlayingItem,
              "integrated",
              e.effectivePlayingAsset,
              "timelinePos",
              "currentTime"
            );
          },
          set currentTime(m) {
            l(m, "integrated");
          },
          get duration() {
            return o("integrated");
          },
          get seekableStart() {
            var m;
            return i(
              ((m = e.primaryDetails) == null ? void 0 : m.fragmentStart) || 0,
              "integrated"
            );
          },
        },
        skip: () => {
          const m = e.effectivePlayingItem,
            p = m?.event;
          if (p && !p.restrictions.skip) {
            const g = e.findItemIndex(m);
            if (p.appendInPlace) {
              const y = m.playout.start + m.event.duration;
              l(y + 0.001, "playout");
            } else e.advanceAfterAssetEnded(p, g, 1 / 0);
          }
        },
      };
    }
    return this.manager;
  }
  get effectivePlayingItem() {
    return this.waitingItem || this.playingItem || this.endedItem;
  }
  get effectivePlayingAsset() {
    return this.playingAsset || this.endedAsset;
  }
  get playingLastItem() {
    var e;
    const t = this.playingItem,
      s = (e = this.schedule) == null ? void 0 : e.items;
    return !this.playbackStarted || !t || !s
      ? !1
      : this.findItemIndex(t) === s.length - 1;
  }
  get playbackStarted() {
    return this.effectivePlayingItem !== null;
  }
  get currentTime() {
    var e, t, s;
    if (this.mediaSelection === null) return;
    const r = this.waitingItem || this.playingItem;
    if (this.isInterstitial(r) && !r.event.appendInPlace) return;
    let i = this.media;
    !i &&
      (e = this.bufferingItem) != null &&
      (t = e.event) != null &&
      t.appendInPlace &&
      (i = this.primaryMedia);
    const a = (s = i) == null ? void 0 : s.currentTime;
    if (!(a === void 0 || !Qe(a))) return a;
  }
  get primaryMedia() {
    var e;
    return (
      this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null
    );
  }
  isInterstitial(e) {
    return !!(e != null && e.event);
  }
  retreiveMediaSource(e, t) {
    const s = this.getAssetPlayer(e);
    s && this.transferMediaFromPlayer(s, t);
  }
  transferMediaFromPlayer(e, t) {
    const s = e.interstitial.appendInPlace,
      r = e.media;
    if (s && r === this.primaryMedia) {
      if (
        ((this.bufferingAsset = null),
        (!t || (this.isInterstitial(t) && !t.event.appendInPlace)) && t && r)
      ) {
        this.detachedData = { media: r };
        return;
      }
      const i = e.transferMedia();
      this.log(`transfer MediaSource from ${e} ${Wn(i)}`),
        (this.detachedData = i);
    } else t && r && (this.shouldPlay || (this.shouldPlay = !r.paused));
  }
  transferMediaTo(e, t) {
    var s, r;
    if (e.media === t) return;
    let i = null;
    const a = this.hls,
      o = e !== a,
      l = o && e.interstitial.appendInPlace,
      c = (s = this.detachedData) == null ? void 0 : s.mediaSource;
    let h;
    if (a.media)
      l && ((i = a.transferMedia()), (this.detachedData = i)), (h = "Primary");
    else if (c) {
      const g = this.getBufferingPlayer();
      g
        ? ((i = g.transferMedia()), (h = `${g}`))
        : (h = "detached MediaSource");
    } else h = "detached media";
    if (!i) {
      if (c)
        (i = this.detachedData),
          this.log(`using detachedData: MediaSource ${Wn(i)}`);
      else if (!this.detachedData || a.media === t) {
        const g = this.playerQueue;
        g.length > 1 &&
          g.forEach((y) => {
            if (o && y.interstitial.appendInPlace !== l) {
              const b = y.interstitial;
              this.clearInterstitial(y.interstitial, null),
                (b.appendInPlace = !1),
                b.appendInPlace &&
                  this.warn(
                    `Could not change append strategy for queued assets ${b}`
                  );
            }
          }),
          this.hls.detachMedia(),
          (this.detachedData = { media: t });
      }
    }
    const m =
        i &&
        "mediaSource" in i &&
        ((r = i.mediaSource) == null ? void 0 : r.readyState) !== "closed",
      p = m && i ? i : t;
    if (
      (this.log(
        `${m ? "transfering MediaSource" : "attaching media"} to ${
          o ? e : "Primary"
        } from ${h}`
      ),
      p === i)
    ) {
      const g = o && e.assetId === this.schedule.assetIdAtEnd;
      p.overrides = {
        duration: this.schedule.duration,
        endOfStream: !o || g,
        cueRemoval: !o,
      };
    }
    e.attachMedia(p);
  }
  onInterstitialCueEnter() {
    this.onTimeupdate();
  }
  checkStart() {
    const e = this.schedule,
      t = e.events;
    if (!t || this.playbackDisabled || !this.media) return;
    this.bufferedPos === -1 && (this.bufferedPos = 0);
    const s = this.timelinePos,
      r = this.effectivePlayingItem;
    if (s === -1) {
      const i = this.hls.startPosition;
      if (((this.timelinePos = i), t.length && t[0].cue.pre)) {
        const a = e.findEventIndex(t[0].identifier);
        this.setSchedulePosition(a);
      } else if (i >= 0 || !this.primaryLive) {
        const a = (this.timelinePos = i > 0 ? i : 0),
          o = e.findItemIndexAtTime(a);
        this.setSchedulePosition(o);
      }
    } else if (r && !this.playingItem) {
      const i = e.findItemIndex(r);
      this.setSchedulePosition(i);
    }
  }
  advanceAfterAssetEnded(e, t, s) {
    const r = RA(e, s);
    if (!e.isAssetPastPlayoutLimit(r)) this.setSchedulePosition(t, r);
    else {
      const i = this.schedule.items;
      if (i) {
        const a = t + 1,
          o = i.length;
        if (a >= o) {
          this.setSchedulePosition(-1);
          return;
        }
        const l = e.resumeTime;
        this.timelinePos < l && ((this.timelinePos = l), this.checkBuffer()),
          this.setSchedulePosition(a);
      }
    }
  }
  setScheduleToAssetAtTime(e, t) {
    const s = this.schedule,
      r = t.parentIdentifier,
      i = s.getEvent(r);
    if (i) {
      const a = s.findEventIndex(r),
        o = s.findAssetIndex(i, e);
      this.advanceAfterAssetEnded(i, a, o - 1);
    }
  }
  setSchedulePosition(e, t) {
    const s = this.schedule.items;
    if (!s || this.playbackDisabled) return;
    this.log(`setSchedulePosition ${e}, ${t}`);
    const r = e >= 0 ? s[e] : null,
      i = this.playingItem,
      a = this.playingLastItem;
    if (this.isInterstitial(i)) {
      var o;
      const c = i.event,
        h = this.playingAsset,
        m = h?.identifier,
        p = m ? this.getAssetPlayer(m) : null;
      if (
        p &&
        m &&
        (!this.eventItemsMatch(i, r) ||
          (t !== void 0 &&
            m !== ((o = c.assetList) == null ? void 0 : o[t].identifier)))
      ) {
        var l;
        const g = c.findAssetIndex(h);
        if (
          (this.log(
            `INTERSTITIAL_ASSET_ENDED ${g + 1}/${c.assetList.length} ${Uh(h)}`
          ),
          (this.endedAsset = h),
          (this.playingAsset = null),
          this.hls.trigger($.INTERSTITIAL_ASSET_ENDED, {
            asset: h,
            assetListIndex: g,
            event: c,
            schedule: s.slice(0),
            scheduleIndex: e,
            player: p,
          }),
          i !== this.playingItem)
        ) {
          this.itemsMatch(i, this.playingItem) &&
            !this.playingAsset &&
            this.advanceAfterAssetEnded(
              c,
              this.findItemIndex(this.playingItem),
              g
            );
          return;
        }
        this.retreiveMediaSource(m, r),
          p.media &&
            !((l = this.detachedData) != null && l.mediaSource) &&
            p.detachMedia();
      }
      if (
        !this.eventItemsMatch(i, r) &&
        ((this.endedItem = i),
        (this.playingItem = null),
        this.log(`INTERSTITIAL_ENDED ${c} ${uc(i)}`),
        (c.hasPlayed = !0),
        this.hls.trigger($.INTERSTITIAL_ENDED, {
          event: c,
          schedule: s.slice(0),
          scheduleIndex: e,
        }),
        c.cue.once)
      ) {
        this.updateSchedule();
        const g = this.schedule.items;
        if (r && g) {
          const y = this.findItemIndex(r);
          this.advanceSchedule(y, g, t, i, a);
        }
        return;
      }
    }
    this.advanceSchedule(e, s, t, i, a);
  }
  advanceSchedule(e, t, s, r, i) {
    const a = e >= 0 ? t[e] : null,
      o = this.primaryMedia,
      l = this.playerQueue;
    if (
      (l.length &&
        l.forEach((c) => {
          const h = c.interstitial,
            m = this.schedule.findEventIndex(h.identifier);
          (m < e || m > e + 1) && this.clearInterstitial(h, a);
        }),
      this.isInterstitial(a))
    ) {
      this.timelinePos = Math.min(Math.max(this.timelinePos, a.start), a.end);
      const c = a.event;
      if (s === void 0) {
        s = this.schedule.findAssetIndex(c, this.timelinePos);
        const g = RA(c, s - 1);
        if (c.isAssetPastPlayoutLimit(g)) {
          this.advanceAfterAssetEnded(c, e, s);
          return;
        }
        s = g;
      }
      const h = this.waitingItem;
      this.assetsBuffered(a, o) || this.setBufferingItem(a);
      let m = this.preloadAssets(c, s);
      if (
        (this.eventItemsMatch(a, h || r) ||
          ((this.waitingItem = a),
          this.log(
            `INTERSTITIAL_STARTED ${uc(a)} ${
              c.appendInPlace ? "append in place" : ""
            }`
          ),
          this.hls.trigger($.INTERSTITIAL_STARTED, {
            event: c,
            schedule: t.slice(0),
            scheduleIndex: e,
          })),
        !c.assetListLoaded)
      ) {
        this.log(`Waiting for ASSET-LIST to complete loading ${c}`);
        return;
      }
      if (
        (c.assetListLoader &&
          (c.assetListLoader.destroy(), (c.assetListLoader = void 0)),
        !o)
      ) {
        this.log(`Waiting for attachMedia to start Interstitial ${c}`);
        return;
      }
      (this.waitingItem = this.endedItem = null), (this.playingItem = a);
      const p = c.assetList[s];
      if (!p) {
        const g = t[e + 1],
          y = this.media;
        g &&
          y &&
          !this.isInterstitial(g) &&
          y.currentTime < g.start &&
          (y.currentTime = this.timelinePos = g.start),
          this.advanceAfterAssetEnded(c, e, s || 0);
        return;
      }
      if (
        (m || (m = this.getAssetPlayer(p.identifier)),
        m === null || m.destroyed)
      ) {
        const g = c.assetList.length;
        this.warn(`asset ${s + 1}/${g} player destroyed ${c}`),
          (m = this.createAssetPlayer(c, p, s));
      }
      if (
        !this.eventItemsMatch(a, this.bufferingItem) &&
        c.appendInPlace &&
        this.isAssetBuffered(p)
      )
        return;
      this.startAssetPlayer(m, s, t, e, o), this.shouldPlay && p5(m.media);
    } else
      a !== null
        ? (this.resumePrimary(a, e, r), this.shouldPlay && p5(this.hls.media))
        : i &&
          this.isInterstitial(r) &&
          ((this.endedItem = null),
          (this.playingItem = r),
          r.event.appendInPlace ||
            this.attachPrimary(this.schedule.durations.primary, null));
  }
  get playbackDisabled() {
    return this.hls.config.enableInterstitialPlayback === !1;
  }
  get primaryDetails() {
    var e, t;
    return (e = this.mediaSelection) == null || (t = e.main) == null
      ? void 0
      : t.details;
  }
  get primaryLive() {
    var e;
    return !!((e = this.primaryDetails) != null && e.live);
  }
  resumePrimary(e, t, s) {
    var r;
    if (
      ((this.playingItem = e),
      (this.playingAsset = this.endedAsset = null),
      (this.waitingItem = this.endedItem = null),
      this.bufferedToItem(e),
      this.log(`resuming ${uc(e)}`),
      !((r = this.detachedData) != null && r.mediaSource))
    ) {
      let a = this.timelinePos;
      (a < e.start || a >= e.end) &&
        ((a = this.getPrimaryResumption(e, t)), (this.timelinePos = a)),
        this.attachPrimary(a, e);
    }
    if (!s) return;
    const i = this.schedule.items;
    i &&
      (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${uc(e)}`),
      this.hls.trigger($.INTERSTITIALS_PRIMARY_RESUMED, {
        schedule: i.slice(0),
        scheduleIndex: t,
      }),
      this.checkBuffer());
  }
  getPrimaryResumption(e, t) {
    const s = e.start;
    if (this.primaryLive) {
      const r = this.primaryDetails;
      if (t === 0) return this.hls.startPosition;
      if (r && (s < r.fragmentStart || s > r.edge))
        return this.hls.liveSyncPosition || -1;
    }
    return s;
  }
  isAssetBuffered(e) {
    const t = this.getAssetPlayer(e.identifier);
    return t != null && t.hls
      ? t.hls.bufferedToEnd
      : Ft.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >=
          e.timelineStart + (e.duration || 0);
  }
  attachPrimary(e, t, s) {
    t ? this.setBufferingItem(t) : (this.bufferingItem = this.playingItem),
      (this.bufferingAsset = null);
    const r = this.primaryMedia;
    if (!r) return;
    const i = this.hls;
    i.media
      ? this.checkBuffer()
      : (this.transferMediaTo(i, r), s && this.startLoadingPrimaryAt(e, s)),
      s || ((this.timelinePos = e), this.startLoadingPrimaryAt(e, s));
  }
  startLoadingPrimaryAt(e, t) {
    var s;
    const r = this.hls;
    !r.loadingEnabled ||
    !r.media ||
    Math.abs(
      (((s = r.mainForwardBufferInfo) == null ? void 0 : s.start) ||
        r.media.currentTime) - e
    ) > 0.5
      ? r.startLoad(e, t)
      : r.bufferingEnabled || r.resumeBuffering();
  }
  onManifestLoading() {
    this.stopLoad(),
      this.schedule.reset(),
      this.emptyPlayerQueue(),
      this.clearScheduleState(),
      (this.shouldPlay = !1),
      (this.bufferedPos = this.timelinePos = -1),
      (this.mediaSelection =
        this.altSelection =
        this.manager =
        this.requiredTracks =
          null),
      this.hls.off($.BUFFER_CODECS, this.onBufferCodecs, this),
      this.hls.on($.BUFFER_CODECS, this.onBufferCodecs, this);
  }
  onLevelUpdated(e, t) {
    if (t.level === -1) return;
    const s = this.hls.levels[t.level],
      r = In(In({}, this.mediaSelection || this.altSelection), {}, { main: s });
    (this.mediaSelection = r),
      this.schedule.parseInterstitialDateRanges(
        r,
        this.hls.config.interstitialAppendInPlace
      ),
      !this.effectivePlayingItem && this.schedule.items && this.checkStart();
  }
  onAudioTrackUpdated(e, t) {
    const s = this.hls.audioTracks[t.id],
      r = this.mediaSelection;
    if (!r) {
      this.altSelection = In(In({}, this.altSelection), {}, { audio: s });
      return;
    }
    const i = In(In({}, r), {}, { audio: s });
    this.mediaSelection = i;
  }
  onSubtitleTrackUpdated(e, t) {
    const s = this.hls.subtitleTracks[t.id],
      r = this.mediaSelection;
    if (!r) {
      this.altSelection = In(In({}, this.altSelection), {}, { subtitles: s });
      return;
    }
    const i = In(In({}, r), {}, { subtitles: s });
    this.mediaSelection = i;
  }
  onAudioTrackSwitching(e, t) {
    const s = AB(t);
    this.playerQueue.forEach(
      (r) => r.hls.setAudioOption(t) || r.hls.setAudioOption(s)
    );
  }
  onSubtitleTrackSwitch(e, t) {
    const s = AB(t);
    this.playerQueue.forEach(
      (r) =>
        r.hls.setSubtitleOption(t) ||
        (t.id !== -1 && r.hls.setSubtitleOption(s))
    );
  }
  onBufferCodecs(e, t) {
    const s = t.tracks;
    s && (this.requiredTracks = s);
  }
  onBufferAppended(e, t) {
    this.checkBuffer();
  }
  onBufferFlushed(e, t) {
    const s = this.playingItem;
    if (
      s &&
      !this.itemsMatch(s, this.bufferingItem) &&
      !this.isInterstitial(s)
    ) {
      const r = this.timelinePos;
      (this.bufferedPos = r), this.checkBuffer();
    }
  }
  onBufferedToEnd(e) {
    const t = this.schedule.events;
    if (this.bufferedPos < Number.MAX_VALUE && t) {
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (i.cue.post) {
          var s;
          const a = this.schedule.findEventIndex(i.identifier),
            o = (s = this.schedule.items) == null ? void 0 : s[a];
          this.isInterstitial(o) &&
            this.eventItemsMatch(o, this.bufferingItem) &&
            this.bufferedToItem(o, 0);
          break;
        }
      }
      this.bufferedPos = Number.MAX_VALUE;
    }
  }
  onMediaEnded(e) {
    const t = this.playingItem;
    if (!this.playingLastItem && t) {
      const s = this.findItemIndex(t);
      this.setSchedulePosition(s + 1);
    } else this.shouldPlay = !1;
  }
  updateItem(e, t) {
    const s = this.schedule.items;
    if (e && s) {
      const r = this.findItemIndex(e, t);
      return s[r] || null;
    }
    return null;
  }
  trimInPlace(e, t) {
    if (
      this.isInterstitial(e) &&
      e.event.appendInPlace &&
      t.end - e.end > 0.25
    ) {
      e.event.assetList.forEach((i, a) => {
        e.event.isAssetPastPlayoutLimit(a) &&
          this.clearAssetPlayer(i.identifier, null);
      });
      const s = e.end + 0.25,
        r = Ft.bufferInfo(this.primaryMedia, s, 0);
      (r.end > s || (r.nextStart || 0) > s) &&
        (this.attachPrimary(s, null), this.flushFrontBuffer(s));
    }
  }
  itemsMatch(e, t) {
    return (
      !!t &&
      (e === t ||
        (e.event && t.event && this.eventItemsMatch(e, t)) ||
        (!e.event &&
          !t.event &&
          this.findItemIndex(e) === this.findItemIndex(t)))
    );
  }
  eventItemsMatch(e, t) {
    var s;
    return (
      !!t &&
      (e === t ||
        e.event.identifier === ((s = t.event) == null ? void 0 : s.identifier))
    );
  }
  findItemIndex(e, t) {
    return e ? this.schedule.findItemIndex(e, t) : -1;
  }
  updateSchedule() {
    const e = this.mediaSelection;
    e && this.schedule.updateSchedule(e, []);
  }
  checkBuffer(e) {
    const t = this.schedule.items;
    if (!t) return;
    const s = Ft.bufferInfo(this.primaryMedia, this.timelinePos, 0);
    e && (this.bufferedPos = this.timelinePos),
      e || (e = s.len < 1),
      this.updateBufferedPos(s.end, t, e);
  }
  updateBufferedPos(e, t, s) {
    const r = this.schedule,
      i = this.bufferingItem;
    if (this.bufferedPos > e) return;
    if (t.length === 1 && this.itemsMatch(t[0], i)) {
      this.bufferedPos = e;
      return;
    }
    const a = this.playingItem,
      o = this.findItemIndex(a);
    let l = r.findItemIndexAtTime(e);
    if (this.bufferedPos < e) {
      var c, h;
      const m = this.findItemIndex(i),
        p = Math.min(m + 1, t.length - 1),
        g = t[p];
      if (
        (((l === -1 && i && e >= i.end) ||
          ((c = g.event) != null && c.appendInPlace && e + 0.01 >= g.start)) &&
          (l = p),
        p - o > 1 &&
          (i == null || (h = i.event) == null ? void 0 : h.appendInPlace) ===
            !1)
      )
        return;
      if (((this.bufferedPos = e), l > m && l > o)) this.bufferedToItem(g);
      else {
        const y = this.primaryDetails;
        this.primaryLive &&
          y &&
          e > y.edge - y.targetduration &&
          g.start < y.edge + this.hls.config.interstitialLiveLookAhead &&
          this.isInterstitial(g) &&
          this.preloadAssets(g.event, 0);
      }
    } else
      s &&
        a &&
        !this.itemsMatch(a, i) &&
        (l === o
          ? this.bufferedToItem(a)
          : l === o + 1 && this.bufferedToItem(t[l]));
  }
  assetsBuffered(e, t) {
    return e.event.assetList.length === 0
      ? !1
      : !e.event.assetList.some((r) => {
          const i = this.getAssetPlayer(r.identifier);
          return !(i != null && i.bufferedInPlaceToEnd(t));
        });
  }
  setBufferingItem(e) {
    const t = this.bufferingItem,
      s = this.schedule;
    if (this.itemsMatch(e, t))
      this.bufferingItem !== e && (this.bufferingItem = e);
    else {
      const { items: r, events: i } = s;
      if (!r || !i) return t;
      const a = this.isInterstitial(e),
        o = this.getBufferingPlayer();
      (this.bufferingItem = e),
        (this.bufferedPos = Math.max(
          e.start,
          Math.min(e.end, this.timelinePos)
        ));
      const l = o ? o.remaining : t ? t.end - this.timelinePos : 0;
      this.log(
        `INTERSTITIALS_BUFFERED_TO_BOUNDARY ${uc(e)}` +
          (t ? ` (${l.toFixed(2)} remaining)` : "")
      ),
        this.playbackDisabled ||
          (a
            ? e.event.assetList.forEach((c) => {
                const h = this.getAssetPlayer(c.identifier);
                h && h.resumeBuffering();
              })
            : (this.hls.resumeBuffering(),
              this.playerQueue.forEach((c) => c.pauseBuffering()))),
        this.hls.trigger($.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
          events: i.slice(0),
          schedule: r.slice(0),
          bufferingIndex: this.findItemIndex(e),
          playingIndex: this.findItemIndex(this.playingItem),
        });
    }
    return t;
  }
  bufferedToItem(e, t = 0) {
    const s = this.setBufferingItem(e);
    if (!this.playbackDisabled) {
      if (this.isInterstitial(e)) this.bufferedToEvent(e, t);
      else if (s !== null) {
        this.bufferingAsset = null;
        const r = this.detachedData;
        r
          ? r.mediaSource
            ? this.attachPrimary(e.start, e, !0)
            : this.preloadPrimary(e)
          : this.preloadPrimary(e);
      }
    }
  }
  preloadPrimary(e) {
    const t = this.findItemIndex(e),
      s = this.getPrimaryResumption(e, t);
    this.startLoadingPrimaryAt(s);
  }
  bufferedToEvent(e, t) {
    const s = e.event,
      r = s.assetList.length === 0 && !s.assetListLoader,
      i = s.cue.once;
    if (r || !i) {
      const a = this.preloadAssets(s, t);
      if (a != null && a.interstitial.appendInPlace) {
        const o = s.assetList[t],
          l = this.primaryMedia;
        o && l && this.bufferAssetPlayer(a, l);
      }
    }
  }
  preloadAssets(e, t) {
    const s = e.assetUrl,
      r = e.assetList.length,
      i = r === 0 && !e.assetListLoader,
      a = e.cue.once;
    if (i) {
      const l = e.timelineStart;
      if (e.appendInPlace) {
        var o;
        const p = this.playingItem;
        !this.isInterstitial(p) &&
          (p == null || (o = p.nextEvent) == null ? void 0 : o.identifier) ===
            e.identifier &&
          this.flushFrontBuffer(l + 0.25);
      }
      let c,
        h = 0;
      if (
        (!this.playingItem &&
          this.primaryLive &&
          ((h = this.hls.startPosition),
          h === -1 && (h = this.hls.liveSyncPosition || 0)),
        h && !(e.cue.pre || e.cue.post))
      ) {
        const p = h - l;
        p > 0 && (c = Math.round(p * 1e3) / 1e3);
      }
      if (
        (this.log(
          `Load interstitial asset ${t + 1}/${s ? 1 : r} ${e}${
            c ? ` live-start: ${h} start-offset: ${c}` : ""
          }`
        ),
        s)
      )
        return this.createAsset(e, 0, 0, l, e.duration, s);
      const m = this.assetListLoader.loadAssetList(e, c);
      m && (e.assetListLoader = m);
    } else if (!a && r) {
      for (let l = t; l < r; l++) {
        const c = e.assetList[l],
          h = this.getAssetPlayerQueueIndex(c.identifier);
        (h === -1 || this.playerQueue[h].destroyed) &&
          !c.error &&
          this.createAssetPlayer(e, c, l);
      }
      return this.getAssetPlayer(e.assetList[t].identifier);
    }
    return null;
  }
  flushFrontBuffer(e) {
    const t = this.requiredTracks;
    if (!t) return;
    this.log(`Removing front buffer starting at ${e}`),
      Object.keys(t).forEach((r) => {
        this.hls.trigger($.BUFFER_FLUSHING, {
          startOffset: e,
          endOffset: 1 / 0,
          type: r,
        });
      });
  }
  getAssetPlayerQueueIndex(e) {
    const t = this.playerQueue;
    for (let s = 0; s < t.length; s++) if (e === t[s].assetId) return s;
    return -1;
  }
  getAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    return this.playerQueue[t] || null;
  }
  getBufferingPlayer() {
    const { playerQueue: e, primaryMedia: t } = this;
    if (t) {
      for (let s = 0; s < e.length; s++) if (e[s].media === t) return e[s];
    }
    return null;
  }
  createAsset(e, t, s, r, i, a) {
    const o = {
      parentIdentifier: e.identifier,
      identifier: TIe(e, a, t),
      duration: i,
      startOffset: s,
      timelineStart: r,
      uri: a,
    };
    return this.createAssetPlayer(e, o, t);
  }
  createAssetPlayer(e, t, s) {
    const r = this.hls,
      i = r.userConfig;
    let a = i.videoPreference;
    const o = r.loadLevelObj || r.levels[r.currentLevel];
    (a || o) &&
      ((a = Tn({}, a)),
      o.videoCodec && (a.videoCodec = o.videoCodec),
      o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
    const l = r.audioTracks[r.audioTrack],
      c = r.subtitleTracks[r.subtitleTrack];
    let h = 0;
    if (this.primaryLive || e.appendInPlace) {
      const _ = this.timelinePos - t.timelineStart;
      if (_ > 1) {
        const R = t.duration;
        R && _ < R && (h = _);
      }
    }
    const m = t.identifier,
      p = In(
        In({}, i),
        {},
        {
          autoStartLoad: !0,
          startFragPrefetch: !0,
          primarySessionId: r.sessionId,
          assetPlayerId: m,
          abrEwmaDefaultEstimate: r.bandwidthEstimate,
          interstitialsController: void 0,
          startPosition: h,
          liveDurationInfinity: !1,
          testBandwidth: !1,
          videoPreference: a,
          audioPreference: l || i.audioPreference,
          subtitlePreference: c || i.subtitlePreference,
        }
      );
    e.appendInPlace &&
      ((e.appendInPlaceStarted = !0),
      t.timelineStart && (p.timelineOffset = t.timelineStart));
    const g = p.cmcd;
    g != null &&
      g.sessionId &&
      g.contentId &&
      (p.cmcd = Tn({}, g, { contentId: gg(t.uri) })),
      this.getAssetPlayer(m) &&
        this.warn(`Duplicate date range identifier ${e} and asset ${m}`);
    const y = new RIe(this.HlsPlayerClass, p, e, t);
    this.playerQueue.push(y), (e.assetList[s] = t);
    const b = (_) => {
      if (_.live) {
        const D = new Error(`Interstitials MUST be VOD assets ${e}`),
          L = {
            fatal: !0,
            type: gt.OTHER_ERROR,
            details: we.INTERSTITIAL_ASSET_ITEM_ERROR,
            error: D,
          };
        this.handleAssetItemError(
          L,
          e,
          this.schedule.findEventIndex(e.identifier),
          s,
          D.message
        );
        return;
      }
      const R = _.edge - _.fragmentStart,
        C = t.duration;
      (C === null || R > C) &&
        (this.log(`Interstitial asset "${m}" duration change ${C} > ${R}`),
        (t.duration = R),
        this.updateSchedule());
    };
    y.on($.LEVEL_UPDATED, (_, { details: R }) => b(R)),
      y.on($.LEVEL_PTS_UPDATED, (_, { details: R }) => b(R));
    const w = (_, R) => {
      const C = this.getAssetPlayer(m);
      if (C && R.tracks) {
        C.off($.BUFFER_CODECS, w), (C.tracks = R.tracks);
        const D = this.primaryMedia;
        this.bufferingAsset === C.assetItem &&
          D &&
          !C.media &&
          this.bufferAssetPlayer(C, D);
      }
    };
    y.on($.BUFFER_CODECS, w);
    const S = () => {
      var _;
      const R = this.getAssetPlayer(m);
      if ((this.log(`buffered to end of asset ${R}`), !R)) return;
      const C = this.schedule.findEventIndex(e.identifier),
        D = (_ = this.schedule.items) == null ? void 0 : _[C];
      if (this.isInterstitial(D)) {
        const P = e.findAssetIndex(t),
          V = RA(e, P);
        if (!e.isAssetPastPlayoutLimit(V)) this.bufferedToItem(D, V);
        else {
          var L;
          const N = (L = this.schedule.items) == null ? void 0 : L[C + 1];
          N && this.bufferedToItem(N);
        }
      }
    };
    y.on($.BUFFERED_TO_END, S);
    const A = (_) => () => {
      if (!this.getAssetPlayer(m)) return;
      this.shouldPlay = !0;
      const C = this.schedule.findEventIndex(e.identifier);
      this.advanceAfterAssetEnded(e, C, _);
    };
    return (
      y.once($.MEDIA_ENDED, A(s)),
      y.once($.PLAYOUT_LIMIT_REACHED, A(1 / 0)),
      y.on($.ERROR, (_, R) => {
        const C = this.getAssetPlayer(m);
        if (R.details === we.BUFFER_STALLED_ERROR) {
          if (C != null && C.media) {
            const D = C.currentTime,
              L = C.duration - D;
            D && e.appendInPlace && L / C.media.playbackRate < 0.5
              ? (this.log(
                  `Advancing buffer past end of asset ${m} ${e} at ${C.media.currentTime}`
                ),
                S())
              : (this.warn(`Stalled at ${D} of ${D + L} in asset ${m} ${e}`),
                this.onTimeupdate(),
                this.checkBuffer(!0));
          }
          return;
        }
        this.handleAssetItemError(
          R,
          e,
          this.schedule.findEventIndex(e.identifier),
          s,
          `Asset player error ${R.error} ${e}`
        );
      }),
      y.on($.DESTROYING, () => {
        if (!this.getAssetPlayer(m)) return;
        const R = new Error(`Asset player destroyed unexpectedly ${m}`),
          C = {
            fatal: !0,
            type: gt.OTHER_ERROR,
            details: we.INTERSTITIAL_ASSET_ITEM_ERROR,
            error: R,
          };
        this.handleAssetItemError(
          C,
          e,
          this.schedule.findEventIndex(e.identifier),
          s,
          R.message
        );
      }),
      this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Uh(t)}`),
      this.hls.trigger($.INTERSTITIAL_ASSET_PLAYER_CREATED, {
        asset: t,
        assetListIndex: s,
        event: e,
        player: y,
      }),
      y
    );
  }
  clearInterstitial(e, t) {
    e.assetList.forEach((s) => {
      this.clearAssetPlayer(s.identifier, t);
    }),
      e.reset();
  }
  resetAssetPlayer(e) {
    const t = this.getAssetPlayerQueueIndex(e);
    if (t !== -1) {
      this.log(`reset asset player "${e}" after error`);
      const s = this.playerQueue[t];
      this.transferMediaFromPlayer(s, null), s.resetDetails();
    }
  }
  clearAssetPlayer(e, t) {
    const s = this.getAssetPlayerQueueIndex(e);
    if (s !== -1) {
      this.log(`clear asset player "${e}" toSegment: ${t && uc(t)}`);
      const r = this.playerQueue[s];
      this.transferMediaFromPlayer(r, t),
        this.playerQueue.splice(s, 1),
        r.destroy();
    }
  }
  emptyPlayerQueue() {
    let e;
    for (; (e = this.playerQueue.pop()); ) e.destroy();
    this.playerQueue = [];
  }
  startAssetPlayer(e, t, s, r, i) {
    const { interstitial: a, assetItem: o, assetId: l } = e,
      c = a.assetList.length,
      h = this.playingAsset;
    (this.endedAsset = null),
      (this.playingAsset = o),
      (!h || h.identifier !== l) &&
        (h && (this.clearAssetPlayer(h.identifier, s[r]), delete h.error),
        this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${Uh(o)}`),
        this.hls.trigger($.INTERSTITIAL_ASSET_STARTED, {
          asset: o,
          assetListIndex: t,
          event: a,
          schedule: s.slice(0),
          scheduleIndex: r,
          player: e,
        })),
      this.bufferAssetPlayer(e, i);
  }
  bufferAssetPlayer(e, t) {
    var s, r;
    const { interstitial: i, assetItem: a } = e,
      o = this.schedule.findEventIndex(i.identifier),
      l = (s = this.schedule.items) == null ? void 0 : s[o];
    if (!l) return;
    this.setBufferingItem(l), (this.bufferingAsset = a);
    const c = this.getBufferingPlayer();
    if (c === e) return;
    const h = i.appendInPlace;
    if (h && c?.interstitial.appendInPlace === !1) return;
    const m =
      c?.tracks ||
      ((r = this.detachedData) == null ? void 0 : r.tracks) ||
      this.requiredTracks;
    if (h && a !== this.playingAsset) {
      if (!e.tracks) return;
      if (m && !iY(m, e.tracks)) {
        const p = new Error(
            `Asset ${Uh(a)} SourceBuffer tracks ('${Object.keys(
              e.tracks
            )}') are not compatible with primary content tracks ('${Object.keys(
              m
            )}')`
          ),
          g = {
            fatal: !0,
            type: gt.OTHER_ERROR,
            details: we.INTERSTITIAL_ASSET_ITEM_ERROR,
            error: p,
          },
          y = i.findAssetIndex(a);
        this.handleAssetItemError(g, i, o, y, p.message);
        return;
      }
    }
    this.transferMediaTo(e, t);
  }
  handleAssetItemError(e, t, s, r, i) {
    if (e.details === we.BUFFER_STALLED_ERROR) return;
    const a = t.assetList[r];
    this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Uh(a)} ${e.error}`);
    const o = a?.identifier,
      l = this.getAssetPlayerQueueIndex(o),
      c = this.playerQueue[l] || null,
      h = this.schedule.items,
      m = Tn({}, e, {
        fatal: !1,
        errorAction: mv(!0),
        asset: a,
        assetListIndex: r,
        event: t,
        schedule: h,
        scheduleIndex: s,
        player: c,
      });
    if ((this.hls.trigger($.INTERSTITIAL_ASSET_ERROR, m), !e.fatal)) return;
    const p = this.playingAsset,
      g = new Error(i);
    if (
      (a && (this.clearAssetPlayer(o, null), (a.error = g)),
      !t.assetList.some((y) => !y.error))
    )
      t.error = g;
    else {
      for (let y = r; y < t.assetList.length; y++)
        this.resetAssetPlayer(t.assetList[y].identifier);
      this.updateSchedule();
    }
    t.error
      ? this.primaryFallback(t)
      : p && p.identifier === o && this.advanceAfterAssetEnded(t, s, r);
  }
  primaryFallback(e) {
    const t = e.timelineStart,
      s = this.effectivePlayingItem;
    if ((this.updateSchedule(), s)) {
      this.log(
        `Fallback to primary from event "${e.identifier}" start: ${t} pos: ${
          this.timelinePos
        } playing: ${s ? uc(s) : "<none>"} error: ${e.error}`
      );
      let r = this.timelinePos;
      r === -1 && (r = this.hls.startPosition);
      const i = this.updateItem(s, r);
      this.itemsMatch(s, i) && this.clearInterstitial(e, null),
        e.appendInPlace &&
          (this.attachPrimary(t, null), this.flushFrontBuffer(t));
      const a = this.schedule.findItemIndexAtTime(r);
      this.setSchedulePosition(a);
    } else this.checkStart();
  }
  onAssetListLoaded(e, t) {
    var s;
    const r = t.event,
      i = r.identifier,
      a = t.assetListResponse.ASSETS;
    if (!this.schedule.hasEvent(i)) return;
    const o = r.timelineStart,
      l = r.duration;
    let c = 0;
    a.forEach((y, b) => {
      const w = parseFloat(y.DURATION);
      this.createAsset(r, b, c, o + c, w, y.URI), (c += w);
    }),
      (r.duration = c),
      this.log(`Loaded asset-list with duration: ${c} (was: ${l}) ${r}`);
    const h = this.waitingItem,
      m = h?.event.identifier === i;
    this.updateSchedule();
    const p = (s = this.bufferingItem) == null ? void 0 : s.event;
    if (m) {
      var g;
      const y = this.schedule.findEventIndex(i),
        b = (g = this.schedule.items) == null ? void 0 : g[y];
      if (b) {
        if (
          !this.playingItem &&
          this.timelinePos > b.end &&
          this.schedule.findItemIndexAtTime(this.timelinePos) !== y
        ) {
          (r.error = new Error(
            `Interstitial no longer within playback range ${this.timelinePos} ${r}`
          )),
            this.primaryFallback(r);
          return;
        }
        this.setBufferingItem(b);
      }
      this.setSchedulePosition(y);
    } else if (p?.identifier === i && p.appendInPlace) {
      const y = r.assetList[0],
        b = this.getAssetPlayer(y.identifier),
        w = this.primaryMedia;
      y && b && w && this.bufferAssetPlayer(b, w);
    }
  }
  onError(e, t) {
    switch (t.details) {
      case we.ASSET_LIST_PARSING_ERROR:
      case we.ASSET_LIST_LOAD_ERROR:
      case we.ASSET_LIST_LOAD_TIMEOUT: {
        const s = t.interstitial;
        s && this.primaryFallback(s);
        break;
      }
      case we.BUFFER_STALLED_ERROR: {
        this.onTimeupdate(), this.checkBuffer(!0);
        break;
      }
    }
  }
}
const g5 = 500;
class LIe extends QP {
  constructor(e, t, s) {
    super(e, t, s, "subtitle-stream-controller", lt.SUBTITLE),
      (this.currentTrackId = -1),
      (this.tracksBuffered = []),
      (this.mainDetails = null),
      this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(),
      super.onHandlerDestroying(),
      (this.mainDetails = null);
  }
  registerListeners() {
    super.registerListeners();
    const { hls: e } = this;
    e.on($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.on($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.on($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.on($.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
      e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const { hls: e } = this;
    e.off($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.off($.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.off($.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.off($.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
      e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  startLoad(e, t) {
    this.stopLoad(),
      (this.state = Me.IDLE),
      this.setInterval(g5),
      (this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset),
      (this.startPosition = t ? -1 : e),
      this.tick();
  }
  onManifestLoading() {
    super.onManifestLoading(), (this.mainDetails = null);
  }
  onMediaDetaching(e, t) {
    (this.tracksBuffered = []), super.onMediaDetaching(e, t);
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details;
  }
  onSubtitleFragProcessed(e, t) {
    const { frag: s, success: r } = t;
    if (
      (this.fragContextChanged(s) ||
        (Os(s) && (this.fragPrevious = s), (this.state = Me.IDLE)),
      !r)
    )
      return;
    const i = this.tracksBuffered[this.currentTrackId];
    if (!i) return;
    let a;
    const o = s.start;
    for (let c = 0; c < i.length; c++)
      if (o >= i[c].start && o <= i[c].end) {
        a = i[c];
        break;
      }
    const l = s.start + s.duration;
    a ? (a.end = l) : ((a = { start: o, end: l }), i.push(a)),
      this.fragmentTracker.fragBuffered(s),
      this.fragBufferedComplete(s, null),
      this.media && this.tick();
  }
  onBufferFlushing(e, t) {
    const { startOffset: s, endOffset: r } = t;
    if (s === 0 && r !== Number.POSITIVE_INFINITY) {
      const i = r - 1;
      if (i <= 0) return;
      (t.endOffsetSubtitles = Math.max(0, i)),
        this.tracksBuffered.forEach((a) => {
          for (let o = 0; o < a.length; ) {
            if (a[o].end <= i) {
              a.shift();
              continue;
            } else if (a[o].start < i) a[o].start = i;
            else break;
            o++;
          }
        }),
        this.fragmentTracker.removeFragmentsInRange(s, i, lt.SUBTITLE);
    }
  }
  onError(e, t) {
    const s = t.frag;
    s?.type === lt.SUBTITLE &&
      (t.details === we.FRAG_GAP && this.fragmentTracker.fragBuffered(s, !0),
      this.fragCurrent && this.fragCurrent.abortRequests(),
      this.state !== Me.STOPPED && (this.state = Me.IDLE));
  }
  onSubtitleTracksUpdated(e, { subtitleTracks: t }) {
    if (this.levels && nX(this.levels, t)) {
      this.levels = t.map((s) => new fv(s));
      return;
    }
    (this.tracksBuffered = []),
      (this.levels = t.map((s) => {
        const r = new fv(s);
        return (this.tracksBuffered[r.id] = []), r;
      })),
      this.fragmentTracker.removeFragmentsInRange(
        0,
        Number.POSITIVE_INFINITY,
        lt.SUBTITLE
      ),
      (this.fragPrevious = null),
      (this.mediaBuffer = null);
  }
  onSubtitleTrackSwitch(e, t) {
    var s;
    if (
      ((this.currentTrackId = t.id),
      !((s = this.levels) != null && s.length) || this.currentTrackId === -1)
    ) {
      this.clearInterval();
      return;
    }
    const r = this.levels[this.currentTrackId];
    r != null && r.details
      ? (this.mediaBuffer = this.mediaBufferTimeRanges)
      : (this.mediaBuffer = null),
      r && this.state !== Me.STOPPED && this.setInterval(g5);
  }
  onSubtitleTrackLoaded(e, t) {
    var s;
    const { currentTrackId: r, levels: i } = this,
      { details: a, id: o } = t;
    if (!i) {
      this.warn(`Subtitle tracks were reset while loading level ${o}`);
      return;
    }
    const l = i[o];
    if (o >= i.length || !l) return;
    this.log(
      `Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${
        a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""
      },duration:${a.totalduration}`
    ),
      (this.mediaBuffer = this.mediaBufferTimeRanges);
    let c = 0;
    if (a.live || ((s = l.details) != null && s.live)) {
      if (a.deltaUpdateFailed) return;
      const m = this.mainDetails;
      if (!m) {
        this.startFragRequested = !1;
        return;
      }
      const p = m.fragments[0];
      if (!l.details)
        a.hasProgramDateTime && m.hasProgramDateTime
          ? (Jw(a, m), (c = a.fragmentStart))
          : p && ((c = p.start), cI(a, c));
      else {
        var h;
        (c = this.alignPlaylists(
          a,
          l.details,
          (h = this.levelLastLoaded) == null ? void 0 : h.details
        )),
          c === 0 && p && ((c = p.start), cI(a, c));
      }
      m && !this.startFragRequested && this.setStartPosition(m, c);
    }
    (l.details = a),
      (this.levelLastLoaded = l),
      o === r &&
        (this.hls.trigger($.SUBTITLE_TRACK_UPDATED, {
          details: a,
          id: o,
          groupId: t.groupId,
        }),
        this.tick(),
        a.live &&
          !this.fragCurrent &&
          this.media &&
          this.state === Me.IDLE &&
          (id(null, a.fragments, this.media.currentTime, 0) ||
            (this.warn("Subtitle playlist not aligned with playback"),
            (l.details = void 0))));
  }
  _handleFragmentLoadComplete(e) {
    const { frag: t, payload: s } = e,
      r = t.decryptdata,
      i = this.hls;
    if (
      !this.fragContextChanged(t) &&
      s &&
      s.byteLength > 0 &&
      r != null &&
      r.key &&
      r.iv &&
      hf(r.method)
    ) {
      const a = performance.now();
      this.decrypter
        .decrypt(new Uint8Array(s), r.key.buffer, r.iv.buffer, XP(r.method))
        .catch((o) => {
          throw (
            (i.trigger($.ERROR, {
              type: gt.MEDIA_ERROR,
              details: we.FRAG_DECRYPT_ERROR,
              fatal: !1,
              error: o,
              reason: o.message,
              frag: t,
            }),
            o)
          );
        })
        .then((o) => {
          const l = performance.now();
          i.trigger($.FRAG_DECRYPTED, {
            frag: t,
            payload: o,
            stats: { tstart: a, tdecrypt: l },
          });
        })
        .catch((o) => {
          this.warn(`${o.name}: ${o.message}`), (this.state = Me.IDLE);
        });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = Me.IDLE;
      return;
    }
    if (this.state === Me.IDLE) {
      const { currentTrackId: e, levels: t } = this,
        s = t?.[e];
      if (!s || !t.length || !s.details || this.waitForLive(s)) return;
      const { config: r } = this,
        i = this.getLoadPosition(),
        a = Ft.bufferedInfo(
          this.tracksBuffered[this.currentTrackId] || [],
          i,
          r.maxBufferHole
        ),
        { end: o, len: l } = a,
        c = s.details,
        h = this.hls.maxBufferLength + c.levelTargetDuration;
      if (l > h) return;
      const m = c.fragments,
        p = m.length,
        g = c.edge;
      let y = null;
      const b = this.fragPrevious;
      if (o < g) {
        const A = r.maxFragLookUpTolerance,
          _ = o > g - A ? 0 : A;
        (y = id(b, m, Math.max(m[0].start, o), _)),
          !y && b && b.start < m[0].start && (y = m[0]);
      } else y = m[p - 1];
      if (((y = this.filterReplacedPrimary(y, s.details)), !y)) return;
      const w = y.sn - c.startSN,
        S = m[w - 1];
      if (
        (S &&
          S.cc === y.cc &&
          this.fragmentTracker.getState(S) === qs.NOT_LOADED &&
          (y = S),
        this.fragmentTracker.getState(y) === qs.NOT_LOADED)
      ) {
        const A = this.mapToInitFragWhenRequired(y);
        A && this.loadFragment(A, s, o);
      }
    }
  }
  loadFragment(e, t, s) {
    Os(e) ? super.loadFragment(e, t, s) : this._loadInitSegment(e, t);
  }
  get mediaBufferTimeRanges() {
    return new DIe(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class DIe {
  constructor(e) {
    this.buffered = void 0;
    const t = (s, r, i) => {
      if (((r = r >>> 0), r > i - 1))
        throw new DOMException(
          `Failed to execute '${s}' on 'TimeRanges': The index provided (${r}) is greater than the maximum bound (${i})`
        );
      return e[r][s];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(s) {
        return t("end", s, e.length);
      },
      start(s) {
        return t("start", s, e.length);
      },
    };
  }
}
const PIe = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499,
  },
  fX = (n) => String.fromCharCode(PIe[n] || n),
  Ea = 15,
  il = 100,
  MIe = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 },
  NIe = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 },
  OIe = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 },
  jIe = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 },
  FIe = [
    "white",
    "green",
    "blue",
    "cyan",
    "red",
    "yellow",
    "magenta",
    "black",
    "transparent",
  ];
class UIe {
  constructor() {
    (this.time = null), (this.verboseLevel = 0);
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const s = typeof t == "function" ? t() : t;
      pn.log(`${this.time} [${e}] ${s}`);
    }
  }
}
const Su = function (e) {
  const t = [];
  for (let s = 0; s < e.length; s++) t.push(e[s].toString(16));
  return t;
};
class mX {
  constructor() {
    (this.foreground = "white"),
      (this.underline = !1),
      (this.italics = !1),
      (this.background = "black"),
      (this.flash = !1);
  }
  reset() {
    (this.foreground = "white"),
      (this.underline = !1),
      (this.italics = !1),
      (this.background = "black"),
      (this.flash = !1);
  }
  setStyles(e) {
    const t = ["foreground", "underline", "italics", "background", "flash"];
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      e.hasOwnProperty(r) && (this[r] = e[r]);
    }
  }
  isDefault() {
    return (
      this.foreground === "white" &&
      !this.underline &&
      !this.italics &&
      this.background === "black" &&
      !this.flash
    );
  }
  equals(e) {
    return (
      this.foreground === e.foreground &&
      this.underline === e.underline &&
      this.italics === e.italics &&
      this.background === e.background &&
      this.flash === e.flash
    );
  }
  copy(e) {
    (this.foreground = e.foreground),
      (this.underline = e.underline),
      (this.italics = e.italics),
      (this.background = e.background),
      (this.flash = e.flash);
  }
  toString() {
    return (
      "color=" +
      this.foreground +
      ", underline=" +
      this.underline +
      ", italics=" +
      this.italics +
      ", background=" +
      this.background +
      ", flash=" +
      this.flash
    );
  }
}
class $Ie {
  constructor() {
    (this.uchar = " "), (this.penState = new mX());
  }
  reset() {
    (this.uchar = " "), this.penState.reset();
  }
  setChar(e, t) {
    (this.uchar = e), this.penState.copy(t);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    (this.uchar = e.uchar), this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class BIe {
  constructor(e) {
    (this.chars = []),
      (this.pos = 0),
      (this.currPenState = new mX()),
      (this.cueStartTime = null),
      (this.logger = void 0);
    for (let t = 0; t < il; t++) this.chars.push(new $Ie());
    this.logger = e;
  }
  equals(e) {
    for (let t = 0; t < il; t++)
      if (!this.chars[t].equals(e.chars[t])) return !1;
    return !0;
  }
  copy(e) {
    for (let t = 0; t < il; t++) this.chars[t].copy(e.chars[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < il; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  setCursor(e) {
    this.pos !== e && (this.pos = e),
      this.pos < 0
        ? (this.logger.log(3, "Negative cursor position " + this.pos),
          (this.pos = 0))
        : this.pos > il &&
          (this.logger.log(3, "Too large cursor position " + this.pos),
          (this.pos = il));
  }
  moveCursor(e) {
    const t = this.pos + e;
    if (e > 1)
      for (let s = this.pos + 1; s < t + 1; s++)
        this.chars[s].setPenState(this.currPenState);
    this.setCursor(t);
  }
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const t = fX(e);
    if (this.pos >= il) {
      this.logger.log(
        0,
        () =>
          "Cannot insert " +
          e.toString(16) +
          " (" +
          t +
          ") at position " +
          this.pos +
          ". Skipping it!"
      );
      return;
    }
    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let t;
    for (t = e; t < il; t++) this.chars[t].reset();
  }
  clear() {
    this.clearFromPos(0), (this.pos = 0), this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let t = !0;
    for (let s = 0; s < il; s++) {
      const r = this.chars[s].uchar;
      r !== " " && (t = !1), e.push(r);
    }
    return t ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e),
      this.chars[this.pos].setPenState(this.currPenState);
  }
}
class kA {
  constructor(e) {
    (this.rows = []),
      (this.currRow = Ea - 1),
      (this.nrRollUpRows = null),
      (this.lastOutputScreen = null),
      (this.logger = void 0);
    for (let t = 0; t < Ea; t++) this.rows.push(new BIe(e));
    this.logger = e;
  }
  reset() {
    for (let e = 0; e < Ea; e++) this.rows[e].clear();
    this.currRow = Ea - 1;
  }
  equals(e) {
    let t = !0;
    for (let s = 0; s < Ea; s++)
      if (!this.rows[s].equals(e.rows[s])) {
        t = !1;
        break;
      }
    return t;
  }
  copy(e) {
    for (let t = 0; t < Ea; t++) this.rows[t].copy(e.rows[t]);
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < Ea; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + Wn(e));
    let t = e.row - 1;
    if (
      (this.nrRollUpRows &&
        t < this.nrRollUpRows - 1 &&
        (t = this.nrRollUpRows - 1),
      this.nrRollUpRows && this.currRow !== t)
    ) {
      for (let o = 0; o < Ea; o++) this.rows[o].clear();
      const i = this.currRow + 1 - this.nrRollUpRows,
        a = this.lastOutputScreen;
      if (a) {
        const o = a.rows[i].cueStartTime,
          l = this.logger.time;
        if (o !== null && l !== null && o < l)
          for (let c = 0; c < this.nrRollUpRows; c++)
            this.rows[t - this.nrRollUpRows + c + 1].copy(a.rows[i + c]);
      }
    }
    this.currRow = t;
    const s = this.rows[this.currRow];
    if (e.indent !== null) {
      const i = e.indent,
        a = Math.max(i - 1, 0);
      s.setCursor(e.indent), (e.color = s.chars[a].penState.foreground);
    }
    const r = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1,
    };
    this.setPen(r);
  }
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + Wn(e)),
      this.backSpace(),
      this.setPen(e),
      this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows,
      t = this.rows.splice(e, 1)[0];
    t.clear(),
      this.rows.splice(this.currRow, 0, t),
      this.logger.log(2, "Rolling up");
  }
  getDisplayText(e) {
    e = e || !1;
    const t = [];
    let s = "",
      r = -1;
    for (let i = 0; i < Ea; i++) {
      const a = this.rows[i].getTextString();
      a &&
        ((r = i + 1),
        e ? t.push("Row " + r + ": '" + a + "'") : t.push(a.trim()));
    }
    return (
      t.length > 0 &&
        (e
          ? (s = "[" + t.join(" | ") + "]")
          : (s = t.join(`
`))),
      s
    );
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class v5 {
  constructor(e, t, s) {
    (this.chNr = void 0),
      (this.outputFilter = void 0),
      (this.mode = void 0),
      (this.verbose = void 0),
      (this.displayedMemory = void 0),
      (this.nonDisplayedMemory = void 0),
      (this.lastOutputScreen = void 0),
      (this.currRollUpRow = void 0),
      (this.writeScreen = void 0),
      (this.cueStartTime = void 0),
      (this.logger = void 0),
      (this.chNr = e),
      (this.outputFilter = t),
      (this.mode = null),
      (this.verbose = 0),
      (this.displayedMemory = new kA(s)),
      (this.nonDisplayedMemory = new kA(s)),
      (this.lastOutputScreen = new kA(s)),
      (this.currRollUpRow = this.displayedMemory.rows[Ea - 1]),
      (this.writeScreen = this.displayedMemory),
      (this.mode = null),
      (this.cueStartTime = null),
      (this.logger = s);
  }
  reset() {
    (this.mode = null),
      this.displayedMemory.reset(),
      this.nonDisplayedMemory.reset(),
      this.lastOutputScreen.reset(),
      this.outputFilter.reset(),
      (this.currRollUpRow = this.displayedMemory.rows[Ea - 1]),
      (this.writeScreen = this.displayedMemory),
      (this.mode = null),
      (this.cueStartTime = null);
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode &&
      ((this.mode = e),
      this.logger.log(2, () => "MODE=" + e),
      this.mode === "MODE_POP-ON"
        ? (this.writeScreen = this.nonDisplayedMemory)
        : ((this.writeScreen = this.displayedMemory), this.writeScreen.reset()),
      this.mode !== "MODE_ROLL-UP" &&
        ((this.displayedMemory.nrRollUpRows = null),
        (this.nonDisplayedMemory.nrRollUpRows = null)),
      (this.mode = e));
  }
  insertChars(e) {
    for (let s = 0; s < e.length; s++) this.writeScreen.insertChar(e[s]);
    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)),
      (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") &&
        (this.logger.log(
          1,
          () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)
        ),
        this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"),
      this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"),
      this.mode !== "MODE_TEXT" &&
        (this.writeScreen.backSpace(),
        this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {}
  ccAON() {}
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"),
      this.writeScreen.clearToEndOfRow(),
      this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"),
      (this.writeScreen = this.displayedMemory),
      this.setMode("MODE_ROLL-UP"),
      this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"),
      this.writeScreen.setPen({ flash: !0 });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"),
      this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"),
      this.displayedMemory.reset(),
      this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"),
      this.writeScreen.rollUp(),
      this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"),
      this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (
      (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON")
    ) {
      const e = this.displayedMemory;
      (this.displayedMemory = this.nonDisplayedMemory),
        (this.nonDisplayedMemory = e),
        (this.writeScreen = this.nonDisplayedMemory),
        this.logger.log(
          1,
          () => "DISP: " + this.displayedMemory.getDisplayText()
        );
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"),
      this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const t = { flash: !1 };
    if (((t.underline = e % 2 === 1), (t.italics = e >= 46), t.italics))
      t.foreground = "white";
    else {
      const s = Math.floor(e / 2) - 16,
        r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      t.foreground = r[s];
    }
    this.logger.log(2, "MIDROW: " + Wn(t)), this.writeScreen.setPen(t);
  }
  outputDataUpdate(e = !1) {
    const t = this.logger.time;
    t !== null &&
      this.outputFilter &&
      (this.cueStartTime === null && !this.displayedMemory.isEmpty()
        ? (this.cueStartTime = t)
        : this.displayedMemory.equals(this.lastOutputScreen) ||
          (this.outputFilter.newCue(
            this.cueStartTime,
            t,
            this.lastOutputScreen
          ),
          e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(),
          (this.cueStartTime = this.displayedMemory.isEmpty() ? null : t)),
      this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter &&
      (this.displayedMemory.isEmpty() ||
        (this.outputFilter.newCue &&
          this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory),
        (this.cueStartTime = e)));
  }
}
class y5 {
  constructor(e, t, s) {
    (this.channels = void 0),
      (this.currentChannel = 0),
      (this.cmdHistory = VIe()),
      (this.logger = void 0);
    const r = (this.logger = new UIe());
    this.channels = [null, new v5(e, t, r), new v5(e + 1, s, r)];
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t);
  }
  addData(e, t) {
    this.logger.time = e;
    for (let s = 0; s < t.length; s += 2) {
      const r = t[s] & 127,
        i = t[s + 1] & 127;
      let a = !1,
        o = null;
      if (r === 0 && i === 0) continue;
      this.logger.log(
        3,
        () => "[" + Su([t[s], t[s + 1]]) + "] -> (" + Su([r, i]) + ")"
      );
      const l = this.cmdHistory;
      if (r >= 16 && r <= 31) {
        if (HIe(r, i, l)) {
          ab(null, null, l),
            this.logger.log(
              3,
              () => "Repeated command (" + Su([r, i]) + ") is dropped"
            );
          continue;
        }
        ab(r, i, this.cmdHistory),
          (a = this.parseCmd(r, i)),
          a || (a = this.parseMidrow(r, i)),
          a || (a = this.parsePAC(r, i)),
          a || (a = this.parseBackgroundAttributes(r, i));
      } else ab(null, null, l);
      if (!a && ((o = this.parseChars(r, i)), o)) {
        const h = this.currentChannel;
        h && h > 0
          ? this.channels[h].insertChars(o)
          : this.logger.log(2, "No channel found yet. TEXT-MODE?");
      }
      !a &&
        !o &&
        this.logger.log(
          2,
          () =>
            "Couldn't parse cleaned data " +
            Su([r, i]) +
            " orig: " +
            Su([t[s], t[s + 1]])
        );
    }
  }
  parseCmd(e, t) {
    const s =
        (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47,
      r = (e === 23 || e === 31) && t >= 33 && t <= 35;
    if (!(s || r)) return !1;
    const i = e === 20 || e === 21 || e === 23 ? 1 : 2,
      a = this.channels[i];
    return (
      e === 20 || e === 21 || e === 28 || e === 29
        ? t === 32
          ? a.ccRCL()
          : t === 33
          ? a.ccBS()
          : t === 34
          ? a.ccAOF()
          : t === 35
          ? a.ccAON()
          : t === 36
          ? a.ccDER()
          : t === 37
          ? a.ccRU(2)
          : t === 38
          ? a.ccRU(3)
          : t === 39
          ? a.ccRU(4)
          : t === 40
          ? a.ccFON()
          : t === 41
          ? a.ccRDC()
          : t === 42
          ? a.ccTR()
          : t === 43
          ? a.ccRTD()
          : t === 44
          ? a.ccEDM()
          : t === 45
          ? a.ccCR()
          : t === 46
          ? a.ccENM()
          : t === 47 && a.ccEOC()
        : a.ccTO(t - 32),
      (this.currentChannel = i),
      !0
    );
  }
  parseMidrow(e, t) {
    let s = 0;
    if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
      if ((e === 17 ? (s = 1) : (s = 2), s !== this.currentChannel))
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const r = this.channels[s];
      return r
        ? (r.ccMIDROW(t),
          this.logger.log(3, () => "MIDROW (" + Su([e, t]) + ")"),
          !0)
        : !1;
    }
    return !1;
  }
  parsePAC(e, t) {
    let s;
    const r =
        ((e >= 17 && e <= 23) || (e >= 25 && e <= 31)) && t >= 64 && t <= 127,
      i = (e === 16 || e === 24) && t >= 64 && t <= 95;
    if (!(r || i)) return !1;
    const a = e <= 23 ? 1 : 2;
    t >= 64 && t <= 95
      ? (s = a === 1 ? MIe[e] : OIe[e])
      : (s = a === 1 ? NIe[e] : jIe[e]);
    const o = this.channels[a];
    return o
      ? (o.setPAC(this.interpretPAC(s, t)), (this.currentChannel = a), !0)
      : !1;
  }
  interpretPAC(e, t) {
    let s;
    const r = { color: null, italics: !1, indent: null, underline: !1, row: e };
    return (
      t > 95 ? (s = t - 96) : (s = t - 64),
      (r.underline = (s & 1) === 1),
      s <= 13
        ? (r.color = [
            "white",
            "green",
            "blue",
            "cyan",
            "red",
            "yellow",
            "magenta",
            "white",
          ][Math.floor(s / 2)])
        : s <= 15
        ? ((r.italics = !0), (r.color = "white"))
        : (r.indent = Math.floor((s - 16) / 2) * 4),
      r
    );
  }
  parseChars(e, t) {
    let s,
      r = null,
      i = null;
    if (
      (e >= 25 ? ((s = 2), (i = e - 8)) : ((s = 1), (i = e)),
      i >= 17 && i <= 19)
    ) {
      let a;
      i === 17 ? (a = t + 80) : i === 18 ? (a = t + 112) : (a = t + 144),
        this.logger.log(
          2,
          () => "Special char '" + fX(a) + "' in channel " + s
        ),
        (r = [a]);
    } else e >= 32 && e <= 127 && (r = t === 0 ? [e] : [e, t]);
    return r && this.logger.log(3, () => "Char codes =  " + Su(r).join(",")), r;
  }
  parseBackgroundAttributes(e, t) {
    const s = (e === 16 || e === 24) && t >= 32 && t <= 47,
      r = (e === 23 || e === 31) && t >= 45 && t <= 47;
    if (!(s || r)) return !1;
    let i;
    const a = {};
    e === 16 || e === 24
      ? ((i = Math.floor((t - 32) / 2)),
        (a.background = FIe[i]),
        t % 2 === 1 && (a.background = a.background + "_semi"))
      : t === 45
      ? (a.background = "transparent")
      : ((a.foreground = "black"), t === 47 && (a.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(a), !0;
  }
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e];
      t && t.reset();
    }
    ab(null, null, this.cmdHistory);
  }
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const s = this.channels[t];
      s && s.cueSplitAtTime(e);
    }
  }
}
function ab(n, e, t) {
  (t.a = n), (t.b = e);
}
function HIe(n, e, t) {
  return t.a === n && t.b === e;
}
function VIe() {
  return { a: null, b: null };
}
var lM = (function () {
  if (Zw != null && Zw.VTTCue) return self.VTTCue;
  const n = ["", "lr", "rl"],
    e = ["start", "middle", "end", "left", "right"];
  function t(o, l) {
    if (typeof l != "string" || !Array.isArray(o)) return !1;
    const c = l.toLowerCase();
    return ~o.indexOf(c) ? c : !1;
  }
  function s(o) {
    return t(n, o);
  }
  function r(o) {
    return t(e, o);
  }
  function i(o, ...l) {
    let c = 1;
    for (; c < arguments.length; c++) {
      const h = arguments[c];
      for (const m in h) o[m] = h[m];
    }
    return o;
  }
  function a(o, l, c) {
    const h = this,
      m = { enumerable: !0 };
    h.hasBeenReset = !1;
    let p = "",
      g = !1,
      y = o,
      b = l,
      w = c,
      S = null,
      A = "",
      _ = !0,
      R = "auto",
      C = "start",
      D = 50,
      L = "middle",
      P = 50,
      V = "middle";
    Object.defineProperty(
      h,
      "id",
      i({}, m, {
        get: function () {
          return p;
        },
        set: function (N) {
          p = "" + N;
        },
      })
    ),
      Object.defineProperty(
        h,
        "pauseOnExit",
        i({}, m, {
          get: function () {
            return g;
          },
          set: function (N) {
            g = !!N;
          },
        })
      ),
      Object.defineProperty(
        h,
        "startTime",
        i({}, m, {
          get: function () {
            return y;
          },
          set: function (N) {
            if (typeof N != "number")
              throw new TypeError("Start time must be set to a number.");
            (y = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "endTime",
        i({}, m, {
          get: function () {
            return b;
          },
          set: function (N) {
            if (typeof N != "number")
              throw new TypeError("End time must be set to a number.");
            (b = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "text",
        i({}, m, {
          get: function () {
            return w;
          },
          set: function (N) {
            (w = "" + N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "region",
        i({}, m, {
          get: function () {
            return S;
          },
          set: function (N) {
            (S = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "vertical",
        i({}, m, {
          get: function () {
            return A;
          },
          set: function (N) {
            const W = s(N);
            if (W === !1)
              throw new SyntaxError(
                "An invalid or illegal string was specified."
              );
            (A = W), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "snapToLines",
        i({}, m, {
          get: function () {
            return _;
          },
          set: function (N) {
            (_ = !!N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "line",
        i({}, m, {
          get: function () {
            return R;
          },
          set: function (N) {
            if (typeof N != "number" && N !== "auto")
              throw new SyntaxError(
                "An invalid number or illegal string was specified."
              );
            (R = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "lineAlign",
        i({}, m, {
          get: function () {
            return C;
          },
          set: function (N) {
            const W = r(N);
            if (!W)
              throw new SyntaxError(
                "An invalid or illegal string was specified."
              );
            (C = W), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "position",
        i({}, m, {
          get: function () {
            return D;
          },
          set: function (N) {
            if (N < 0 || N > 100)
              throw new Error("Position must be between 0 and 100.");
            (D = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "positionAlign",
        i({}, m, {
          get: function () {
            return L;
          },
          set: function (N) {
            const W = r(N);
            if (!W)
              throw new SyntaxError(
                "An invalid or illegal string was specified."
              );
            (L = W), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "size",
        i({}, m, {
          get: function () {
            return P;
          },
          set: function (N) {
            if (N < 0 || N > 100)
              throw new Error("Size must be between 0 and 100.");
            (P = N), (this.hasBeenReset = !0);
          },
        })
      ),
      Object.defineProperty(
        h,
        "align",
        i({}, m, {
          get: function () {
            return V;
          },
          set: function (N) {
            const W = r(N);
            if (!W)
              throw new SyntaxError(
                "An invalid or illegal string was specified."
              );
            (V = W), (this.hasBeenReset = !0);
          },
        })
      ),
      (h.displayState = void 0);
  }
  return (
    (a.prototype.getCueAsHTML = function () {
      return self.WebVTT.convertCueToDOMTree(self, this.text);
    }),
    a
  );
})();
class zIe {
  decode(e, t) {
    if (!e) return "";
    if (typeof e != "string") throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function pX(n) {
  function e(s, r, i, a) {
    return (s | 0) * 3600 + (r | 0) * 60 + (i | 0) + parseFloat(a || 0);
  }
  const t = n.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return t
    ? parseFloat(t[2]) > 59
      ? e(t[2], t[3], 0, t[4])
      : e(t[1], t[2], t[3], t[4])
    : null;
}
class GIe {
  constructor() {
    this.values = Object.create(null);
  }
  set(e, t) {
    !this.get(e) && t !== "" && (this.values[e] = t);
  }
  get(e, t, s) {
    return s
      ? this.has(e)
        ? this.values[e]
        : t[s]
      : this.has(e)
      ? this.values[e]
      : t;
  }
  has(e) {
    return e in this.values;
  }
  alt(e, t, s) {
    for (let r = 0; r < s.length; ++r)
      if (t === s[r]) {
        this.set(e, t);
        break;
      }
  }
  integer(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
  }
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const s = parseFloat(t);
      if (s >= 0 && s <= 100) return this.set(e, s), !0;
    }
    return !1;
  }
}
function gX(n, e, t, s) {
  const r = s ? n.split(s) : [n];
  for (const i in r) {
    if (typeof r[i] != "string") continue;
    const a = r[i].split(t);
    if (a.length !== 2) continue;
    const o = a[0],
      l = a[1];
    e(o, l);
  }
}
const gI = new lM(0, 0, ""),
  ob = gI.align === "middle" ? "middle" : "center";
function qIe(n, e, t) {
  const s = n;
  function r() {
    const o = pX(n);
    if (o === null) throw new Error("Malformed timestamp: " + s);
    return (n = n.replace(/^[^\sa-zA-Z-]+/, "")), o;
  }
  function i(o, l) {
    const c = new GIe();
    gX(
      o,
      function (p, g) {
        let y;
        switch (p) {
          case "region":
            for (let b = t.length - 1; b >= 0; b--)
              if (t[b].id === g) {
                c.set(p, t[b].region);
                break;
              }
            break;
          case "vertical":
            c.alt(p, g, ["rl", "lr"]);
            break;
          case "line":
            (y = g.split(",")),
              c.integer(p, y[0]),
              c.percent(p, y[0]) && c.set("snapToLines", !1),
              c.alt(p, y[0], ["auto"]),
              y.length === 2 && c.alt("lineAlign", y[1], ["start", ob, "end"]);
            break;
          case "position":
            (y = g.split(",")),
              c.percent(p, y[0]),
              y.length === 2 &&
                c.alt("positionAlign", y[1], [
                  "start",
                  ob,
                  "end",
                  "line-left",
                  "line-right",
                  "auto",
                ]);
            break;
          case "size":
            c.percent(p, g);
            break;
          case "align":
            c.alt(p, g, ["start", ob, "end", "left", "right"]);
            break;
        }
      },
      /:/,
      /\s/
    ),
      (l.region = c.get("region", null)),
      (l.vertical = c.get("vertical", ""));
    let h = c.get("line", "auto");
    h === "auto" && gI.line === -1 && (h = -1),
      (l.line = h),
      (l.lineAlign = c.get("lineAlign", "start")),
      (l.snapToLines = c.get("snapToLines", !0)),
      (l.size = c.get("size", 100)),
      (l.align = c.get("align", ob));
    let m = c.get("position", "auto");
    m === "auto" &&
      gI.position === 50 &&
      (m =
        l.align === "start" || l.align === "left"
          ? 0
          : l.align === "end" || l.align === "right"
          ? 100
          : 50),
      (l.position = m);
  }
  function a() {
    n = n.replace(/^\s+/, "");
  }
  if ((a(), (e.startTime = r()), a(), n.slice(0, 3) !== "-->"))
    throw new Error(
      "Malformed time stamp (time stamps must be separated by '-->'): " + s
    );
  (n = n.slice(3)), a(), (e.endTime = r()), a(), i(n, e);
}
function vX(n) {
  return n.replace(
    /<br(?: \/)?>/gi,
    `
`
  );
}
class WIe {
  constructor() {
    (this.state = "INITIAL"),
      (this.buffer = ""),
      (this.decoder = new zIe()),
      (this.regionList = []),
      (this.cue = null),
      (this.oncue = void 0),
      (this.onparsingerror = void 0),
      (this.onflush = void 0);
  }
  parse(e) {
    const t = this;
    e && (t.buffer += t.decoder.decode(e, { stream: !0 }));
    function s() {
      let i = t.buffer,
        a = 0;
      for (
        i = vX(i);
        a < i.length &&
        i[a] !== "\r" &&
        i[a] !==
          `
`;

      )
        ++a;
      const o = i.slice(0, a);
      return (
        i[a] === "\r" && ++a,
        i[a] ===
          `
` && ++a,
        (t.buffer = i.slice(a)),
        o
      );
    }
    function r(i) {
      gX(i, function (a, o) {}, /:/);
    }
    try {
      let i = "";
      if (t.state === "INITIAL") {
        if (!/\r\n|\n/.test(t.buffer)) return this;
        i = s();
        const o = i.match(/^()?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0]))
          throw new Error("Malformed WebVTT signature.");
        t.state = "HEADER";
      }
      let a = !1;
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer)) return this;
        switch ((a ? (a = !1) : (i = s()), t.state)) {
          case "HEADER":
            /:/.test(i) ? r(i) : i || (t.state = "ID");
            continue;
          case "NOTE":
            i || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(i)) {
              t.state = "NOTE";
              break;
            }
            if (!i) continue;
            if (
              ((t.cue = new lM(0, 0, "")),
              (t.state = "CUE"),
              i.indexOf("-->") === -1)
            ) {
              t.cue.id = i;
              continue;
            }
          case "CUE":
            if (!t.cue) {
              t.state = "BADCUE";
              continue;
            }
            try {
              qIe(i, t.cue, t.regionList);
            } catch {
              (t.cue = null), (t.state = "BADCUE");
              continue;
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const o = i.indexOf("-->") !== -1;
              if (!i || (o && (a = !0))) {
                t.oncue && t.cue && t.oncue(t.cue),
                  (t.cue = null),
                  (t.state = "ID");
                continue;
              }
              if (t.cue === null) continue;
              t.cue.text &&
                (t.cue.text += `
`),
                (t.cue.text += i);
            }
            continue;
          case "BADCUE":
            i || (t.state = "ID");
        }
      }
    } catch {
      t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue),
        (t.cue = null),
        (t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE");
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if (
        ((e.cue || e.state === "HEADER") &&
          ((e.buffer += `

`),
          e.parse()),
        e.state === "INITIAL" || e.state === "BADWEBVTT")
      )
        throw new Error("Malformed WebVTT signature.");
    } catch (t) {
      e.onparsingerror && e.onparsingerror(t);
    }
    return e.onflush && e.onflush(), this;
  }
}
const KIe = /\r\n|\n\r|\n|\r/g,
  CA = function (e, t, s = 0) {
    return e.slice(s, s + t.length) === t;
  },
  YIe = function (e) {
    let t = parseInt(e.slice(-3));
    const s = parseInt(e.slice(-6, -4)),
      r = parseInt(e.slice(-9, -7)),
      i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
    if (!Qe(t) || !Qe(s) || !Qe(r) || !Qe(i))
      throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
    return (t += 1e3 * s), (t += 60 * 1e3 * r), (t += 3600 * 1e3 * i), t;
  };
function cM(n, e, t) {
  return gg(n.toString()) + gg(e.toString()) + gg(t);
}
const XIe = function (e, t, s) {
  let r = e[t],
    i = e[r.prevCC];
  if (!i || (!i.new && r.new)) {
    (e.ccOffset = e.presentationOffset = r.start), (r.new = !1);
    return;
  }
  for (; (a = i) != null && a.new; ) {
    var a;
    (e.ccOffset += r.start - i.start), (r.new = !1), (r = i), (i = e[r.prevCC]);
  }
  e.presentationOffset = s;
};
function QIe(n, e, t, s, r, i, a) {
  const o = new WIe(),
    l = ki(new Uint8Array(n))
      .trim()
      .replace(
        KIe,
        `
`
      ).split(`
`),
    c = [],
    h = e ? hCe(e.baseTime, e.timescale) : 0;
  let m = "00:00.000",
    p = 0,
    g = 0,
    y,
    b = !0;
  (o.oncue = function (w) {
    const S = t[s];
    let A = t.ccOffset;
    const _ = (p - h) / 9e4;
    if (
      (S != null &&
        S.new &&
        (g !== void 0 ? (A = t.ccOffset = S.start) : XIe(t, s, _)),
      _)
    ) {
      if (!e) {
        y = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      A = _ - t.presentationOffset;
    }
    const R = w.endTime - w.startTime,
      C = Xi((w.startTime + A - g) * 9e4, r * 9e4) / 9e4;
    (w.startTime = Math.max(C, 0)), (w.endTime = Math.max(C + R, 0));
    const D = w.text.trim();
    (w.text = decodeURIComponent(encodeURIComponent(D))),
      w.id || (w.id = cM(w.startTime, w.endTime, D)),
      w.endTime > 0 && c.push(w);
  }),
    (o.onparsingerror = function (w) {
      y = w;
    }),
    (o.onflush = function () {
      if (y) {
        a(y);
        return;
      }
      i(c);
    }),
    l.forEach((w) => {
      if (b)
        if (CA(w, "X-TIMESTAMP-MAP=")) {
          (b = !1),
            w
              .slice(16)
              .split(",")
              .forEach((S) => {
                CA(S, "LOCAL:")
                  ? (m = S.slice(6))
                  : CA(S, "MPEGTS:") && (p = parseInt(S.slice(7)));
              });
          try {
            g = YIe(m) / 1e3;
          } catch (S) {
            y = S;
          }
          return;
        } else w === "" && (b = !1);
      o.parse(
        w +
          `
`
      );
    }),
    o.flush();
}
const IA = "stpp.ttml.im1t",
  yX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
  bX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
  ZIe = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end",
  };
function b5(n, e, t, s) {
  const r = Qt(new Uint8Array(n), ["mdat"]);
  if (r.length === 0) {
    s(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const i = r.map((o) => ki(o)),
    a = dCe(e.baseTime, 1, e.timescale);
  try {
    i.forEach((o) => t(JIe(o, a)));
  } catch (o) {
    s(o);
  }
}
function JIe(n, e) {
  const r = new DOMParser()
    .parseFromString(n, "text/xml")
    .getElementsByTagName("tt")[0];
  if (!r) throw new Error("Invalid ttml");
  const i = {
      frameRate: 30,
      subFrameRate: 1,
      frameRateMultiplier: 0,
      tickRate: 0,
    },
    a = Object.keys(i).reduce(
      (m, p) => ((m[p] = r.getAttribute(`ttp:${p}`) || i[p]), m),
      {}
    ),
    o = r.getAttribute("xml:space") !== "preserve",
    l = x5(LA(r, "styling", "style")),
    c = x5(LA(r, "layout", "region")),
    h = LA(r, "body", "[begin]");
  return [].map
    .call(h, (m) => {
      const p = xX(m, o);
      if (!p || !m.hasAttribute("begin")) return null;
      const g = PA(m.getAttribute("begin"), a),
        y = PA(m.getAttribute("dur"), a);
      let b = PA(m.getAttribute("end"), a);
      if (g === null) throw w5(m);
      if (b === null) {
        if (y === null) throw w5(m);
        b = g + y;
      }
      const w = new lM(g - e, b - e, p);
      w.id = cM(w.startTime, w.endTime, w.text);
      const S = c[m.getAttribute("region")],
        A = l[m.getAttribute("style")],
        _ = eLe(S, A, l),
        { textAlign: R } = _;
      if (R) {
        const C = ZIe[R];
        C && (w.lineAlign = C), (w.align = R);
      }
      return Tn(w, _), w;
    })
    .filter((m) => m !== null);
}
function LA(n, e, t) {
  const s = n.getElementsByTagName(e)[0];
  return s ? [].slice.call(s.querySelectorAll(t)) : [];
}
function x5(n) {
  return n.reduce((e, t) => {
    const s = t.getAttribute("xml:id");
    return s && (e[s] = t), e;
  }, {});
}
function xX(n, e) {
  return [].slice.call(n.childNodes).reduce((t, s, r) => {
    var i;
    return s.nodeName === "br" && r
      ? t +
          `
`
      : (i = s.childNodes) != null && i.length
      ? xX(s, e)
      : e
      ? t + s.textContent.trim().replace(/\s+/g, " ")
      : t + s.textContent;
  }, "");
}
function eLe(n, e, t) {
  const s = "http://www.w3.org/ns/ttml#styling";
  let r = null;
  const i = [
      "displayAlign",
      "textAlign",
      "color",
      "backgroundColor",
      "fontSize",
      "fontFamily",
    ],
    a = n != null && n.hasAttribute("style") ? n.getAttribute("style") : null;
  return (
    a && t.hasOwnProperty(a) && (r = t[a]),
    i.reduce((o, l) => {
      const c = DA(e, s, l) || DA(n, s, l) || DA(r, s, l);
      return c && (o[l] = c), o;
    }, {})
  );
}
function DA(n, e, t) {
  return n && n.hasAttributeNS(e, t) ? n.getAttributeNS(e, t) : null;
}
function w5(n) {
  return new Error(`Could not parse ttml timestamp ${n}`);
}
function PA(n, e) {
  if (!n) return null;
  let t = pX(n);
  return (
    t === null &&
      (yX.test(n) ? (t = tLe(n, e)) : bX.test(n) && (t = nLe(n, e))),
    t
  );
}
function tLe(n, e) {
  const t = yX.exec(n),
    s = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + s / e.frameRate;
}
function nLe(n, e) {
  const t = bX.exec(n),
    s = Number(t[1]);
  switch (t[2]) {
    case "h":
      return s * 3600;
    case "m":
      return s * 60;
    case "ms":
      return s * 1e3;
    case "f":
      return s / e.frameRate;
    case "t":
      return s / e.tickRate;
  }
  return s;
}
class lb {
  constructor(e, t) {
    (this.timelineController = void 0),
      (this.cueRanges = []),
      (this.trackName = void 0),
      (this.startTime = null),
      (this.endTime = null),
      (this.screen = null),
      (this.timelineController = e),
      (this.trackName = t);
  }
  dispatchCue() {
    this.startTime !== null &&
      (this.timelineController.addCues(
        this.trackName,
        this.startTime,
        this.endTime,
        this.screen,
        this.cueRanges
      ),
      (this.startTime = null));
  }
  newCue(e, t, s) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e),
      (this.endTime = t),
      (this.screen = s),
      this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    (this.cueRanges = []), (this.startTime = null);
  }
}
class sLe {
  constructor(e) {
    (this.hls = void 0),
      (this.media = null),
      (this.config = void 0),
      (this.enabled = !0),
      (this.Cues = void 0),
      (this.textTracks = []),
      (this.tracks = []),
      (this.initPTS = []),
      (this.unparsedVttFrags = []),
      (this.captionsTracks = {}),
      (this.nonNativeCaptionsTracks = {}),
      (this.cea608Parser1 = void 0),
      (this.cea608Parser2 = void 0),
      (this.lastCc = -1),
      (this.lastSn = -1),
      (this.lastPartIndex = -1),
      (this.prevCC = -1),
      (this.vttCCs = S5()),
      (this.captionsProperties = void 0),
      (this.hls = e),
      (this.config = e.config),
      (this.Cues = e.config.cueHandler),
      (this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode,
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode,
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode,
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode,
        },
      }),
      e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.on($.FRAG_LOADING, this.onFragLoading, this),
      e.on($.FRAG_LOADED, this.onFragLoaded, this),
      e.on($.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
      e.on($.FRAG_DECRYPTED, this.onFragDecrypted, this),
      e.on($.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.on($.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
      e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const { hls: e } = this;
    e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off($.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.off($.FRAG_LOADING, this.onFragLoading, this),
      e.off($.FRAG_LOADED, this.onFragLoaded, this),
      e.off($.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
      e.off($.FRAG_DECRYPTED, this.onFragDecrypted, this),
      e.off($.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.off($.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
      e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      (this.hls = this.config = this.media = null),
      (this.cea608Parser1 = this.cea608Parser2 = void 0);
  }
  initCea608Parsers() {
    const e = new lb(this, "textTrack1"),
      t = new lb(this, "textTrack2"),
      s = new lb(this, "textTrack3"),
      r = new lb(this, "textTrack4");
    (this.cea608Parser1 = new y5(1, e, t)),
      (this.cea608Parser2 = new y5(3, s, r));
  }
  addCues(e, t, s, r, i) {
    let a = !1;
    for (let o = i.length; o--; ) {
      const l = i[o],
        c = rLe(l[0], l[1], t, s);
      if (
        c >= 0 &&
        ((l[0] = Math.min(l[0], t)),
        (l[1] = Math.max(l[1], s)),
        (a = !0),
        c / (s - t) > 0.5)
      )
        return;
    }
    if ((a || i.push([t, s]), this.config.renderTextTracksNatively)) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, t, s, r);
    } else {
      const o = this.Cues.newCue(null, t, s, r);
      this.hls.trigger($.CUES_PARSED, { type: "captions", cues: o, track: e });
    }
  }
  onInitPtsFound(e, { frag: t, id: s, initPTS: r, timescale: i }) {
    const { unparsedVttFrags: a } = this;
    s === lt.MAIN && (this.initPTS[t.cc] = { baseTime: r, timescale: i }),
      a.length &&
        ((this.unparsedVttFrags = []),
        a.forEach((o) => {
          this.initPTS[o.frag.cc]
            ? this.onFragLoaded($.FRAG_LOADED, o)
            : this.hls.trigger($.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: o.frag,
                error: new Error(
                  "Subtitle discontinuity domain does not match main"
                ),
              });
        }));
  }
  getExistingTrack(e, t) {
    const { media: s } = this;
    if (s)
      for (let r = 0; r < s.textTracks.length; r++) {
        const i = s.textTracks[r];
        if (
          E5(i, {
            name: e,
            lang: t,
            characteristics:
              "transcribes-spoken-dialog,describes-music-and-sound",
          })
        )
          return i;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively
      ? this.createNativeTrack(e)
      : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e]) return;
    const { captionsProperties: t, captionsTracks: s, media: r } = this,
      { label: i, languageCode: a } = t[e],
      o = this.getExistingTrack(i, a);
    if (o) (s[e] = o), Qh(s[e]), uX(s[e], r);
    else {
      const l = this.createTextTrack("captions", i, a);
      l && ((l[e] = !0), (s[e] = l));
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e]) return;
    const t = this.captionsProperties[e];
    if (!t) return;
    const s = t.label,
      r = {
        _id: e,
        label: s,
        kind: "captions",
        default: t.media ? !!t.media.default : !1,
        closedCaptions: t.media,
      };
    (this.nonNativeCaptionsTracks[e] = r),
      this.hls.trigger($.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [r] });
  }
  createTextTrack(e, t, s) {
    const r = this.media;
    if (r) return r.addTextTrack(e, t, s);
  }
  onMediaAttaching(e, t) {
    (this.media = t.media), t.mediaSource || this._cleanTracks();
  }
  onMediaDetaching(e, t) {
    const s = !!t.transferMedia;
    if (((this.media = null), s)) return;
    const { captionsTracks: r } = this;
    Object.keys(r).forEach((i) => {
      Qh(r[i]), delete r[i];
    }),
      (this.nonNativeCaptionsTracks = {});
  }
  onManifestLoading() {
    (this.lastCc = -1),
      (this.lastSn = -1),
      (this.lastPartIndex = -1),
      (this.prevCC = -1),
      (this.vttCCs = S5()),
      this._cleanTracks(),
      (this.tracks = []),
      (this.captionsTracks = {}),
      (this.nonNativeCaptionsTracks = {}),
      (this.textTracks = []),
      (this.unparsedVttFrags = []),
      (this.initPTS = []),
      this.cea608Parser1 &&
        this.cea608Parser2 &&
        (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const { media: e } = this;
    if (!e) return;
    const t = e.textTracks;
    if (t) for (let s = 0; s < t.length; s++) Qh(t[s]);
  }
  onSubtitleTracksUpdated(e, t) {
    const s = t.subtitleTracks || [],
      r = s.some((i) => i.textCodec === IA);
    if (this.config.enableWebVTT || (r && this.config.enableIMSC1)) {
      if (nX(this.tracks, s)) {
        this.tracks = s;
        return;
      }
      if (
        ((this.textTracks = []),
        (this.tracks = s),
        this.config.renderTextTracksNatively)
      ) {
        const a = this.media,
          o = a ? ox(a.textTracks) : null;
        if (
          (this.tracks.forEach((l, c) => {
            let h;
            if (o) {
              let m = null;
              for (let p = 0; p < o.length; p++)
                if (o[p] && E5(o[p], l)) {
                  (m = o[p]), (o[p] = null);
                  break;
                }
              m && (h = m);
            }
            if (h) Qh(h);
            else {
              const m = wX(l);
              (h = this.createTextTrack(m, l.name, l.lang)),
                h && (h.mode = "disabled");
            }
            h && this.textTracks.push(h);
          }),
          o != null && o.length)
        ) {
          const l = o.filter((c) => c !== null).map((c) => c.label);
          l.length &&
            this.hls.logger.warn(
              `Media element contains unused subtitle tracks: ${l.join(
                ", "
              )}. Replace media element for each source to clear TextTracks and captions menu.`
            );
        }
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o,
        }));
        this.hls.trigger($.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: a });
      }
    }
  }
  onManifestLoaded(e, t) {
    this.config.enableCEA708Captions &&
      t.captions &&
      t.captions.forEach((s) => {
        const r = /(?:CC|SERVICE)([1-4])/.exec(s.instreamId);
        if (!r) return;
        const i = `textTrack${r[1]}`,
          a = this.captionsProperties[i];
        a &&
          ((a.label = s.name),
          s.lang && (a.languageCode = s.lang),
          (a.media = s));
      });
  }
  closedCaptionsForLevel(e) {
    const t = this.hls.levels[e.level];
    return t?.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, t) {
    if (this.enabled && t.frag.type === lt.MAIN) {
      var s, r;
      const { cea608Parser1: i, cea608Parser2: a, lastSn: o } = this,
        { cc: l, sn: c } = t.frag,
        h = (s = (r = t.part) == null ? void 0 : r.index) != null ? s : -1;
      i &&
        a &&
        (c !== o + 1 ||
          (c === o && h !== this.lastPartIndex + 1) ||
          l !== this.lastCc) &&
        (i.reset(), a.reset()),
        (this.lastCc = l),
        (this.lastSn = c),
        (this.lastPartIndex = h);
    }
  }
  onFragLoaded(e, t) {
    const { frag: s, payload: r } = t;
    if (s.type === lt.SUBTITLE)
      if (r.byteLength) {
        const i = s.decryptdata,
          a = "stats" in t;
        if (i == null || !i.encrypted || a) {
          const o = this.tracks[s.level],
            l = this.vttCCs;
          l[s.cc] ||
            ((l[s.cc] = { start: s.start, prevCC: this.prevCC, new: !0 }),
            (this.prevCC = s.cc)),
            o && o.textCodec === IA
              ? this._parseIMSC1(s, r)
              : this._parseVTTs(t);
        }
      } else
        this.hls.trigger($.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: s,
          error: new Error("Empty subtitle payload"),
        });
  }
  _parseIMSC1(e, t) {
    const s = this.hls;
    b5(
      t,
      this.initPTS[e.cc],
      (r) => {
        this._appendCues(r, e.level),
          s.trigger($.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e });
      },
      (r) => {
        s.logger.log(`Failed to parse IMSC1: ${r}`),
          s.trigger($.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: e,
            error: r,
          });
      }
    );
  }
  _parseVTTs(e) {
    var t;
    const { frag: s, payload: r } = e,
      { initPTS: i, unparsedVttFrags: a } = this,
      o = i.length - 1;
    if (!i[s.cc] && o === -1) {
      a.push(e);
      return;
    }
    const l = this.hls,
      c =
        (t = s.initSegment) != null && t.data
          ? da(s.initSegment.data, new Uint8Array(r)).buffer
          : r;
    QIe(
      c,
      this.initPTS[s.cc],
      this.vttCCs,
      s.cc,
      s.start,
      (h) => {
        this._appendCues(h, s.level),
          l.trigger($.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: s });
      },
      (h) => {
        const m = h.message === "Missing initPTS for VTT MPEGTS";
        m ? a.push(e) : this._fallbackToIMSC1(s, r),
          l.logger.log(`Failed to parse VTT cue: ${h}`),
          !(m && o > s.cc) &&
            l.trigger($.SUBTITLE_FRAG_PROCESSED, {
              success: !1,
              frag: s,
              error: h,
            });
      }
    );
  }
  _fallbackToIMSC1(e, t) {
    const s = this.tracks[e.level];
    s.textCodec ||
      b5(
        t,
        this.initPTS[e.cc],
        () => {
          (s.textCodec = IA), this._parseIMSC1(e, t);
        },
        () => {
          s.textCodec = "wvtt";
        }
      );
  }
  _appendCues(e, t) {
    const s = this.hls;
    if (this.config.renderTextTracksNatively) {
      const r = this.textTracks[t];
      if (!r || r.mode === "disabled") return;
      e.forEach((i) => dX(r, i));
    } else {
      const r = this.tracks[t];
      if (!r) return;
      const i = r.default ? "default" : "subtitles" + t;
      s.trigger($.CUES_PARSED, { type: "subtitles", cues: e, track: i });
    }
  }
  onFragDecrypted(e, t) {
    const { frag: s } = t;
    s.type === lt.SUBTITLE && this.onFragLoaded($.FRAG_LOADED, t);
  }
  onSubtitleTracksCleared() {
    (this.tracks = []), (this.captionsTracks = {});
  }
  onFragParsingUserdata(e, t) {
    if (!this.enabled || !this.config.enableCEA708Captions) return;
    const { frag: s, samples: r } = t;
    if (!(s.type === lt.MAIN && this.closedCaptionsForLevel(s) === "NONE"))
      for (let i = 0; i < r.length; i++) {
        const a = r[i].bytes;
        if (a) {
          this.cea608Parser1 || this.initCea608Parsers();
          const o = this.extractCea608Data(a);
          this.cea608Parser1.addData(r[i].pts, o[0]),
            this.cea608Parser2.addData(r[i].pts, o[1]);
        }
      }
  }
  onBufferFlushing(
    e,
    { startOffset: t, endOffset: s, endOffsetSubtitles: r, type: i }
  ) {
    const { media: a } = this;
    if (!(!a || a.currentTime < s)) {
      if (!i || i === "video") {
        const { captionsTracks: o } = this;
        Object.keys(o).forEach((l) => pI(o[l], t, s));
      }
      if (this.config.renderTextTracksNatively && t === 0 && r !== void 0) {
        const { textTracks: o } = this;
        Object.keys(o).forEach((l) => pI(o[l], t, r));
      }
    }
  }
  extractCea608Data(e) {
    const t = [[], []],
      s = e[0] & 31;
    let r = 2;
    for (let i = 0; i < s; i++) {
      const a = e[r++],
        o = 127 & e[r++],
        l = 127 & e[r++];
      if (o === 0 && l === 0) continue;
      if ((4 & a) !== 0) {
        const h = 3 & a;
        (h === 0 || h === 1) && (t[h].push(o), t[h].push(l));
      }
    }
    return t;
  }
}
function wX(n) {
  return n.characteristics &&
    /transcribes-spoken-dialog/gi.test(n.characteristics) &&
    /describes-music-and-sound/gi.test(n.characteristics)
    ? "captions"
    : "subtitles";
}
function E5(n, e) {
  return !!n && n.kind === wX(e) && hI(e, n);
}
function rLe(n, e, t, s) {
  return Math.min(e, s) - Math.max(n, t);
}
function S5() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: { start: 0, prevCC: -1, new: !0 },
  };
}
const iLe = /\s/,
  aLe = {
    newCue(n, e, t, s) {
      const r = [];
      let i, a, o, l, c;
      const h = self.VTTCue || self.TextTrackCue;
      for (let p = 0; p < s.rows.length; p++)
        if (((i = s.rows[p]), (o = !0), (l = 0), (c = ""), !i.isEmpty())) {
          var m;
          for (let b = 0; b < i.chars.length; b++)
            iLe.test(i.chars[b].uchar) && o
              ? l++
              : ((c += i.chars[b].uchar), (o = !1));
          (i.cueStartTime = e), e === t && (t += 1e-4), l >= 16 ? l-- : l++;
          const g = vX(c.trim()),
            y = cM(e, t, g);
          (n != null && (m = n.cues) != null && m.getCueById(y)) ||
            ((a = new h(e, t, g)),
            (a.id = y),
            (a.line = p + 1),
            (a.align = "left"),
            (a.position = 10 + Math.min(80, Math.floor((l * 8) / 32) * 10)),
            r.push(a));
        }
      return (
        n &&
          r.length &&
          (r.sort((p, g) =>
            p.line === "auto" || g.line === "auto"
              ? 0
              : p.line > 8 && g.line > 8
              ? g.line - p.line
              : p.line - g.line
          ),
          r.forEach((p) => dX(n, p))),
        r
      );
    },
  };
function oLe() {
  if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
    try {
      return new self.ReadableStream({}), !0;
    } catch {}
  return !1;
}
const lLe = /(\d+)-(\d+)\/(\d+)/;
class T5 {
  constructor(e) {
    (this.fetchSetup = void 0),
      (this.requestTimeout = void 0),
      (this.request = null),
      (this.response = null),
      (this.controller = void 0),
      (this.context = null),
      (this.config = null),
      (this.callbacks = null),
      (this.stats = void 0),
      (this.loader = null),
      (this.fetchSetup = e.fetchSetup || hLe),
      (this.controller = new self.AbortController()),
      (this.stats = new VP());
  }
  destroy() {
    (this.loader =
      this.callbacks =
      this.context =
      this.config =
      this.request =
        null),
      this.abortInternal(),
      (this.response = null),
      (this.fetchSetup = this.controller = this.stats = null);
  }
  abortInternal() {
    this.controller &&
      !this.stats.loading.end &&
      ((this.stats.aborted = !0), this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(),
      (e = this.callbacks) != null &&
        e.onAbort &&
        this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, t, s) {
    const r = this.stats;
    if (r.loading.start) throw new Error("Loader can only be used once.");
    r.loading.start = self.performance.now();
    const i = cLe(e, this.controller.signal),
      a = e.responseType === "arraybuffer",
      o = a ? "byteLength" : "length",
      { maxTimeToFirstByteMs: l, maxLoadTimeMs: c } = t.loadPolicy;
    (this.context = e),
      (this.config = t),
      (this.callbacks = s),
      (this.request = this.fetchSetup(e, i)),
      self.clearTimeout(this.requestTimeout),
      (t.timeout = l && Qe(l) ? l : c),
      (this.requestTimeout = self.setTimeout(() => {
        this.callbacks &&
          (this.abortInternal(), this.callbacks.onTimeout(r, e, this.response));
      }, t.timeout)),
      (vv(this.request)
        ? this.request.then(self.fetch)
        : self.fetch(this.request)
      )
        .then((m) => {
          var p;
          this.response = this.loader = m;
          const g = Math.max(self.performance.now(), r.loading.start);
          if (
            (self.clearTimeout(this.requestTimeout),
            (t.timeout = c),
            (this.requestTimeout = self.setTimeout(() => {
              this.callbacks &&
                (this.abortInternal(),
                this.callbacks.onTimeout(r, e, this.response));
            }, c - (g - r.loading.start))),
            !m.ok)
          ) {
            const { status: b, statusText: w } = m;
            throw new fLe(w || "fetch, bad network response", b, m);
          }
          (r.loading.first = g), (r.total = dLe(m.headers) || r.total);
          const y = (p = this.callbacks) == null ? void 0 : p.onProgress;
          return y && Qe(t.highWaterMark)
            ? this.loadProgressively(m, r, e, t.highWaterMark, y)
            : a
            ? m.arrayBuffer()
            : e.responseType === "json"
            ? m.json()
            : m.text();
        })
        .then((m) => {
          var p, g;
          const y = this.response;
          if (!y) throw new Error("loader destroyed");
          self.clearTimeout(this.requestTimeout),
            (r.loading.end = Math.max(self.performance.now(), r.loading.first));
          const b = m[o];
          b && (r.loaded = r.total = b);
          const w = { url: y.url, data: m, code: y.status },
            S = (p = this.callbacks) == null ? void 0 : p.onProgress;
          S && !Qe(t.highWaterMark) && S(r, e, m, y),
            (g = this.callbacks) == null || g.onSuccess(w, r, e, y);
        })
        .catch((m) => {
          var p;
          if ((self.clearTimeout(this.requestTimeout), r.aborted)) return;
          const g = (m && m.code) || 0,
            y = m ? m.message : null;
          (p = this.callbacks) == null ||
            p.onError({ code: g, text: y }, e, m ? m.details : null, r);
        });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const t = this.response.headers.get("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, t, s, r = 0, i) {
    const a = new OY(),
      o = e.body.getReader(),
      l = () =>
        o
          .read()
          .then((c) => {
            if (c.done)
              return (
                a.dataLength && i(t, s, a.flush().buffer, e),
                Promise.resolve(new ArrayBuffer(0))
              );
            const h = c.value,
              m = h.length;
            return (
              (t.loaded += m),
              m < r || a.dataLength
                ? (a.push(h), a.dataLength >= r && i(t, s, a.flush().buffer, e))
                : i(t, s, h.buffer, e),
              l()
            );
          })
          .catch(() => Promise.reject());
    return l();
  }
}
function cLe(n, e) {
  const t = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Tn({}, n.headers)),
  };
  return (
    n.rangeEnd &&
      t.headers.set(
        "Range",
        "bytes=" + n.rangeStart + "-" + String(n.rangeEnd - 1)
      ),
    t
  );
}
function uLe(n) {
  const e = lLe.exec(n);
  if (e) return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function dLe(n) {
  const e = n.get("Content-Range");
  if (e) {
    const s = uLe(e);
    if (Qe(s)) return s;
  }
  const t = n.get("Content-Length");
  if (t) return parseInt(t);
}
function hLe(n, e) {
  return new self.Request(n.url, e);
}
class fLe extends Error {
  constructor(e, t, s) {
    super(e),
      (this.code = void 0),
      (this.details = void 0),
      (this.code = t),
      (this.details = s);
  }
}
const mLe = /^age:\s*[\d.]+\s*$/im;
class EX {
  constructor(e) {
    (this.xhrSetup = void 0),
      (this.requestTimeout = void 0),
      (this.retryTimeout = void 0),
      (this.retryDelay = void 0),
      (this.config = null),
      (this.callbacks = null),
      (this.context = null),
      (this.loader = null),
      (this.stats = void 0),
      (this.xhrSetup = (e && e.xhrSetup) || null),
      (this.stats = new VP()),
      (this.retryDelay = 0);
  }
  destroy() {
    (this.callbacks = null),
      this.abortInternal(),
      (this.loader = null),
      (this.config = null),
      (this.context = null),
      (this.xhrSetup = null);
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout),
      self.clearTimeout(this.retryTimeout),
      e &&
        ((e.onreadystatechange = null),
        (e.onprogress = null),
        e.readyState !== 4 && ((this.stats.aborted = !0), e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(),
      (e = this.callbacks) != null &&
        e.onAbort &&
        this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, t, s) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    (this.stats.loading.start = self.performance.now()),
      (this.context = e),
      (this.config = t),
      (this.callbacks = s),
      this.loadInternal();
  }
  loadInternal() {
    const { config: e, context: t } = this;
    if (!e || !t) return;
    const s = (this.loader = new self.XMLHttpRequest()),
      r = this.stats;
    (r.loading.first = 0), (r.loaded = 0), (r.aborted = !1);
    const i = this.xhrSetup;
    i
      ? Promise.resolve()
          .then(() => {
            if (!(this.loader !== s || this.stats.aborted)) return i(s, t.url);
          })
          .catch((a) => {
            if (!(this.loader !== s || this.stats.aborted))
              return s.open("GET", t.url, !0), i(s, t.url);
          })
          .then(() => {
            this.loader !== s ||
              this.stats.aborted ||
              this.openAndSendXhr(s, t, e);
          })
          .catch((a) => {
            var o;
            (o = this.callbacks) == null ||
              o.onError({ code: s.status, text: a.message }, t, s, r);
          })
      : this.openAndSendXhr(s, t, e);
  }
  openAndSendXhr(e, t, s) {
    e.readyState || e.open("GET", t.url, !0);
    const r = t.headers,
      { maxTimeToFirstByteMs: i, maxLoadTimeMs: a } = s.loadPolicy;
    if (r) for (const o in r) e.setRequestHeader(o, r[o]);
    t.rangeEnd &&
      e.setRequestHeader(
        "Range",
        "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)
      ),
      (e.onreadystatechange = this.readystatechange.bind(this)),
      (e.onprogress = this.loadprogress.bind(this)),
      (e.responseType = t.responseType),
      self.clearTimeout(this.requestTimeout),
      (s.timeout = i && Qe(i) ? i : a),
      (this.requestTimeout = self.setTimeout(
        this.loadtimeout.bind(this),
        s.timeout
      )),
      e.send();
  }
  readystatechange() {
    const { context: e, loader: t, stats: s } = this;
    if (!e || !t) return;
    const r = t.readyState,
      i = this.config;
    if (
      !s.aborted &&
      r >= 2 &&
      (s.loading.first === 0 &&
        ((s.loading.first = Math.max(self.performance.now(), s.loading.start)),
        i.timeout !== i.loadPolicy.maxLoadTimeMs &&
          (self.clearTimeout(this.requestTimeout),
          (i.timeout = i.loadPolicy.maxLoadTimeMs),
          (this.requestTimeout = self.setTimeout(
            this.loadtimeout.bind(this),
            i.loadPolicy.maxLoadTimeMs - (s.loading.first - s.loading.start)
          )))),
      r === 4)
    ) {
      self.clearTimeout(this.requestTimeout),
        (t.onreadystatechange = null),
        (t.onprogress = null);
      const c = t.status,
        h = t.responseType === "text" ? t.responseText : null;
      if (c >= 200 && c < 300) {
        const y = h ?? t.response;
        if (y != null) {
          var a, o;
          s.loading.end = Math.max(self.performance.now(), s.loading.first);
          const b = t.responseType === "arraybuffer" ? y.byteLength : y.length;
          (s.loaded = s.total = b),
            (s.bwEstimate =
              (s.total * 8e3) / (s.loading.end - s.loading.first));
          const w = (a = this.callbacks) == null ? void 0 : a.onProgress;
          w && w(s, e, y, t);
          const S = { url: t.responseURL, data: y, code: c };
          (o = this.callbacks) == null || o.onSuccess(S, s, e, t);
          return;
        }
      }
      const m = i.loadPolicy.errorRetry,
        p = s.retry,
        g = { url: e.url, data: void 0, code: c };
      if (Qw(m, p, !1, g)) this.retry(m);
      else {
        var l;
        pn.error(`${c} while loading ${e.url}`),
          (l = this.callbacks) == null ||
            l.onError({ code: c, text: t.statusText }, e, t, s);
      }
    }
  }
  loadtimeout() {
    if (!this.config) return;
    const e = this.config.loadPolicy.timeoutRetry,
      t = this.stats.retry;
    if (Qw(e, t, !0)) this.retry(e);
    else {
      var s;
      pn.warn(
        `timeout while loading ${(s = this.context) == null ? void 0 : s.url}`
      );
      const r = this.callbacks;
      r &&
        (this.abortInternal(),
        r.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const { context: t, stats: s } = this;
    (this.retryDelay = WP(e, s.retry)),
      s.retry++,
      pn.warn(
        `${status ? "HTTP Status " + status : "Timeout"} while loading ${
          t?.url
        }, retrying ${s.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`
      ),
      this.abortInternal(),
      (this.loader = null),
      self.clearTimeout(this.retryTimeout),
      (this.retryTimeout = self.setTimeout(
        this.loadInternal.bind(this),
        this.retryDelay
      ));
  }
  loadprogress(e) {
    const t = this.stats;
    (t.loaded = e.loaded), e.lengthComputable && (t.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && mLe.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader("age");
      e = t ? parseFloat(t) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader &&
      new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(
        this.loader.getAllResponseHeaders()
      )
      ? this.loader.getResponseHeader(e)
      : null;
  }
}
const pLe = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null,
  },
  gLe = In(
    In(
      {
        autoStartLoad: !0,
        startPosition: -1,
        defaultAudioCodec: void 0,
        debug: !1,
        capLevelOnFPSDrop: !1,
        capLevelToPlayerSize: !1,
        ignoreDevicePixelRatio: !1,
        maxDevicePixelRatio: Number.POSITIVE_INFINITY,
        preferManagedMediaSource: !0,
        initialLiveManifestSize: 1,
        maxBufferLength: 30,
        backBufferLength: 1 / 0,
        frontBufferFlushThreshold: 1 / 0,
        startOnSegmentBoundary: !1,
        maxBufferSize: 60 * 1e3 * 1e3,
        maxFragLookUpTolerance: 0.25,
        maxBufferHole: 0.1,
        detectStallWithCurrentTimeMs: 1250,
        highBufferWatchdogPeriod: 2,
        nudgeOffset: 0.1,
        nudgeMaxRetry: 3,
        nudgeOnVideoHole: !0,
        liveSyncMode: "edge",
        liveSyncDurationCount: 3,
        liveSyncOnStallIncrease: 1,
        liveMaxLatencyDurationCount: 1 / 0,
        liveSyncDuration: void 0,
        liveMaxLatencyDuration: void 0,
        maxLiveSyncPlaybackRate: 1,
        liveDurationInfinity: !1,
        liveBackBufferLength: null,
        maxMaxBufferLength: 600,
        enableWorker: !0,
        workerPath: null,
        enableSoftwareAES: !0,
        startLevel: void 0,
        startFragPrefetch: !1,
        fpsDroppedMonitoringPeriod: 5e3,
        fpsDroppedMonitoringThreshold: 0.2,
        appendErrorMaxRetry: 3,
        ignorePlaylistParsingErrors: !1,
        loader: EX,
        fLoader: void 0,
        pLoader: void 0,
        xhrSetup: void 0,
        licenseXhrSetup: void 0,
        licenseResponseCallback: void 0,
        abrController: FRe,
        bufferController: RCe,
        capLevelController: aM,
        errorController: VRe,
        fpsController: bIe,
        stretchShortVideoTrack: !1,
        maxAudioFramesDrift: 1,
        forceKeyFrameOnDiscontinuity: !0,
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrEwmaFastVoD: 3,
        abrEwmaSlowVoD: 9,
        abrEwmaDefaultEstimate: 5e5,
        abrEwmaDefaultEstimateMax: 5e6,
        abrBandWidthFactor: 0.95,
        abrBandWidthUpFactor: 0.7,
        abrMaxWithRealBitrate: !1,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        minAutoBitrate: 0,
        emeEnabled: !1,
        widevineLicenseUrl: void 0,
        drmSystems: {},
        drmSystemOptions: {},
        requestMediaKeySystemAccessFunc: AY,
        requireKeySystemAccessOnStart: !1,
        testBandwidth: !0,
        progressive: !1,
        lowLatencyMode: !0,
        cmcd: void 0,
        enableDateRangeMetadataCues: !0,
        enableEmsgMetadataCues: !0,
        enableEmsgKLVMetadata: !1,
        enableID3MetadataCues: !0,
        enableInterstitialPlayback: !0,
        interstitialAppendInPlace: !0,
        interstitialLiveLookAhead: 10,
        useMediaCapabilities: !0,
        preserveManualLevelOnError: !1,
        certLoadPolicy: { default: pLe },
        keyLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: "linear",
            },
            errorRetry: {
              maxNumRetry: 8,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: "linear",
            },
          },
        },
        manifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0,
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3,
            },
          },
        },
        playlistLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0,
            },
            errorRetry: {
              maxNumRetry: 2,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3,
            },
          },
        },
        fragLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: {
              maxNumRetry: 4,
              retryDelayMs: 0,
              maxRetryDelayMs: 0,
            },
            errorRetry: {
              maxNumRetry: 6,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3,
            },
          },
        },
        steeringManifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0,
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3,
            },
          },
        },
        interstitialAssetListLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 3e4,
            timeoutRetry: {
              maxNumRetry: 0,
              retryDelayMs: 0,
              maxRetryDelayMs: 0,
            },
            errorRetry: {
              maxNumRetry: 0,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 8e3,
            },
          },
        },
        manifestLoadingTimeOut: 1e4,
        manifestLoadingMaxRetry: 1,
        manifestLoadingRetryDelay: 1e3,
        manifestLoadingMaxRetryTimeout: 64e3,
        levelLoadingTimeOut: 1e4,
        levelLoadingMaxRetry: 4,
        levelLoadingRetryDelay: 1e3,
        levelLoadingMaxRetryTimeout: 64e3,
        fragLoadingTimeOut: 2e4,
        fragLoadingMaxRetry: 6,
        fragLoadingRetryDelay: 1e3,
        fragLoadingMaxRetryTimeout: 64e3,
      },
      vLe()
    ),
    {},
    {
      subtitleStreamController: LIe,
      subtitleTrackController: EIe,
      timelineController: sLe,
      audioStreamController: SCe,
      audioTrackController: TCe,
      emeController: ff,
      cmcdController: gIe,
      contentSteeringController: yIe,
      interstitialsController: IIe,
    }
  );
function vLe() {
  return {
    cueHandler: aLe,
    enableWebVTT: !0,
    enableIMSC1: !0,
    enableCEA708Captions: !0,
    captionsTextTrack1Label: "English",
    captionsTextTrack1LanguageCode: "en",
    captionsTextTrack2Label: "Spanish",
    captionsTextTrack2LanguageCode: "es",
    captionsTextTrack3Label: "Unknown CC",
    captionsTextTrack3LanguageCode: "",
    captionsTextTrack4Label: "Unknown CC",
    captionsTextTrack4LanguageCode: "",
    renderTextTracksNatively: !0,
  };
}
function yLe(n, e, t) {
  if (
    (e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) &&
    (e.liveSyncDuration || e.liveMaxLatencyDuration)
  )
    throw new Error(
      "Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"
    );
  if (
    e.liveMaxLatencyDurationCount !== void 0 &&
    (e.liveSyncDurationCount === void 0 ||
      e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)
  )
    throw new Error(
      'Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'
    );
  if (
    e.liveMaxLatencyDuration !== void 0 &&
    (e.liveSyncDuration === void 0 ||
      e.liveMaxLatencyDuration <= e.liveSyncDuration)
  )
    throw new Error(
      'Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'
    );
  const s = vI(n),
    r = ["manifest", "level", "frag"],
    i = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return (
    r.forEach((a) => {
      const o = `${a === "level" ? "playlist" : a}LoadPolicy`,
        l = e[o] === void 0,
        c = [];
      i.forEach((h) => {
        const m = `${a}Loading${h}`,
          p = e[m];
        if (p !== void 0 && l) {
          c.push(m);
          const g = s[o].default;
          switch (((e[o] = { default: g }), h)) {
            case "TimeOut":
              (g.maxLoadTimeMs = p), (g.maxTimeToFirstByteMs = p);
              break;
            case "MaxRetry":
              (g.errorRetry.maxNumRetry = p), (g.timeoutRetry.maxNumRetry = p);
              break;
            case "RetryDelay":
              (g.errorRetry.retryDelayMs = p),
                (g.timeoutRetry.retryDelayMs = p);
              break;
            case "MaxRetryTimeout":
              (g.errorRetry.maxRetryDelayMs = p),
                (g.timeoutRetry.maxRetryDelayMs = p);
              break;
          }
        }
      }),
        c.length &&
          t.warn(
            `hls.js config: "${c.join(
              '", "'
            )}" setting(s) are deprecated, use "${o}": ${Wn(e[o])}`
          );
    }),
    In(In({}, s), e)
  );
}
function vI(n) {
  return n && typeof n == "object"
    ? Array.isArray(n)
      ? n.map(vI)
      : Object.keys(n).reduce((e, t) => ((e[t] = vI(n[t])), e), {})
    : n;
}
function bLe(n, e) {
  const t = n.loader;
  t !== T5 && t !== EX
    ? (e.log(
        "[config]: Custom loader detected, cannot enable progressive streaming"
      ),
      (n.progressive = !1))
    : oLe() &&
      ((n.loader = T5),
      (n.progressive = !0),
      (n.enableSoftwareAES = !0),
      e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const lx = 2,
  xLe = 0.1,
  wLe = 0.05,
  ELe = 100;
class SLe extends EY {
  constructor(e, t) {
    super("gap-controller", e.logger),
      (this.hls = null),
      (this.fragmentTracker = null),
      (this.media = null),
      (this.mediaSource = void 0),
      (this.nudgeRetry = 0),
      (this.stallReported = !1),
      (this.stalled = null),
      (this.moved = !1),
      (this.seeking = !1),
      (this.buffered = {}),
      (this.lastCurrentTime = 0),
      (this.ended = 0),
      (this.waiting = 0),
      (this.onMediaPlaying = () => {
        (this.ended = 0), (this.waiting = 0);
      }),
      (this.onMediaWaiting = () => {
        var s;
        ((s = this.media) != null && s.seeking) ||
          ((this.waiting = self.performance.now()), this.tick());
      }),
      (this.onMediaEnded = () => {
        if (this.hls) {
          var s;
          (this.ended =
            ((s = this.media) == null ? void 0 : s.currentTime) || 1),
            this.hls.trigger($.MEDIA_ENDED, { stalled: !1 });
        }
      }),
      (this.hls = e),
      (this.fragmentTracker = t),
      this.registerListeners();
  }
  registerListeners() {
    const { hls: e } = this;
    e &&
      (e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  unregisterListeners() {
    const { hls: e } = this;
    e &&
      (e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  destroy() {
    super.destroy(),
      this.unregisterListeners(),
      (this.media = this.hls = this.fragmentTracker = null),
      (this.mediaSource = void 0);
  }
  onMediaAttached(e, t) {
    this.setInterval(ELe), (this.mediaSource = t.mediaSource);
    const s = (this.media = t.media);
    na(s, "playing", this.onMediaPlaying),
      na(s, "waiting", this.onMediaWaiting),
      na(s, "ended", this.onMediaEnded);
  }
  onMediaDetaching(e, t) {
    this.clearInterval();
    const { media: s } = this;
    s &&
      (La(s, "playing", this.onMediaPlaying),
      La(s, "waiting", this.onMediaWaiting),
      La(s, "ended", this.onMediaEnded),
      (this.media = null)),
      (this.mediaSource = void 0);
  }
  onBufferAppended(e, t) {
    this.buffered = t.timeRanges;
  }
  get hasBuffered() {
    return Object.keys(this.buffered).length > 0;
  }
  tick() {
    var e;
    if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
      return;
    const t = this.media.currentTime;
    this.poll(t, this.lastCurrentTime), (this.lastCurrentTime = t);
  }
  poll(e, t) {
    var s, r;
    const i = (s = this.hls) == null ? void 0 : s.config;
    if (!i) return;
    const a = this.media;
    if (!a) return;
    const { seeking: o } = a,
      l = this.seeking && !o,
      c = !this.seeking && o,
      h = (a.paused && !o) || a.ended || a.playbackRate === 0;
    if (((this.seeking = o), e !== t)) {
      t && (this.ended = 0),
        (this.moved = !0),
        o ||
          ((this.nudgeRetry = 0),
          i.nudgeOnVideoHole && !h && e > t && this.nudgeOnVideoHole(e, t)),
        this.waiting === 0 && this.stallResolved(e);
      return;
    }
    if (c || l) {
      l && this.stallResolved(e);
      return;
    }
    if (h) {
      (this.nudgeRetry = 0),
        this.stallResolved(e),
        !this.ended &&
          a.ended &&
          this.hls &&
          ((this.ended = e || 1),
          this.hls.trigger($.MEDIA_ENDED, { stalled: !1 }));
      return;
    }
    if (!Ft.getBuffered(a).length) {
      this.nudgeRetry = 0;
      return;
    }
    const m = Ft.bufferInfo(a, e, 0),
      p = m.nextStart || 0,
      g = this.fragmentTracker;
    if (o && g && this.hls) {
      const D = _5(this.hls.inFlightFragments, e),
        L = m.len > lx,
        P = !p || D || (p - e > lx && !g.getPartialFragment(e));
      if (L || P) return;
      this.moved = !1;
    }
    const y = (r = this.hls) == null ? void 0 : r.latestLevelDetails;
    if (!this.moved && this.stalled !== null && g) {
      if (!(m.len > 0) && !p) return;
      const L = Math.max(p, m.start || 0) - e,
        V = !!(y != null && y.live) ? y.targetduration * 2 : lx,
        N = g.getPartialFragment(e);
      if (L > 0 && (L <= V || N)) {
        a.paused || this._trySkipBufferHole(N);
        return;
      }
    }
    const b = i.detectStallWithCurrentTimeMs,
      w = self.performance.now(),
      S = this.waiting;
    let A = this.stalled;
    if (A === null)
      if (S > 0 && w - S < b) A = this.stalled = S;
      else {
        this.stalled = w;
        return;
      }
    const _ = w - A;
    if (!o && (_ >= b || S) && this.hls) {
      var R;
      if (
        ((R = this.mediaSource) == null ? void 0 : R.readyState) === "ended" &&
        !(y != null && y.live) &&
        Math.abs(e - (y?.edge || 0)) < 1
      ) {
        if (this.ended) return;
        (this.ended = e || 1), this.hls.trigger($.MEDIA_ENDED, { stalled: !0 });
        return;
      }
      if ((this._reportStall(m), !this.media || !this.hls)) return;
    }
    const C = Ft.bufferInfo(a, e, i.maxBufferHole);
    this._tryFixBufferStall(C, _, e);
  }
  stallResolved(e) {
    const t = this.stalled;
    if (t && this.hls && ((this.stalled = null), this.stallReported)) {
      const s = self.performance.now() - t;
      this.log(`playback not stuck anymore @${e}, after ${Math.round(s)}ms`),
        (this.stallReported = !1),
        (this.waiting = 0),
        this.hls.trigger($.STALL_RESOLVED, {});
    }
  }
  nudgeOnVideoHole(e, t) {
    var s;
    const r = this.buffered.video;
    if (
      this.hls &&
      this.media &&
      this.fragmentTracker &&
      (s = this.buffered.audio) != null &&
      s.length &&
      r &&
      r.length > 1 &&
      e > r.end(0)
    ) {
      const i = Ft.bufferedInfo(
        Ft.timeRangesToArray(this.buffered.audio),
        e,
        0
      );
      if (i.len > 1 && t >= i.start) {
        const a = Ft.timeRangesToArray(r),
          o = Ft.bufferedInfo(a, t, 0).bufferedIndex;
        if (o > -1 && o < a.length - 1) {
          const l = Ft.bufferedInfo(a, e, 0).bufferedIndex,
            c = a[o].end,
            h = a[o + 1].start;
          if ((l === -1 || l > o) && h - c < 1 && e - c < 2) {
            const m = new Error(
              `nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${c} -> ${h} buffered index: ${l}`
            );
            this.warn(m.message), (this.media.currentTime += 1e-6);
            const p = this.fragmentTracker.getPartialFragment(e) || void 0,
              g = Ft.bufferInfo(this.media, e, 0);
            this.hls.trigger($.ERROR, {
              type: gt.MEDIA_ERROR,
              details: we.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: m,
              reason: m.message,
              frag: p,
              buffer: g.len,
              bufferInfo: g,
            });
          }
        }
      }
    }
  }
  _tryFixBufferStall(e, t, s) {
    var r, i;
    const { fragmentTracker: a, media: o } = this,
      l = (r = this.hls) == null ? void 0 : r.config;
    if (!o || !a || !l) return;
    const c = (i = this.hls) == null ? void 0 : i.latestLevelDetails,
      h = a.getPartialFragment(s);
    if (
      (h || (c != null && c.live && s < c.fragmentStart)) &&
      (this._trySkipBufferHole(h) || !this.media)
    )
      return;
    const m = e.buffered,
      p = this.adjacentTraversal(e, s);
    ((m && m.length > 1 && e.len > l.maxBufferHole) ||
      (e.nextStart && (e.nextStart - s < l.maxBufferHole || p))) &&
      (t > l.highBufferWatchdogPeriod * 1e3 || this.waiting) &&
      (this.warn("Trying to nudge playhead over buffer-hole"),
      this._tryNudgeBuffer(e));
  }
  adjacentTraversal(e, t) {
    const s = this.fragmentTracker,
      r = e.nextStart;
    if (s && r) {
      const i = s.getFragAtPos(t, lt.MAIN),
        a = s.getFragAtPos(r, lt.MAIN);
      if (i && a) return a.sn - i.sn < 2;
    }
    return !1;
  }
  _reportStall(e) {
    const { hls: t, media: s, stallReported: r, stalled: i } = this;
    if (!r && i !== null && s && t) {
      this.stallReported = !0;
      const a = new Error(
        `Playback stalling at @${s.currentTime} due to low buffer (${Wn(e)})`
      );
      this.warn(a.message),
        t.trigger($.ERROR, {
          type: gt.MEDIA_ERROR,
          details: we.BUFFER_STALLED_ERROR,
          fatal: !1,
          error: a,
          buffer: e.len,
          bufferInfo: e,
          stalled: { start: i },
        });
    }
  }
  _trySkipBufferHole(e) {
    var t;
    const { fragmentTracker: s, media: r } = this,
      i = (t = this.hls) == null ? void 0 : t.config;
    if (!r || !s || !i) return 0;
    const a = r.currentTime,
      o = Ft.bufferInfo(r, a, 0),
      l = a < o.start ? o.start : o.nextStart;
    if (l && this.hls) {
      const h = o.len <= i.maxBufferHole,
        m = o.len > 0 && o.len < 1 && r.readyState < 3,
        p = l - a;
      if (p > 0 && (h || m)) {
        if (p > i.maxBufferHole) {
          let y = !1;
          if (a === 0) {
            const b = s.getAppendedFrag(0, lt.MAIN);
            b && l < b.end && (y = !0);
          }
          if (!y) {
            const b = e || s.getAppendedFrag(a, lt.MAIN);
            if (b) {
              var c;
              if (
                !((c = this.hls.loadLevelObj) != null && c.details) ||
                _5(this.hls.inFlightFragments, l)
              )
                return 0;
              let S = !1,
                A = b.end;
              for (; A < l; ) {
                const _ =
                  s.getAppendedFrag(A, lt.MAIN) || s.getPartialFragment(A);
                if (_) A += _.duration;
                else {
                  S = !0;
                  break;
                }
              }
              if (S) return 0;
            }
          }
        }
        const g = Math.max(l + wLe, a + xLe);
        if (
          (this.warn(`skipping hole, adjusting currentTime from ${a} to ${g}`),
          (this.moved = !0),
          (r.currentTime = g),
          !(e != null && e.gap))
        ) {
          const y = new Error(
            `fragment loaded with buffer holes, seeking from ${a} to ${g}`
          );
          this.hls.trigger($.ERROR, {
            type: gt.MEDIA_ERROR,
            details: we.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: y,
            reason: y.message,
            frag: e || void 0,
            buffer: o.len,
            bufferInfo: o,
          });
        }
        return g;
      }
    }
    return 0;
  }
  _tryNudgeBuffer(e) {
    const { hls: t, media: s, nudgeRetry: r } = this,
      i = t?.config;
    if (!s || !i) return 0;
    const a = s.currentTime;
    if ((this.nudgeRetry++, r < i.nudgeMaxRetry)) {
      const o = a + (r + 1) * i.nudgeOffset,
        l = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
      this.warn(l.message),
        (s.currentTime = o),
        t.trigger($.ERROR, {
          type: gt.MEDIA_ERROR,
          details: we.BUFFER_NUDGE_ON_STALL,
          error: l,
          fatal: !1,
          buffer: e.len,
          bufferInfo: e,
        });
    } else {
      const o = new Error(
        `Playhead still not moving while enough data buffered @${a} after ${i.nudgeMaxRetry} nudges`
      );
      this.error(o.message),
        t.trigger($.ERROR, {
          type: gt.MEDIA_ERROR,
          details: we.BUFFER_STALLED_ERROR,
          error: o,
          fatal: !0,
          buffer: e.len,
          bufferInfo: e,
        });
    }
  }
}
function _5(n, e) {
  const t = A5(n.main);
  if (t && t.start <= e) return t;
  const s = A5(n.audio);
  return s && s.start <= e ? s : null;
}
function A5(n) {
  if (!n) return null;
  switch (n.state) {
    case Me.IDLE:
    case Me.STOPPED:
    case Me.ENDED:
    case Me.ERROR:
      return null;
  }
  return n.frag;
}
const TLe = 0.25;
function yI() {
  if (!(typeof self > "u")) return self.VTTCue || self.TextTrackCue;
}
function R5(n, e, t, s, r) {
  let i = new n(e, t, "");
  try {
    (i.value = s), r && (i.type = r);
  } catch {
    i = new n(e, t, Wn(r ? In({ type: r }, s) : s));
  }
  return i;
}
const cb = (() => {
  const n = yI();
  try {
    n && new n(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
class _Le {
  constructor(e) {
    (this.hls = void 0),
      (this.id3Track = null),
      (this.media = null),
      (this.dateRangeCuesAppended = {}),
      (this.removeCues = !0),
      (this.onEventCueEnter = () => {
        this.hls && this.hls.trigger($.EVENT_CUE_ENTER, {});
      }),
      (this.hls = e),
      this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(),
      (this.id3Track = null),
      (this.media = null),
      (this.dateRangeCuesAppended = {}),
      (this.hls = this.onEventCueEnter = null);
  }
  _registerListeners() {
    const { hls: e } = this;
    e.on($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.on($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.on($.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
  }
  _unregisterListeners() {
    const { hls: e } = this;
    e.off($.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.off($.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.off($.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this);
  }
  onMediaAttaching(e, t) {
    var s;
    (this.media = t.media),
      ((s = t.overrides) == null ? void 0 : s.cueRemoval) === !1 &&
        (this.removeCues = !1);
  }
  onMediaAttached() {
    const e = this.hls.latestLevelDetails;
    e && this.updateDateRangeCues(e);
  }
  onMediaDetaching(e, t) {
    (this.media = null),
      !t.transferMedia &&
        (this.id3Track &&
          (this.removeCues && Qh(this.id3Track, this.onEventCueEnter),
          (this.id3Track = null)),
        (this.dateRangeCuesAppended = {}));
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks);
    return (t.mode = "hidden"), t;
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const s = e[t];
        if (s.kind === "metadata" && s.label === "id3")
          return uX(s, this.media), s;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media) return;
    const {
      hls: {
        config: { enableEmsgMetadataCues: s, enableID3MetadataCues: r },
      },
    } = this;
    if (!s && !r) return;
    const { samples: i } = t;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = yI();
    if (a)
      for (let o = 0; o < i.length; o++) {
        const l = i[o].type;
        if ((l === Si.emsg && !s) || !r) continue;
        const c = VY(i[o].data);
        if (c) {
          const h = i[o].pts;
          let m = h + i[o].duration;
          m > cb && (m = cb), m - h <= 0 && (m = h + TLe);
          for (let g = 0; g < c.length; g++) {
            const y = c[g];
            if (!zY(y)) {
              this.updateId3CueEnds(h, l);
              const b = R5(a, h, m, y, l);
              b && this.id3Track.addCue(b);
            }
          }
        }
      }
  }
  updateId3CueEnds(e, t) {
    var s;
    const r = (s = this.id3Track) == null ? void 0 : s.cues;
    if (r)
      for (let i = r.length; i--; ) {
        const a = r[i];
        a.type === t && a.startTime < e && a.endTime === cb && (a.endTime = e);
      }
  }
  onBufferFlushing(e, { startOffset: t, endOffset: s, type: r }) {
    const { id3Track: i, hls: a } = this;
    if (!a) return;
    const {
      config: { enableEmsgMetadataCues: o, enableID3MetadataCues: l },
    } = a;
    if (i && (o || l)) {
      let c;
      r === "audio"
        ? (c = (h) => h.type === Si.audioId3 && l)
        : r === "video"
        ? (c = (h) => h.type === Si.emsg && o)
        : (c = (h) =>
            (h.type === Si.audioId3 && l) || (h.type === Si.emsg && o)),
        pI(i, t, s, c);
    }
  }
  onLevelUpdated(e, { details: t }) {
    this.updateDateRangeCues(t, !0);
  }
  onLevelPtsUpdated(e, t) {
    Math.abs(t.drift) > 0.01 && this.updateDateRangeCues(t.details);
  }
  updateDateRangeCues(e, t) {
    if (
      !this.media ||
      !e.hasProgramDateTime ||
      !this.hls.config.enableDateRangeMetadataCues
    )
      return;
    const { id3Track: s } = this,
      { dateRanges: r } = e,
      i = Object.keys(r);
    let a = this.dateRangeCuesAppended;
    if (s && t) {
      var o;
      if ((o = s.cues) != null && o.length) {
        const h = Object.keys(a).filter((m) => !i.includes(m));
        for (let m = h.length; m--; ) {
          const p = h[m],
            g = a[p].cues;
          delete a[p],
            Object.keys(g).forEach((y) => {
              try {
                const b = g[y];
                b.removeEventListener("enter", this.onEventCueEnter),
                  s.removeCue(b);
              } catch {}
            });
        }
      } else a = this.dateRangeCuesAppended = {};
    }
    const l = e.fragments[e.fragments.length - 1];
    if (i.length === 0 || !Qe(l?.programDateTime)) return;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const c = yI();
    for (let h = 0; h < i.length; h++) {
      const m = i[h],
        p = r[m],
        g = p.startTime,
        y = a[m],
        b = y?.cues || {};
      let w = y?.durationKnown || !1,
        S = cb;
      const { duration: A, endDate: _ } = p;
      if (_ && A !== null) (S = g + A), (w = !0);
      else if (p.endOnNext && !w) {
        const C = i.reduce((D, L) => {
          if (L !== p.id) {
            const P = r[L];
            if (
              P.class === p.class &&
              P.startDate > p.startDate &&
              (!D || p.startDate < D.startDate)
            )
              return P;
          }
          return D;
        }, null);
        C && ((S = C.startTime), (w = !0));
      }
      const R = Object.keys(p.attr);
      for (let C = 0; C < R.length; C++) {
        const D = R[C];
        if (!nke(D)) continue;
        const L = b[D];
        if (L)
          w && !y.durationKnown
            ? (L.endTime = S)
            : Math.abs(L.startTime - g) > 0.01 &&
              ((L.startTime = g), (L.endTime = S));
        else if (c) {
          let P = p.attr[D];
          ske(D) && (P = aY(P));
          const N = R5(c, g, S, { key: D, data: P }, Si.dateRange);
          N &&
            ((N.id = m),
            this.id3Track.addCue(N),
            (b[D] = N),
            this.hls.config.interstitialsController &&
              (D === "X-ASSET-LIST" || D === "X-ASSET-URL") &&
              N.addEventListener("enter", this.onEventCueEnter));
        }
      }
      a[m] = { cues: b, dateRange: p, durationKnown: w };
    }
  }
}
class ALe {
  constructor(e) {
    (this.hls = void 0),
      (this.config = void 0),
      (this.media = null),
      (this.currentTime = 0),
      (this.stallCount = 0),
      (this._latency = null),
      (this._targetLatencyUpdated = !1),
      (this.onTimeupdate = () => {
        const { media: t } = this,
          s = this.levelDetails;
        if (!t || !s) return;
        this.currentTime = t.currentTime;
        const r = this.computeLatency();
        if (r === null) return;
        this._latency = r;
        const { lowLatencyMode: i, maxLiveSyncPlaybackRate: a } = this.config;
        if (!i || a === 1 || !s.live) return;
        const o = this.targetLatency;
        if (o === null) return;
        const l = r - o,
          c = Math.min(this.maxLatency, o + s.targetduration);
        if (l < c && l > 0.05 && this.forwardBufferLength > 1) {
          const m = Math.min(2, Math.max(1, a)),
            p =
              Math.round(
                (2 / (1 + Math.exp(-0.75 * l - this.edgeStalled))) * 20
              ) / 20,
            g = Math.min(m, Math.max(1, p));
          this.changeMediaPlaybackRate(t, g);
        } else
          t.playbackRate !== 1 &&
            t.playbackRate !== 0 &&
            this.changeMediaPlaybackRate(t, 1);
      }),
      (this.hls = e),
      (this.config = e.config),
      this.registerListeners();
  }
  get levelDetails() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const { config: e } = this;
    if (e.liveMaxLatencyDuration !== void 0) return e.liveMaxLatencyDuration;
    const t = this.levelDetails;
    return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;
  }
  get targetLatency() {
    const e = this.levelDetails;
    if (e === null || this.hls === null) return null;
    const { holdBack: t, partHoldBack: s, targetduration: r } = e,
      {
        liveSyncDuration: i,
        liveSyncDurationCount: a,
        lowLatencyMode: o,
      } = this.config,
      l = this.hls.userConfig;
    let c = (o && s) || t;
    (this._targetLatencyUpdated ||
      l.liveSyncDuration ||
      l.liveSyncDurationCount ||
      c === 0) &&
      (c = i !== void 0 ? i : a * r);
    const h = r;
    return (
      c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, h)
    );
  }
  set targetLatency(e) {
    (this.stallCount = 0),
      (this.config.liveSyncDuration = e),
      (this._targetLatencyUpdated = !0);
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(),
      t = this.targetLatency;
    if (e === null || t === null) return null;
    const s = this.levelDetails;
    if (s === null) return null;
    const r = s.edge,
      i = e - t - this.edgeStalled,
      a = r - s.totalduration,
      o =
        r - ((this.config.lowLatencyMode && s.partTarget) || s.targetduration);
    return Math.min(Math.max(a, i), o);
  }
  get drift() {
    const e = this.levelDetails;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const e = this.levelDetails;
    if (e === null) return 0;
    const t =
      ((this.config.lowLatencyMode && e.partTarget) || e.targetduration) * 3;
    return Math.max(e.age - t, 0);
  }
  get forwardBufferLength() {
    const { media: e } = this,
      t = this.levelDetails;
    if (!e || !t) return 0;
    const s = e.buffered.length;
    return (s ? e.buffered.end(s - 1) : t.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), (this.hls = null);
  }
  registerListeners() {
    const { hls: e } = this;
    e &&
      (e.on($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.on($.ERROR, this.onError, this));
  }
  unregisterListeners() {
    const { hls: e } = this;
    e &&
      (e.off($.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off($.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.off($.ERROR, this.onError, this));
  }
  onMediaAttached(e, t) {
    (this.media = t.media),
      this.media.addEventListener("timeupdate", this.onTimeupdate);
  }
  onMediaDetaching() {
    this.media &&
      (this.media.removeEventListener("timeupdate", this.onTimeupdate),
      (this.media = null));
  }
  onManifestLoading() {
    (this._latency = null), (this.stallCount = 0);
  }
  onLevelUpdated(e, { details: t }) {
    t.advanced && this.onTimeupdate(),
      !t.live &&
        this.media &&
        this.media.removeEventListener("timeupdate", this.onTimeupdate);
  }
  onError(e, t) {
    var s;
    t.details === we.BUFFER_STALLED_ERROR &&
      (this.stallCount++,
      this.hls &&
        (s = this.levelDetails) != null &&
        s.live &&
        this.hls.logger.warn(
          "[latency-controller]: Stall detected, adjusting target latency"
        ));
  }
  changeMediaPlaybackRate(e, t) {
    var s, r;
    e.playbackRate !== t &&
      ((s = this.hls) == null ||
        s.logger.debug(
          `[latency-controller]: latency=${this.latency.toFixed(
            3
          )}, targetLatency=${
            (r = this.targetLatency) == null ? void 0 : r.toFixed(3)
          }, forwardBufferLength=${this.forwardBufferLength.toFixed(
            3
          )}: adjusting playback rate from ${e.playbackRate} to ${t}`
        ),
      (e.playbackRate = t));
  }
  estimateLiveEdge() {
    const e = this.levelDetails;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
class RLe extends iM {
  constructor(e, t) {
    super(e, "level-controller"),
      (this._levels = []),
      (this._firstLevel = -1),
      (this._maxAutoLevel = -1),
      (this._startLevel = void 0),
      (this.currentLevel = null),
      (this.currentLevelIndex = -1),
      (this.manualLevelIndex = -1),
      (this.steering = void 0),
      (this.onParsedComplete = void 0),
      (this.steering = t),
      this._registerListeners();
  }
  _registerListeners() {
    const { hls: e } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on($.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const { hls: e } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off($.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off($.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(),
      (this.steering = null),
      this.resetLevels(),
      super.destroy();
  }
  stopLoad() {
    this._levels.forEach((t) => {
      (t.loadError = 0), (t.fragmentError = 0);
    }),
      super.stopLoad();
  }
  resetLevels() {
    (this._startLevel = void 0),
      (this.manualLevelIndex = -1),
      (this.currentLevelIndex = -1),
      (this.currentLevel = null),
      (this._levels = []),
      (this._maxAutoLevel = -1);
  }
  onManifestLoading(e, t) {
    this.resetLevels();
  }
  onManifestLoaded(e, t) {
    const s = this.hls.config.preferManagedMediaSource,
      r = [],
      i = {},
      a = {};
    let o = !1,
      l = !1,
      c = !1;
    t.levels.forEach((h) => {
      const m = h.attrs;
      let { audioCodec: p, videoCodec: g } = h;
      p && (h.audioCodec = p = Ww(p, s) || void 0),
        g && (g = h.videoCodec = wRe(g));
      const { width: y, height: b, unknownCodecs: w } = h;
      let S = w ? w.length : 0;
      if (w)
        for (let N = S; N--; ) {
          const W = w[N];
          this.isAudioSupported(W)
            ? ((h.audioCodec = p = p ? `${p},${W}` : W),
              S--,
              (Pf.audio[p.substring(0, 4)] = 2))
            : this.isVideoSupported(W) &&
              ((h.videoCodec = g = g ? `${g},${W}` : W),
              S--,
              (Pf.video[g.substring(0, 4)] = 2));
        }
      if (
        (o || (o = !!(y && b)),
        l || (l = !!g),
        c || (c = !!p),
        S ||
          (p && !this.isAudioSupported(p)) ||
          (g && !this.isVideoSupported(g)))
      ) {
        this.log(`Some or all CODECS not supported "${m.CODECS}"`);
        return;
      }
      const {
          CODECS: A,
          "FRAME-RATE": _,
          "HDCP-LEVEL": R,
          "PATHWAY-ID": C,
          RESOLUTION: D,
          "VIDEO-RANGE": L,
        } = m,
        V = `${`${C || "."}-`}${h.bitrate}-${D}-${_}-${A}-${L}-${R}`;
      if (i[V])
        if (i[V].uri !== h.url && !h.attrs["PATHWAY-ID"]) {
          const N = (a[V] += 1);
          h.attrs["PATHWAY-ID"] = new Array(N + 1).join(".");
          const W = this.createLevel(h);
          (i[V] = W), r.push(W);
        } else
          i[V].addGroupId("audio", m.AUDIO),
            i[V].addGroupId("text", m.SUBTITLES);
      else {
        const N = this.createLevel(h);
        (i[V] = N), (a[V] = 1), r.push(N);
      }
    }),
      this.filterAndSortMediaOptions(r, t, o, l, c);
  }
  createLevel(e) {
    const t = new fv(e),
      s = e.supplemental;
    if (s != null && s.videoCodec && !this.isVideoSupported(s.videoCodec)) {
      const r = new Error(
        `SUPPLEMENTAL-CODECS not supported "${s.videoCodec}"`
      );
      this.log(r.message), (t.supportedResult = gY(r, []));
    }
    return t;
  }
  isAudioSupported(e) {
    return nI(e, "audio", this.hls.config.preferManagedMediaSource);
  }
  isVideoSupported(e) {
    return nI(e, "video", this.hls.config.preferManagedMediaSource);
  }
  filterAndSortMediaOptions(e, t, s, r, i) {
    let a = [],
      o = [],
      l = e;
    if (
      ((s || r) &&
        i &&
        (l = l.filter(
          ({ videoCodec: w, videoRange: S, width: A, height: _ }) =>
            (!!w || !!(A && _)) && CRe(S)
        )),
      l.length === 0)
    ) {
      Promise.resolve().then(() => {
        if (this.hls) {
          let w = "no level with compatible codecs found in manifest",
            S = w;
          t.levels.length &&
            ((S = `one or more CODECS in variant not supported: ${Wn(
              t.levels
                .map((_) => _.attrs.CODECS)
                .filter((_, R, C) => C.indexOf(_) === R)
            )}`),
            this.warn(S),
            (w += ` (${S})`));
          const A = new Error(w);
          this.hls.trigger($.ERROR, {
            type: gt.MEDIA_ERROR,
            details: we.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: t.url,
            error: A,
            reason: S,
          });
        }
      });
      return;
    }
    t.audioTracks &&
      ((a = t.audioTracks.filter(
        (w) => !w.audioCodec || this.isAudioSupported(w.audioCodec)
      )),
      k5(a)),
      t.subtitles && ((o = t.subtitles), k5(o));
    const c = l.slice(0);
    l.sort((w, S) => {
      if (w.attrs["HDCP-LEVEL"] !== S.attrs["HDCP-LEVEL"])
        return (w.attrs["HDCP-LEVEL"] || "") > (S.attrs["HDCP-LEVEL"] || "")
          ? 1
          : -1;
      if (s && w.height !== S.height) return w.height - S.height;
      if (w.frameRate !== S.frameRate) return w.frameRate - S.frameRate;
      if (w.videoRange !== S.videoRange)
        return Kw.indexOf(w.videoRange) - Kw.indexOf(S.videoRange);
      if (w.videoCodec !== S.videoCodec) {
        const A = xB(w.videoCodec),
          _ = xB(S.videoCodec);
        if (A !== _) return _ - A;
      }
      if (w.uri === S.uri && w.codecSet !== S.codecSet) {
        const A = qw(w.codecSet),
          _ = qw(S.codecSet);
        if (A !== _) return _ - A;
      }
      return w.averageBitrate !== S.averageBitrate
        ? w.averageBitrate - S.averageBitrate
        : 0;
    });
    let h = c[0];
    if (
      this.steering &&
      ((l = this.steering.filterParsedLevels(l)), l.length !== c.length)
    ) {
      for (let w = 0; w < c.length; w++)
        if (c[w].pathwayId === l[0].pathwayId) {
          h = c[w];
          break;
        }
    }
    this._levels = l;
    for (let w = 0; w < l.length; w++)
      if (l[w] === h) {
        var m;
        this._firstLevel = w;
        const S = h.bitrate,
          A = this.hls.bandwidthEstimate;
        if (
          (this.log(
            `manifest loaded, ${l.length} level(s) found, first bitrate: ${S}`
          ),
          ((m = this.hls.userConfig) == null
            ? void 0
            : m.abrEwmaDefaultEstimate) === void 0)
        ) {
          const _ = Math.min(S, this.hls.config.abrEwmaDefaultEstimateMax);
          _ > A &&
            A === this.hls.abrEwmaDefaultEstimate &&
            (this.hls.bandwidthEstimate = _);
        }
        break;
      }
    const p = i && !r,
      g = this.hls.config,
      y = !!(g.audioStreamController && g.audioTrackController),
      b = {
        levels: l,
        audioTracks: a,
        subtitleTracks: o,
        sessionData: t.sessionData,
        sessionKeys: t.sessionKeys,
        firstLevel: this._firstLevel,
        stats: t.stats,
        audio: i,
        video: r,
        altAudio: y && !p && a.some((w) => !!w.url),
      };
    this.hls.trigger($.MANIFEST_PARSED, b);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get loadLevelObj() {
    return this.currentLevel;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const t = this._levels;
    if (t.length === 0) return;
    if (e < 0 || e >= t.length) {
      const h = new Error("invalid level idx"),
        m = e < 0;
      if (
        (this.hls.trigger($.ERROR, {
          type: gt.OTHER_ERROR,
          details: we.LEVEL_SWITCH_ERROR,
          level: e,
          fatal: m,
          error: h,
          reason: h.message,
        }),
        m)
      )
        return;
      e = Math.min(e, t.length - 1);
    }
    const s = this.currentLevelIndex,
      r = this.currentLevel,
      i = r ? r.attrs["PATHWAY-ID"] : void 0,
      a = t[e],
      o = a.attrs["PATHWAY-ID"];
    if (
      ((this.currentLevelIndex = e),
      (this.currentLevel = a),
      s === e && r && i === o)
    )
      return;
    this.log(
      `Switching to level ${e} (${a.height ? a.height + "p " : ""}${
        a.videoRange ? a.videoRange + " " : ""
      }${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${
        o ? " with Pathway " + o : ""
      } from level ${s}${i ? " with Pathway " + i : ""}`
    );
    const l = {
      level: e,
      attrs: a.attrs,
      details: a.details,
      bitrate: a.bitrate,
      averageBitrate: a.averageBitrate,
      maxBitrate: a.maxBitrate,
      realBitrate: a.realBitrate,
      width: a.width,
      height: a.height,
      codecSet: a.codecSet,
      audioCodec: a.audioCodec,
      videoCodec: a.videoCodec,
      audioGroups: a.audioGroups,
      subtitleGroups: a.subtitleGroups,
      loaded: a.loaded,
      loadError: a.loadError,
      fragmentError: a.fragmentError,
      name: a.name,
      id: a.id,
      uri: a.uri,
      url: a.url,
      urlId: 0,
      audioGroupIds: a.audioGroupIds,
      textGroupIds: a.textGroupIds,
    };
    this.hls.trigger($.LEVEL_SWITCHING, l);
    const c = a.details;
    if (!c || c.live) {
      const h = this.switchParams(a.uri, r?.details, c);
      this.loadPlaylist(h);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    (this.manualLevelIndex = e),
      this._startLevel === void 0 && (this._startLevel = e),
      e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  get pathways() {
    return this.steering ? this.steering.pathways() : [];
  }
  get pathwayPriority() {
    return this.steering ? this.steering.pathwayPriority : null;
  }
  set pathwayPriority(e) {
    if (this.steering) {
      const t = this.steering.pathways(),
        s = e.filter((r) => t.indexOf(r) !== -1);
      if (e.length < 1) {
        this.warn(
          `pathwayPriority ${e} should contain at least one pathway from list: ${t}`
        );
        return;
      }
      this.steering.pathwayPriority = s;
    }
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === en.LEVEL &&
        t.context.level === this.level &&
        this.checkRetry(t));
  }
  onFragBuffered(e, { frag: t }) {
    if (t !== void 0 && t.type === lt.MAIN) {
      const s = t.elementaryStreams;
      if (!Object.keys(s).some((i) => !!s[i])) return;
      const r = this._levels[t.level];
      r != null &&
        r.loadError &&
        (this.log(
          `Resetting level error count of ${r.loadError} on frag buffered`
        ),
        (r.loadError = 0));
    }
  }
  onLevelLoaded(e, t) {
    var s;
    const { level: r, details: i } = t,
      a = t.levelInfo;
    if (!a) {
      var o;
      this.warn(`Invalid level index ${r}`),
        (o = t.deliveryDirectives) != null &&
          o.skip &&
          (i.deltaUpdateFailed = !0);
      return;
    }
    if (a === this.currentLevel || t.withoutMultiVariant) {
      a.fragmentError === 0 && (a.loadError = 0);
      let l = a.details;
      l === t.details && l.advanced && (l = void 0),
        this.playlistLoaded(r, t, l);
    } else
      (s = t.deliveryDirectives) != null &&
        s.skip &&
        (i.deltaUpdateFailed = !0);
  }
  loadPlaylist(e) {
    super.loadPlaylist(),
      this.shouldLoadPlaylist(this.currentLevel) &&
        this.scheduleLoading(this.currentLevel, e);
  }
  loadingPlaylist(e, t) {
    super.loadingPlaylist(e, t);
    const s = this.getUrlWithDirectives(e.uri, t),
      r = this.currentLevelIndex,
      i = e.attrs["PATHWAY-ID"],
      a = e.details,
      o = a?.age;
    this.log(
      `Loading level index ${r}${
        t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""
      }${i ? " Pathway " + i : ""}${
        o && a.live
          ? " age " + o.toFixed(1) + ((a.type && " " + a.type) || "")
          : ""
      } ${s}`
    ),
      this.hls.trigger($.LEVEL_LOADING, {
        url: s,
        level: r,
        levelInfo: e,
        pathwayId: e.attrs["PATHWAY-ID"],
        id: 0,
        deliveryDirectives: t || null,
      });
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1
      ? this.manualLevelIndex
      : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    (this.level = e),
      this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e) {
    var t;
    if (this._levels.length === 1) return;
    const s = this._levels.filter((i, a) =>
      a !== e
        ? !0
        : (this.steering && this.steering.removeLevel(i),
          i === this.currentLevel &&
            ((this.currentLevel = null),
            (this.currentLevelIndex = -1),
            i.details && i.details.fragments.forEach((o) => (o.level = -1))),
          !1)
    );
    PY(s),
      (this._levels = s),
      this.currentLevelIndex > -1 &&
        (t = this.currentLevel) != null &&
        t.details &&
        (this.currentLevelIndex = this.currentLevel.details.fragments[0].level),
      this.manualLevelIndex > -1 &&
        (this.manualLevelIndex = this.currentLevelIndex);
    const r = s.length - 1;
    (this._firstLevel = Math.min(this._firstLevel, r)),
      this._startLevel && (this._startLevel = Math.min(this._startLevel, r)),
      this.hls.trigger($.LEVELS_UPDATED, { levels: s });
  }
  onLevelsUpdated(e, { levels: t }) {
    this._levels = t;
  }
  checkMaxAutoUpdated() {
    const { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: s } = this.hls;
    this._maxAutoLevel !== t &&
      ((this._maxAutoLevel = t),
      this.hls.trigger($.MAX_AUTO_LEVEL_UPDATED, {
        autoLevelCapping: e,
        levels: this.levels,
        maxAutoLevel: t,
        minAutoLevel: this.hls.minAutoLevel,
        maxHdcpLevel: s,
      }));
  }
}
function k5(n) {
  const e = {};
  n.forEach((t) => {
    const s = t.groupId || "";
    (t.id = e[s] = e[s] || 0), e[s]++;
  });
}
function SX() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function TX() {
  if (!Bc()) return !1;
  const e = SX();
  return (
    !e ||
    (e.prototype &&
      typeof e.prototype.appendBuffer == "function" &&
      typeof e.prototype.remove == "function")
  );
}
function kLe() {
  if (!TX()) return !1;
  const n = Bc();
  return (
    typeof n?.isTypeSupported == "function" &&
    (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e) =>
      n.isTypeSupported(hv(e, "video"))
    ) ||
      ["mp4a.40.2", "fLaC"].some((e) => n.isTypeSupported(hv(e, "audio"))))
  );
}
function CLe() {
  var n;
  const e = SX();
  return (
    typeof (e == null || (n = e.prototype) == null ? void 0 : n.changeType) ==
    "function"
  );
}
const ILe = 100;
class LLe extends QP {
  constructor(e, t, s) {
    super(e, t, s, "stream-controller", lt.MAIN),
      (this.audioCodecSwap = !1),
      (this.level = -1),
      (this._forceStartLoad = !1),
      (this._hasEnoughToStart = !1),
      (this.altAudio = 0),
      (this.audioOnly = !1),
      (this.fragPlaying = null),
      (this.fragLastKbps = 0),
      (this.couldBacktrack = !1),
      (this.backtrackFragment = null),
      (this.audioCodecSwitch = !1),
      (this.videoBuffer = null),
      (this.onMediaPlaying = () => {
        this.tick();
      }),
      (this.onMediaSeeked = () => {
        const r = this.media,
          i = r ? r.currentTime : null;
        if (
          i === null ||
          !Qe(i) ||
          (this.log(`Media seeked to ${i.toFixed(3)}`),
          !this.getBufferedFrag(i))
        )
          return;
        const a = this.getFwdBufferInfoAtPos(r, i, lt.MAIN, 0);
        if (a === null || a.len === 0) {
          this.warn(
            `Main forward buffer length at ${i} on "seeked" event ${
              a ? a.len : "empty"
            })`
          );
          return;
        }
        this.tick();
      }),
      this.registerListeners();
  }
  registerListeners() {
    super.registerListeners();
    const { hls: e } = this;
    e.on($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on($.LEVEL_LOADING, this.onLevelLoading, this),
      e.on($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(
        $.FRAG_LOAD_EMERGENCY_ABORTED,
        this.onFragLoadEmergencyAborted,
        this
      ),
      e.on($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.on($.BUFFER_CREATED, this.onBufferCreated, this),
      e.on($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on($.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const { hls: e } = this;
    e.off($.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off($.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(
        $.FRAG_LOAD_EMERGENCY_ABORTED,
        this.onFragLoadEmergencyAborted,
        this
      ),
      e.off($.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off($.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.off($.BUFFER_CREATED, this.onBufferCreated, this),
      e.off($.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off($.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    (this.onMediaPlaying = this.onMediaSeeked = null),
      this.unregisterListeners(),
      super.onHandlerDestroying();
  }
  startLoad(e, t) {
    if (this.levels) {
      const { lastCurrentTime: s, hls: r } = this;
      if (
        (this.stopLoad(),
        this.setInterval(ILe),
        (this.level = -1),
        !this.startFragRequested)
      ) {
        let i = r.startLevel;
        i === -1 &&
          (r.config.testBandwidth && this.levels.length > 1
            ? ((i = 0), (this.bitrateTest = !0))
            : (i = r.firstAutoLevel)),
          (r.nextLoadLevel = i),
          (this.level = r.loadLevel),
          (this._hasEnoughToStart = !!t);
      }
      s > 0 &&
        e === -1 &&
        !t &&
        (this.log(
          `Override startPosition with lastCurrentTime @${s.toFixed(3)}`
        ),
        (e = s)),
        (this.state = Me.IDLE),
        (this.nextLoadPosition = this.lastCurrentTime =
          e + this.timelineOffset),
        (this.startPosition = t ? -1 : e),
        this.tick();
    } else (this._forceStartLoad = !0), (this.state = Me.STOPPED);
  }
  stopLoad() {
    (this._forceStartLoad = !1), super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case Me.WAITING_LEVEL: {
        const { levels: t, level: s } = this,
          r = t?.[s],
          i = r?.details;
        if (
          i &&
          (!i.live || (this.levelLastLoaded === r && !this.waitForLive(r)))
        ) {
          if (this.waitForCdnTuneIn(i)) break;
          this.state = Me.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = Me.IDLE;
          break;
        }
        break;
      }
      case Me.FRAG_LOADING_WAITING_RETRY:
        {
          var e;
          const t = self.performance.now(),
            s = this.retryDate;
          if (!s || t >= s || ((e = this.media) != null && e.seeking)) {
            const { levels: r, level: i } = this,
              a = r?.[i];
            this.resetStartWhenNotLoaded(a || null), (this.state = Me.IDLE);
          }
        }
        break;
    }
    this.state === Me.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    var e;
    super.onTickEnd(),
      (e = this.media) != null &&
        e.readyState &&
        this.media.seeking === !1 &&
        (this.lastCurrentTime = this.media.currentTime),
      this.checkFragmentChanged();
  }
  doTickIdle() {
    const { hls: e, levelLastLoaded: t, levels: s, media: r } = this;
    if (
      t === null ||
      (!r &&
        !this.primaryPrefetch &&
        (this.startFragRequested || !e.config.startFragPrefetch)) ||
      (this.altAudio && this.audioOnly)
    )
      return;
    const i = this.buffering ? e.nextLoadLevel : e.loadLevel;
    if (!(s != null && s[i])) return;
    const a = s[i],
      o = this.getMainFwdBufferInfo();
    if (o === null) return;
    const l = this.getLevelDetails();
    if (l && this._streamEnded(o, l)) {
      const b = {};
      this.altAudio === 2 && (b.type = "video"),
        this.hls.trigger($.BUFFER_EOS, b),
        (this.state = Me.ENDED);
      return;
    }
    if (!this.buffering) return;
    e.loadLevel !== i &&
      e.manualLevel === -1 &&
      this.log(`Adapting to level ${i} from level ${this.level}`),
      (this.level = e.nextLoadLevel = i);
    const c = a.details;
    if (!c || this.state === Me.WAITING_LEVEL || this.waitForLive(a)) {
      (this.level = i),
        (this.state = Me.WAITING_LEVEL),
        (this.startFragRequested = !1);
      return;
    }
    const h = o.len,
      m = this.getMaxBufferLength(a.maxBitrate);
    if (h >= m) return;
    this.backtrackFragment &&
      this.backtrackFragment.start > o.end &&
      (this.backtrackFragment = null);
    const p = this.backtrackFragment ? this.backtrackFragment.start : o.end;
    let g = this.getNextFragment(p, c);
    if (
      this.couldBacktrack &&
      !this.fragPrevious &&
      g &&
      Os(g) &&
      this.fragmentTracker.getState(g) !== qs.OK
    ) {
      var y;
      const w = ((y = this.backtrackFragment) != null ? y : g).sn - c.startSN,
        S = c.fragments[w - 1];
      S && g.cc === S.cc && ((g = S), this.fragmentTracker.removeFragment(S));
    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
    if (g && this.isLoopLoading(g, p)) {
      if (!g.gap) {
        const w = this.audioOnly && !this.altAudio ? On.AUDIO : On.VIDEO,
          S =
            (w === On.VIDEO ? this.videoBuffer : this.mediaBuffer) ||
            this.media;
        S && this.afterBufferFlushed(S, w, lt.MAIN);
      }
      g = this.getNextFragmentLoopLoading(g, c, o, lt.MAIN, m);
    }
    g &&
      (g.initSegment &&
        !g.initSegment.data &&
        !this.bitrateTest &&
        (g = g.initSegment),
      this.loadFragment(g, a, p));
  }
  loadFragment(e, t, s) {
    const r = this.fragmentTracker.getState(e);
    r === qs.NOT_LOADED || r === qs.PARTIAL
      ? Os(e)
        ? this.bitrateTest
          ? (this.log(
              `Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`
            ),
            this._loadBitrateTestFrag(e, t))
          : super.loadFragment(e, t, s)
        : this._loadInitSegment(e, t)
      : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, lt.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  nextLevelSwitch() {
    const { levels: e, media: t } = this;
    if (t != null && t.readyState) {
      let s;
      const r = this.getAppendedFrag(t.currentTime);
      r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
      const i = this.getLevelDetails();
      if (i != null && i.live) {
        const o = this.getMainFwdBufferInfo();
        if (!o || o.len < i.targetduration * 2) return;
      }
      if (!t.paused && e) {
        const o = this.hls.nextLoadLevel,
          l = e[o],
          c = this.fragLastKbps;
        c && this.fragCurrent
          ? (s = (this.fragCurrent.duration * l.maxBitrate) / (1e3 * c) + 1)
          : (s = 0);
      } else s = 0;
      const a = this.getBufferedFrag(t.currentTime + s);
      if (a) {
        const o = this.followingBufferedFrag(a);
        if (o) {
          this.abortCurrentFrag();
          const l = o.maxStartPTS ? o.maxStartPTS : o.start,
            c = o.duration,
            h = Math.max(
              a.end,
              l +
                Math.min(
                  Math.max(
                    c - this.config.maxFragLookUpTolerance,
                    c * (this.couldBacktrack ? 0.5 : 0.125)
                  ),
                  c * (this.couldBacktrack ? 0.75 : 0.25)
                )
            );
          this.flushMainBuffer(h, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (
      ((this.fragCurrent = null),
      (this.backtrackFragment = null),
      e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
      this.state)
    ) {
      case Me.KEY_LOADING:
      case Me.FRAG_LOADING:
      case Me.FRAG_LOADING_WAITING_RETRY:
      case Me.PARSING:
      case Me.PARSED:
        this.state = Me.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null);
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t);
    const s = t.media;
    na(s, "playing", this.onMediaPlaying), na(s, "seeked", this.onMediaSeeked);
  }
  onMediaDetaching(e, t) {
    const { media: s } = this;
    s &&
      (La(s, "playing", this.onMediaPlaying),
      La(s, "seeked", this.onMediaSeeked)),
      (this.videoBuffer = null),
      (this.fragPlaying = null),
      super.onMediaDetaching(e, t),
      !t.transferMedia && (this._hasEnoughToStart = !1);
  }
  onManifestLoading() {
    super.onManifestLoading(),
      this.log("Trigger BUFFER_RESET"),
      this.hls.trigger($.BUFFER_RESET, void 0),
      (this.couldBacktrack = !1),
      (this.fragLastKbps = 0),
      (this.fragPlaying = this.backtrackFragment = null),
      (this.altAudio = 0),
      (this.audioOnly = !1);
  }
  onManifestParsed(e, t) {
    let s = !1,
      r = !1;
    t.levels.forEach((i) => {
      const a = i.audioCodec;
      a &&
        ((s = s || a.indexOf("mp4a.40.2") !== -1),
        (r = r || a.indexOf("mp4a.40.5") !== -1));
    }),
      (this.audioCodecSwitch = s && r && !CLe()),
      this.audioCodecSwitch &&
        this.log(
          "Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"
        ),
      (this.levels = t.levels),
      (this.startFragRequested = !1);
  }
  onLevelLoading(e, t) {
    const { levels: s } = this;
    if (!s || this.state !== Me.IDLE) return;
    const r = t.levelInfo;
    (!r.details ||
      (r.details.live && (this.levelLastLoaded !== r || r.details.expired)) ||
      this.waitForCdnTuneIn(r.details)) &&
      (this.state = Me.WAITING_LEVEL);
  }
  onLevelLoaded(e, t) {
    var s;
    const { levels: r, startFragRequested: i } = this,
      a = t.level,
      o = t.details,
      l = o.totalduration;
    if (!r) {
      this.warn(`Levels were reset while loading level ${a}`);
      return;
    }
    this.log(
      `Level ${a} loaded [${o.startSN},${o.endSN}]${
        o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""
      }, cc [${o.startCC}, ${o.endCC}] duration:${l}`
    );
    const c = t.levelInfo,
      h = this.fragCurrent;
    h &&
      (this.state === Me.FRAG_LOADING ||
        this.state === Me.FRAG_LOADING_WAITING_RETRY) &&
      h.level !== t.level &&
      h.loader &&
      this.abortCurrentFrag();
    let m = 0;
    if (o.live || ((s = c.details) != null && s.live)) {
      var p;
      if ((this.checkLiveUpdate(o), o.deltaUpdateFailed)) return;
      m = this.alignPlaylists(
        o,
        c.details,
        (p = this.levelLastLoaded) == null ? void 0 : p.details
      );
    }
    if (
      ((c.details = o),
      (this.levelLastLoaded = c),
      i || this.setStartPosition(o, m),
      this.hls.trigger($.LEVEL_UPDATED, { details: o, level: a }),
      this.state === Me.WAITING_LEVEL)
    ) {
      if (this.waitForCdnTuneIn(o)) return;
      this.state = Me.IDLE;
    }
    i && o.live && this.synchronizeToLiveEdge(o), this.tick();
  }
  synchronizeToLiveEdge(e) {
    const { config: t, media: s } = this;
    if (!s) return;
    const r = this.hls.liveSyncPosition,
      i = this.getLoadPosition(),
      a = e.fragmentStart,
      o = e.edge,
      l = i >= a - t.maxFragLookUpTolerance && i <= o;
    if (r !== null && s.duration > r && (i < r || !l)) {
      const h =
        t.liveMaxLatencyDuration !== void 0
          ? t.liveMaxLatencyDuration
          : t.liveMaxLatencyDurationCount * e.targetduration;
      if (
        ((!l && s.readyState < 4) || i < o - h) &&
        (this._hasEnoughToStart || (this.nextLoadPosition = r), s.readyState)
      )
        if (
          (this.warn(
            `Playback: ${i.toFixed(
              3
            )} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${r.toFixed(
              3
            )}`
          ),
          this.config.liveSyncMode === "buffered")
        ) {
          var c;
          const m = Ft.bufferInfo(s, r, 0);
          if (!(m != null && (c = m.buffered) != null && c.length)) {
            s.currentTime = r;
            return;
          }
          if (m.start <= i) {
            s.currentTime = r;
            return;
          }
          const { nextStart: g } = Ft.bufferedInfo(m.buffered, i, 0);
          g && (s.currentTime = g);
        } else s.currentTime = r;
    }
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const s = e.frag,
      { part: r, payload: i } = e,
      { levels: a } = this;
    if (!a) {
      this.warn(
        `Levels were reset while fragment load was in progress. Fragment ${s.sn} of level ${s.level} will not be buffered`
      );
      return;
    }
    const o = a[s.level];
    if (!o) {
      this.warn(`Level ${s.level} not found on progress`);
      return;
    }
    const l = o.details;
    if (!l) {
      this.warn(
        `Dropping fragment ${s.sn} of level ${s.level} after level details were reset`
      ),
        this.fragmentTracker.removeFragment(s);
      return;
    }
    const c = o.videoCodec,
      h = l.PTSKnown || !l.live,
      m = (t = s.initSegment) == null ? void 0 : t.data,
      p = this._getAudioCodec(o),
      g = (this.transmuxer =
        this.transmuxer ||
        new tX(
          this.hls,
          lt.MAIN,
          this._handleTransmuxComplete.bind(this),
          this._handleTransmuxerFlush.bind(this)
        )),
      y = r ? r.index : -1,
      b = y !== -1,
      w = new YP(s.level, s.sn, s.stats.chunkCount, i.byteLength, y, b),
      S = this.initPTS[s.cc];
    g.push(i, m, p, c, s, r, l.totalduration, h, w, S);
  }
  onAudioTrackSwitching(e, t) {
    const s = this.hls,
      r = this.altAudio === 2;
    if (Yw(t.url, s)) this.altAudio = 1;
    else {
      if (this.mediaBuffer !== this.media) {
        this.log(
          "Switching on main audio, use media.buffered to schedule main fragment loading"
        ),
          (this.mediaBuffer = this.media);
        const a = this.fragCurrent;
        a &&
          (this.log("Switching to main audio track, cancel main fragment load"),
          a.abortRequests(),
          this.fragmentTracker.removeFragment(a)),
          this.resetTransmuxer(),
          this.resetLoadingState();
      } else this.audioOnly && this.resetTransmuxer();
      if (r) {
        this.fragmentTracker.removeAllFragments(),
          s.once($.BUFFER_FLUSHED, () => {
            var a;
            (a = this.hls) == null || a.trigger($.AUDIO_TRACK_SWITCHED, t);
          }),
          s.trigger($.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: Number.POSITIVE_INFINITY,
            type: null,
          });
        return;
      }
      s.trigger($.AUDIO_TRACK_SWITCHED, t);
    }
  }
  onAudioTrackSwitched(e, t) {
    const s = Yw(t.url, this.hls);
    if (s) {
      const r = this.videoBuffer;
      r &&
        this.mediaBuffer !== r &&
        (this.log(
          "Switching on alternate audio, use video.buffered to schedule main fragment loading"
        ),
        (this.mediaBuffer = r));
    }
    (this.altAudio = s ? 2 : 0), this.tick();
  }
  onBufferCreated(e, t) {
    const s = t.tracks;
    let r,
      i,
      a = !1;
    for (const o in s) {
      const l = s[o];
      if (l.id === "main") {
        if (((i = o), (r = l), o === "video")) {
          const c = s[o];
          c && (this.videoBuffer = c.buffer);
        }
      } else a = !0;
    }
    a && r
      ? (this.log(
          `Alternate track found, use ${i}.buffered to schedule main fragment loading`
        ),
        (this.mediaBuffer = r.buffer))
      : (this.mediaBuffer = this.media);
  }
  onFragBuffered(e, t) {
    const { frag: s, part: r } = t,
      i = s.type === lt.MAIN;
    if (i) {
      if (this.fragContextChanged(s)) {
        this.warn(
          `Fragment ${s.sn}${r ? " p: " + r.index : ""} of level ${
            s.level
          } finished buffering, but was aborted. state: ${this.state}`
        ),
          this.state === Me.PARSED && (this.state = Me.IDLE);
        return;
      }
      const o = r ? r.stats : s.stats;
      (this.fragLastKbps = Math.round(
        (8 * o.total) / (o.buffering.end - o.loading.first)
      )),
        Os(s) && (this.fragPrevious = s),
        this.fragBufferedComplete(s, r);
    }
    const a = this.media;
    a &&
      (!this._hasEnoughToStart &&
        Ft.getBuffered(a).length &&
        ((this._hasEnoughToStart = !0), this.seekToStartPos()),
      i && this.tick());
  }
  get hasEnoughToStart() {
    return this._hasEnoughToStart;
  }
  onError(e, t) {
    var s;
    if (t.fatal) {
      this.state = Me.ERROR;
      return;
    }
    switch (t.details) {
      case we.FRAG_GAP:
      case we.FRAG_PARSING_ERROR:
      case we.FRAG_DECRYPT_ERROR:
      case we.FRAG_LOAD_ERROR:
      case we.FRAG_LOAD_TIMEOUT:
      case we.KEY_LOAD_ERROR:
      case we.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(lt.MAIN, t);
        break;
      case we.LEVEL_LOAD_ERROR:
      case we.LEVEL_LOAD_TIMEOUT:
      case we.LEVEL_PARSING_ERROR:
        !t.levelRetry &&
          this.state === Me.WAITING_LEVEL &&
          ((s = t.context) == null ? void 0 : s.type) === en.LEVEL &&
          (this.state = Me.IDLE);
        break;
      case we.BUFFER_ADD_CODEC_ERROR:
      case we.BUFFER_APPEND_ERROR:
        if (t.parent !== "main") return;
        this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState();
        break;
      case we.BUFFER_FULL_ERROR:
        if (t.parent !== "main") return;
        this.reduceLengthAndFlushBuffer(t) &&
          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        break;
      case we.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t);
        break;
    }
  }
  onFragLoadEmergencyAborted() {
    (this.state = Me.IDLE),
      this._hasEnoughToStart ||
        ((this.startFragRequested = !1),
        (this.nextLoadPosition = this.lastCurrentTime)),
      this.tickImmediate();
  }
  onBufferFlushed(e, { type: t }) {
    if (t !== On.AUDIO || !this.altAudio) {
      const s =
        (t === On.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      s && (this.afterBufferFlushed(s, t, lt.MAIN), this.tick());
    }
  }
  onLevelsUpdated(e, t) {
    this.level > -1 &&
      this.fragCurrent &&
      ((this.level = this.fragCurrent.level),
      this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)),
      (this.levels = t.levels);
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  seekToStartPos() {
    const { media: e } = this;
    if (!e) return;
    const t = e.currentTime;
    let s = this.startPosition;
    if (s >= 0 && t < s) {
      if (e.seeking) {
        this.log(`could not seek to ${s}, already seeking at ${t}`);
        return;
      }
      const r = this.timelineOffset;
      r && s && (s += r);
      const i = this.getLevelDetails(),
        a = Ft.getBuffered(e),
        o = a.length ? a.start(0) : 0,
        l = o - s,
        c = Math.max(
          this.config.maxBufferHole,
          this.config.maxFragLookUpTolerance
        );
      (this.config.startOnSegmentBoundary ||
        (l > 0 &&
          (l < c || (this.loadingParts && l < 2 * (i?.partTarget || 0))))) &&
        (this.log(`adjusting start position by ${l} to match buffer start`),
        (s += l),
        (this.startPosition = s)),
        t < s &&
          (this.log(
            `seek to target start position ${s} from current time ${t} buffer start ${o}`
          ),
          (e.currentTime = s));
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec;
    return (
      this.audioCodecSwap &&
        t &&
        (this.log("Swapping audio codec"),
        t.indexOf("mp4a.40.5") !== -1 ? (t = "mp4a.40.2") : (t = "mp4a.40.5")),
      t
    );
  }
  _loadBitrateTestFrag(e, t) {
    (e.bitrateTest = !0),
      this._doFragLoad(e, t).then((s) => {
        const { hls: r } = this,
          i = s?.frag;
        if (!i || this.fragContextChanged(i)) return;
        (t.fragmentError = 0),
          (this.state = Me.IDLE),
          (this.startFragRequested = !1),
          (this.bitrateTest = !1);
        const a = i.stats;
        (a.parsing.start =
          a.parsing.end =
          a.buffering.start =
          a.buffering.end =
            self.performance.now()),
          r.trigger($.FRAG_LOADED, s),
          (i.bitrateTest = !1);
      });
  }
  _handleTransmuxComplete(e) {
    var t;
    const s = this.playlistType,
      { hls: r } = this,
      { remuxResult: i, chunkMeta: a } = e,
      o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const { frag: l, part: c, level: h } = o,
      { video: m, text: p, id3: g, initSegment: y } = i,
      { details: b } = h,
      w = this.altAudio ? void 0 : i.audio;
    if (this.fragContextChanged(l)) {
      this.fragmentTracker.removeFragment(l);
      return;
    }
    if (((this.state = Me.PARSING), y)) {
      if (y != null && y.tracks) {
        const R = l.initSegment || l;
        this._bufferInitSegment(h, y.tracks, R, a),
          r.trigger($.FRAG_PARSING_INIT_SEGMENT, {
            frag: R,
            id: s,
            tracks: y.tracks,
          });
      }
      const S = y.initPTS,
        A = y.timescale,
        _ = this.initPTS[l.cc];
      Qe(S) &&
        (!_ || _.baseTime !== S || _.timescale !== A) &&
        ((this.initPTS[l.cc] = { baseTime: S, timescale: A }),
        r.trigger($.INIT_PTS_FOUND, {
          frag: l,
          id: s,
          initPTS: S,
          timescale: A,
        }));
    }
    if (m && b) {
      w && m.type === "audiovideo" && this.logMuxedErr(l);
      const S = b.fragments[l.sn - 1 - b.startSN],
        A = l.sn === b.startSN,
        _ = !S || l.cc > S.cc;
      if (i.independent !== !1) {
        const { startPTS: R, endPTS: C, startDTS: D, endDTS: L } = m;
        if (c)
          c.elementaryStreams[m.type] = {
            startPTS: R,
            endPTS: C,
            startDTS: D,
            endDTS: L,
          };
        else if (
          (m.firstKeyFrame &&
            m.independent &&
            a.id === 1 &&
            !_ &&
            (this.couldBacktrack = !0),
          m.dropped && m.independent)
        ) {
          const P = this.getMainFwdBufferInfo(),
            V =
              (P ? P.end : this.getLoadPosition()) + this.config.maxBufferHole,
            N = m.firstKeyFramePTS ? m.firstKeyFramePTS : R;
          if (!A && V < N - this.config.maxBufferHole && !_) {
            this.backtrack(l);
            return;
          } else _ && (l.gap = !0);
          l.setElementaryStreamInfo(m.type, l.start, C, l.start, L, !0);
        } else A && R - (b.appliedTimelineOffset || 0) > lx && (l.gap = !0);
        l.setElementaryStreamInfo(m.type, R, C, D, L),
          this.backtrackFragment && (this.backtrackFragment = l),
          this.bufferFragmentData(m, l, c, a, A || _);
      } else if (A || _) l.gap = !0;
      else {
        this.backtrack(l);
        return;
      }
    }
    if (w) {
      const { startPTS: S, endPTS: A, startDTS: _, endDTS: R } = w;
      c &&
        (c.elementaryStreams[On.AUDIO] = {
          startPTS: S,
          endPTS: A,
          startDTS: _,
          endDTS: R,
        }),
        l.setElementaryStreamInfo(On.AUDIO, S, A, _, R),
        this.bufferFragmentData(w, l, c, a);
    }
    if (b && g != null && (t = g.samples) != null && t.length) {
      const S = { id: s, frag: l, details: b, samples: g.samples };
      r.trigger($.FRAG_PARSING_METADATA, S);
    }
    if (b && p) {
      const S = { id: s, frag: l, details: b, samples: p.samples };
      r.trigger($.FRAG_PARSING_USERDATA, S);
    }
  }
  logMuxedErr(e) {
    this.warn(
      `${
        Os(e) ? "Media" : "Init"
      } segment with muxed audiovideo where only video expected: ${e.url}`
    );
  }
  _bufferInitSegment(e, t, s, r) {
    if (this.state !== Me.PARSING) return;
    (this.audioOnly = !!t.audio && !t.video),
      this.altAudio &&
        !this.audioOnly &&
        (delete t.audio, t.audiovideo && this.logMuxedErr(s));
    const { audio: i, video: a, audiovideo: o } = t;
    if (i) {
      const c = e.audioCodec;
      let h = tx(i.codec, c);
      h === "mp4a" && (h = "mp4a.40.5");
      const m = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        h &&
          (h.indexOf("mp4a.40.5") !== -1
            ? (h = "mp4a.40.2")
            : (h = "mp4a.40.5"));
        const p = i.metadata;
        p &&
          "channelCount" in p &&
          (p.channelCount || 1) !== 1 &&
          m.indexOf("firefox") === -1 &&
          (h = "mp4a.40.5");
      }
      h &&
        h.indexOf("mp4a.40.5") !== -1 &&
        m.indexOf("android") !== -1 &&
        i.container !== "audio/mpeg" &&
        ((h = "mp4a.40.2"), this.log(`Android: force audio codec to ${h}`)),
        c &&
          c !== h &&
          this.log(`Swapping manifest audio codec "${c}" for "${h}"`),
        (i.levelCodec = h),
        (i.id = lt.MAIN),
        this.log(
          `Init audio buffer, container:${
            i.container
          }, codecs[selected/level/parsed]=[${h || ""}/${c || ""}/${i.codec}]`
        ),
        delete t.audiovideo;
    }
    if (a) {
      (a.levelCodec = e.videoCodec), (a.id = lt.MAIN);
      const c = a.codec;
      if (c?.length === 4)
        switch (c) {
          case "hvc1":
          case "hev1":
            a.codec = "hvc1.1.6.L120.90";
            break;
          case "av01":
            a.codec = "av01.0.04M.08";
            break;
          case "avc1":
            a.codec = "avc1.42e01e";
            break;
        }
      this.log(
        `Init video buffer, container:${a.container}, codecs[level/parsed]=[${
          e.videoCodec || ""
        }/${c}]${a.codec !== c ? " parsed-corrected=" + a.codec : ""}${
          a.supplemental ? " supplemental=" + a.supplemental : ""
        }`
      ),
        delete t.audiovideo;
    }
    o &&
      (this.log(
        `Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`
      ),
      delete t.video,
      delete t.audio);
    const l = Object.keys(t);
    if (l.length) {
      if ((this.hls.trigger($.BUFFER_CODECS, t), !this.hls)) return;
      l.forEach((c) => {
        const m = t[c].initSegment;
        m != null &&
          m.byteLength &&
          this.hls.trigger($.BUFFER_APPENDING, {
            type: c,
            data: m,
            frag: s,
            part: null,
            chunkMeta: r,
            parent: s.type,
          });
      });
    }
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    const e =
      this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
    return this.getFwdBufferInfo(e, lt.MAIN);
  }
  get maxBufferLength() {
    const { levels: e, level: t } = this,
      s = e?.[t];
    return s
      ? this.getMaxBufferLength(s.maxBitrate)
      : this.config.maxBufferLength;
  }
  backtrack(e) {
    (this.couldBacktrack = !0),
      (this.backtrackFragment = e),
      this.resetTransmuxer(),
      this.flushBufferGap(e),
      this.fragmentTracker.removeFragment(e),
      (this.fragPrevious = null),
      (this.nextLoadPosition = e.start),
      (this.state = Me.IDLE);
  }
  checkFragmentChanged() {
    const e = this.media;
    let t = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const s = e.currentTime;
      if (
        (Ft.isBuffered(e, s)
          ? (t = this.getAppendedFrag(s))
          : Ft.isBuffered(e, s + 0.1) && (t = this.getAppendedFrag(s + 0.1)),
        t)
      ) {
        this.backtrackFragment = null;
        const r = this.fragPlaying,
          i = t.level;
        (!r || t.sn !== r.sn || r.level !== i) &&
          ((this.fragPlaying = t),
          this.hls.trigger($.FRAG_CHANGED, { frag: t }),
          (!r || r.level !== i) &&
            this.hls.trigger($.LEVEL_SWITCHED, { level: i }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    var e;
    if (this.fragPlaying) return this.fragPlaying;
    const t =
      ((e = this.media) == null ? void 0 : e.currentTime) ||
      this.lastCurrentTime;
    return Qe(t) ? this.getAppendedFrag(t) : null;
  }
  get currentProgramDateTime() {
    var e;
    const t =
      ((e = this.media) == null ? void 0 : e.currentTime) ||
      this.lastCurrentTime;
    if (Qe(t)) {
      const s = this.getLevelDetails(),
        r = this.currentFrag || (s ? id(null, s.fragments, t) : null);
      if (r) {
        const i = r.programDateTime;
        if (i !== null) {
          const a = i + (t - r.start) * 1e3;
          return new Date(a);
        }
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class DLe {
  constructor(e) {
    (this.config = void 0),
      (this.keyUriToKeyInfo = {}),
      (this.emeController = null),
      (this.config = e);
  }
  abort(e) {
    for (const s in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[s].loader;
      if (r) {
        var t;
        if (e && e !== ((t = r.context) == null ? void 0 : t.frag.type)) return;
        r.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e];
      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) &&
        delete this.keyUriToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e].loader;
      t && t.destroy();
    }
    this.keyUriToKeyInfo = {};
  }
  createKeyLoadError(e, t = we.KEY_LOAD_ERROR, s, r, i) {
    return new pl({
      type: gt.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: i,
      error: s,
      networkDetails: r,
    });
  }
  loadClear(e, t, s) {
    if (
      this.emeController &&
      this.config.emeEnabled &&
      !this.emeController.getSelectedKeySystemFormats().length
    ) {
      if (t.length)
        for (let r = 0, i = t.length; r < i; r++) {
          const a = t[r];
          if (
            (e.cc <= a.cc && (!Os(e) || !Os(a) || e.sn < a.sn)) ||
            (!s && r == i - 1)
          )
            return this.emeController.selectKeySystemFormat(a).then((o) => {
              if (!this.emeController) return;
              a.setKeyFormat(o);
              const l = oI(o);
              if (l) return this.emeController.getKeySystemAccess([l]);
            });
        }
      if (this.config.requireKeySystemAccessOnStart) {
        const r = sx(this.config);
        if (r.length) return this.emeController.getKeySystemAccess(r);
      }
    }
    return null;
  }
  load(e) {
    return !e.decryptdata &&
      e.encrypted &&
      this.emeController &&
      this.config.emeEnabled
      ? this.emeController
          .selectKeySystemFormat(e)
          .then((t) => this.loadInternal(e, t))
      : this.loadInternal(e);
  }
  loadInternal(e, t) {
    var s, r;
    t && e.setKeyFormat(t);
    const i = e.decryptdata;
    if (!i) {
      const c = new Error(
        t
          ? `Expected frag.decryptdata to be defined after setting format ${t}`
          : "Missing decryption data on fragment in onKeyLoading"
      );
      return Promise.reject(this.createKeyLoadError(e, we.KEY_LOAD_ERROR, c));
    }
    const a = i.uri;
    if (!a)
      return Promise.reject(
        this.createKeyLoadError(
          e,
          we.KEY_LOAD_ERROR,
          new Error(`Invalid key URI: "${a}"`)
        )
      );
    let o = this.keyUriToKeyInfo[a];
    if ((s = o) != null && s.decryptdata.key)
      return (
        (i.key = o.decryptdata.key), Promise.resolve({ frag: e, keyInfo: o })
      );
    if ((r = o) != null && r.keyLoadPromise) {
      var l;
      switch ((l = o.mediaKeySessionContext) == null ? void 0 : l.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return o.keyLoadPromise.then(
            (c) => (
              (i.key = c.keyInfo.decryptdata.key), { frag: e, keyInfo: o }
            )
          );
      }
    }
    switch (
      ((o = this.keyUriToKeyInfo[a] =
        {
          decryptdata: i,
          keyLoadPromise: null,
          loader: null,
          mediaKeySessionContext: null,
        }),
      i.method)
    ) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return i.keyFormat === "identity"
          ? this.loadKeyHTTP(o, e)
          : this.loadKeyEME(o, e);
      case "AES-128":
      case "AES-256":
      case "AES-256-CTR":
        return this.loadKeyHTTP(o, e);
      default:
        return Promise.reject(
          this.createKeyLoadError(
            e,
            we.KEY_LOAD_ERROR,
            new Error(`Key supplied with unsupported METHOD: "${i.method}"`)
          )
        );
    }
  }
  loadKeyEME(e, t) {
    const s = { frag: t, keyInfo: e };
    if (this.emeController && this.config.emeEnabled) {
      const r = this.emeController.loadKey(s);
      if (r)
        return (e.keyLoadPromise = r.then(
          (i) => ((e.mediaKeySessionContext = i), s)
        )).catch((i) => {
          throw ((e.keyLoadPromise = null), i);
        });
    }
    return Promise.resolve(s);
  }
  loadKeyHTTP(e, t) {
    const s = this.config,
      r = s.loader,
      i = new r(s);
    return (
      (t.keyLoader = e.loader = i),
      (e.keyLoadPromise = new Promise((a, o) => {
        const l = {
            keyInfo: e,
            frag: t,
            responseType: "arraybuffer",
            url: e.decryptdata.uri,
          },
          c = s.keyLoadPolicy.default,
          h = {
            loadPolicy: c,
            timeout: c.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0,
          },
          m = {
            onSuccess: (p, g, y, b) => {
              const { frag: w, keyInfo: S, url: A } = y;
              if (!w.decryptdata || S !== this.keyUriToKeyInfo[A])
                return o(
                  this.createKeyLoadError(
                    w,
                    we.KEY_LOAD_ERROR,
                    new Error("after key load, decryptdata unset or changed"),
                    b
                  )
                );
              (S.decryptdata.key = w.decryptdata.key = new Uint8Array(p.data)),
                (w.keyLoader = null),
                (S.loader = null),
                a({ frag: w, keyInfo: S });
            },
            onError: (p, g, y, b) => {
              this.resetLoader(g),
                o(
                  this.createKeyLoadError(
                    t,
                    we.KEY_LOAD_ERROR,
                    new Error(`HTTP Error ${p.code} loading key ${p.text}`),
                    y,
                    In({ url: l.url, data: void 0 }, p)
                  )
                );
            },
            onTimeout: (p, g, y) => {
              this.resetLoader(g),
                o(
                  this.createKeyLoadError(
                    t,
                    we.KEY_LOAD_TIMEOUT,
                    new Error("key loading timed out"),
                    y
                  )
                );
            },
            onAbort: (p, g, y) => {
              this.resetLoader(g),
                o(
                  this.createKeyLoadError(
                    t,
                    we.INTERNAL_ABORTED,
                    new Error("key loading aborted"),
                    y
                  )
                );
            },
          };
        i.load(l, h, m);
      }))
    );
  }
  resetLoader(e) {
    const { frag: t, keyInfo: s, url: r } = e,
      i = s.loader;
    t.keyLoader === i && ((t.keyLoader = null), (s.loader = null)),
      delete this.keyUriToKeyInfo[r],
      i && i.destroy();
  }
}
function C5(n) {
  const { type: e } = n;
  switch (e) {
    case en.AUDIO_TRACK:
      return lt.AUDIO;
    case en.SUBTITLE_TRACK:
      return lt.SUBTITLE;
    default:
      return lt.MAIN;
  }
}
function MA(n, e) {
  let t = n.url;
  return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t;
}
class PLe {
  constructor(e) {
    (this.hls = void 0),
      (this.loaders = Object.create(null)),
      (this.variableList = null),
      (this.onManifestLoaded = this.checkAutostartLoad),
      (this.hls = e),
      this.registerListeners();
  }
  startLoad(e) {}
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const { hls: e } = this;
    e.on($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on($.LEVEL_LOADING, this.onLevelLoading, this),
      e.on($.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.on($.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
      e.on($.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  unregisterListeners() {
    const { hls: e } = this;
    e.off($.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off($.LEVEL_LOADING, this.onLevelLoading, this),
      e.off($.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.off($.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
      e.off($.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  createInternalLoader(e) {
    const t = this.hls.config,
      s = t.pLoader,
      r = t.loader,
      i = s || r,
      a = new i(t);
    return (this.loaders[e.type] = a), a;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e];
      t && t.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    (this.variableList = null),
      this.unregisterListeners(),
      this.destroyInternalLoaders();
  }
  onManifestLoading(e, t) {
    const { url: s } = t;
    (this.variableList = null),
      this.load({
        id: null,
        level: 0,
        responseType: "text",
        type: en.MANIFEST,
        url: s,
        deliveryDirectives: null,
        levelOrTrack: null,
      });
  }
  onLevelLoading(e, t) {
    const {
      id: s,
      level: r,
      pathwayId: i,
      url: a,
      deliveryDirectives: o,
      levelInfo: l,
    } = t;
    this.load({
      id: s,
      level: r,
      pathwayId: i,
      responseType: "text",
      type: en.LEVEL,
      url: a,
      deliveryDirectives: o,
      levelOrTrack: l,
    });
  }
  onAudioTrackLoading(e, t) {
    const { id: s, groupId: r, url: i, deliveryDirectives: a, track: o } = t;
    this.load({
      id: s,
      groupId: r,
      level: null,
      responseType: "text",
      type: en.AUDIO_TRACK,
      url: i,
      deliveryDirectives: a,
      levelOrTrack: o,
    });
  }
  onSubtitleTrackLoading(e, t) {
    const { id: s, groupId: r, url: i, deliveryDirectives: a, track: o } = t;
    this.load({
      id: s,
      groupId: r,
      level: null,
      responseType: "text",
      type: en.SUBTITLE_TRACK,
      url: i,
      deliveryDirectives: a,
      levelOrTrack: o,
    });
  }
  onLevelsUpdated(e, t) {
    const s = this.loaders[en.LEVEL];
    if (s) {
      const r = s.context;
      r &&
        !t.levels.some((i) => i === r.levelOrTrack) &&
        (s.abort(), delete this.loaders[en.LEVEL]);
    }
  }
  load(e) {
    var t;
    const s = this.hls.config;
    let r = this.getInternalLoader(e);
    if (r) {
      const c = this.hls.logger,
        h = r.context;
      if (
        h &&
        h.levelOrTrack === e.levelOrTrack &&
        (h.url === e.url || (h.deliveryDirectives && !e.deliveryDirectives))
      ) {
        h.url === e.url
          ? c.log(`[playlist-loader]: ignore ${e.url} ongoing request`)
          : c.log(`[playlist-loader]: ignore ${e.url} in favor of ${h.url}`);
        return;
      }
      c.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`),
        r.abort();
    }
    let i;
    if (
      (e.type === en.MANIFEST
        ? (i = s.manifestLoadPolicy.default)
        : (i = Tn({}, s.playlistLoadPolicy.default, {
            timeoutRetry: null,
            errorRetry: null,
          })),
      (r = this.createInternalLoader(e)),
      Qe((t = e.deliveryDirectives) == null ? void 0 : t.part))
    ) {
      let c;
      if (
        (e.type === en.LEVEL && e.level !== null
          ? (c = this.hls.levels[e.level].details)
          : e.type === en.AUDIO_TRACK && e.id !== null
          ? (c = this.hls.audioTracks[e.id].details)
          : e.type === en.SUBTITLE_TRACK &&
            e.id !== null &&
            (c = this.hls.subtitleTracks[e.id].details),
        c)
      ) {
        const h = c.partTarget,
          m = c.targetduration;
        if (h && m) {
          const p = Math.max(h * 3, m * 0.8) * 1e3;
          i = Tn({}, i, {
            maxTimeToFirstByteMs: Math.min(p, i.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(p, i.maxTimeToFirstByteMs),
          });
        }
      }
    }
    const a = i.errorRetry || i.timeoutRetry || {},
      o = {
        loadPolicy: i,
        timeout: i.maxLoadTimeMs,
        maxRetry: a.maxNumRetry || 0,
        retryDelay: a.retryDelayMs || 0,
        maxRetryDelay: a.maxRetryDelayMs || 0,
      },
      l = {
        onSuccess: (c, h, m, p) => {
          const g = this.getInternalLoader(m);
          this.resetInternalLoader(m.type);
          const y = c.data;
          if (y.indexOf("#EXTM3U") !== 0) {
            this.handleManifestParsingError(
              c,
              m,
              new Error("no EXTM3U delimiter"),
              p || null,
              h
            );
            return;
          }
          (h.parsing.start = performance.now()),
            _o.isMediaPlaylist(y) || m.type !== en.MANIFEST
              ? this.handleTrackOrLevelPlaylist(c, h, m, p || null, g)
              : this.handleMasterPlaylist(c, h, m, p);
        },
        onError: (c, h, m, p) => {
          this.handleNetworkError(h, m, !1, c, p);
        },
        onTimeout: (c, h, m) => {
          this.handleNetworkError(h, m, !0, void 0, c);
        },
      };
    r.load(e, o, l);
  }
  checkAutostartLoad() {
    if (!this.hls) return;
    const {
      config: { autoStartLoad: e, startPosition: t },
      forceStartLoad: s,
    } = this.hls;
    (e || s) &&
      (this.hls.logger.log(
        `${e ? "auto" : "force"} startLoad with configured startPosition ${t}`
      ),
      this.hls.startLoad(t));
  }
  handleMasterPlaylist(e, t, s, r) {
    const i = this.hls,
      a = e.data,
      o = MA(e, s),
      l = _o.parseMasterPlaylist(a, o);
    if (l.playlistParsingError) {
      this.handleManifestParsingError(e, s, l.playlistParsingError, r, t);
      return;
    }
    const {
      contentSteering: c,
      levels: h,
      sessionData: m,
      sessionKeys: p,
      startTimeOffset: g,
      variableList: y,
    } = l;
    this.variableList = y;
    const {
      AUDIO: b = [],
      SUBTITLES: w,
      "CLOSED-CAPTIONS": S,
    } = _o.parseMasterPlaylistMedia(a, o, l);
    b.length &&
      !b.some((_) => !_.url) &&
      h[0].audioCodec &&
      !h[0].attrs.AUDIO &&
      (this.hls.logger.log(
        "[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"
      ),
      b.unshift({
        type: "main",
        name: "main",
        groupId: "main",
        default: !1,
        autoselect: !1,
        forced: !1,
        id: -1,
        attrs: new rs({}),
        bitrate: 0,
        url: "",
      })),
      i.trigger($.MANIFEST_LOADED, {
        levels: h,
        audioTracks: b,
        subtitles: w,
        captions: S,
        contentSteering: c,
        url: o,
        stats: t,
        networkDetails: r,
        sessionData: m,
        sessionKeys: p,
        startTimeOffset: g,
        variableList: y,
      });
  }
  handleTrackOrLevelPlaylist(e, t, s, r, i) {
    const a = this.hls,
      { id: o, level: l, type: c } = s,
      h = MA(e, s),
      m = Qe(l) ? l : Qe(o) ? o : 0,
      p = C5(s),
      g = _o.parseLevelPlaylist(e.data, h, m, p, 0, this.variableList);
    if (c === en.MANIFEST) {
      const y = { attrs: new rs({}), bitrate: 0, details: g, name: "", url: h };
      (g.requestScheduled = t.loading.start + IY(g, 0)),
        a.trigger($.MANIFEST_LOADED, {
          levels: [y],
          audioTracks: [],
          url: h,
          stats: t,
          networkDetails: r,
          sessionData: null,
          sessionKeys: null,
          contentSteering: null,
          startTimeOffset: null,
          variableList: null,
        });
    }
    (t.parsing.end = performance.now()),
      (s.levelDetails = g),
      this.handlePlaylistLoaded(g, e, t, s, r, i);
  }
  handleManifestParsingError(e, t, s, r, i) {
    this.hls.trigger($.ERROR, {
      type: gt.NETWORK_ERROR,
      details: we.MANIFEST_PARSING_ERROR,
      fatal: t.type === en.MANIFEST,
      url: e.url,
      err: s,
      error: s,
      reason: s.message,
      response: e,
      context: t,
      networkDetails: r,
      stats: i,
    });
  }
  handleNetworkError(e, t, s = !1, r, i) {
    let a = `A network ${
      s ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")
    } occurred while loading ${e.type}`;
    e.type === en.LEVEL
      ? (a += `: ${e.level} id: ${e.id}`)
      : (e.type === en.AUDIO_TRACK || e.type === en.SUBTITLE_TRACK) &&
        (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(a);
    this.hls.logger.warn(`[playlist-loader]: ${a}`);
    let l = we.UNKNOWN,
      c = !1;
    const h = this.getInternalLoader(e);
    switch (e.type) {
      case en.MANIFEST:
        (l = s ? we.MANIFEST_LOAD_TIMEOUT : we.MANIFEST_LOAD_ERROR), (c = !0);
        break;
      case en.LEVEL:
        (l = s ? we.LEVEL_LOAD_TIMEOUT : we.LEVEL_LOAD_ERROR), (c = !1);
        break;
      case en.AUDIO_TRACK:
        (l = s ? we.AUDIO_TRACK_LOAD_TIMEOUT : we.AUDIO_TRACK_LOAD_ERROR),
          (c = !1);
        break;
      case en.SUBTITLE_TRACK:
        (l = s ? we.SUBTITLE_TRACK_LOAD_TIMEOUT : we.SUBTITLE_LOAD_ERROR),
          (c = !1);
        break;
    }
    h && this.resetInternalLoader(e.type);
    const m = {
      type: gt.NETWORK_ERROR,
      details: l,
      fatal: c,
      url: e.url,
      loader: h,
      context: e,
      error: o,
      networkDetails: t,
      stats: i,
    };
    if (r) {
      const p = t?.url || e.url;
      m.response = In({ url: p, data: void 0 }, r);
    }
    this.hls.trigger($.ERROR, m);
  }
  handlePlaylistLoaded(e, t, s, r, i, a) {
    const o = this.hls,
      { type: l, level: c, id: h, groupId: m, deliveryDirectives: p } = r,
      g = MA(t, r),
      y = C5(r),
      b = typeof r.level == "number" && y === lt.MAIN ? c : void 0;
    if (!e.fragments.length) {
      const S = (e.playlistParsingError = new Error(
        "No Segments found in Playlist"
      ));
      o.trigger($.ERROR, {
        type: gt.NETWORK_ERROR,
        details: we.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: g,
        error: S,
        reason: S.message,
        response: t,
        context: r,
        level: b,
        parent: y,
        networkDetails: i,
        stats: s,
      });
      return;
    }
    e.targetduration ||
      (e.playlistParsingError = new Error("Missing Target Duration"));
    const w = e.playlistParsingError;
    if (w) {
      if ((this.hls.logger.warn(w), !o.config.ignorePlaylistParsingErrors)) {
        o.trigger($.ERROR, {
          type: gt.NETWORK_ERROR,
          details: we.LEVEL_PARSING_ERROR,
          fatal: !1,
          url: g,
          error: w,
          reason: w.message,
          response: t,
          context: r,
          level: b,
          parent: y,
          networkDetails: i,
          stats: s,
        });
        return;
      }
      e.playlistParsingError = null;
    }
    switch (
      (e.live &&
        a &&
        (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0),
        (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)),
      l)
    ) {
      case en.MANIFEST:
      case en.LEVEL:
        o.trigger($.LEVEL_LOADED, {
          details: e,
          levelInfo: r.levelOrTrack || o.levels[0],
          level: b || 0,
          id: h || 0,
          stats: s,
          networkDetails: i,
          deliveryDirectives: p,
          withoutMultiVariant: l === en.MANIFEST,
        });
        break;
      case en.AUDIO_TRACK:
        o.trigger($.AUDIO_TRACK_LOADED, {
          details: e,
          track: r.levelOrTrack,
          id: h || 0,
          groupId: m || "",
          stats: s,
          networkDetails: i,
          deliveryDirectives: p,
        });
        break;
      case en.SUBTITLE_TRACK:
        o.trigger($.SUBTITLE_TRACK_LOADED, {
          details: e,
          track: r.levelOrTrack,
          id: h || 0,
          groupId: m || "",
          stats: s,
          networkDetails: i,
          deliveryDirectives: p,
        });
        break;
    }
  }
}
class ei {
  static get version() {
    return pv;
  }
  static isMSESupported() {
    return TX();
  }
  static isSupported() {
    return kLe();
  }
  static getMediaSource() {
    return Bc();
  }
  static get Events() {
    return $;
  }
  static get MetadataSchema() {
    return Si;
  }
  static get ErrorTypes() {
    return gt;
  }
  static get ErrorDetails() {
    return we;
  }
  static get DefaultConfig() {
    return ei.defaultConfig ? ei.defaultConfig : gLe;
  }
  static set DefaultConfig(e) {
    ei.defaultConfig = e;
  }
  constructor(e = {}) {
    (this.config = void 0),
      (this.userConfig = void 0),
      (this.logger = void 0),
      (this.coreComponents = void 0),
      (this.networkControllers = void 0),
      (this._emitter = new ZP()),
      (this._autoLevelCapping = -1),
      (this._maxHdcpLevel = null),
      (this.abrController = void 0),
      (this.bufferController = void 0),
      (this.capLevelController = void 0),
      (this.latencyController = void 0),
      (this.levelController = void 0),
      (this.streamController = void 0),
      (this.audioStreamController = void 0),
      (this.subtititleStreamController = void 0),
      (this.audioTrackController = void 0),
      (this.subtitleTrackController = void 0),
      (this.interstitialsController = void 0),
      (this.gapController = void 0),
      (this.emeController = void 0),
      (this.cmcdController = void 0),
      (this._media = null),
      (this._url = null),
      (this._sessionId = void 0),
      (this.triggeringException = void 0),
      (this.started = !1);
    const t = (this.logger = JAe(
        e.debug || !1,
        "Hls instance",
        e.assetPlayerId
      )),
      s = (this.config = yLe(ei.DefaultConfig, e, t));
    (this.userConfig = e), s.progressive && bLe(s, t);
    const {
        abrController: r,
        bufferController: i,
        capLevelController: a,
        errorController: o,
        fpsController: l,
      } = s,
      c = new o(this),
      h = (this.abrController = new r(this)),
      m = new zRe(this),
      p = s.interstitialsController,
      g = p ? (this.interstitialsController = new p(this, ei)) : null,
      y = (this.bufferController = new i(this, m)),
      b = (this.capLevelController = new a(this)),
      w = new l(this),
      S = new PLe(this),
      A = s.contentSteeringController,
      _ = A ? new A(this) : null,
      R = (this.levelController = new RLe(this, _)),
      C = new _Le(this),
      D = new DLe(this.config),
      L = (this.streamController = new LLe(this, m, D)),
      P = (this.gapController = new SLe(this, m));
    b.setStreamController(L), w.setStreamController(L);
    const V = [S, R, L];
    g && V.splice(1, 0, g),
      _ && V.splice(1, 0, _),
      (this.networkControllers = V);
    const N = [h, y, P, b, w, C, m];
    this.audioTrackController = this.createController(
      s.audioTrackController,
      V
    );
    const W = s.audioStreamController;
    W && V.push((this.audioStreamController = new W(this, m, D))),
      (this.subtitleTrackController = this.createController(
        s.subtitleTrackController,
        V
      ));
    const H = s.subtitleStreamController;
    H && V.push((this.subtititleStreamController = new H(this, m, D))),
      this.createController(s.timelineController, N),
      (D.emeController = this.emeController =
        this.createController(s.emeController, N)),
      (this.cmcdController = this.createController(s.cmcdController, N)),
      (this.latencyController = this.createController(ALe, N)),
      (this.coreComponents = N),
      V.push(c);
    const z = c.onErrorOut;
    typeof z == "function" && this.on($.ERROR, z, c),
      this.on($.MANIFEST_LOADED, S.onManifestLoaded, S);
  }
  createController(e, t) {
    if (e) {
      const s = new e(this);
      return t && t.push(s), s;
    }
    return null;
  }
  on(e, t, s = this) {
    this._emitter.on(e, t, s);
  }
  once(e, t, s = this) {
    this._emitter.once(e, t, s);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, t, s = this, r) {
    this._emitter.off(e, t, s, r);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, t, s) {
    return this._emitter.emit(e, t, s);
  }
  trigger(e, t) {
    if (this.config.debug) return this.emit(e, e, t);
    try {
      return this.emit(e, e, t);
    } catch (s) {
      if (
        (this.logger.error(
          "An internal error happened while handling event " +
            e +
            '. Error message: "' +
            s.message +
            '". Here is a stacktrace:',
          s
        ),
        !this.triggeringException)
      ) {
        this.triggeringException = !0;
        const r = e === $.ERROR;
        this.trigger($.ERROR, {
          type: gt.OTHER_ERROR,
          details: we.INTERNAL_EXCEPTION,
          fatal: r,
          event: e,
          error: s,
        }),
          (this.triggeringException = !1);
      }
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  destroy() {
    this.logger.log("destroy"),
      this.trigger($.DESTROYING, void 0),
      this.detachMedia(),
      this.removeAllListeners(),
      (this._autoLevelCapping = -1),
      (this._url = null),
      this.networkControllers.forEach((t) => t.destroy()),
      (this.networkControllers.length = 0),
      this.coreComponents.forEach((t) => t.destroy()),
      (this.coreComponents.length = 0);
    const e = this.config;
    (e.xhrSetup = e.fetchSetup = void 0), (this.userConfig = null);
  }
  attachMedia(e) {
    if (!e || ("media" in e && !e.media)) {
      const i = new Error(`attachMedia failed: invalid argument (${e})`);
      this.trigger($.ERROR, {
        type: gt.OTHER_ERROR,
        details: we.ATTACH_MEDIA_ERROR,
        fatal: !0,
        error: i,
      });
      return;
    }
    this.logger.log("attachMedia"),
      this._media &&
        (this.logger.warn("media must be detached before attaching"),
        this.detachMedia());
    const t = "media" in e,
      s = t ? e.media : e,
      r = t ? e : { media: s };
    (this._media = s), this.trigger($.MEDIA_ATTACHING, r);
  }
  detachMedia() {
    this.logger.log("detachMedia"),
      this.trigger($.MEDIA_DETACHING, {}),
      (this._media = null);
  }
  transferMedia() {
    this._media = null;
    const e = this.bufferController.transferMedia();
    return this.trigger($.MEDIA_DETACHING, { transferMedia: e }), e;
  }
  loadSource(e) {
    this.stopLoad();
    const t = this.media,
      s = this._url,
      r = (this._url = HP.buildAbsoluteURL(self.location.href, e, {
        alwaysNormalize: !0,
      }));
    (this._autoLevelCapping = -1),
      (this._maxHdcpLevel = null),
      this.logger.log(`loadSource:${r}`),
      t &&
        s &&
        (s !== r || this.bufferController.hasSourceTypes()) &&
        (this.detachMedia(), this.attachMedia(t)),
      this.trigger($.MANIFEST_LOADING, { url: e });
  }
  get url() {
    return this._url;
  }
  get hasEnoughToStart() {
    return this.streamController.hasEnoughToStart;
  }
  get startPosition() {
    return this.streamController.startPositionValue;
  }
  startLoad(e = -1, t) {
    this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`),
      (this.started = !0),
      this.resumeBuffering();
    for (
      let s = 0;
      s < this.networkControllers.length &&
      (this.networkControllers[s].startLoad(e, t),
      !(!this.started || !this.networkControllers));
      s++
    );
  }
  stopLoad() {
    this.logger.log("stopLoad"), (this.started = !1);
    for (
      let e = 0;
      e < this.networkControllers.length &&
      (this.networkControllers[e].stopLoad(),
      !(this.started || !this.networkControllers));
      e++
    );
  }
  get loadingEnabled() {
    return this.started;
  }
  get bufferingEnabled() {
    return this.streamController.bufferingEnabled;
  }
  resumeBuffering() {
    this.bufferingEnabled ||
      (this.logger.log("resume buffering"),
      this.networkControllers.forEach((e) => {
        e.resumeBuffering && e.resumeBuffering();
      }));
  }
  pauseBuffering() {
    this.bufferingEnabled &&
      (this.logger.log("pause buffering"),
      this.networkControllers.forEach((e) => {
        e.pauseBuffering && e.pauseBuffering();
      }));
  }
  get inFlightFragments() {
    const e = { [lt.MAIN]: this.streamController.inFlightFrag };
    return (
      this.audioStreamController &&
        (e[lt.AUDIO] = this.audioStreamController.inFlightFrag),
      this.subtititleStreamController &&
        (e[lt.SUBTITLE] = this.subtititleStreamController.inFlightFrag),
      e
    );
  }
  swapAudioCodec() {
    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  recoverMediaError() {
    this.logger.log("recoverMediaError");
    const e = this._media,
      t = e?.currentTime;
    this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t));
  }
  removeLevel(e) {
    this.levelController.removeLevel(e);
  }
  get sessionId() {
    let e = this._sessionId;
    return e || (e = this._sessionId = SIe()), e;
  }
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  get latestLevelDetails() {
    return this.streamController.getLevelDetails() || null;
  }
  get loadLevelObj() {
    return this.levelController.loadLevelObj;
  }
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  set currentLevel(e) {
    this.logger.log(`set currentLevel:${e}`),
      (this.levelController.manualLevel = e),
      this.streamController.immediateLevelSwitch();
  }
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  set nextLevel(e) {
    this.logger.log(`set nextLevel:${e}`),
      (this.levelController.manualLevel = e),
      this.streamController.nextLevelSwitch();
  }
  get loadLevel() {
    return this.levelController.level;
  }
  set loadLevel(e) {
    this.logger.log(`set loadLevel:${e}`),
      (this.levelController.manualLevel = e);
  }
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  set firstLevel(e) {
    this.logger.log(`set firstLevel:${e}`),
      (this.levelController.firstLevel = e);
  }
  get startLevel() {
    const e = this.levelController.startLevel;
    return e === -1 && this.abrController.forcedAutoLevel > -1
      ? this.abrController.forcedAutoLevel
      : e;
  }
  set startLevel(e) {
    this.logger.log(`set startLevel:${e}`),
      e !== -1 && (e = Math.max(e, this.minAutoLevel)),
      (this.levelController.startLevel = e);
  }
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  set capLevelToPlayerSize(e) {
    const t = !!e;
    t !== this.config.capLevelToPlayerSize &&
      (t
        ? this.capLevelController.startCapping()
        : (this.capLevelController.stopCapping(),
          (this.autoLevelCapping = -1),
          this.streamController.nextLevelSwitch()),
      (this.config.capLevelToPlayerSize = t));
  }
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  get bandwidthEstimate() {
    const { bwEstimator: e } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  set bandwidthEstimate(e) {
    this.abrController.resetEstimator(e);
  }
  get abrEwmaDefaultEstimate() {
    const { bwEstimator: e } = this.abrController;
    return e ? e.defaultEstimate : NaN;
  }
  get ttfbEstimate() {
    const { bwEstimator: e } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e &&
      (this.logger.log(`set autoLevelCapping:${e}`),
      (this._autoLevelCapping = e),
      this.levelController.checkMaxAutoUpdated());
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    kRe(e) &&
      this._maxHdcpLevel !== e &&
      ((this._maxHdcpLevel = e), this.levelController.checkMaxAutoUpdated());
  }
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  get minAutoLevel() {
    const {
      levels: e,
      config: { minAutoBitrate: t },
    } = this;
    if (!e) return 0;
    const s = e.length;
    for (let r = 0; r < s; r++) if (e[r].maxBitrate >= t) return r;
    return 0;
  }
  get maxAutoLevel() {
    const { levels: e, autoLevelCapping: t, maxHdcpLevel: s } = this;
    let r;
    if ((t === -1 && e != null && e.length ? (r = e.length - 1) : (r = t), s))
      for (let i = r; i--; ) {
        const a = e[i].attrs["HDCP-LEVEL"];
        if (a && a <= s) return i;
      }
    return r;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = e;
  }
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  get maxBufferLength() {
    return this.streamController.maxBufferLength;
  }
  setAudioOption(e) {
    var t;
    return (
      ((t = this.audioTrackController) == null
        ? void 0
        : t.setAudioOption(e)) || null
    );
  }
  setSubtitleOption(e) {
    var t;
    return (
      ((t = this.subtitleTrackController) == null
        ? void 0
        : t.setSubtitleOption(e)) || null
    );
  }
  get allAudioTracks() {
    const e = this.audioTrackController;
    return e ? e.allAudioTracks : [];
  }
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  set audioTrack(e) {
    const t = this.audioTrackController;
    t && (t.audioTrack = e);
  }
  get allSubtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.allSubtitleTracks : [];
  }
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  set subtitleTrack(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleTrack = e);
  }
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleDisplay = e);
  }
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  get latency() {
    return this.latencyController.latency;
  }
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  set targetLatency(e) {
    this.latencyController.targetLatency = e;
  }
  get drift() {
    return this.latencyController.drift;
  }
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
  get pathways() {
    return this.levelController.pathways;
  }
  get pathwayPriority() {
    return this.levelController.pathwayPriority;
  }
  set pathwayPriority(e) {
    this.levelController.pathwayPriority = e;
  }
  get bufferedToEnd() {
    var e;
    return !!((e = this.bufferController) != null && e.bufferedToEnd);
  }
  get interstitialsManager() {
    var e;
    return (
      ((e = this.interstitialsController) == null
        ? void 0
        : e.interstitialsManager) || null
    );
  }
  getMediaDecodingInfo(e, t = this.allAudioTracks) {
    const s = bY(t);
    return vY(e, s, navigator.mediaCapabilities);
  }
}
ei.defaultConfig = void 0;
const MLe = (n) =>
    class extends n {
      static shadowRootOptions = { ...n.shadowRootOptions };
      static getTemplateHTML = (t, s = {}) => {
        const { src: r, ...i } = t;
        return `
        <script type="application/json" id="config">
          ${JSON.stringify(s.config || {})}
        <\/script>
        ${n.getTemplateHTML(i)}
      `;
      };
      #e = null;
      #t = null;
      constructor() {
        super(), this.#r("config");
      }
      get config() {
        return this.#t;
      }
      set config(t) {
        this.#t = t;
      }
      attributeChangedCallback(t, s, r) {
        t !== "src" && super.attributeChangedCallback(t, s, r),
          t === "src" && s != r && this.load();
      }
      #n() {
        var t, s;
        (t = this.#e) == null || t.remove(),
          (s = this.nativeEl) == null ||
            s.removeEventListener(
              "webkitcurrentplaybacktargetiswirelesschanged",
              this.#s
            ),
          this.api &&
            (this.api.detachMedia(), this.api.destroy(), (this.api = null));
      }
      async load() {
        var t, s;
        const r = !this.api;
        if ((this.#n(), !!this.src)) {
          if (
            (r &&
              !this.#t &&
              (this.#t = JSON.parse(
                ((t = this.shadowRoot.getElementById("config")) == null
                  ? void 0
                  : t.textContent) || "{}"
              )),
            ei.isSupported())
          ) {
            switch (
              ((this.api = new ei({
                liveDurationInfinity: !0,
                autoStartLoad: !1,
                ...this.config,
              })),
              await Promise.resolve(),
              this.api.loadSource(this.src),
              this.api.attachMedia(this.nativeEl),
              this.nativeEl.preload)
            ) {
              case "none": {
                const l = () => this.api.startLoad();
                this.nativeEl.addEventListener("play", l, { once: !0 }),
                  this.api.on(ei.Events.DESTROYING, () => {
                    this.nativeEl.removeEventListener("play", l);
                  });
                break;
              }
              case "metadata": {
                const l = this.api.config.maxBufferLength,
                  c = this.api.config.maxBufferSize;
                (this.api.config.maxBufferLength = 1),
                  (this.api.config.maxBufferSize = 1);
                const h = () => {
                  (this.api.config.maxBufferLength = l),
                    (this.api.config.maxBufferSize = c);
                };
                this.nativeEl.addEventListener("play", h, { once: !0 }),
                  this.api.on(ei.Events.DESTROYING, () => {
                    this.nativeEl.removeEventListener("play", h);
                  }),
                  this.api.startLoad();
                break;
              }
              default:
                this.api.startLoad();
            }
            this.nativeEl.webkitCurrentPlaybackTargetIsWireless &&
              this.api.stopLoad(),
              this.nativeEl.addEventListener(
                "webkitcurrentplaybacktargetiswirelesschanged",
                this.#s
              ),
              (this.#e = document.createElement("source")),
              this.#e.setAttribute("type", "application/x-mpegURL"),
              this.#e.setAttribute("src", this.src),
              (this.nativeEl.disableRemotePlayback = !1),
              this.nativeEl.append(this.#e);
            const i = new WeakMap();
            this.api.on(ei.Events.MANIFEST_PARSED, (l, c) => {
              this.nativeEl.autoplay &&
                this.nativeEl.paused &&
                this.nativeEl.play().catch((m) => {
                  console.warn("Autoplay failed:", m);
                }),
                o();
              let h = this.videoTracks.getTrackById("main");
              h ||
                ((h = this.addVideoTrack("main")),
                (h.id = "main"),
                (h.selected = !0));
              for (const [m, p] of c.levels.entries()) {
                const g = h.addRendition(
                  p.url[0],
                  p.width,
                  p.height,
                  p.videoCodec,
                  p.bitrate
                );
                i.set(p, `${m}`), (g.id = `${m}`);
              }
              for (let [m, p] of c.audioTracks.entries()) {
                const g = p.default ? "main" : "alternative",
                  y = this.addAudioTrack(g, p.name, p.lang);
                (y.id = `${m}`), p.default && (y.enabled = !0);
              }
            }),
              this.audioTracks.addEventListener("change", () => {
                var l;
                const c = +((l = [...this.audioTracks].find(
                    (m) => m.enabled
                  )) == null
                    ? void 0
                    : l.id),
                  h = this.api.audioTracks.map((m) => m.id);
                c != this.api.audioTrack &&
                  h.includes(c) &&
                  (this.api.audioTrack = c);
              }),
              this.api.on(ei.Events.LEVELS_UPDATED, (l, c) => {
                const h = this.videoTracks[this.videoTracks.selectedIndex ?? 0];
                if (!h) return;
                const m = c.levels.map((p) => i.get(p));
                for (const p of this.videoRenditions)
                  p.id && !m.includes(p.id) && h.removeRendition(p);
              });
            const a = (l) => {
              const c = l.target.selectedIndex;
              c != this.api.nextLevel && (this.api.nextLevel = c);
            };
            (s = this.videoRenditions) == null ||
              s.addEventListener("change", a);
            const o = () => {
              for (const l of this.videoTracks) this.removeVideoTrack(l);
              for (const l of this.audioTracks) this.removeAudioTrack(l);
            };
            this.api.once(ei.Events.DESTROYING, o);
            return;
          }
          await Promise.resolve(),
            this.nativeEl.canPlayType("application/vnd.apple.mpegurl") &&
              (this.nativeEl.src = this.src);
        }
      }
      #s = () => {
        var t, s, r;
        (t = this.nativeEl) != null && t.webkitCurrentPlaybackTargetIsWireless
          ? (s = this.api) == null || s.stopLoad()
          : (r = this.api) == null || r.startLoad();
      };
      #r(t) {
        if (Object.prototype.hasOwnProperty.call(this, t)) {
          const s = this[t];
          delete this[t], (this[t] = s);
        }
      }
    },
  NLe = MLe(HAe(IAe));
globalThis.customElements &&
  !globalThis.customElements.get("hls-video") &&
  globalThis.customElements.define("hls-video", NLe);
const OLe = () => {
  const n = E.useRef(null),
    e = E.useRef(null),
    [t, s] = E.useState(!0),
    [r, i] = E.useState(null),
    [a, o] = E.useState(0),
    [l, c] = E.useState(0),
    [h, m] = E.useState(!1),
    [p, g] = E.useState(null),
    y = Be((B) => B.activeRecordingId),
    b = Be((B) => B.activeRecordingUrl),
    w = Be((B) => B.isRecordingPlaying),
    S = Be((B) => B.recordingPlaybackRate),
    A = Be((B) => B.isRecordingFullscreen),
    _ = Be((B) => B.setIsRecordingPlaying),
    R = Be((B) => B.setRecordingLoading),
    C = Be((B) => B.setRecordingPlayerHovered),
    D = Be((B) => B.toggleRecordingPlayback),
    L = Be((B) => B.setRecordingPlaybackRate),
    P = Be((B) => B.setRecordingFullscreen);
  E.useEffect(() => {
    b && (o(0), c(0), s(!0), R?.(!0));
  }, [b, R]),
    E.useEffect(() => {
      const B = n.current;
      if (!B || !b) return;
      const q = () => {
          s(!1),
            R?.(!1),
            Be.getState().isRecordingFullscreen ||
              B.play().catch((Y) => {
                console.error("[SingleRecordingPlayer] Auto-play failed:", Y);
              });
        },
        O = () => {
          _(!0);
        },
        U = () => {
          _(!1);
        },
        j = (Y) => {
          console.error("[SingleRecordingPlayer] Video error:", Y, B.error),
            s(!1),
            R?.(!1);
        },
        Q = () => {
          o(B.currentTime),
            Be.getState().isRecordingFullscreen ||
              Be.getState().setRecordingCurrentTime(B.currentTime);
        },
        M = () => {
          B.duration, c(B.duration), (B.playbackRate = S);
        },
        I = () => {
          s(!0), R?.(!0);
        },
        F = () => {};
      return (
        B.addEventListener("loadstart", I),
        B.addEventListener("loadeddata", F),
        B.addEventListener("canplay", q),
        B.addEventListener("play", O),
        B.addEventListener("pause", U),
        B.addEventListener("error", j),
        B.addEventListener("timeupdate", Q),
        B.addEventListener("loadedmetadata", M),
        "src" in B && ((B.src = b), B.load()),
        () => {
          B.removeEventListener("loadstart", I),
            B.removeEventListener("loadeddata", F),
            B.removeEventListener("canplay", q),
            B.removeEventListener("play", O),
            B.removeEventListener("pause", U),
            B.removeEventListener("error", j),
            B.removeEventListener("timeupdate", Q),
            B.removeEventListener("loadedmetadata", M);
        }
      );
    }, [b, _, R, S]),
    E.useEffect(() => {
      n.current && (n.current.playbackRate = S);
    }, [S]);
  const V = E.useRef(A);
  if (
    (E.useEffect(() => {
      if (n.current) {
        if ((n.current.paused, A)) {
          n.current.paused || n.current.pause(), (V.current = !0);
          return;
        }
        if (V.current && !A) {
          const B = Be.getState().recordingSyncTime;
          B > 0 &&
            Math.abs(n.current.currentTime - B) > 0.5 &&
            (n.current.currentTime = B),
            (V.current = !1);
        }
        w && n.current.paused
          ? n.current.play().catch((B) => {
              console.error("[SingleRecordingPlayer] Play failed:", B);
            })
          : !w && !n.current.paused && n.current.pause();
      }
    }, [w, A]),
    E.useEffect(() => {
      if (!y || A) {
        g(null);
        return;
      }
      let B = null;
      const q = () => {
        const I = document.getElementById(`recording-player-${y}`);
        if (I) {
          const F = I.getBoundingClientRect();
          (!B ||
            Math.abs(F.top - B.top) > 0.5 ||
            Math.abs(F.left - B.left) > 0.5 ||
            Math.abs(F.width - B.width) > 0.5 ||
            Math.abs(F.height - B.height) > 0.5) &&
            ((B = F), g(F));
        } else (B = null), g(null);
      };
      q();
      const O = new MutationObserver(q);
      O.observe(document.body, {
        childList: !0,
        subtree: !0,
        attributes: !0,
        attributeFilter: ["style", "class"],
      }),
        window.addEventListener("scroll", q, !0),
        window.addEventListener("resize", q);
      let U,
        j = !0,
        Q = 0;
      const M = () => {
        q(), Q++, Q < 120 && j && (U = requestAnimationFrame(M));
      };
      return (
        (U = requestAnimationFrame(M)),
        () => {
          (j = !1),
            O.disconnect(),
            window.removeEventListener("scroll", q, !0),
            window.removeEventListener("resize", q),
            cancelAnimationFrame(U);
        }
      );
    }, [y, A]),
    !y || !b)
  )
    return null;
  const N = (B) => {
      if (!n.current || !l) return;
      const q = B.currentTarget.getBoundingClientRect(),
        U = (B.clientX - q.left) / q.width;
      n.current.currentTime = U * l;
    },
    W = (B) => {
      const q = B.currentTarget.getBoundingClientRect(),
        U = ((B.clientX - q.left) / q.width) * 100;
      i(U);
    },
    H = () => {
      i(null);
    },
    z = l > 0 ? (a / l) * 100 : 0;
  return u.jsxs("div", {
    ref: e,
    "data-element-child": "true",
    className: Le(
      "fixed rounded-2xl overflow-hidden pointer-events-auto",
      A || !p ? "invisible" : "visible",
      t ? "bg-transparent" : "bg-black"
    ),
    style: {
      top: p ? `${p.top}px` : 0,
      left: p ? `${p.left}px` : 0,
      width: p ? `${p.width}px` : 0,
      height: p ? `${p.height}px` : 0,
      zIndex: 50,
      transition: "opacity 0.2s",
    },
    onMouseEnter: () => {
      m(!0), C(!0);
    },
    onMouseLeave: () => {
      m(!1), C(!1);
    },
    children: [
      de.createElement("hls-video", {
        ref: n,
        className: Le(
          "w-full h-full",
          t ? "opacity-0" : "opacity-100",
          "transition-opacity duration-200"
        ),
        style: {
          pointerEvents: "auto",
          objectFit: "cover",
          backgroundColor: "transparent",
        },
        controls: !1,
        playsInline: !0,
        autoPlay: !1,
        muted: !1,
        onLoadStart: () => s(!0),
      }),
      t &&
        u.jsx("div", {
          className: "absolute inset-0 flex items-center justify-center",
          children: u.jsx("div", {
            className:
              "animate-spin rounded-full h-8 w-8 border-2 border-white border-t-transparent drop-shadow-lg",
          }),
        }),
      u.jsxs("div", {
        className: "absolute inset-0",
        style: { pointerEvents: "auto" },
        onClickCapture: (B) => {
          const q = B.target;
          q.tagName === "BUTTON" || q.closest("button") || N(B);
        },
        onMouseMove: W,
        onMouseLeave: H,
        children: [
          u.jsx("div", {
            className:
              "absolute top-0 bottom-0 w-0.5 bg-red-500 shadow-[8_8_8px_rgba(255,255,255,1)] pointer-events-none transition-all duration-100",
            style: { left: `${z}%` },
          }),
          r !== null &&
            u.jsx("div", {
              className: `absolute top-0 bottom-0 w-0.5 bg-white/50 pointer-events-none shadow-[0_0_8px_rgba(255,255,255,0.5)] transition-opacity duration-100 ${
                h ? "opacity-100" : "opacity-0"
              }`,
              style: { left: `${r}%` },
            }),
        ],
      }),
      h &&
        u.jsx("div", {
          className:
            "absolute bottom-1.5 left-1.5 right-1.5 z-[60] pointer-events-none",
          children: u.jsxs("div", {
            className:
              "flex items-center h-[36px] bg-element-background border-t border-white/40 rounded-full shadow-[0_2px_8px_rgba(0,0,0,0.5)] overflow-hidden pointer-events-auto",
            children: [
              u.jsx("button", {
                className:
                  "flex items-center justify-center h-full flex-1 hover:bg-border/30 transition-colors group border-r border-white/10",
                onClick: (B) => {
                  B.stopPropagation(), D();
                },
                onMouseDown: (B) => B.stopPropagation(),
                children: w
                  ? u.jsx("svg", {
                      className:
                        "w-3.5 h-3.5 text-text-secondary group-hover:text-text-primary transition-colors duration-100",
                      fill: "currentColor",
                      viewBox: "0 0 24 24",
                      children: u.jsx("path", {
                        d: "M6 4h4v16H6V4zm8 0h4v16h-4V4z",
                      }),
                    })
                  : u.jsx("svg", {
                      className:
                        "w-3.5 h-3.5 text-text-secondary group-hover:text-text-primary transition-colors duration-100",
                      fill: "currentColor",
                      viewBox: "0 0 24 24",
                      children: u.jsx("path", { d: "M8 5v14l11-7z" }),
                    }),
              }),
              u.jsx("button", {
                className:
                  "flex items-center justify-center h-full flex-1 hover:bg-border/30 transition-colors group border-r border-white/10",
                onClick: (B) => {
                  B.stopPropagation();
                  const q = [1, 1.5, 2],
                    O = q.indexOf(S),
                    U = q[(O + 1) % q.length];
                  L(U);
                },
                onMouseDown: (B) => B.stopPropagation(),
                children: u.jsxs("span", {
                  className:
                    "text-xs text-text-secondary group-hover:text-text-primary transition-colors duration-100 font-medium",
                  children: [S, "x"],
                }),
              }),
              u.jsx("button", {
                className:
                  "flex items-center justify-center h-full flex-1 hover:bg-border/30 transition-colors group border-r border-white/10",
                onClick: (B) => {
                  B.stopPropagation(), P(!0);
                },
                onMouseDown: (B) => B.stopPropagation(),
                children: u.jsx("svg", {
                  className:
                    "w-3.5 h-3.5 text-text-secondary group-hover:text-text-primary transition-colors duration-100",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  viewBox: "0 0 24 24",
                  children: u.jsx("path", {
                    d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3",
                  }),
                }),
              }),
              u.jsx("div", {
                className:
                  "flex items-center justify-center h-full flex-1 px-2.5 text-text-primary text-xs font-mono",
                children: jLe(a),
              }),
            ],
          }),
        }),
    ],
  });
};
function jLe(n) {
  if (!n || !isFinite(n)) return "0:00";
  const e = Math.floor(n / 60),
    t = Math.floor(n % 60);
  return `${e}:${t.toString().padStart(2, "0")}`;
}
const FLe = () => {
    const {
        permissions: n,
        requestPermissions: e,
        pendingRecordingType: t,
        setPendingRecordingType: s,
        closeSettingsPopover: r,
        isPermissionModalVisible: i,
        hasRequestedPermission: a,
        showPermissionModal: o,
        hidePermissionModal: l,
        setHasRequestedPermission: c,
        showPermissionConfirmation: h,
        setShowPermissionConfirmation: m,
      } = on(),
      p = hn((R) => R.user);
    E.useEffect(() => {
      (async () => {
        if (t) {
          if (!p) {
            s(null), l();
            return;
          }
          await on.getState().checkPermissions();
          const C = on.getState().permissions,
            D = t === "thoughts",
            L = C.microphone !== "granted",
            P = D && C.camera !== "granted";
          if (L || P) i || o();
          else {
            const V = new CustomEvent("startPendingRecording", {
              detail: { type: t },
            });
            window.dispatchEvent(V), s(null), l();
          }
        }
      })();
    }, [t, n, i, o, s, p, l]);
    const g = () => {
        l(), s(null), r(), c(!1);
      },
      y = () => {
        m(!0);
      },
      b = () => {
        m(!1), g();
      },
      w = () => {
        m(!1);
      },
      S = () =>
        t === "thoughts"
          ? "Flask needs to access camera and microphone to record your thoughts. Flask uses camera and mic only while recording."
          : "Flask needs to access your microphone to record your screen. Flask uses the mic only while recording.",
      A = () =>
        t === "thoughts"
          ? u.jsx(CH, { className: "w-16 h-16" })
          : u.jsx(xle, { className: "w-16 h-16" });
    if (h)
      return u.jsx(os, {
        open: h,
        onOpenChange: () => m(!1),
        children: u.jsxs(Jn, {
          className: "sm:max-w-[450px] border-border/50 z-[51]",
          overlayClassName:
            "fixed inset-0 z-50 bg-black/95 backdrop-blur-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
          children: [
            u.jsx(bs, {
              children: u.jsx(xs, {
                className: "text-xl",
                children: "You still haven't granted permissions",
              }),
            }),
            u.jsx("div", {
              className: "py-4",
              children: u.jsx("p", {
                className: "text-md text-white/70 leading-relaxed",
                children: "Are you sure you want to leave?",
              }),
            }),
            u.jsxs("div", {
              className: "flex gap-3 justify-end",
              children: [
                u.jsx(et, {
                  variant: "ghost",
                  className:
                    "rounded-full text-text-secondary hover:text-white",
                  onClick: b,
                  children: "Cancel",
                }),
                u.jsx(et, {
                  variant: "secondary",
                  className: "button-primary rounded-full",
                  onClick: w,
                  children: "Grant Permissions",
                }),
              ],
            }),
          ],
        }),
      });
    const _ = p && t && i;
    return u.jsxs(u.Fragment, {
      children: [
        u.jsx(os, {
          open: _,
          onOpenChange: y,
          children: u.jsxs(Jn, {
            className: "sm:max-w-[500px] border-border/50 relative !z-[100]",
            overlayClassName:
              "fixed inset-0 !z-[99] bg-black/95 backdrop-blur-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
            children: [
              u.jsx("div", {
                className:
                  "absolute -left-32 -top-32 w-48 h-48 pointer-events-none",
                children: u.jsx("img", {
                  src: "/svgs/arrow.svg",
                  alt: "",
                  className: "w-full h-full transform -rotate-90",
                }),
              }),
              u.jsx("div", {
                className:
                  "absolute -right-32 -top-32 w-48 h-48 pointer-events-none",
                children: u.jsx("img", {
                  src: "/svgs/arrow.svg",
                  alt: "",
                  className: "w-full h-full transform rotate-180 scale-x-[-1]",
                }),
              }),
              u.jsx("div", {
                className: "flex justify-center mb-6",
                children: u.jsx("div", {
                  className:
                    "bg-gradient-to-b from-text-primary to-text-primary/50 bg-clip-text text-transparent",
                  style: {
                    WebkitBackgroundClip: "text",
                    WebkitTextFillColor: "transparent",
                  },
                  children: A(),
                }),
              }),
              u.jsx(bs, {
                children: u.jsx(xs, {
                  className: "text-xl text-center",
                  children: "Allow permissions to continue",
                }),
              }),
              u.jsx("div", {
                className: "py-4",
                children: u.jsx("p", {
                  className:
                    "text-md text-white/70 leading-relaxed text-center",
                  children: S(),
                }),
              }),
            ],
          }),
        }),
        i &&
          u.jsx("div", {
            className: "fixed bottom-8 left-1/2 -translate-x-1/2 !z-[101]",
            children: u.jsx(et, {
              variant: "ghost",
              className:
                "rounded-full text-white/60 hover:text-white/80 underline",
              onClick: y,
              children: "Close",
            }),
          }),
      ],
    });
  },
  ULe = "https://www.youtube.com/embed",
  $Le = "https://www.youtube-nocookie.com/embed",
  BLe = "https://www.youtube.com/iframe_api",
  HLe = "YT",
  VLe = "onYouTubeIframeAPIReady",
  I5 =
    /(?:youtu\.be\/|youtube(?:-nocookie)?\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})/,
  zLe = /(?:youtu\.be\/|youtube(?:-nocookie)?\.com\/.*?[?&]list=)([\w_-]+)/;
function L5(n, e = {}) {
  const t = {
    src: _X(n, e),
    frameborder: 0,
    width: "100%",
    height: "100%",
    allow:
      "accelerometer; fullscreen; autoplay; encrypted-media; gyroscope; picture-in-picture",
  };
  return (
    e.config && (t["data-config"] = JSON.stringify(e.config)),
    `
    <style>
      :host {
        display: inline-block;
        line-height: 0;
        position: relative;
        min-width: 300px;
        min-height: 150px;
      }
      iframe {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
    <iframe${qLe(t)}></iframe>
  `
  );
}
function _X(n, e) {
  if (!n.src) return;
  const t = n.src.includes("-nocookie") ? $Le : ULe,
    s = {
      controls: n.controls === "" ? null : 0,
      autoplay: n.autoplay,
      loop: n.loop,
      mute: n.muted,
      playsinline: n.playsinline,
      preload: n.preload ?? "metadata",
      enablejsapi: 1,
      showinfo: 0,
      rel: 0,
      iv_load_policy: 3,
      modestbranding: 1,
      ...e.config,
    };
  if (I5.test(n.src)) {
    const o = n.src.match(I5),
      l = o && o[1];
    return `${t}/${l}?${D5(s)}`;
  }
  const r = n.src.match(zLe),
    a = { listType: "playlist", list: r && r[1], ...s };
  return `${t}?${D5(a)}`;
}
class GLe extends (globalThis.HTMLElement ?? class {}) {
  static getTemplateHTML = L5;
  static shadowRootOptions = { mode: "open" };
  static observedAttributes = [
    "autoplay",
    "controls",
    "crossorigin",
    "loop",
    "muted",
    "playsinline",
    "poster",
    "preload",
    "src",
  ];
  loadComplete = new jA();
  #e;
  #t;
  #n = 0;
  #s = !1;
  #r;
  isLoaded = !1;
  #o = null;
  #i = null;
  constructor() {
    super(), this.#a("config");
  }
  get config() {
    return this.#i;
  }
  set config(e) {
    this.#i = e;
  }
  async load() {
    if (this.#e) return;
    this.shadowRoot || this.attachShadow({ mode: "open" });
    const e = !this.#t;
    this.#t && ((this.loadComplete = new jA()), (this.isLoaded = !1)),
      (this.#t = !0),
      await (this.#e = Promise.resolve()),
      (this.#e = null),
      (this.#n = 0),
      this.dispatchEvent(new Event("emptied"));
    let t = this.api;
    if (((this.api = null), !this.src)) {
      t?.destroy();
      return;
    }
    this.dispatchEvent(new Event("loadstart"));
    let s = this.shadowRoot.querySelector("iframe"),
      r = KLe(this.attributes);
    e && s && (this.#i = JSON.parse(s.getAttribute("data-config") || "{}")),
      (!s?.src || s.src !== _X(r, this)) &&
        ((this.shadowRoot.innerHTML = L5(r, this)),
        (s = this.shadowRoot.querySelector("iframe")));
    const i = await YLe(BLe, HLe, VLe);
    this.api = new i.Player(s, {
      events: {
        onReady: () => {
          (this.#n = 1),
            this.dispatchEvent(new Event("loadedmetadata")),
            this.dispatchEvent(new Event("durationchange")),
            this.dispatchEvent(new Event("volumechange")),
            this.dispatchEvent(new Event("loadcomplete")),
            (this.isLoaded = !0),
            this.loadComplete.resolve();
        },
        onError: (h) => {
          console.error(h),
            (this.#o = {
              code: h.data,
              message: `YouTube iframe player error #${h.data}; visit https://developers.google.com/youtube/iframe_api_reference#onError for the full error message.`,
            }),
            this.dispatchEvent(new Event("error"));
        },
      },
    });
    let a = !1;
    this.api.addEventListener("onStateChange", (h) => {
      var m;
      const p = h.data;
      if (
        ((p === i.PlayerState.PLAYING || p === i.PlayerState.BUFFERING) &&
          (a || ((a = !0), this.dispatchEvent(new Event("play")))),
        p === i.PlayerState.PLAYING)
      )
        this.seeking &&
          ((this.#s = !1),
          (m = this.#r) == null || m.resolve(),
          this.dispatchEvent(new Event("seeked"))),
          (this.#n = 3),
          this.dispatchEvent(new Event("playing"));
      else if (p === i.PlayerState.PAUSED) {
        const g = Math.abs(this.currentTime - o);
        !this.seeking &&
          g > 0.1 &&
          ((this.#s = !0), this.dispatchEvent(new Event("seeking"))),
          (a = !1),
          this.dispatchEvent(new Event("pause"));
      }
      p === i.PlayerState.ENDED &&
        ((a = !1),
        this.dispatchEvent(new Event("pause")),
        this.dispatchEvent(new Event("ended")),
        this.loop && this.play());
    }),
      this.api.addEventListener("onPlaybackRateChange", () => {
        this.dispatchEvent(new Event("ratechange"));
      }),
      this.api.addEventListener("onVolumeChange", () => {
        this.dispatchEvent(new Event("volumechange"));
      }),
      this.api.addEventListener("onVideoProgress", () => {
        this.dispatchEvent(new Event("timeupdate"));
      }),
      await this.loadComplete;
    let o = 0;
    setInterval(() => {
      var h;
      const m = Math.abs(this.currentTime - o),
        p = this.buffered.end(this.buffered.length - 1);
      this.seeking && p > 0.1
        ? ((this.#s = !1),
          (h = this.#r) == null || h.resolve(),
          this.dispatchEvent(new Event("seeked")))
        : !this.seeking &&
          m > 0.1 &&
          ((this.#s = !0), this.dispatchEvent(new Event("seeking"))),
        (o = this.currentTime);
    }, 50);
    let l;
    const c = setInterval(() => {
      const h = this.buffered.end(this.buffered.length - 1);
      h >= this.duration && (clearInterval(c), (this.#n = 4)),
        l != h && ((l = h), this.dispatchEvent(new Event("progress")));
    }, 100);
  }
  async attributeChangedCallback(e, t, s) {
    if (t !== s)
      switch (e) {
        case "src":
        case "autoplay":
        case "controls":
        case "loop":
        case "playsinline":
          this.load();
      }
  }
  async play() {
    var e;
    return (
      (this.#r = null),
      await this.loadComplete,
      (e = this.api) == null || e.playVideo(),
      ZLe(this)
    );
  }
  async pause() {
    var e;
    return (
      await this.loadComplete, (e = this.api) == null ? void 0 : e.pauseVideo()
    );
  }
  get seeking() {
    return this.#s;
  }
  get readyState() {
    return this.#n;
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(e) {
    this.src != e && this.setAttribute("src", e);
  }
  get error() {
    return this.#o;
  }
  get paused() {
    var e, t;
    return this.isLoaded
      ? [-1, 0, 2, 5].includes(
          (t = (e = this.api) == null ? void 0 : e.getPlayerState) == null
            ? void 0
            : t.call(e)
        )
      : !this.autoplay;
  }
  get duration() {
    var e, t;
    return (
      ((t = (e = this.api) == null ? void 0 : e.getDuration) == null
        ? void 0
        : t.call(e)) ?? NaN
    );
  }
  get autoplay() {
    return this.hasAttribute("autoplay");
  }
  set autoplay(e) {
    this.autoplay != e && this.toggleAttribute("autoplay", !!e);
  }
  get buffered() {
    var e, t;
    if (!this.isLoaded) return FA();
    const s =
      ((e = this.api) == null ? void 0 : e.getVideoLoadedFraction()) *
      ((t = this.api) == null ? void 0 : t.getDuration());
    return s > 0 ? FA(0, s) : FA();
  }
  get controls() {
    return this.hasAttribute("controls");
  }
  set controls(e) {
    this.controls != e && this.toggleAttribute("controls", !!e);
  }
  get currentTime() {
    var e, t;
    return (
      ((t = (e = this.api) == null ? void 0 : e.getCurrentTime) == null
        ? void 0
        : t.call(e)) ?? 0
    );
  }
  set currentTime(e) {
    this.currentTime != e &&
      ((this.#r = new jA()),
      this.loadComplete.then(() => {
        var t, s;
        (t = this.api) == null || t.seekTo(e, !0),
          this.paused &&
            ((s = this.#r) == null ||
              s.then(() => {
                var r;
                this.#r && ((r = this.api) == null || r.pauseVideo());
              }));
      }));
  }
  set defaultMuted(e) {
    this.defaultMuted != e && this.toggleAttribute("muted", !!e);
  }
  get defaultMuted() {
    return this.hasAttribute("muted");
  }
  get loop() {
    return this.hasAttribute("loop");
  }
  set loop(e) {
    this.loop != e && this.toggleAttribute("loop", !!e);
  }
  set muted(e) {
    this.muted != e &&
      this.loadComplete.then(() => {
        var t, s;
        e
          ? (t = this.api) == null || t.mute()
          : (s = this.api) == null || s.unMute();
      });
  }
  get muted() {
    var e, t;
    return this.isLoaded
      ? (t = (e = this.api) == null ? void 0 : e.isMuted) == null
        ? void 0
        : t.call(e)
      : this.defaultMuted;
  }
  get playbackRate() {
    var e, t;
    return (
      ((t = (e = this.api) == null ? void 0 : e.getPlaybackRate) == null
        ? void 0
        : t.call(e)) ?? 1
    );
  }
  set playbackRate(e) {
    this.playbackRate != e &&
      this.loadComplete.then(() => {
        var t;
        (t = this.api) == null || t.setPlaybackRate(e);
      });
  }
  get playsInline() {
    return this.hasAttribute("playsinline");
  }
  set playsInline(e) {
    this.playsInline != e && this.toggleAttribute("playsinline", !!e);
  }
  get poster() {
    return this.getAttribute("poster");
  }
  set poster(e) {
    this.poster != e && this.setAttribute("poster", `${e}`);
  }
  set volume(e) {
    this.volume != e &&
      this.loadComplete.then(() => {
        var t;
        (t = this.api) == null || t.setVolume(e * 100);
      });
  }
  get volume() {
    var e;
    return this.isLoaded
      ? ((e = this.api) == null ? void 0 : e.getVolume()) / 100
      : 1;
  }
  #a(e) {
    if (Object.prototype.hasOwnProperty.call(this, e)) {
      const t = this[e];
      delete this[e], (this[e] = t);
    }
  }
}
function qLe(n) {
  let e = "";
  for (const t in n) {
    const s = n[t];
    s === "" ? (e += ` ${NA(t)}`) : (e += ` ${NA(t)}="${NA(`${s}`)}"`);
  }
  return e;
}
function NA(n) {
  return n
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;")
    .replace(/`/g, "&#x60;");
}
function D5(n) {
  return String(new URLSearchParams(WLe(n)));
}
function WLe(n) {
  let e = {};
  for (let t in n) {
    let s = n[t];
    s === !0 || s === ""
      ? (e[t] = 1)
      : s === !1
      ? (e[t] = 0)
      : s != null && (e[t] = s);
  }
  return e;
}
function KLe(n) {
  let e = {};
  for (let t of n) e[t.name] = t.value;
  return e;
}
const OA = {};
async function YLe(n, e, t) {
  return OA[n]
    ? OA[n]
    : self[e]
    ? (await XLe(0), self[e])
    : (OA[n] = new Promise(function (s, r) {
        const i = document.createElement("script");
        i.src = n;
        const a = () => s(self[e]);
        (self[t] = a),
          (i.onload = () => !t),
          (i.onerror = r),
          document.head.append(i);
      }));
}
const XLe = (n) => new Promise((e) => setTimeout(e, n));
function QLe(n) {
  return (...e) =>
    new Promise((t) => {
      n(...e, (...s) => {
        s.length > 1 ? t(s) : t(s[0]);
      });
    });
}
function ZLe(n) {
  return QLe((e, t) => {
    let s;
    n.addEventListener(
      e,
      (s = () => {
        n.removeEventListener(e, s), t();
      })
    );
  })("playing");
}
class jA extends Promise {
  constructor(e = () => {}) {
    let t, s;
    super((r, i) => {
      e(r, i), (t = r), (s = i);
    }),
      (this.resolve = t),
      (this.reject = s);
  }
}
function FA(n, e) {
  return Array.isArray(n)
    ? UA(n)
    : n == null || e == null || (n === 0 && e === 0)
    ? UA([[0, 0]])
    : UA([[n, e]]);
}
function UA(n) {
  return (
    Object.defineProperties(n, {
      start: { value: (e) => n[e][0] },
      end: { value: (e) => n[e][1] },
    }),
    n
  );
}
globalThis.customElements &&
  !globalThis.customElements.get("youtube-video") &&
  globalThis.customElements.define("youtube-video", GLe);
const P5 = ({
  youtubeUrl: n,
  nativeAsset: e,
  onReady: t,
  onPlay: s,
  onPause: r,
  onTimeUpdate: i,
  onDurationChange: a,
  playbackRate: o = 1,
  isMuted: l = !1,
  volume: c = 1,
  initialTime: h = 0,
}) => {
  const m = E.useRef(null),
    p = E.useRef(null),
    g = Sf(n || ""),
    y = Be((N) => N.isPreviewMode),
    b = Be((N) => N.previewTimestamp),
    w = Be((N) => N.togglePlayPause),
    S = Be((N) => N.isReady),
    A = Be((N) => N.isPlaying),
    [_, R] = E.useState(!1),
    C = E.useRef(null),
    D = E.useCallback(
      (N) => ({
        play: () => N.play(),
        pause: () => N.pause(),
        currentTime: (W) =>
          W !== void 0 ? ((N.currentTime = W), N) : N.currentTime,
        duration: () => N.duration || 0,
        playbackRate: (W) =>
          W !== void 0 ? ((N.playbackRate = W), N) : N.playbackRate,
        muted: (W) => (W !== void 0 ? ((N.muted = W), N) : N.muted),
        volume: (W) => (W !== void 0 ? ((N.volume = W), N) : N.volume),
        paused: () => N.paused,
        dispose: () => {},
        on: (W, H) => {
          N.addEventListener(W, H);
        },
        off: (W, H) => {
          N.removeEventListener(W, H);
        },
      }),
      []
    );
  E.useEffect(() => {
    if ((m.current, e?.hls_url, !m.current)) return;
    p.current && (p.current.remove(), (p.current = null)),
      (m.current.innerHTML = "");
    let N;
    if (e?.hls_url)
      (N = document.createElement("hls-video")),
        N.setAttribute("src", e.hls_url),
        N.setAttribute("crossorigin", "anonymous"),
        N.setAttribute("preload", "auto");
    else if (g)
      (N = document.createElement("youtube-video")),
        N.setAttribute("src", `https://www.youtube.com/watch?v=${g}`);
    else return;
    (N.slot = "media"),
      (N.style.width = "100%"),
      (N.style.height = "100%"),
      (N.style.objectFit = "cover");
    const W = document.createElement("media-controller");
    (W.style.width = "100%"),
      (W.style.height = "100%"),
      W.setAttribute("noautohide", ""),
      W.appendChild(N),
      m.current.appendChild(W),
      (p.current = N);
    let H = !1;
    const z = () => {
        if (H) return;
        H = !0;
        const J = D(N);
        t && t(J),
          h > 0 && N.duration > 0 && (N.currentTime = h),
          (N.muted = l),
          (N.volume = c),
          (N.playbackRate = o);
      },
      B = () => {
        s && s();
      },
      q = () => {
        r && r();
      },
      O = () => {
        i && N && i(N.currentTime);
      },
      U = () => {
        a && N && a(N.duration);
      },
      j = (J) => {
        const X = J.target.error;
        console.error("[MainAssetPlayer] Media element error:", {
          event: J,
          error: X,
          code: X?.code,
          message: X?.message,
        }),
          H || z();
      },
      Q = () => {
        Be.getState().handleWaiting();
      },
      M = () => {
        Be.getState().handleSeeking();
      },
      I = () => {
        Be.getState().handleSeeked();
      },
      F = () => {
        Be.getState().handleCanPlay();
      };
    N.addEventListener("loadedmetadata", z),
      N.addEventListener("loadeddata", z),
      N.addEventListener("canplay", z),
      N.addEventListener("loadstart", z),
      N.addEventListener("play", B),
      N.addEventListener("pause", q),
      N.addEventListener("timeupdate", O),
      N.addEventListener("durationchange", U),
      N.addEventListener("error", j),
      N.addEventListener("waiting", Q),
      N.addEventListener("seeking", M),
      N.addEventListener("seeked", I),
      N.addEventListener("canplay", F),
      N.readyState >= 3 && z();
    const Y = setTimeout(() => {
      H || z();
    }, 5e3);
    return () => {
      clearTimeout(Y),
        N.removeEventListener("loadedmetadata", z),
        N.removeEventListener("loadeddata", z),
        N.removeEventListener("canplay", z),
        N.removeEventListener("loadstart", z),
        N.removeEventListener("play", B),
        N.removeEventListener("pause", q),
        N.removeEventListener("timeupdate", O),
        N.removeEventListener("durationchange", U),
        N.removeEventListener("error", j),
        N.removeEventListener("waiting", Q),
        N.removeEventListener("seeking", M),
        N.removeEventListener("seeked", I),
        N.removeEventListener("canplay", F),
        p.current && (p.current.remove(), (p.current = null));
    };
  }, [n, g, e, t, s, r, i, a, h, D]),
    E.useEffect(() => {
      const N = p.current;
      N && N.playbackRate !== o && (N.playbackRate = o);
    }, [o]),
    E.useEffect(() => {
      const N = p.current;
      N && N.muted !== l && (N.muted = l);
    }, [l]),
    E.useEffect(() => {
      const N = p.current;
      N && N.volume !== c && (N.volume = c);
    }, [c]);
  const L = E.useCallback(
      (N) => {
        N.target.closest("[data-video-control]") || (!y && S && w());
      },
      [y, S, w]
    ),
    P = E.useCallback(() => {
      document.querySelector('[data-state="open"]') ||
        (C.current && (clearTimeout(C.current), (C.current = null)), R(!0));
    }, []),
    V = E.useCallback(() => {
      document.querySelector('[data-state="open"]') ||
        (C.current && clearTimeout(C.current),
        (C.current = setTimeout(() => {
          R(!1), (C.current = null);
        }, 100)));
    }, []);
  return (
    E.useEffect(
      () => () => {
        C.current && clearTimeout(C.current);
      },
      []
    ),
    !g && !e?.hls_url
      ? u.jsx("div", {
          className:
            "main-asset-placeholder bg-gray-800 w-full h-full rounded-md flex items-center justify-center text-white",
          children: "No Video",
        })
      : u.jsx("div", {
          className:
            "main-asset-player md:rounded-md overflow-hidden bg-black w-full h-full",
          onMouseEnter: P,
          onMouseLeave: V,
          onClick: L,
          children: u.jsxs("div", {
            className: "relative w-full h-full",
            children: [
              u.jsx("div", {
                ref: m,
                className:
                  "video-container w-full h-full [&>*]:w-full [&>*]:h-full [&>*]:object-contain",
              }),
              u.jsx("div", {
                className: `absolute inset-0 flex items-center justify-center z-20 ${
                  _ ? "opacity-100" : "opacity-0 pointer-events-none"
                }`,
                children: u.jsx("button", {
                  "data-video-control": "true",
                  className:
                    "flex items-center justify-center h-20 w-20 bg-text-primary/50 text-black rounded-full hover:bg-text-primary/60 backdrop-blur-sm shadow-md ",
                  onClick: w,
                  "aria-label": A ? "Pause" : "Play",
                  children: A
                    ? u.jsx(uL, { size: 20 })
                    : u.jsx(Pg, { size: 20 }),
                }),
              }),
              u.jsxs("div", {
                className: `absolute inset-0 pointer-events-none ${
                  y && b !== null
                    ? "opacity-100"
                    : "opacity-0 pointer-events-none"
                }`,
                style: { zIndex: 10 },
                children: [
                  u.jsx("div", {
                    className: "absolute inset-0",
                    style: {
                      background:
                        "linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 60%, transparent 100%)",
                    },
                  }),
                  y &&
                    b !== null &&
                    u.jsx("div", {
                      className:
                        "absolute bottom-4 left-1/2 transform -translate-x-1/2 mb-[10%]",
                      children: u.jsxs("div", {
                        className:
                          "text-text-primary shadow-xl text-shadow-md text-lg opacity-90 font-mono",
                        children: ["Previewing ", zg(b)],
                      }),
                    }),
                ],
              }),
            ],
          }),
        })
  );
};
var AX = ["PageUp", "PageDown"],
  RX = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"],
  kX = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"],
  },
  Jf = "Slider",
  [bI, JLe, eDe] = Tv(Jf),
  [CX, f2e] = Pr(Jf, [eDe]),
  [tDe, pS] = CX(Jf),
  IX = E.forwardRef((n, e) => {
    const {
        name: t,
        min: s = 0,
        max: r = 100,
        step: i = 1,
        orientation: a = "horizontal",
        disabled: o = !1,
        minStepsBetweenThumbs: l = 0,
        defaultValue: c = [s],
        value: h,
        onValueChange: m = () => {},
        onValueCommit: p = () => {},
        inverted: g = !1,
        form: y,
        ...b
      } = n,
      w = E.useRef(new Set()),
      S = E.useRef(0),
      _ = a === "horizontal" ? nDe : sDe,
      [R = [], C] = ci({
        prop: h,
        defaultProp: c,
        onChange: (W) => {
          [...w.current][S.current]?.focus(), m(W);
        },
      }),
      D = E.useRef(R);
    function L(W) {
      const H = lDe(R, W);
      N(W, H);
    }
    function P(W) {
      N(W, S.current);
    }
    function V() {
      const W = D.current[S.current];
      R[S.current] !== W && p(R);
    }
    function N(W, H, { commit: z } = { commit: !1 }) {
      const B = hDe(i),
        q = fDe(Math.round((W - s) / i) * i + s, B),
        O = Qx(q, [s, r]);
      C((U = []) => {
        const j = aDe(U, O, H);
        if (dDe(j, l * i)) {
          S.current = j.indexOf(O);
          const Q = String(j) !== String(U);
          return Q && z && p(j), Q ? j : U;
        } else return U;
      });
    }
    return u.jsx(tDe, {
      scope: n.__scopeSlider,
      name: t,
      disabled: o,
      min: s,
      max: r,
      valueIndexToChangeRef: S,
      thumbs: w.current,
      values: R,
      orientation: a,
      form: y,
      children: u.jsx(bI.Provider, {
        scope: n.__scopeSlider,
        children: u.jsx(bI.Slot, {
          scope: n.__scopeSlider,
          children: u.jsx(_, {
            "aria-disabled": o,
            "data-disabled": o ? "" : void 0,
            ...b,
            ref: e,
            onPointerDown: qe(b.onPointerDown, () => {
              o || (D.current = R);
            }),
            min: s,
            max: r,
            inverted: g,
            onSlideStart: o ? void 0 : L,
            onSlideMove: o ? void 0 : P,
            onSlideEnd: o ? void 0 : V,
            onHomeKeyDown: () => !o && N(s, 0, { commit: !0 }),
            onEndKeyDown: () => !o && N(r, R.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: W, direction: H }) => {
              if (!o) {
                const q =
                    AX.includes(W.key) || (W.shiftKey && RX.includes(W.key))
                      ? 10
                      : 1,
                  O = S.current,
                  U = R[O],
                  j = i * q * H;
                N(U + j, O, { commit: !0 });
              }
            },
          }),
        }),
      }),
    });
  });
IX.displayName = Jf;
var [LX, DX] = CX(Jf, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1,
  }),
  nDe = E.forwardRef((n, e) => {
    const {
        min: t,
        max: s,
        dir: r,
        inverted: i,
        onSlideStart: a,
        onSlideMove: o,
        onSlideEnd: l,
        onStepKeyDown: c,
        ...h
      } = n,
      [m, p] = E.useState(null),
      g = Nt(e, (_) => p(_)),
      y = E.useRef(void 0),
      b = _v(r),
      w = b === "ltr",
      S = (w && !i) || (!w && i);
    function A(_) {
      const R = y.current || m.getBoundingClientRect(),
        C = [0, R.width],
        L = uM(C, S ? [t, s] : [s, t]);
      return (y.current = R), L(_ - R.left);
    }
    return u.jsx(LX, {
      scope: n.__scopeSlider,
      startEdge: S ? "left" : "right",
      endEdge: S ? "right" : "left",
      direction: S ? 1 : -1,
      size: "width",
      children: u.jsx(PX, {
        dir: b,
        "data-orientation": "horizontal",
        ...h,
        ref: g,
        style: {
          ...h.style,
          "--radix-slider-thumb-transform": "translateX(-50%)",
        },
        onSlideStart: (_) => {
          const R = A(_.clientX);
          a?.(R);
        },
        onSlideMove: (_) => {
          const R = A(_.clientX);
          o?.(R);
        },
        onSlideEnd: () => {
          (y.current = void 0), l?.();
        },
        onStepKeyDown: (_) => {
          const C = kX[S ? "from-left" : "from-right"].includes(_.key);
          c?.({ event: _, direction: C ? -1 : 1 });
        },
      }),
    });
  }),
  sDe = E.forwardRef((n, e) => {
    const {
        min: t,
        max: s,
        inverted: r,
        onSlideStart: i,
        onSlideMove: a,
        onSlideEnd: o,
        onStepKeyDown: l,
        ...c
      } = n,
      h = E.useRef(null),
      m = Nt(e, h),
      p = E.useRef(void 0),
      g = !r;
    function y(b) {
      const w = p.current || h.current.getBoundingClientRect(),
        S = [0, w.height],
        _ = uM(S, g ? [s, t] : [t, s]);
      return (p.current = w), _(b - w.top);
    }
    return u.jsx(LX, {
      scope: n.__scopeSlider,
      startEdge: g ? "bottom" : "top",
      endEdge: g ? "top" : "bottom",
      size: "height",
      direction: g ? 1 : -1,
      children: u.jsx(PX, {
        "data-orientation": "vertical",
        ...c,
        ref: m,
        style: {
          ...c.style,
          "--radix-slider-thumb-transform": "translateY(50%)",
        },
        onSlideStart: (b) => {
          const w = y(b.clientY);
          i?.(w);
        },
        onSlideMove: (b) => {
          const w = y(b.clientY);
          a?.(w);
        },
        onSlideEnd: () => {
          (p.current = void 0), o?.();
        },
        onStepKeyDown: (b) => {
          const S = kX[g ? "from-bottom" : "from-top"].includes(b.key);
          l?.({ event: b, direction: S ? -1 : 1 });
        },
      }),
    });
  }),
  PX = E.forwardRef((n, e) => {
    const {
        __scopeSlider: t,
        onSlideStart: s,
        onSlideMove: r,
        onSlideEnd: i,
        onHomeKeyDown: a,
        onEndKeyDown: o,
        onStepKeyDown: l,
        ...c
      } = n,
      h = pS(Jf, t);
    return u.jsx(Et.span, {
      ...c,
      ref: e,
      onKeyDown: qe(n.onKeyDown, (m) => {
        m.key === "Home"
          ? (a(m), m.preventDefault())
          : m.key === "End"
          ? (o(m), m.preventDefault())
          : AX.concat(RX).includes(m.key) && (l(m), m.preventDefault());
      }),
      onPointerDown: qe(n.onPointerDown, (m) => {
        const p = m.target;
        p.setPointerCapture(m.pointerId),
          m.preventDefault(),
          h.thumbs.has(p) ? p.focus() : s(m);
      }),
      onPointerMove: qe(n.onPointerMove, (m) => {
        m.target.hasPointerCapture(m.pointerId) && r(m);
      }),
      onPointerUp: qe(n.onPointerUp, (m) => {
        const p = m.target;
        p.hasPointerCapture(m.pointerId) &&
          (p.releasePointerCapture(m.pointerId), i(m));
      }),
    });
  }),
  MX = "SliderTrack",
  NX = E.forwardRef((n, e) => {
    const { __scopeSlider: t, ...s } = n,
      r = pS(MX, t);
    return u.jsx(Et.span, {
      "data-disabled": r.disabled ? "" : void 0,
      "data-orientation": r.orientation,
      ...s,
      ref: e,
    });
  });
NX.displayName = MX;
var xI = "SliderRange",
  OX = E.forwardRef((n, e) => {
    const { __scopeSlider: t, ...s } = n,
      r = pS(xI, t),
      i = DX(xI, t),
      a = E.useRef(null),
      o = Nt(e, a),
      l = r.values.length,
      c = r.values.map((p) => UX(p, r.min, r.max)),
      h = l > 1 ? Math.min(...c) : 0,
      m = 100 - Math.max(...c);
    return u.jsx(Et.span, {
      "data-orientation": r.orientation,
      "data-disabled": r.disabled ? "" : void 0,
      ...s,
      ref: o,
      style: { ...n.style, [i.startEdge]: h + "%", [i.endEdge]: m + "%" },
    });
  });
OX.displayName = xI;
var wI = "SliderThumb",
  jX = E.forwardRef((n, e) => {
    const t = JLe(n.__scopeSlider),
      [s, r] = E.useState(null),
      i = Nt(e, (o) => r(o)),
      a = E.useMemo(
        () => (s ? t().findIndex((o) => o.ref.current === s) : -1),
        [t, s]
      );
    return u.jsx(rDe, { ...n, ref: i, index: a });
  }),
  rDe = E.forwardRef((n, e) => {
    const { __scopeSlider: t, index: s, name: r, ...i } = n,
      a = pS(wI, t),
      o = DX(wI, t),
      [l, c] = E.useState(null),
      h = Nt(e, (A) => c(A)),
      m = l ? a.form || !!l.closest("form") : !0,
      p = IE(l),
      g = a.values[s],
      y = g === void 0 ? 0 : UX(g, a.min, a.max),
      b = oDe(s, a.values.length),
      w = p?.[o.size],
      S = w ? cDe(w, y, o.direction) : 0;
    return (
      E.useEffect(() => {
        if (l)
          return (
            a.thumbs.add(l),
            () => {
              a.thumbs.delete(l);
            }
          );
      }, [l, a.thumbs]),
      u.jsxs("span", {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [o.startEdge]: `calc(${y}% + ${S}px)`,
        },
        children: [
          u.jsx(bI.ItemSlot, {
            scope: n.__scopeSlider,
            children: u.jsx(Et.span, {
              role: "slider",
              "aria-label": n["aria-label"] || b,
              "aria-valuemin": a.min,
              "aria-valuenow": g,
              "aria-valuemax": a.max,
              "aria-orientation": a.orientation,
              "data-orientation": a.orientation,
              "data-disabled": a.disabled ? "" : void 0,
              tabIndex: a.disabled ? void 0 : 0,
              ...i,
              ref: h,
              style: g === void 0 ? { display: "none" } : n.style,
              onFocus: qe(n.onFocus, () => {
                a.valueIndexToChangeRef.current = s;
              }),
            }),
          }),
          m &&
            u.jsx(
              FX,
              {
                name:
                  r ??
                  (a.name
                    ? a.name + (a.values.length > 1 ? "[]" : "")
                    : void 0),
                form: a.form,
                value: g,
              },
              s
            ),
        ],
      })
    );
  });
jX.displayName = wI;
var iDe = "RadioBubbleInput",
  FX = E.forwardRef(({ __scopeSlider: n, value: e, ...t }, s) => {
    const r = E.useRef(null),
      i = Nt(r, s),
      a = GE(e);
    return (
      E.useEffect(() => {
        const o = r.current;
        if (!o) return;
        const l = window.HTMLInputElement.prototype,
          h = Object.getOwnPropertyDescriptor(l, "value").set;
        if (a !== e && h) {
          const m = new Event("input", { bubbles: !0 });
          h.call(o, e), o.dispatchEvent(m);
        }
      }, [a, e]),
      u.jsx(Et.input, {
        style: { display: "none" },
        ...t,
        ref: i,
        defaultValue: e,
      })
    );
  });
FX.displayName = iDe;
function aDe(n = [], e, t) {
  const s = [...n];
  return (s[t] = e), s.sort((r, i) => r - i);
}
function UX(n, e, t) {
  const i = (100 / (t - e)) * (n - e);
  return Qx(i, [0, 100]);
}
function oDe(n, e) {
  return e > 2
    ? `Value ${n + 1} of ${e}`
    : e === 2
    ? ["Minimum", "Maximum"][n]
    : void 0;
}
function lDe(n, e) {
  if (n.length === 1) return 0;
  const t = n.map((r) => Math.abs(r - e)),
    s = Math.min(...t);
  return t.indexOf(s);
}
function cDe(n, e, t) {
  const s = n / 2,
    i = uM([0, 50], [0, s]);
  return (s - i(e) * t) * t;
}
function uDe(n) {
  return n.slice(0, -1).map((e, t) => n[t + 1] - e);
}
function dDe(n, e) {
  if (e > 0) {
    const t = uDe(n);
    return Math.min(...t) >= e;
  }
  return !0;
}
function uM(n, e) {
  return (t) => {
    if (n[0] === n[1] || e[0] === e[1]) return e[0];
    const s = (e[1] - e[0]) / (n[1] - n[0]);
    return e[0] + s * (t - n[0]);
  };
}
function hDe(n) {
  return (String(n).split(".")[1] || "").length;
}
function fDe(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
var $X = IX,
  mDe = NX,
  pDe = OX,
  gDe = jX;
const BX = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsxs($X, {
    ref: t,
    className: Le(
      "relative flex w-full touch-none select-none items-center",
      n
    ),
    ...e,
    children: [
      u.jsx(mDe, {
        className:
          "relative h-1 w-full grow overflow-hidden rounded-full bg-secondary",
        children: u.jsx(pDe, { className: "absolute h-full bg-text-primary" }),
      }),
      u.jsx(gDe, {
        className:
          "block h-3 w-3 rounded-full bg-text-primary shadow transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 cursor-grab active:cursor-grabbing",
      }),
    ],
  })
);
BX.displayName = $X.displayName;
const vDe = ({ isOpen: n, onClose: e }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "max-w-md",
        children: [
          u.jsx(bs, {
            children: u.jsx(xs, {
              className: "text-text-primary",
              children: "Keyboard Shortcuts",
            }),
          }),
          u.jsxs("div", {
            className: "space-y-6",
            children: [
              u.jsxs("div", {
                children: [
                  u.jsx("p", {
                    className:
                      "text-xs font-semibold text-text-secondary uppercase tracking-wider mb-3",
                    children: "Navigate",
                  }),
                  u.jsx("div", {
                    className: "space-y-2",
                    children: u.jsxs("div", {
                      className: "flex items-center justify-between gap-4",
                      children: [
                        u.jsx("span", {
                          className: "text-sm text-text-primary",
                          children: "Next / Previous Element ",
                        }),
                        u.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [
                            u.jsx(mn, { children: "" }),
                            u.jsx("span", {
                              className: "text-xs text-text-secondary",
                              children: "+",
                            }),
                            u.jsx(mn, { children: "Tab" }),
                          ],
                        }),
                      ],
                    }),
                  }),
                ],
              }),
              u.jsxs("div", {
                children: [
                  u.jsx("p", {
                    className:
                      "text-xs font-semibold text-text-secondary uppercase tracking-wider mb-3",
                    children: "Add Elements",
                  }),
                  u.jsxs("div", {
                    className: "space-y-2",
                    children: [
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Add Comment",
                          }),
                          u.jsx(mn, { children: "C" }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Record Thoughts",
                          }),
                          u.jsx(mn, { children: "R" }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Record Screen",
                          }),
                          u.jsx(mn, { children: "S" }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              u.jsxs("div", {
                children: [
                  u.jsx("p", {
                    className:
                      "text-xs font-semibold text-text-secondary uppercase tracking-wider mb-3",
                    children: "Canvas Actions",
                  }),
                  u.jsxs("div", {
                    className: "space-y-2",
                    children: [
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Delete Selected Element",
                          }),
                          u.jsx(mn, { children: "" }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Edit Selected Element",
                          }),
                          u.jsx(mn, { children: "E" }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Reply to Selected Element",
                          }),
                          u.jsx(mn, { children: "" }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              u.jsxs("div", {
                children: [
                  u.jsx("p", {
                    className:
                      "text-xs font-semibold text-text-secondary uppercase tracking-wider mb-3",
                    children: "Playback Controls",
                  }),
                  u.jsxs("div", {
                    className: "space-y-2",
                    children: [
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Seek by 5 seconds",
                          }),
                          u.jsxs("div", {
                            className: "flex items-center gap-1",
                            children: [
                              u.jsx(mn, { children: "" }),
                              u.jsx(mn, { children: "" }),
                            ],
                          }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Next-prev frame",
                          }),
                          u.jsxs("div", {
                            className: "flex items-center gap-1",
                            children: [
                              u.jsx(mn, { children: "" }),
                              u.jsx("span", {
                                className: "text-xs text-text-secondary",
                                children: "+",
                              }),
                              u.jsx(mn, { children: "" }),
                              u.jsx(mn, { children: "" }),
                            ],
                          }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Faster / Slower playback",
                          }),
                          u.jsxs("div", {
                            className: "flex items-center gap-1",
                            children: [
                              u.jsx(mn, { children: "J" }),
                              u.jsx(mn, { children: "L" }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              u.jsxs("div", {
                children: [
                  u.jsx("p", {
                    className:
                      "text-xs font-semibold text-text-secondary uppercase tracking-wider mb-3",
                    children: "Zoom",
                  }),
                  u.jsxs("div", {
                    className: "space-y-2",
                    children: [
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Zoom In / Out",
                          }),
                          u.jsxs("div", {
                            className: "flex items-center gap-1",
                            children: [
                              u.jsx(mn, { children: "+" }),
                              u.jsx(mn, { children: "-" }),
                            ],
                          }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center justify-between gap-4",
                        children: [
                          u.jsx("span", {
                            className: "text-sm text-text-primary",
                            children: "Reset zoom",
                          }),
                          u.jsx(mn, { children: "Z" }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          u.jsx(xr, {
            className: "gap-2",
            children: u.jsx("button", {
              onClick: e,
              className:
                "button-primary flex items-center rounded-xl justify-center px-6 py-3 cursor-pointer text-sm font-medium",
              children: "Go smash Keys",
            }),
          }),
        ],
      }),
    }),
  EI = ({ showCloseButton: n = !1, onClose: e }) => {
    const {
        currentTime: t,
        duration: s,
        volume: r,
        isMuted: i,
        playbackRate: a,
        toggleMainAssetFullscreen: o,
        videoId: l,
      } = Be(),
      c = k7(),
      h = pt((q) => q.resetZoom),
      m = pt((q) => q.zoomIn),
      p = pt((q) => q.zoomOut),
      [g, y] = E.useState(!1),
      [b, w] = E.useState(!1),
      [S, A] = E.useState(!1),
      _ = E.useRef(null),
      R = E.useRef(null),
      C = E.useRef(null),
      D = E.useCallback(
        (q) => {
          const O = q[0];
          c.setVolume(O), O > 0 && i && c.toggleMute();
        },
        [c, i]
      ),
      L = E.useCallback(() => {
        R.current && (clearTimeout(R.current), (R.current = null)),
          (_.current = setTimeout(() => {
            y(!0);
          }, 400));
      }, []),
      P = E.useCallback(() => {
        _.current && (clearTimeout(_.current), (_.current = null)),
          (R.current = setTimeout(() => {
            y(!1);
          }, 400));
      }, []),
      V = E.useCallback(() => {
        h(() => {});
      }, [h]),
      N = E.useCallback(() => {
        m();
      }, [m]),
      W = E.useCallback(() => {
        p();
      }, [p]),
      H = l
        ? [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2]
        : [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4],
      z = E.useCallback((q) => {
        const { setPlaybackRate: O, playerRef: U } = Be.getState();
        if ((O(q), U && typeof U.playbackRate == "function"))
          try {
            U.playbackRate(q);
          } catch (j) {
            console.error("Error setting playback rate:", j);
          }
        A(!1);
      }, []),
      B = E.useCallback(() => {
        A((q) => !q);
      }, []);
    return (
      de.useEffect(() => {
        const q = (O) => {
          C.current && !C.current.contains(O.target) && A(!1);
        };
        if (S)
          return (
            document.addEventListener("mousedown", q),
            () => document.removeEventListener("mousedown", q)
          );
      }, [S]),
      u.jsx(Br, {
        delayDuration: 0,
        children: u.jsxs(u.Fragment, {
          children: [
            !n &&
              u.jsx("div", {
                className: "hidden md:flex fixed left-2 items-center gap-1",
                style: { bottom: "inherit" },
                children: u.jsx("div", {
                  className:
                    "h-8 flex items-center bg-inbetween-background backdrop-blur-md rounded-full px-1.5",
                  children: u.jsxs("div", {
                    className: "flex items-center gap-1",
                    children: [
                      u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center h-6 w-6 text-text-secondary hover:text-text-primary cursor-pointer rounded transition-colors",
                              onClick: W,
                              type: "button",
                              children: u.jsx(ble, { className: "h-3 w-3" }),
                            }),
                          }),
                          u.jsx(Pn, {
                            className: "mb-3",
                            children: u.jsxs("div", {
                              className: "flex items-center gap-2",
                              children: [
                                "Zoom out",
                                u.jsx(mn, { children: "-" }),
                              ],
                            }),
                          }),
                        ],
                      }),
                      u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center h-6 w-6 text-text-secondary hover:text-text-primary cursor-pointer rounded transition-colors",
                              onClick: V,
                              type: "button",
                              children: u.jsx(Ele, { className: "h-3 w-3" }),
                            }),
                          }),
                          u.jsx(Pn, {
                            className: "mb-3",
                            children: u.jsxs("div", {
                              className: "flex items-center gap-2",
                              children: [
                                "Reset zoom",
                                u.jsx(mn, { children: "Z" }),
                              ],
                            }),
                          }),
                        ],
                      }),
                      u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center h-6 w-6 text-text-secondary hover:text-text-primary cursor-pointer rounded transition-colors",
                              onClick: N,
                              type: "button",
                              children: u.jsx(Zu, { className: "h-3 w-3" }),
                            }),
                          }),
                          u.jsx(Pn, {
                            className: "mb-3",
                            children: u.jsxs("div", {
                              className: "flex items-center gap-2",
                              children: [
                                "Zoom in",
                                u.jsx(mn, { children: "+" }),
                              ],
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
              }),
            u.jsxs("div", {
              className: "relative z-30 flex items-center justify-center mt-1",
              children: [
                u.jsxs(Xn, {
                  delayDuration: 300,
                  children: [
                    u.jsx(Qn, {
                      asChild: !0,
                      children: u.jsx("div", {
                        className:
                          "h-8 w-8 flex items-center justify-center bg-inbetween-background backdrop-blur-md rounded-full -mt-1.5 mr-1 p-0 z-40 cursor-pointer",
                        onClick: c.togglePlayPause,
                        children: c.isPlaying
                          ? u.jsx(uL, {
                              size: 14,
                              className: "text-text-primary",
                              fill: "currentColor",
                            })
                          : u.jsx(Pg, {
                              size: 14,
                              className: "text-text-primary",
                              fill: "currentColor",
                            }),
                      }),
                    }),
                    u.jsx(Pn, {
                      className: "mb-3",
                      children: c.isPlaying ? "Pause" : "Play",
                    }),
                  ],
                }),
                u.jsx("div", {
                  className:
                    "h-8 flex items-center bg-inbetween-background backdrop-blur-md rounded-full px-3 -mt-1.5 z-0",
                  children: u.jsx("div", {
                    className: "px-2 py-1",
                    children: u.jsxs("span", {
                      className:
                        "font-mono text-sm select-none whitespace-nowrap",
                      children: [
                        u.jsx("span", {
                          className: "text-text-primary ",
                          children: zg(t),
                        }),
                        u.jsxs("span", {
                          className: "text-text-secondary",
                          children: [" ", "/ ", zg(s)],
                        }),
                      ],
                    }),
                  }),
                }),
              ],
            }),
            !n &&
              u.jsx("div", {
                className: "hidden md:flex fixed right-2 items-center gap-1",
                style: { bottom: "inherit" },
                children: u.jsx("div", {
                  className:
                    "h-8 flex items-center bg-inbetween-background backdrop-blur-md rounded-full px-4",
                  children: u.jsxs("div", {
                    className: "flex items-center gap-3",
                    children: [
                      u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center h-6 w-6 text-text-secondary hover:text-text-primary cursor-pointer rounded transition-colors",
                              onClick: () => w(!0),
                              type: "button",
                              children: u.jsx(ule, { className: "h-4 w-4" }),
                            }),
                          }),
                          u.jsx(Pn, {
                            className: "mb-3",
                            children: "Keyboard Shortcuts",
                          }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "relative",
                        ref: C,
                        children: [
                          u.jsxs(Xn, {
                            delayDuration: 300,
                            children: [
                              u.jsx(Qn, {
                                asChild: !0,
                                children: u.jsxs("button", {
                                  className:
                                    "font-mono text-sm text-text-secondary hover:text-text-primary transition-colors px-1 flex items-center gap-1",
                                  onClick: B,
                                  type: "button",
                                  style: { minWidth: "2rem" },
                                  children: [
                                    u.jsx("span", {
                                      children:
                                        a % 1 === 0
                                          ? `${a}x`
                                          : `${a.toFixed(2)}x`,
                                    }),
                                    S
                                      ? u.jsx(lL, { className: "h-3 w-3" })
                                      : u.jsx(cd, { className: "h-3 w-3" }),
                                  ],
                                }),
                              }),
                              u.jsx(Pn, {
                                className: "mb-3",
                                children: u.jsxs("div", {
                                  className: "flex items-center gap-2",
                                  children: [
                                    u.jsx("span", {
                                      children: "Playback Speed",
                                    }),
                                    u.jsxs("div", {
                                      className: "flex items-center gap-1",
                                      children: [
                                        u.jsx(mn, { children: "J" }),
                                        u.jsx(mn, { children: "L" }),
                                      ],
                                    }),
                                  ],
                                }),
                              }),
                            ],
                          }),
                          S &&
                            u.jsx("div", {
                              className:
                                "absolute bottom-full right-0 mb-2 bg-inbetween-background backdrop-blur-md rounded-lg border element-border shadow-lg overflow-hidden z-50 ",
                              children: u.jsx("div", {
                                className: "py-1",
                                children: H.map((q) =>
                                  u.jsx(
                                    "button",
                                    {
                                      onClick: () => z(q),
                                      className: Le(
                                        "w-full px-3 py-2 text-left text-sm transition-colors font-mono",
                                        a === q
                                          ? "bg-element-hover text-text-primary"
                                          : "text-text-secondary hover:bg-element-hover hover:text-text-primary"
                                      ),
                                      type: "button",
                                      children:
                                        q % 1 === 0
                                          ? `${q}x`
                                          : `${q.toFixed(2)}x`,
                                    },
                                    q
                                  )
                                ),
                              }),
                            }),
                        ],
                      }),
                      u.jsxs("div", {
                        className: "flex items-center group",
                        onMouseEnter: L,
                        onMouseLeave: P,
                        children: [
                          u.jsx("button", {
                            className:
                              "flex items-center justify-center p-1 text-text-secondary hover:text-text-primary transition-colors",
                            onClick: c.toggleMute,
                            type: "button",
                            children: i
                              ? u.jsx(Cle, { className: "h-4 w-4" })
                              : u.jsx(kle, { className: "h-4 w-4" }),
                          }),
                          u.jsx("div", {
                            className: Le(
                              "transition-all duration-300 ease-out flex items-center",
                              g
                                ? "w-20 ml-2 opacity-100"
                                : "w-0 ml-0 opacity-0 overflow-hidden"
                            ),
                            children: u.jsx(BX, {
                              value: [i ? 0 : r],
                              onValueChange: D,
                              max: 1,
                              min: 0,
                              step: 0.01,
                              className: "w-20 cursor-pointer",
                            }),
                          }),
                        ],
                      }),
                      u.jsxs(Xn, {
                        delayDuration: 300,
                        children: [
                          u.jsx(Qn, {
                            asChild: !0,
                            children: u.jsx("button", {
                              className:
                                "flex items-center justify-center p-1 text-text-secondary hover:text-text-primary transition-colors",
                              onClick: o,
                              type: "button",
                              children: u.jsx(mle, { className: "h-4 w-4" }),
                            }),
                          }),
                          u.jsx(Pn, {
                            className: "mb-3",
                            children: "Fullscreen",
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
              }),
            n &&
              e &&
              u.jsx("div", {
                className: "fixed right-2 items-center gap-1",
                style: { bottom: "inherit" },
                children: u.jsxs(Xn, {
                  delayDuration: 300,
                  children: [
                    u.jsx(Qn, {
                      asChild: !0,
                      children: u.jsx("button", {
                        className:
                          "flex items-center justify-center h-8 w-8 bg-inbetween-background backdrop-blur-md rounded-full text-text-secondary hover:text-text-primary transition-colors",
                        onClick: e,
                        type: "button",
                        children: u.jsx(Pa, { className: "h-4 w-4" }),
                      }),
                    }),
                    u.jsx(Pn, {
                      className: "mb-3",
                      children: "Exit Fullscreen",
                    }),
                  ],
                }),
              }),
            u.jsx(vDe, { isOpen: b, onClose: () => w(!1) }),
          ],
        }),
      })
    );
  },
  yDe = ({
    youtubeUrl: n,
    nativeAsset: e,
    hasEditingPermissions: t,
    playerHeightVh: s,
    onPlayerReady: r,
    onPlay: i,
    onTimeUpdate: a,
    onDurationChange: o,
    onHeightResize: l,
  }) => {
    const c = Be((C) => C.isPreviewMode),
      { playbackRate: h, isMuted: m, volume: p, handlePause: g } = Be();
    I7({ transformWrapperRef: null });
    const [y, b] = E.useState(() => window.innerWidth < 768);
    E.useEffect(() => {
      const C = () => b(window.innerWidth < 768);
      return (
        window.addEventListener("resize", C),
        () => window.removeEventListener("resize", C)
      );
    }, []);
    const [w, S] = E.useState(() => {
        if (typeof window < "u") {
          const P = window.innerHeight * (s / 100) - 50 - 10;
          return { width: P * (16 / 9), height: P };
        }
        return { width: 640, height: 360 };
      }),
      A = E.useRef(0),
      _ = E.useRef(0),
      R = E.useCallback(
        (C) => {
          if (!l || !s) return;
          (A.current = C.clientY), (_.current = s);
          const D = (P) => {
              const V = P.clientY - A.current,
                N = window.innerHeight,
                W = (V / N) * 100,
                H = Math.max(Rie, Math.min(kie, _.current + W));
              l(H);
            },
            L = () => {
              document.removeEventListener("mousemove", D),
                document.removeEventListener("mouseup", L),
                (document.body.style.cursor = ""),
                (document.body.style.userSelect = "");
            };
          document.addEventListener("mousemove", D),
            document.addEventListener("mouseup", L),
            (document.body.style.cursor = "ns-resize"),
            (document.body.style.userSelect = "none");
        },
        [l, s]
      );
    return (
      E.useEffect(() => {
        if (typeof window > "u") return;
        const C = () => {
          const V = window.innerHeight * (s / 100) - 50 - 10,
            N = V * (16 / 9);
          S({ width: N, height: V });
        };
        return (
          C(),
          window.addEventListener("resize", C),
          () => window.removeEventListener("resize", C)
        );
      }, [s]),
      y
        ? u.jsx(u.Fragment, {
            children: u.jsxs("div", {
              className: "relative z-30 w-screen ",
              "data-testid": "fixed-main-asset",
              children: [
                u.jsx("div", {
                  "data-main-asset-player-container": !0,
                  className:
                    "relative w-screen aspect-video bg-black overflow-hidden",
                  children:
                    n || e
                      ? u.jsx(P5, {
                          youtubeUrl: n,
                          nativeAsset: e,
                          onReady: r,
                          onPlay: i,
                          onPause: g,
                          onTimeUpdate: a,
                          onDurationChange: o,
                          playbackRate: h,
                          isMuted: m,
                          volume: p,
                        })
                      : u.jsx("div", { className: "w-full h-full bg-black" }),
                }),
                u.jsx("div", {
                  className: "mt-2 mb-1 flex justify-center items-center gap-3",
                  children: u.jsx(EI, {}),
                }),
              ],
            }),
          })
        : u.jsx(u.Fragment, {
            children: u.jsxs("div", {
              className: "relative flex flex-col items-center z-30 pt-4",
              "data-testid": "fixed-main-asset",
              style: { height: `${s}vh` },
              children: [
                u.jsx("div", {
                  className: "relative flex-shrink-0",
                  style: { height: `${w.height}px`, width: `${w.width}px` },
                  children: u.jsx("div", {
                    className:
                      "overflow-hidden w-full h-full rounded-lg shadow-xl shadow-black",
                    children:
                      n || e
                        ? u.jsx("div", {
                            "data-main-asset-player-container": !0,
                            className: `w-full h-full overflow-hidden rounded-lg shadow-2xl ${
                              c ? "border-text-primary" : "element-border"
                            } border`,
                            children: u.jsx(P5, {
                              youtubeUrl: n,
                              nativeAsset: e,
                              onReady: r,
                              onPlay: i,
                              onPause: g,
                              onTimeUpdate: a,
                              onDurationChange: o,
                              playbackRate: h,
                              isMuted: m,
                              volume: p,
                            }),
                          })
                        : u.jsx("div", {
                            className:
                              "flex flex-col items-center justify-center w-full h-full p-8 relative bg-black rounded-lg shadow-2xl border-border border",
                          }),
                  }),
                }),
                u.jsxs("div", {
                  className:
                    "mt-2 mb-1 flex justify-center items-center gap-3 relative",
                  children: [
                    l &&
                      s &&
                      u.jsx("div", {
                        className:
                          "fixed left-1/2 -translate-x-1/2 cursor-ns-resize z-40 border-t border-white opacity-0 hover:opacity-100 transition-opacity hidden md:block bg-text-primary/50 backdrop-blur-sm rounded-full",
                        style: {
                          top: `${w.height + 56}px`,
                          width: "99vw",
                          height: "4px",
                        },
                        onMouseDown: R,
                        onDragStart: (C) => C.preventDefault(),
                        draggable: !1,
                        title: "Drag to resize player",
                      }),
                    u.jsx(EI, {}),
                  ],
                }),
              ],
            }),
          })
    );
  },
  bDe = ({
    youtubeUrl: n,
    nativeAsset: e,
    hasEditingPermissions: t,
    onCreateLinkedFrame: s,
    onCreateElementInFrame: r,
  }) => {
    const i = E.useRef(null),
      [a, o] = E.useState(!0),
      [l, c] = E.useState(!1),
      h = E.useRef(null),
      m = E.useRef(null),
      [p, g] = E.useState(null),
      {
        currentTime: y,
        duration: b,
        isPlaying: w,
        setMainAssetFullscreen: S,
        isPreviewMode: A,
        previewTimestamp: _,
      } = Be(),
      R = typeof window < "u" ? window.innerWidth * 0.9 - 32 : 800,
      C = fl((L) => L.setInFullscreen);
    E.useEffect(
      () => (
        C(!0),
        (async () => {
          const P = document.querySelector("media-controller");
          if (!P) {
            console.warn("Could not find media-controller for fullscreen");
            return;
          }
          (m.current = P), g(P);
          try {
            P.requestFullscreen
              ? await P.requestFullscreen()
              : P.webkitRequestFullscreen
              ? await P.webkitRequestFullscreen()
              : P.mozRequestFullScreen
              ? await P.mozRequestFullScreen()
              : P.msRequestFullscreen && (await P.msRequestFullscreen()),
              c(!0);
          } catch (V) {
            console.error("Error entering fullscreen:", V);
          }
        })(),
        () => {
          C(!1),
            document.fullscreenElement
              ? document.exitFullscreen().catch((P) => {
                  console.error("Error exiting fullscreen:", P);
                })
              : document.webkitFullscreenElement
              ? document.webkitExitFullscreen()
              : document.mozFullScreenElement
              ? document.mozCancelFullScreen()
              : document.msFullscreenElement && document.msExitFullscreen();
        }
      ),
      [C]
    ),
      E.useEffect(() => {
        if (!p || !l) return;
        const L = (V) => {
            const N = window.innerHeight,
              W = V.clientY,
              H = N * 0.25;
            h.current && (clearTimeout(h.current), (h.current = null)),
              W >= N - H
                ? o(!0)
                : (h.current = setTimeout(() => {
                    o(!1);
                  }, 300));
          },
          P = () => {
            h.current && (clearTimeout(h.current), (h.current = null)), o(!1);
          };
        return (
          p.addEventListener("mousemove", L),
          p.addEventListener("mouseleave", P),
          () => {
            p.removeEventListener("mousemove", L),
              p.removeEventListener("mouseleave", P);
          }
        );
      }, [p, l]);
    const D = E.useCallback(() => {
      S(!1);
    }, [S]);
    return (
      E.useEffect(
        () => () => {
          h.current && clearTimeout(h.current);
        },
        []
      ),
      E.useEffect(() => {
        const L = () => {
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
            ? c(!0)
            : (c(!1), D());
        };
        return (
          document.addEventListener("fullscreenchange", L),
          document.addEventListener("webkitfullscreenchange", L),
          document.addEventListener("mozfullscreenchange", L),
          document.addEventListener("MSFullscreenChange", L),
          () => {
            document.removeEventListener("fullscreenchange", L),
              document.removeEventListener("webkitfullscreenchange", L),
              document.removeEventListener("mozfullscreenchange", L),
              document.removeEventListener("MSFullscreenChange", L);
          }
        );
      }, [D]),
      !l || !p
        ? null
        : ri.createPortal(
            u.jsxs("div", {
              ref: i,
              className: "fixed inset-0 z-[9999] pointer-events-none",
              children: [
                u.jsxs("div", {
                  className: `absolute inset-0 pointer-events-none transition-opacity duration-200 ${
                    A && _ !== null ? "opacity-100" : "opacity-0"
                  }`,
                  style: { zIndex: 10 },
                  children: [
                    u.jsx("div", {
                      className: "absolute inset-0",
                      style: {
                        background:
                          "linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 60%, transparent 100%)",
                      },
                    }),
                    A &&
                      _ !== null &&
                      u.jsx("div", {
                        className:
                          "absolute bottom-4 left-1/2 transform -translate-x-1/2 mb-[10%]",
                        children: u.jsxs("div", {
                          className:
                            "text-text-primary shadow-xl text-shadow-md text-lg opacity-90 font-mono",
                          children: ["Previewing ", zg(_)],
                        }),
                      }),
                  ],
                }),
                u.jsx(Qg, {
                  children:
                    a &&
                    u.jsxs(la.div, {
                      initial: { opacity: 0, y: 100 },
                      animate: { opacity: 1, y: 0 },
                      exit: { opacity: 0, y: 100 },
                      transition: {
                        type: "spring",
                        stiffness: 400,
                        damping: 25,
                      },
                      className:
                        "absolute bottom-0 left-0 right-0 pointer-events-none z-50",
                      children: [
                        u.jsx("div", {
                          className:
                            "absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent pointer-events-none",
                        }),
                        u.jsxs("div", {
                          className:
                            "relative flex flex-col items-center pb-6 pt-12",
                          style: { pointerEvents: "auto" },
                          children: [
                            u.jsx("div", {
                              className: "mb-12",
                              children: u.jsx(EI, {
                                showCloseButton: !0,
                                onClose: D,
                              }),
                            }),
                            u.jsx("div", {
                              className: "w-full max-w-[90vw] px-4",
                              style: { pointerEvents: "auto" },
                              children: u.jsx(gq, {
                                currentTime: y,
                                duration: b,
                                isPlaying: w,
                                playbarWidth: R,
                                hasEditingPermissions: t,
                                youtubeUrl: n,
                                nativeAsset: e,
                                onCreateLinkedFrame: s,
                                onCreateElementInFrame: r,
                                preventSeekOnLinkClick: !1,
                                timelineScale: 1,
                                isFullscreen: !0,
                              }),
                            }),
                          ],
                        }),
                      ],
                    }),
                }),
              ],
            }),
            p
          )
    );
  },
  xDe = ({
    isOpen: n,
    onClose: e,
    onConfirm: t,
    assetName: s,
    isDownloading: r = !1,
  }) =>
    u.jsx(os, {
      open: n,
      onOpenChange: e,
      children: u.jsxs(Jn, {
        className: "sm:max-w-[425px]",
        children: [
          u.jsxs(bs, {
            children: [
              u.jsxs(xs, {
                className: "flex items-center gap-2",
                children: [
                  u.jsx(JR, { className: "h-5 w-5" }),
                  "Download Original File",
                ],
              }),
              u.jsxs(Cl, {
                className: "pt-4",
                children: [
                  "You are about to download the original file for",
                  " ",
                  u.jsxs("strong", { children: ['"', s, '"'] }),
                  ".",
                ],
              }),
            ],
          }),
          u.jsxs(xr, {
            className: "pt-6",
            children: [
              u.jsx(et, {
                variant: "outline",
                onClick: e,
                disabled: r,
                children: "Cancel",
              }),
              u.jsx(et, {
                onClick: t,
                disabled: r,
                children: r
                  ? u.jsxs(u.Fragment, {
                      children: [
                        u.jsx(wo, { className: "h-4 w-4 mr-2 animate-spin" }),
                        "Preparing Download...",
                      ],
                    })
                  : u.jsxs(u.Fragment, {
                      children: [
                        u.jsx(JR, { className: "h-4 w-4 mr-2" }),
                        "Download",
                      ],
                    }),
              }),
            ],
          }),
        ],
      }),
    });
function wDe({ onOpenChange: n }) {
  const e = Ce((S) => S.availableAssets),
    { currentAssetIndex: t, isCreator: s } = dd(),
    [r, i] = od(),
    [a, o] = E.useState(!1),
    [l, c] = E.useState(!1),
    [h, m] = E.useState(null),
    [p, g] = E.useState(!1),
    y = (S) => {
      S === 0 ? r.delete("asset") : r.set("asset", String(S + 1)),
        i(r, { replace: !0 });
    },
    b = (S, A) => {
      A.stopPropagation(), m(S), c(!0), n(!1);
    },
    w = async () => {
      if (h) {
        g(!0);
        try {
          const S = await Ut(`/api/assets/${h.id}/download`, {
            method: "POST",
          });
          if (!S.ok) {
            const C = await S.json();
            throw new Error(C.error || "Failed to generate download URL");
          }
          const { downloadUrl: A, filename: _ } = await S.json();
          c(!1), g(!1), m(null);
          const R = document.createElement("a");
          (R.href = A),
            (R.download = _),
            document.body.appendChild(R),
            R.click(),
            document.body.removeChild(R),
            setTimeout(() => {
              Ms({
                title: "Download started",
                description: `Downloading ${h.title}`,
              });
            }, 100);
        } catch (S) {
          console.error("Download error:", S),
            g(!1),
            m(null),
            Ms({
              title: "Download failed",
              description:
                S instanceof Error ? S.message : "Failed to download asset",
              variant: "destructive",
            });
        }
      }
    };
  return !e || e.length === 0
    ? null
    : u.jsxs(u.Fragment, {
        children: [
          u.jsxs(ui, {
            align: "end",
            className: "min-w-[350px] p-2 mt-3 rounded-xl",
            children: [
              u.jsxs("div", {
                className:
                  "px-3 pr-0 py-2 text-sm font-semibold text-muted-foreground border-b border-border mb-2 flex items-center justify-between",
                children: [
                  u.jsx("span", { children: "Assets" }),
                  s &&
                    u.jsxs("button", {
                      onClick: () => o(!0),
                      className:
                        "button-secondary items-center flex gap-2 text-xs py-1 px-3",
                      children: [u.jsx(Zu, { width: "12" }), "Add Asset"],
                    }),
                ],
              }),
              e.map((S, A) => {
                const _ = S.asset_type === "native" && S.mux_asset_id;
                return u.jsxs(
                  "div",
                  {
                    className: "flex items-center gap-3 py-1",
                    children: [
                      u.jsx("div", {
                        className:
                          "text-white text-xs uppercase font-semibold flex items-center justify-start",
                        children: u.jsx("div", {
                          className: "flex items-center gap-2",
                          children: u.jsxs("div", { children: ["#", A + 1] }),
                        }),
                      }),
                      u.jsxs(jn, {
                        onClick: () => y(A),
                        className: `cursor-pointer rounded-md p-3 flex-1 flex items-center gap-3 ${
                          A === t
                            ? "bg-element-background"
                            : "hover:bg-accent/50 focus:bg-accent/50"
                        }`,
                        children: [
                          u.jsxs("div", {
                            className:
                              "relative w-16 h-10 rounded overflow-hidden flex-shrink-0",
                            children: [
                              u.jsx("img", {
                                src:
                                  S.thumbnail_url ||
                                  "/images/video-placeholder.png",
                                alt: S.title,
                                className: `w-full h-full object-cover transition-opacity ${
                                  A === t ? "opacity-20 " : "opacity-100 "
                                }`,
                              }),
                              A === t &&
                                u.jsx("div", {
                                  className:
                                    "absolute inset-0 flex items-center justify-center bg-black/20",
                                  children: u.jsx(zs, {
                                    className:
                                      "h-4 w-4 text-white drop-shadow-sm",
                                  }),
                                }),
                            ],
                          }),
                          u.jsxs("div", {
                            className: "flex-1 min-w-0",
                            children: [
                              u.jsx("div", {
                                className: "font-medium truncate text-xs",
                                children: S.title,
                              }),
                              A === 0 &&
                                u.jsx("div", {
                                  className:
                                    "text-[10px] uppercase text-muted-foreground mt-0.5",
                                  children: "Latest",
                                }),
                            ],
                          }),
                          _ &&
                            u.jsx("button", {
                              onClick: (R) =>
                                b({ id: S.id, title: S.title }, R),
                              className:
                                "p-2 rounded hover:bg-accent/70 transition-colors",
                              title: "Download original file",
                              children: u.jsx(JR, { className: "h-4 w-4" }),
                            }),
                        ],
                      }),
                    ],
                  },
                  S.id
                );
              }),
            ],
          }),
          u.jsx(QG, { isOpen: a, onClose: () => o(!1) }),
          h &&
            u.jsx(xDe, {
              isOpen: l,
              onClose: () => {
                c(!1), m(null);
              },
              onConfirm: w,
              assetName: h.title,
              isDownloading: p,
            }),
        ],
      });
}
function M5(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function (r) {
    if ((n?.(r), t === !1 || !r.defaultPrevented)) return e?.(r);
  };
}
function EDe(n, e) {
  return E.useReducer((t, s) => e[t][s] ?? t, n);
}
var HX = (n) => {
  const { present: e, children: t } = n,
    s = SDe(e),
    r =
      typeof t == "function" ? t({ present: s.isPresent }) : E.Children.only(t),
    i = Nt(s.ref, TDe(r));
  return typeof t == "function" || s.isPresent
    ? E.cloneElement(r, { ref: i })
    : null;
};
HX.displayName = "Presence";
function SDe(n) {
  const [e, t] = E.useState(),
    s = E.useRef(null),
    r = E.useRef(n),
    i = E.useRef("none"),
    a = n ? "mounted" : "unmounted",
    [o, l] = EDe(a, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    E.useEffect(() => {
      const c = ub(s.current);
      i.current = o === "mounted" ? c : "none";
    }, [o]),
    ys(() => {
      const c = s.current,
        h = r.current;
      if (h !== n) {
        const p = i.current,
          g = ub(c);
        n
          ? l("MOUNT")
          : g === "none" || c?.display === "none"
          ? l("UNMOUNT")
          : l(h && p !== g ? "ANIMATION_OUT" : "UNMOUNT"),
          (r.current = n);
      }
    }, [n, l]),
    ys(() => {
      if (e) {
        let c;
        const h = e.ownerDocument.defaultView ?? window,
          m = (g) => {
            const b = ub(s.current).includes(CSS.escape(g.animationName));
            if (g.target === e && b && (l("ANIMATION_END"), !r.current)) {
              const w = e.style.animationFillMode;
              (e.style.animationFillMode = "forwards"),
                (c = h.setTimeout(() => {
                  e.style.animationFillMode === "forwards" &&
                    (e.style.animationFillMode = w);
                }));
            }
          },
          p = (g) => {
            g.target === e && (i.current = ub(s.current));
          };
        return (
          e.addEventListener("animationstart", p),
          e.addEventListener("animationcancel", m),
          e.addEventListener("animationend", m),
          () => {
            h.clearTimeout(c),
              e.removeEventListener("animationstart", p),
              e.removeEventListener("animationcancel", m),
              e.removeEventListener("animationend", m);
          }
        );
      } else l("ANIMATION_END");
    }, [e, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(o),
      ref: E.useCallback((c) => {
        (s.current = c ? getComputedStyle(c) : null), t(c);
      }, []),
    }
  );
}
function ub(n) {
  return n?.animationName || "none";
}
function TDe(n) {
  let e = Object.getOwnPropertyDescriptor(n.props, "ref")?.get,
    t = e && "isReactWarning" in e && e.isReactWarning;
  return t
    ? n.ref
    : ((e = Object.getOwnPropertyDescriptor(n, "ref")?.get),
      (t = e && "isReactWarning" in e && e.isReactWarning),
      t ? n.props.ref : n.props.ref || n.ref);
}
var gS = "Checkbox",
  [_De, m2e] = Pr(gS),
  [ADe, dM] = _De(gS);
function RDe(n) {
  const {
      __scopeCheckbox: e,
      checked: t,
      children: s,
      defaultChecked: r,
      disabled: i,
      form: a,
      name: o,
      onCheckedChange: l,
      required: c,
      value: h = "on",
      internal_do_not_use_render: m,
    } = n,
    [p, g] = ci({ prop: t, defaultProp: r ?? !1, onChange: l, caller: gS }),
    [y, b] = E.useState(null),
    [w, S] = E.useState(null),
    A = E.useRef(!1),
    _ = y ? !!a || !!y.closest("form") : !0,
    R = {
      checked: p,
      disabled: i,
      setChecked: g,
      control: y,
      setControl: b,
      name: o,
      form: a,
      value: h,
      hasConsumerStoppedPropagationRef: A,
      required: c,
      defaultChecked: Dc(r) ? !1 : r,
      isFormControl: _,
      bubbleInput: w,
      setBubbleInput: S,
    };
  return u.jsx(ADe, { scope: e, ...R, children: kDe(m) ? m(R) : s });
}
var VX = "CheckboxTrigger",
  zX = E.forwardRef(
    ({ __scopeCheckbox: n, onKeyDown: e, onClick: t, ...s }, r) => {
      const {
          control: i,
          value: a,
          disabled: o,
          checked: l,
          required: c,
          setControl: h,
          setChecked: m,
          hasConsumerStoppedPropagationRef: p,
          isFormControl: g,
          bubbleInput: y,
        } = dM(VX, n),
        b = Nt(r, h),
        w = E.useRef(l);
      return (
        E.useEffect(() => {
          const S = i?.form;
          if (S) {
            const A = () => m(w.current);
            return (
              S.addEventListener("reset", A),
              () => S.removeEventListener("reset", A)
            );
          }
        }, [i, m]),
        u.jsx(Et.button, {
          type: "button",
          role: "checkbox",
          "aria-checked": Dc(l) ? "mixed" : l,
          "aria-required": c,
          "data-state": YX(l),
          "data-disabled": o ? "" : void 0,
          disabled: o,
          value: a,
          ...s,
          ref: b,
          onKeyDown: M5(e, (S) => {
            S.key === "Enter" && S.preventDefault();
          }),
          onClick: M5(t, (S) => {
            m((A) => (Dc(A) ? !0 : !A)),
              y &&
                g &&
                ((p.current = S.isPropagationStopped()),
                p.current || S.stopPropagation());
          }),
        })
      );
    }
  );
zX.displayName = VX;
var hM = E.forwardRef((n, e) => {
  const {
    __scopeCheckbox: t,
    name: s,
    checked: r,
    defaultChecked: i,
    required: a,
    disabled: o,
    value: l,
    onCheckedChange: c,
    form: h,
    ...m
  } = n;
  return u.jsx(RDe, {
    __scopeCheckbox: t,
    checked: r,
    defaultChecked: i,
    disabled: o,
    required: a,
    onCheckedChange: c,
    name: s,
    form: h,
    value: l,
    internal_do_not_use_render: ({ isFormControl: p }) =>
      u.jsxs(u.Fragment, {
        children: [
          u.jsx(zX, { ...m, ref: e, __scopeCheckbox: t }),
          p && u.jsx(KX, { __scopeCheckbox: t }),
        ],
      }),
  });
});
hM.displayName = gS;
var GX = "CheckboxIndicator",
  qX = E.forwardRef((n, e) => {
    const { __scopeCheckbox: t, forceMount: s, ...r } = n,
      i = dM(GX, t);
    return u.jsx(HX, {
      present: s || Dc(i.checked) || i.checked === !0,
      children: u.jsx(Et.span, {
        "data-state": YX(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: e,
        style: { pointerEvents: "none", ...n.style },
      }),
    });
  });
qX.displayName = GX;
var WX = "CheckboxBubbleInput",
  KX = E.forwardRef(({ __scopeCheckbox: n, ...e }, t) => {
    const {
        control: s,
        hasConsumerStoppedPropagationRef: r,
        checked: i,
        defaultChecked: a,
        required: o,
        disabled: l,
        name: c,
        value: h,
        form: m,
        bubbleInput: p,
        setBubbleInput: g,
      } = dM(WX, n),
      y = Nt(t, g),
      b = GE(i),
      w = IE(s);
    E.useEffect(() => {
      const A = p;
      if (!A) return;
      const _ = window.HTMLInputElement.prototype,
        C = Object.getOwnPropertyDescriptor(_, "checked").set,
        D = !r.current;
      if (b !== i && C) {
        const L = new Event("click", { bubbles: D });
        (A.indeterminate = Dc(i)),
          C.call(A, Dc(i) ? !1 : i),
          A.dispatchEvent(L);
      }
    }, [p, b, i, r]);
    const S = E.useRef(Dc(i) ? !1 : i);
    return u.jsx(Et.input, {
      type: "checkbox",
      "aria-hidden": !0,
      defaultChecked: a ?? S.current,
      required: o,
      disabled: l,
      name: c,
      value: h,
      form: m,
      ...e,
      tabIndex: -1,
      ref: y,
      style: {
        ...e.style,
        ...w,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0,
        transform: "translateX(-100%)",
      },
    });
  });
KX.displayName = WX;
function kDe(n) {
  return typeof n == "function";
}
function Dc(n) {
  return n === "indeterminate";
}
function YX(n) {
  return Dc(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
const SI = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(hM, {
    ref: t,
    className: Le(
      "peer h-4 w-4 shrink-0 rounded-sm border border-white/30 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      n
    ),
    ...e,
    children: u.jsx(qX, {
      className: Le("flex items-center justify-center text-current"),
      children: u.jsx(zs, { className: "h-4 w-4" }),
    }),
  })
);
SI.displayName = hM.displayName;
const CDe = ({
    flask: n,
    isOpen: e,
    onClose: t,
    currentAssetIndex: s,
    hasEditingPermissions: r,
    isCreator: i,
    onAccessLevelChange: a,
  }) => {
    const [o, l] = E.useState("Copy Link to Flask"),
      [c, h] = E.useState(n?.access_level || "private"),
      [m, p] = E.useState(!0),
      [g, y] = E.useState(!0),
      b = vn(),
      { filterMode: w, activeFilterTags: S } = b,
      A = b.isFilteringActive();
    de.useEffect(() => {
      h(n?.access_level || "private");
    }, [n?.access_level]);
    const _ = [
        {
          value: "public",
          Icon: cle,
          title: "Anyone with Link can edit",
          description:
            "Anyone with Link can collaborate (they don't need to be part of your Flask team)",
        },
        {
          value: "viewonly",
          Icon: lle,
          title: "Anyone with Link can view",
          description: "Anyone with Link can view, creator can edit",
        },
        {
          value: "private",
          Icon: hle,
          title: "Secret",
          description: "Only creator view and edit.",
        },
      ],
      R = () => {
        if (!n) return "";
        const D = new URL(window.location.href),
          L = new URLSearchParams(D.search);
        m || L.delete("asset"),
          g || (L.delete("includeTags"), L.delete("excludeTags"));
        const P = `https://flask.do/flask/${n.id}`,
          V = L.toString();
        return V ? `${P}?${V}` : P;
      },
      C = () => {
        const D = R();
        !D ||
          !n ||
          navigator.clipboard
            .writeText(D)
            .then(() => {
              C0e({
                flask_id: n.id,
                share_method: "copy_link",
                current_visibility: "unknown",
                user_role: r ? "editor" : "viewer",
              });
            })
            .catch((L) => {
              console.error("Failed to copy link: ", L);
            });
      };
    return u.jsx(os, {
      open: e,
      onOpenChange: t,
      children: u.jsx(Jn, {
        className: "sm:max-w-md p-0",
        children: u.jsxs("div", {
          className: "p-6",
          children: [
            u.jsx(bs, {
              className: "mb-2",
              children: u.jsxs(xs, {
                className: "flex items-center justify-between mb-4",
                children: [
                  u.jsx("span", {
                    className: "text-lg font-semibold",
                    children: "Share this Flask",
                  }),
                  u.jsxs("div", {
                    className:
                      "button-primary flex items-center rounded-xl overflow-hidden",
                    children: [
                      u.jsxs("div", {
                        onClick: () => {
                          C(),
                            l("Link copied!"),
                            setTimeout(() => {
                              l("Copy Link to Flask");
                            }, 2e3);
                        },
                        className:
                          "flex items-center justify-center px-4 py-2 cursor-pointer text-sm font-medium",
                        children: [
                          u.jsx(dle, {
                            className: "w-4 h-4 mr-2 font-semibolds",
                          }),
                          u.jsx("span", { children: o }),
                        ],
                      }),
                      u.jsxs(Ii, {
                        children: [
                          u.jsx(Li, {
                            asChild: !0,
                            children: u.jsx("div", {
                              className:
                                "flex items-center justify-center px-2 py-2 cursor-pointer text-sm font-medium h-full border-l border-white/20",
                              children: u.jsx(cd, { className: "w-4 h-4" }),
                            }),
                          }),
                          u.jsx(ui, {
                            align: "end",
                            className: "w-64",
                            children: u.jsxs("div", {
                              className: "p-2 space-y-3",
                              children: [
                                u.jsx("p", {
                                  className:
                                    "text-xs font-medium text-white/60 px-2",
                                  children: "Link Options",
                                }),
                                u.jsxs("div", {
                                  className: `flex items-center space-x-2 px-2 py-1.5 hover:bg-white/5 rounded ${
                                    A
                                      ? "cursor-pointer"
                                      : "opacity-50 cursor-not-allowed"
                                  }`,
                                  children: [
                                    u.jsx(SI, {
                                      id: "include-filters-dropdown",
                                      checked: g,
                                      disabled: !A,
                                      onCheckedChange: (D) => y(D === !0),
                                    }),
                                    u.jsxs("label", {
                                      htmlFor: "include-filters-dropdown",
                                      className: `text-sm text-white/90 ${
                                        A
                                          ? "cursor-pointer"
                                          : "cursor-not-allowed"
                                      }`,
                                      children: [
                                        "Include Current Filters in Link",
                                        !A &&
                                          u.jsx("span", {
                                            className:
                                              "text-xs text-white/50 block",
                                            children: "(No active filters)",
                                          }),
                                      ],
                                    }),
                                  ],
                                }),
                                u.jsxs("div", {
                                  className: `flex items-center space-x-2 px-2 py-1.5 hover:bg-white/5 rounded ${
                                    s > 0
                                      ? "cursor-pointer"
                                      : "opacity-50 cursor-not-allowed"
                                  }`,
                                  children: [
                                    u.jsx(SI, {
                                      id: "include-asset-dropdown",
                                      checked: m,
                                      disabled: s === 0,
                                      onCheckedChange: (D) => p(D === !0),
                                    }),
                                    u.jsxs("label", {
                                      htmlFor: "include-asset-dropdown",
                                      className: `text-sm text-white/90 ${
                                        s > 0
                                          ? "cursor-pointer"
                                          : "cursor-not-allowed"
                                      }`,
                                      children: [
                                        "Link to this Asset",
                                        s === 0 &&
                                          u.jsx("span", {
                                            className:
                                              "text-xs text-white/50 block",
                                            children: "(On first asset)",
                                          }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            }),
            u.jsxs("div", {
              className: "space-y-4",
              children: [
                u.jsx("p", {
                  className: "text-sm font-medium text-white/90",
                  children: "Flask Permissions",
                }),
                u.jsx("div", {
                  className: "space-y-1.5",
                  children: _.map((D) =>
                    u.jsx(
                      "button",
                      {
                        onClick: () => {
                          i &&
                            a &&
                            (h(D.value),
                            a(D.value),
                            Ms({ title: "Permissions updated" }));
                        },
                        disabled: !i || !a,
                        className: `w-full p-3 rounded-md transition-all text-left ${
                          c === D.value
                            ? "bg-card-background border-b border-border/50"
                            : ""
                        } ${
                          i && a
                            ? "hover:bg-white/10 cursor-pointer"
                            : "opacity-50 cursor-not-allowed"
                        }`,
                        children: u.jsx("div", {
                          className: "flex items-start gap-3",
                          children: u.jsxs("div", {
                            children: [
                              u.jsx("p", {
                                className: "font-xl text-white text-sm",
                                children: D.title,
                              }),
                              u.jsx("p", {
                                className: "text-xs text-white/60",
                                children: D.description,
                              }),
                            ],
                          }),
                        }),
                      },
                      D.value
                    )
                  ),
                }),
                !i &&
                  u.jsx("p", {
                    className: "text-xs text-center text-white/50 mt-4",
                    children: "Only the flask creator can change permissions",
                  }),
              ],
            }),
          ],
        }),
      }),
    });
  },
  IDe = ({ hasEditingPermissions: n }) => {
    const {
        state: e,
        hasUnsavedChanges: t,
        hasActiveUploads: s,
        onRetry: r,
      } = T7(),
      i = on((g) => g.elements),
      a = Ce((g) => g.boardState.elements),
      o = de.useMemo(() => {
        if (Object.keys(i).length === 0) return !1;
        const g = Object.values(i).filter(
            (b) =>
              !(
                !a[b.id] ||
                !(b.state === "preparing" || b.state === "uploading") ||
                b.uploadProgress === 100
              )
          ),
          y = g.length > 0;
        return Object.keys(i).length, g.length, y;
      }, [i, a]);
    de.useEffect(() => {}, [e, t, s, o, i]);
    const [l, c] = de.useState(!1);
    E.useEffect(() => {
      const g =
          e === "syncing" ||
          e === "uploading" ||
          s ||
          o ||
          (e === "error" && t),
        y = (b) => {
          if (g) {
            b.preventDefault();
            const w =
              e === "uploading" || s || o
                ? "Video upload in progress. Leaving now will cancel the upload."
                : e === "syncing"
                ? "Save in progress. Leaving now may lose your changes."
                : "Your changes failed to save. Leaving now will lose your changes.";
            return (b.returnValue = w), w;
          }
        };
      return (
        g && window.addEventListener("beforeunload", y),
        () => {
          window.removeEventListener("beforeunload", y);
        }
      );
    }, [e, t, s, o]),
      E.useEffect(() => {
        e !== "error" && e !== "offline" && c(!1);
      }, [e]);
    const h = async (g) => {
      g.preventDefault(), g.stopPropagation(), c(!0);
      try {
        await r();
      } finally {
        c(!1);
      }
    };
    if (!n || !((e !== "idle" && e !== "synced") || o)) return null;
    const p = o || e === "uploading";
    return u.jsx(Br, {
      children: u.jsx("div", {
        className: "inline-flex items-center",
        children: u.jsxs("div", {
          className: `text-text-secondary text-xs flex items-center transition-all duration-200 gap-2 ${
            e === "error" || e === "offline"
              ? "py-1 px-2 rounded-md border border-amber-500/50 bg-amber-900/20"
              : p
              ? "py-1 px-2"
              : "w-6 h-6 justify-center rounded-full"
          } ${
            e === "syncing" || e === "uploading" || p ? "text-blue-500/50" : ""
          }`,
          children: [
            p &&
              u.jsxs(u.Fragment, {
                children: [
                  u.jsx("div", {
                    className:
                      "animate-spin h-4 w-4 rounded-full border-2 border-text-secondary border-t-transparent flex-shrink-0",
                  }),
                  u.jsx("div", {
                    className:
                      "text-[11px] text-text-secondary whitespace-nowrap",
                    children: ["Uploading", "recording.."].map((g, y) => {
                      const b = g.split("");
                      return u.jsx(
                        la.span,
                        {
                          className: "inline-block mr-[0.25em]",
                          initial: { opacity: 0, y: 5 },
                          animate: { opacity: 1, y: 0 },
                          transition: {
                            delay: y * 0.1,
                            duration: 0.3,
                            ease: "easeOut",
                          },
                          children: b.map((w, S) => {
                            const A =
                              ["Uploading", "recording.."].slice(0, y).join("")
                                .length + S;
                            return u.jsx(
                              la.span,
                              {
                                className: "inline-block",
                                animate: { opacity: [0.4, 1, 0.4] },
                                transition: {
                                  duration: 2,
                                  repeat: 1 / 0,
                                  ease: "easeInOut",
                                  delay: A * 0.1,
                                },
                                children: w,
                              },
                              `char-${y}-${S}`
                            );
                          }),
                        },
                        `upload-word-${y}`
                      );
                    }),
                  }),
                ],
              }),
            e === "syncing" &&
              !p &&
              u.jsxs(Xn, {
                delayDuration: 0,
                children: [
                  u.jsx(Qn, {
                    asChild: !0,
                    children: u.jsx("div", {
                      className:
                        "animate-spin h-4 w-4 rounded-full border-2 border-text-secondary border-t-transparent",
                    }),
                  }),
                  u.jsx(Pn, { children: u.jsx("p", { children: "Saving.." }) }),
                ],
              }),
            e === "offline" &&
              u.jsxs("div", {
                className: "flex items-center gap-2 w-full",
                children: [
                  u.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [
                      u.jsx(Lx, { className: "h-4 w-4 text-amber-400" }),
                      u.jsx("span", {
                        className: "text-amber-200",
                        children: t ? "Offline - changes pending" : "Offline",
                      }),
                    ],
                  }),
                  u.jsx(et, {
                    variant: "link",
                    onClick: h,
                    className:
                      "p-0 text-amber-300 hover:text-amber-100 underline h-auto ml-4 text-xs",
                    disabled: l,
                    children: l ? "Trying..." : "Try again",
                  }),
                ],
              }),
            e === "error" &&
              u.jsxs("div", {
                className: "flex items-center gap-2 w-full",
                children: [
                  u.jsxs("div", {
                    className: "flex items-center gap-2",
                    children: [
                      u.jsx(Lx, { className: "h-4 w-4 text-amber-400" }),
                      u.jsx("span", {
                        className: "text-amber-200",
                        children: t ? "Save failed" : "Connection error",
                      }),
                    ],
                  }),
                  u.jsx(et, {
                    variant: "link",
                    onClick: h,
                    className:
                      "p-0 text-amber-300 hover:text-amber-100 underline h-auto ml-4 text-xs",
                    disabled: l,
                    children: l ? "Retrying..." : "Try again",
                  }),
                ],
              }),
          ],
        }),
      }),
    });
  },
  LDe = ({
    flask: n,
    hasEditingPermissions: e = !1,
    isCreator: t = !1,
    onNameUpdate: s,
    onAccessLevelChange: r,
  }) => {
    const i = cD(),
      [a, o] = E.useState(!1),
      [l, c] = E.useState(n?.name || ""),
      [h, m] = E.useState(!1),
      [p, g] = E.useState(!1),
      [y, b] = E.useState(!1);
    de.useEffect(() => {
      c(n?.name || "");
    }, [n?.name]),
      AH();
    const { user: w } = ks(),
      S = Ce((C) => C.availableAssets),
      { currentAssetIndex: A } = dd(),
      _ = w ? "/dash" : "/",
      R = async () => {
        if (!n) return;
        const C = l.trim();
        if (C) {
          m(!0);
          try {
            (await WI(n.id, { name: C })) && (o(!1), s && s(C));
          } finally {
            m(!1);
          }
        }
      };
    return u.jsxs("div", {
      ref: i,
      className:
        "shared-nav w-full flex items-center justify-between pl-1 pt-0.5 md:pr-4 pr-2 -mb-4 text-white/80 transition-colors overflow-visible duration-200 z-50",
      children: [
        u.jsx("div", {
          className: "relative overflow-visible",
          children: u.jsx("div", {
            className:
              "flex items-center m-0 flex-shrink min-w-0 overflow-visible -mt-1 relative",
            children: n
              ? u.jsxs(u.Fragment, {
                  children: [
                    u.jsxs("div", {
                      className:
                        "outline-none transition-all duration-200 pl-3 pr-3 py-2 mt-1 rounded-full flex items-center gap-2 relative",
                      children: [
                        u.jsx(br, {
                          to: _,
                          className: "px-1 mb-1",
                          children: u.jsx(Ig, { size: "small" }),
                        }),
                        u.jsx("span", {
                          className:
                            "mb-1 text-lg px-1 pr-2 text-text-secondary/50",
                          children: "/",
                        }),
                        u.jsxs("div", {
                          className: "flex items-center gap-1",
                          children: [
                            u.jsxs(os, {
                              open: a,
                              onOpenChange: o,
                              children: [
                                t
                                  ? u.jsxs(Xn, {
                                      children: [
                                        u.jsx(Qn, {
                                          asChild: !0,
                                          children: u.jsx(Fde, {
                                            asChild: !0,
                                            children: u.jsx("button", {
                                              className:
                                                "h-7 text-sm element-border bg-element-background text-text-primary hover:text-text-secondary outline-none transition-all duration-200 cursor-pointer px-4 truncate max-w-[120px] sm:max-w-[180px] md:max-w-[400px] lg:max-w-[500px] text-left flex items-center",
                                              style: {
                                                borderTopLeftRadius: "18px",
                                                borderBottomLeftRadius: "18px",
                                                borderTopRightRadius: "4px",
                                                borderBottomRightRadius: "4px",
                                              },
                                              onClick: (C) => {
                                                C.stopPropagation();
                                              },
                                              disabled: !t,
                                              tabIndex: t ? 0 : -1,
                                              title: n.name || "Untitled Flask",
                                              children:
                                                n.name || "Untitled Flask",
                                            }),
                                          }),
                                        }),
                                        u.jsx(Pn, {
                                          children: u.jsx("p", {
                                            children: "Edit Flask Name",
                                          }),
                                        }),
                                      ],
                                    })
                                  : u.jsx("span", {
                                      className:
                                        "h-7 text-sm element-border bg-element-background text-text-secondary hover:text-text-primary outline-none transition-all duration-200 cursor-default pl-3 pr-3 truncate max-w-[120px] sm:max-w-[180px] md:max-w-[400px] lg:max-w-[500px] flex items-center ",
                                      title: n.name || "Untitled Flask",
                                      children: n.name || "Untitled Flask",
                                    }),
                                u.jsxs(Jn, {
                                  onOpenAutoFocus: (C) => {
                                    C.preventDefault();
                                  },
                                  children: [
                                    u.jsx(bs, {
                                      children: u.jsx(xs, {
                                        children: "Edit Flask Name",
                                      }),
                                    }),
                                    u.jsx(ta, {
                                      value: l,
                                      onChange: (C) => c(C.target.value),
                                      maxLength: 64,
                                      autoFocus: !0,
                                      placeholder: "Flask name",
                                      onKeyDown: (C) => {
                                        C.key === "Enter" && R();
                                      },
                                      disabled: h,
                                    }),
                                    u.jsxs(xr, {
                                      children: [
                                        u.jsx(et, {
                                          variant: "default",
                                          onClick: R,
                                          disabled: h || !l.trim(),
                                          children: h ? "Saving..." : "Save",
                                        }),
                                        u.jsx(et, {
                                          variant: "outline",
                                          onClick: () => o(!1),
                                          disabled: h,
                                          children: "Cancel",
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            }),
                            S &&
                              S.length > 0 &&
                              u.jsxs(Ii, {
                                open: y,
                                onOpenChange: b,
                                children: [
                                  u.jsx(Li, {
                                    asChild: !0,
                                    children: u.jsxs("button", {
                                      "data-asset-switcher-trigger": !0,
                                      className:
                                        "h-7 text-text-secondary bg-element-background element-border hover:text-text-primary outline-none transition-all duration-200 cursor-pointer flex items-center gap-1 whitespace-nowrap px-3 uppercase text-xs ",
                                      style: {
                                        borderTopLeftRadius: "4px",
                                        borderBottomLeftRadius: "4px",
                                        borderTopRightRadius: "18px",
                                        borderBottomRightRadius: "18px",
                                      },
                                      children: [
                                        u.jsx("span", {
                                          className: "text-white",
                                          children: A + 1,
                                        }),
                                        "/",
                                        S.length,
                                        u.jsx(IH, {
                                          className:
                                            "h-3.5 w-3.5 opacity-70 ml-1",
                                        }),
                                      ],
                                    }),
                                  }),
                                  u.jsx(wDe, { onOpenChange: b }),
                                ],
                              }),
                          ],
                        }),
                      ],
                    }),
                    u.jsx("div", {
                      className: "ml-2 flex items-center",
                      children: u.jsx(IDe, { hasEditingPermissions: e }),
                    }),
                  ],
                })
              : u.jsx(br, {
                  to: _,
                  title: w ? "Go to My Flasks" : "Flask Home",
                  children: u.jsx(Ig, { size: "small", className: "py-3" }),
                }),
          }),
        }),
        u.jsxs("div", {
          className: "flex items-center md:-mr-3 -mr-1 -mt-1 ",
          children: [
            n &&
              u.jsxs("div", {
                className: "flex items-center gap-3",
                children: [
                  u.jsx(Br, {
                    delayDuration: 0,
                    children: u.jsxs(Xn, {
                      delayDuration: 300,
                      children: [
                        u.jsx(Qn, {
                          asChild: !0,
                          children: u.jsx("a", {
                            href: "https://enritarta.notion.site/286abb4f34b78017ade3caa106f9ca9f?pvs=105",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            className:
                              "flex items-center justify-center h-[30px] w-[30px] cursor-pointer transition-all duration-200 ease-out overflow-hidden button-secondary rounded-full ",
                            children: u.jsx(gle, {
                              className: "h-4 w-4 flex-shrink-0",
                            }),
                          }),
                        }),
                        u.jsx(Pn, {
                          side: "bottom",
                          children: "Feedback / Support",
                        }),
                      ],
                    }),
                  }),
                  u.jsx("div", {
                    className: "h-[30px] mr-0.5 flex items-center",
                    children: u.jsx(Lk, { iconOnly: !0, fullHeightIcon: !0 }),
                  }),
                ],
              }),
            n &&
              u.jsx(Br, {
                delayDuration: 0,
                children: u.jsxs("div", {
                  className: "flex items-center ",
                  children: [
                    u.jsx("div", {
                      className:
                        "min-h-[2rem] h-[46px] text-text-secondary outline-none transition-all duration-200 px-2 py-1.5 flex items-center gap-2",
                      children: u.jsx("button", {
                        className:
                          "button-primary h-[30px] px-3.5 text-sm font-medium",
                        onClick: () => g(!0),
                        children: "Share",
                      }),
                    }),
                    n &&
                      u.jsx(CDe, {
                        flask: n,
                        isOpen: p,
                        onClose: () => g(!1),
                        currentAssetIndex: A,
                        hasEditingPermissions: e,
                        isCreator: t,
                        onAccessLevelChange: r,
                      }),
                  ],
                }),
              }),
            !n && u.jsx(Lk, {}),
          ],
        }),
      ],
    });
  };
function DDe(n) {
  const e = hn((r) => r.user),
    t = E.useRef(null),
    s = E.useRef(null);
  E.useEffect(() => {
    if (!(!n || !e?.id))
      return (
        (t.current = new Date().toISOString()),
        (s.current = setTimeout(async () => {
          try {
            const { error: r } = await Ds.from("asset_last_seen").upsert(
              { user_id: e.id, asset_id: n, last_seen_at: t.current },
              { onConflict: "user_id,asset_id" }
            );
            r && console.error("Failed to update asset last seen:", r);
          } catch (r) {
            console.error("Error tracking asset access:", r);
          }
        }, 3e4)),
        () => {
          s.current && clearTimeout(s.current);
        }
      );
  }, [n, e?.id]);
}
const PDe = ({
    flaskId: n,
    hasEditingPermissions: e,
    flask: t,
    isCreator: s,
    onAccessLevelChange: r,
    onReady: i,
    sharedNavProps: a,
  }) => {
    const o = Ce((j) => j.boardState),
      l = Ce((j) => j.isDataLoaded);
    Ce((j) => j.getAssetElement);
    const c = fl((j) => j.reset);
    E.useRef(null), E.useRef(!1);
    const { initialize: h, reset: m } = Z0e(),
      p = Be((j) => j.isReady),
      [g, y] = E.useState(Aie),
      b = E.useRef(null),
      [w, S] = E.useState(() => window.innerWidth < 768);
    E.useEffect(() => {
      const j = () => S(window.innerWidth < 768);
      return (
        window.addEventListener("resize", j),
        () => window.removeEventListener("resize", j)
      );
    }, []);
    const [A, _] = E.useState({
        width: typeof window < "u" ? window.innerWidth : 1920,
        height:
          typeof window < "u" ? window.innerHeight * ((100 - g) / 100) : 702,
      }),
      R = E.useRef(null);
    E.useEffect(() => {
      if (typeof window < "u") {
        const j = window.innerHeight * ((100 - g) / 100);
        _((Q) => ({ ...Q, height: j }));
      }
    }, [g]),
      E.useEffect(() => {
        if (((R.current = null), b.current)) {
          const j = b.current.getBoundingClientRect();
          (R.current = { width: j.width, height: j.height }),
            _({ width: j.width, height: j.height });
        }
      }, [n]),
      E.useEffect(() => {
        if (!R.current && b.current) {
          const j = b.current.getBoundingClientRect();
          (R.current = { width: j.width, height: j.height }),
            _({ width: j.width, height: j.height });
        }
      }, []),
      E.useEffect(() => {
        if (!b.current) return;
        const j = new ResizeObserver((Q) => {
          for (const M of Q) {
            const { width: I, height: F } = M.contentRect;
            _({ width: I, height: F }),
              R.current || (R.current = { width: I, height: F });
          }
        });
        return (
          j.observe(b.current),
          () => {
            j.disconnect();
          }
        );
      }, []),
      E.useEffect(() => {
        p && l && i && i();
      }, [p, l, i]);
    const C = Ce((j) => j.currentAssetId),
      D = Ce((j) => j.availableAssets);
    DDe(C);
    const L = E.useMemo(() => D.find((j) => j.id === C), [D, C]),
      P = E.useMemo(
        () => (L?.asset_type === "youtube" && L.youtube_url) || null,
        [L]
      ),
      V = E.useMemo(() => {
        if (L?.asset_type === "native" && L.status === "ready") return L;
      }, [L]),
      N = Be((j) => j.duration),
      W = Be((j) => j.handlePlayerReady),
      H = Be((j) => j.handleTimeUpdate),
      z = Be((j) => j.handleDurationChange),
      B = Be((j) => j.handlePlay),
      q = Be((j) => j.setMediaUrl),
      O = Be((j) => j.isMainAssetFullscreen);
    E.useEffect(() => {
      P ? q(P) : V?.hls_url ? q("native") : q(null);
    }, [P, V, q]),
      E.useMemo(() => {
        if (!N || N <= 0) return vF;
        const j = d8.find((I) => N >= I.minDuration && N < I.maxDuration),
          Q = j ? j.width : vF;
        return Object.values(o.elements).filter((I) =>
          !I || !I.links ? !1 : I.links.some((F) => F && F.type === "timeline")
        ).length > 16
          ? Math.min(Q * 2, 15e3)
          : Q;
      }, [N, o.elements]);
    const { currentAssetIndex: U } = dd();
    return (
      de.useLayoutEffect(
        () => (
          m(),
          c(),
          h(n, e, U),
          () => {
            m(), c();
          }
        ),
        [U]
      ),
      l
        ? u.jsxs(Kxe, {
            children: [
              u.jsxs("div", {
                className:
                  "w-full h-full flex flex-col overflow-hidden transition-all duration-300",
                style: {},
                children: [
                  !O && a && u.jsx(LDe, { ...a }),
                  u.jsx("div", {
                    className:
                      "flex-shrink-0 flex items-center justify-center relative",
                    style: { ...(w ? {} : { height: `${g}vh` }) },
                    children: u.jsx(yDe, {
                      youtubeUrl: P,
                      nativeAsset: V,
                      hasEditingPermissions: e,
                      playerHeightVh: g,
                      onPlayerReady: W,
                      onPlay: B,
                      onTimeUpdate: H,
                      onDurationChange: z,
                      onHeightResize: y,
                    }),
                  }),
                  !O &&
                    u.jsxs("div", {
                      ref: b,
                      className: "flex-1 relative overflow-hidden",
                      children: [
                        u.jsx("style", {
                          dangerouslySetInnerHTML: {
                            __html: `
                       html, body {
                         overflow: hidden !important;
                         height: 100vh !important;
                       }
                       .vjs-youtube iframe { pointer-events: auto !important; }
                       .video-js { outline: none !important; }
                       .video-js:focus { outline: none !important; }
                       `,
                          },
                        }),
                        l &&
                          u.jsx(
                            ATe,
                            {
                              flask: t,
                              hasEditingPermissions: e,
                              youtubeUrl: P,
                              nativeAsset: V,
                            },
                            `timeline-view-${n}`
                          ),
                        u.jsx(DTe, {}),
                        u.jsx(FLe, {}),
                      ],
                    }),
                  !O &&
                    l &&
                    u.jsx(LTe, {
                      hasEditingPermissions: e,
                      teamType: t?.team_type,
                    }),
                ],
              }),
              !O && l && u.jsx(pq, { hasEditingPermissions: e }),
              u.jsx(OLe, {}),
              O &&
                u.jsx(bDe, {
                  youtubeUrl: P,
                  nativeAsset: V,
                  hasEditingPermissions: e,
                }),
            ],
          })
        : null
    );
  },
  MDe = ({
    flaskId: n,
    hasEditingPermissions: e,
    flask: t,
    onUpdateFlaskName: s,
    onUpdateFlaskAccessLevel: r,
    onUpdateFlaskThumbnail: i,
    onReady: a,
    sharedNavProps: o,
  }) => {
    const { data: l } = N6({
      queryKey: ["flaskUrl", n],
      queryFn: async () => {
        const { data: c, error: h } = await Ds.from("flasks")
          .select(
            `
          assets(*)
        `
          )
          .eq("id", n)
          .single();
        return h ? null : c;
      },
      staleTime: 1 / 0,
      gcTime: 1 / 0,
    });
    return u.jsx(PDe, {
      flaskId: n,
      hasEditingPermissions: e,
      flask: t || l,
      isCreator: o?.isCreator,
      onAccessLevelChange: r,
      onReady: a,
      sharedNavProps: o,
    });
  },
  NDe = () => {
    const n = Be((K) => K.togglePlayPauseContextAware),
      e = Be((K) => K.seekForwardOneFrame),
      t = Be((K) => K.seekBackwardOneFrame),
      s = Be((K) => K.seekForwardTenFrames),
      r = Be((K) => K.seekBackwardTenFrames),
      i = Be((K) => K.increasePlaybackRate),
      a = Be((K) => K.decreasePlaybackRate),
      o = Be((K) => K.seek),
      l = Be((K) => K.duration),
      c = Be((K) => K.currentTime),
      h = Ce((K) => K.deleteElements);
    Ce((K) => K.setSelectedFrames);
    const m = Ce((K) => K.selectedFrames);
    Ce((K) => K.setBoardState), Ce((K) => K.deleteElementsWithConfirmation);
    const p = Ce((K) => K.createElementViaKeyboard),
      g = Ce((K) => K.clearSelection),
      y = Ce((K) => K.cycleToNextElement),
      b = Ce((K) => K.cycleToPreviousElement),
      w = Ce((K) => K.getClosestElementToViewportCenter);
    Ce((K) => K.selectElement);
    const S = Ce((K) => K.enterTextEditMode),
      A = Ce((K) => K.enterDescriptionEditMode),
      _ = Ce((K) => K.boardState),
      R = pt((K) => K.resetZoom),
      C = pt((K) => K.zoomIn),
      D = pt((K) => K.zoomOut),
      L = Ce((K) => K.hasEditingPermissions),
      P = hn((K) => K.user),
      V = fl((K) => K.shortcuts.enabled),
      N = fl((K) => K.isInInputElement),
      W = fl((K) => K.isInFullscreen),
      H = fl((K) => K.setInInputElement),
      z = fl((K) => K.setSpacePressed),
      B = fl((K) => K.setModifier),
      q = fl((K) => K.reset),
      O = Ce((K) => K.currentTextEditElementId),
      U = Ce((K) => K.exitTextEditMode),
      j = Ce((K) => K.updateElement),
      Q = on((K) => K.globalState),
      M = on((K) => K.activeRecordingElementId),
      I = on((K) => K.stopRecording),
      F = on((K) => K.cancelRecording),
      Y = vt((K) => K.state),
      J = vt((K) => K.replyToolbar.state),
      X = vt((K) => !!K.replyToolbar.threadId),
      Z = E.useRef(!1),
      te = E.useCallback(
        (K) => {
          if (!K) return !1;
          const ve =
            K instanceof HTMLInputElement ||
            K instanceof HTMLTextAreaElement ||
            (K instanceof HTMLElement && K.isContentEditable);
          return H(ve), ve;
        },
        [H]
      ),
      ce = E.useCallback(
        (K) => {
          const ve = document.querySelector(
            `[data-element-id="${K}"] [contenteditable]`
          );
          if (ve) {
            const Ee = ve.textContent || ve.innerText || "";
            ve.blur();
            const De = window.getSelection();
            De && De.removeAllRanges(), j(K, { content: Ee });
          }
          U();
        },
        [j, U]
      ),
      pe = E.useCallback(async () => {
        if (m.length === 0) return;
        m.find((ve) => ve === M && Q === "recording") ? F() : h(m);
      }, [m, M, Q, F, h]),
      se = E.useCallback(
        (K) => {
          if ((K.code === "KeyC" && K.target, !V)) {
            K.code;
            return;
          }
          B("ctrl", K.ctrlKey),
            B("alt", K.altKey),
            B("shift", K.shiftKey),
            B("meta", K.metaKey);
          const ve = K.metaKey || K.ctrlKey,
            Ee = K.altKey;
          if (ve || Ee) {
            K.code;
            return;
          }
          if (K.code === "Enter") {
            if (document.querySelector('[role="dialog"]')) return;
            if (Y === "recording") {
              K.preventDefault();
              const re = document.querySelector("[data-toolbar-stop-btn]");
              re && re.click();
              return;
            }
            if (J === "recording") {
              K.preventDefault();
              const re = document.querySelector(
                "[data-reply-toolbar-stop-btn]"
              );
              re && re.click();
              return;
            }
            if (Q === "recording" && M) {
              K.preventDefault(), I();
              return;
            }
            if (O) {
              if (K.shiftKey) return;
              K.preventDefault(), ce(O);
              return;
            }
            if (m.length > 0 && L) {
              if (N || Y === "focused" || J === "focused") return;
              const re = m[0],
                fe = _.elements[re];
              if (fe && !fe.links?.some((ke) => ke.type === "element")) {
                K.preventDefault();
                const ke = pt.getState();
                ke.enableThreadScrollOnHover(re),
                  vt.getState().setReplyThreadId(re),
                  vt.getState().enterReplyFocusedState(re),
                  setTimeout(() => {
                    ke.scrollThreadToBottom(re),
                      ke.notifyThreadHeightChanged(re);
                  }, 50);
                return;
              }
            }
          }
          if (K.code === "Escape") {
            if (document.querySelector('[role="dialog"]')) return;
            if (Y === "recording") {
              K.preventDefault();
              const re = document.querySelector("[data-toolbar-cancel-btn]");
              re && re.click();
              return;
            }
            if (J === "recording") {
              K.preventDefault();
              const re = document.querySelector(
                "[data-reply-toolbar-cancel-btn]"
              );
              re && re.click();
              return;
            }
            if (Q === "recording" && M) {
              K.preventDefault(), F();
              return;
            }
            if (O) {
              K.preventDefault(), ce(O);
              return;
            }
            if (Y === "focused") {
              K.preventDefault();
              const re = document.querySelector("[data-toolbar-textbox]");
              re && re.blur(),
                Lt(async () => {
                  const { useToolbarStore: fe } = await Promise.resolve().then(
                    () => So
                  );
                  return { useToolbarStore: fe };
                }, void 0).then(({ useToolbarStore: fe }) => {
                  const {
                    exitToIdle: ke,
                    setTextContent: ne,
                    exitElementLinking: ie,
                  } = fe.getState();
                  ne(""), ke(), ie();
                });
              return;
            }
            if (J === "focused") {
              K.preventDefault();
              const re = document.querySelector("[data-reply-toolbar-textbox]");
              re && re.blur(),
                Lt(async () => {
                  const { useToolbarStore: fe } = await Promise.resolve().then(
                    () => So
                  );
                  return { useToolbarStore: fe };
                }, void 0).then(({ useToolbarStore: fe }) => {
                  const { exitReplyToIdle: ke, setReplyTextContent: ne } =
                    fe.getState();
                  ne(""), ke();
                });
              return;
            }
            if (m.length > 0) {
              K.preventDefault(), g();
              return;
            }
          }
          const De = te(K.target);
          if (O) {
            K.code;
            return;
          }
          if (De) {
            K.code === "KeyC" && K.target;
            return;
          }
          if (W)
            switch (K.code) {
              case "Escape":
                return;
              case "Space":
              case "KeyK":
                K.code === "Space" && z(!0), K.preventDefault(), n();
                return;
              case "KeyJ":
                K.preventDefault(), a();
                return;
              case "KeyL":
                K.preventDefault(), i();
                return;
              case "ArrowLeft":
                if ((K.preventDefault(), K.shiftKey)) t();
                else {
                  const ge = Math.max(0, c - 5);
                  o(ge);
                }
                return;
              case "ArrowRight":
                if ((K.preventDefault(), K.shiftKey)) e();
                else {
                  const ge = Math.min(l, c + 5);
                  o(ge);
                }
                return;
              default:
                return;
            }
          switch ((K.code, K.code)) {
            case "Space":
            case "KeyK":
              K.code === "Space" && z(!0), K.preventDefault(), n();
              return;
            case "KeyJ":
              K.preventDefault(), a();
              return;
            case "KeyL":
              K.preventDefault(), i();
              return;
            case "ArrowLeft":
              if ((K.preventDefault(), K.shiftKey)) t();
              else {
                const fe = Math.max(0, c - 5);
                o(fe);
              }
              return;
            case "ArrowRight":
              if ((K.preventDefault(), K.shiftKey)) e();
              else {
                const fe = Math.min(l, c + 5);
                o(fe);
              }
              return;
            case "ArrowUp":
              if (m.length === 1) {
                K.preventDefault();
                const fe = m[0],
                  ne = Ce.getState().findRootElementInThread(fe);
                ne && pt.getState().scrollThreadToTop(ne);
                return;
              }
              return;
            case "ArrowDown":
              if (m.length === 1) {
                K.preventDefault();
                const fe = m[0],
                  ne = Ce.getState().findRootElementInThread(fe);
                ne && pt.getState().scrollThreadToBottom(ne);
                return;
              }
              return;
            case "Tab":
              if ((K.preventDefault(), K.shiftKey)) b();
              else {
                const fe = pt.getState(),
                  ke = fe.timelineScale > 1,
                  ne = m.length === 0;
                if ((fe.timelineScale, m.length, ne && ke)) {
                  const ie = w();
                  ie && tS(ie);
                } else y();
              }
              return;
            case "KeyZ":
              K.preventDefault(), R();
              return;
            case "Equal":
            case "NumpadAdd":
              K.preventDefault(), C();
              return;
            case "Minus":
            case "NumpadSubtract":
              K.preventDefault(), D();
              return;
            case "KeyE":
              if (!P || !L) return;
              if ((K.preventDefault(), m.length === 1)) {
                const fe = m[0],
                  ke = _.elements[fe];
                if (ke) {
                  if (ke.createdBy !== P.id) return;
                  ke.type === "text" ? S(fe) : ke.type === "recording" && A(fe);
                }
              }
              return;
            case "Backspace":
            case "Delete":
              K.preventDefault(), pe();
              return;
            case "KeyC":
              if (!P || !L) return;
              K.preventDefault(),
                X
                  ? Lt(async () => {
                      const { useToolbarStore: fe } =
                        await Promise.resolve().then(() => So);
                      return { useToolbarStore: fe };
                    }, void 0).then(({ useToolbarStore: fe }) => {
                      fe.getState().focusTextbox("reply");
                    })
                  : Lt(async () => {
                      const { useToolbarStore: fe } =
                        await Promise.resolve().then(() => So);
                      return { useToolbarStore: fe };
                    }, void 0).then(({ useToolbarStore: fe }) => {
                      fe.getState().focusTextbox("timeline");
                    });
              return;
            case "KeyS":
              if (!P || !L) return;
              K.preventDefault();
              const ge = document.querySelector("[data-toolbar-screen-btn]");
              ge && ge.click();
              return;
            case "KeyR":
              if (!P || !L) return;
              K.preventDefault();
              const re = document.querySelector("[data-toolbar-thoughts-btn]");
              re && re.click();
              return;
          }
        },
        [
          V,
          B,
          Q,
          M,
          I,
          Y,
          J,
          X,
          O,
          y,
          b,
          R,
          C,
          D,
          ce,
          te,
          z,
          n,
          i,
          a,
          e,
          t,
          s,
          r,
          o,
          l,
          c,
          pe,
          p,
          P,
          L,
          g,
          m,
          F,
          S,
          A,
          _,
          W,
        ]
      ),
      be = E.useCallback(
        (K) => {
          V &&
            (B("ctrl", K.ctrlKey),
            B("alt", K.altKey),
            B("shift", K.shiftKey),
            B("meta", K.metaKey),
            K.code === "Space" && z(!1));
        },
        [V, B, z]
      );
    return (
      E.useEffect(() => {
        if (!(!V || Z.current))
          return (
            window.addEventListener("keydown", se),
            window.addEventListener("keyup", be),
            (Z.current = !0),
            () => {
              window.removeEventListener("keydown", se),
                window.removeEventListener("keyup", be),
                (Z.current = !1),
                q();
            }
          );
      }, [V, se, be, q, P, L]),
      E.useEffect(() => {
        !V &&
          Z.current &&
          (window.removeEventListener("keydown", se),
          window.removeEventListener("keyup", be),
          (Z.current = !1),
          q());
      }, [V, se, be, q]),
      {
        shortcuts: [
          {
            key: "Enter",
            description: O
              ? "Save text and exit edit mode"
              : Q === "recording"
              ? "Stop recording"
              : "Context-dependent action",
          },
          {
            key: "Shift+Enter",
            description: O ? "New line in text" : "Not available",
          },
          {
            key: "Escape",
            description: O
              ? "Save text and exit edit mode"
              : m.length > 0
              ? "Clear selection"
              : "Exit current mode",
          },
          { key: "Space", description: "Play/pause media" },
          { key: "Left Arrow", description: "Go back 5 seconds" },
          { key: "Right Arrow", description: "Go forward 5 seconds" },
          { key: "Shift+Left Arrow", description: "Go back 1 frame" },
          { key: "Shift+Right Arrow", description: "Go forward 1 frame" },
          { key: "Tab", description: "Cycle to next timeline element" },
          {
            key: "Shift+Tab",
            description: "Cycle to previous timeline element",
          },
          { key: "Z", description: "Reset zoom to 1x" },
          { key: "E", description: "Edit selected element" },
          { key: "Backspace/Delete", description: "Delete selected elements" },
          { key: "C", description: "Create new Note element" },
          { key: "S", description: "Create new Screen recording element" },
          { key: "R", description: "Create new Thoughts recording element" },
        ],
      }
    );
  },
  ODe = E.createContext(void 0),
  jDe = ({ children: n }) => {
    const {
        user: e,
        profile: t,
        isLoading: s,
        signInWithGoogle: r,
        signOut: i,
        fetchProfile: a,
      } = hn(),
      [o, l] = E.useState(!1);
    E.useEffect(() => {
      (async () => {
        await hn.getState().initialize(), l(!0);
      })();
    }, []);
    const c = {
      user: e,
      profile: t,
      isLoading: s || !o,
      isAuthenticated: !!e,
      signInWithGoogle: r,
      signOut: i,
      refreshProfile: async () => {
        await a(e?.id || "");
      },
    };
    return u.jsx(ODe.Provider, { value: c, children: n });
  },
  FDe = ({ flaskName: n }) => {
    const [e, t] = E.useState(!1),
      [s, r] = E.useState(!1);
    return (
      E.useEffect(() => {
        if (n) {
          const i = setTimeout(() => r(!0), 50);
          return () => clearTimeout(i);
        }
      }, [n]),
      u.jsxs(u.Fragment, {
        children: [
          u.jsx("style", {
            children: `
        @keyframes progress-bar {
          0% {
            transform: translateX(-100%);
          }
          100% {
            transform: translateX(100%);
          }
        }
        .progress-bar {
          animation: progress-bar 1.5s ease-in-out infinite;
        }

        @keyframes flask-shake {
          0%, 100% {
            transform: rotate(0deg);
          }
          10% {
            transform: rotate(-8deg);
          }
          20% {
            transform: rotate(8deg);
          }
          30% {
            transform: rotate(-8deg);
          }
          40% {
            transform: rotate(8deg);
          }
          50% {
            transform: rotate(-4deg);
          }
          60% {
            transform: rotate(4deg);
          }
          70% {
            transform: rotate(0deg);
          }
        }

        .flask-shake-animation {
          animation: flask-shake 2s ease-in-out infinite 1s;
        }

        @keyframes fade-in-up {
          from {
            opacity: 0;
            transform: translateY(1rem);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .fade-in-up {
          animation: fade-in-up 0.6s ease-out forwards;
        }

        .fade-in-and-shake {
          animation: fade-in-up 0.6s ease-out forwards, flask-shake 2s ease-in-out infinite 0.1s;
        }

        .fade-in-delayed {
          opacity: 0;
          animation: fade-in-up 0.4s ease-out forwards;
        }
      `,
          }),
          u.jsxs("div", {
            className:
              "absolute inset-0 flex flex-col items-center justify-center",
            children: [
              u.jsxs("div", {
                className: "flex flex-col items-center gap-8",
                children: [
                  u.jsxs("div", {
                    className: "flex h-[128px] items-center mb-1 relative",
                    children: [
                      u.jsx("p", {
                        className:
                          "text-text-primary/85 text-bold tracking-[-0.075em] text-[64px] font-bold fade-in-up relative z-0",
                        children: "Flask",
                      }),
                      u.jsx("img", {
                        src: "/images/flasklogo.png",
                        alt: "Flask Logo",
                        className: `h-[128px] object-contain absolute left-6 mb-0 z-10 ${
                          e ? "opacity-90 fade-in-and-shake" : "opacity-0"
                        }`,
                        onLoad: () => t(!0),
                      }),
                    ],
                  }),
                  u.jsx("div", {
                    className:
                      "w-48 h-1 bg-text-primary/30 rounded-full overflow-hidden",
                    children: u.jsx("div", {
                      className:
                        "h-full w-1/3 bg-text-primary/60 rounded-full progress-bar",
                    }),
                  }),
                ],
              }),
              u.jsx("div", {
                className:
                  "absolute top-8 left-0 right-0 flex justify-center h-8",
                children:
                  n &&
                  s &&
                  u.jsxs("p", {
                    className:
                      "text-text-secondary text-xs font-medium fade-in-delayed",
                    children: [
                      u.jsx("span", {
                        className: "text-text-primary",
                        children: "Opening Flask ",
                      }),
                      "    ",
                      n,
                    ],
                  }),
              }),
            ],
          }),
        ],
      })
    );
  },
  UDe = () => {
    const { id: n } = p6();
    es();
    const [e, t] = od(),
      s = P6(),
      { user: r, signInWithGoogle: i, isLoading: a } = ks();
    W0e(), NDe();
    const { data: o, isLoading: l, error: c } = k0e(n),
      [h, m] = E.useState(o?.flask || null),
      [p, g] = E.useState(0),
      [y, b] = E.useState(!1),
      [w, S] = E.useState(() => window.innerWidth < 768),
      [A, _] = E.useState(!0),
      [R, C] = E.useState(!1),
      [D, L] = E.useState(!1);
    de.useEffect(() => {
      o?.flask && m(o.flask);
    }, [o?.flask]),
      E.useEffect(() => {
        o?.flask &&
          n &&
          (r
            ? Bt.capture("flask_opened", {
                flask_id: n,
                flask_name: o.flask.name,
                access_level: o.flask.access_level,
                has_edit_access: o.hasEditAccess,
                is_owner: o.isOwner,
              })
            : Bt.capture("flask_viewed_anonymous", {
                flask_id: n,
                flask_name: o.flask.name,
                access_level: o.flask.access_level,
              }));
      }, [o?.flask, n, r]),
      E.useEffect(() => {
        const j = e.get("asset");
        if (j && o?.flask?.assets) {
          const Q = parseInt(j, 10),
            M = o.flask.assets.length;
          !isNaN(Q) && Q > 0 && Q <= M
            ? g(Q - 1)
            : (g(0), j && (e.delete("asset"), t(e, { replace: !0 })));
        } else g(0);
      }, [e, o?.flask?.assets, t]),
      E.useEffect(() => {
        const j = () => S(window.innerWidth < 768);
        return (
          window.addEventListener("resize", j),
          () => window.removeEventListener("resize", j)
        );
      }, []),
      E.useEffect(() => {
        if (w && o?.flask) {
          const j = setTimeout(() => {
            b(!0);
          }, 2e3);
          return () => clearTimeout(j);
        }
      }, [w, !!o?.flask]),
      de.useEffect(
        () => (
          h?.name
            ? (document.title = `${h.name} | Flask`)
            : (document.title = "Flask"),
          () => {
            document.title = "Flask";
          }
        ),
        [h?.name]
      );
    const P = E.useCallback(async () => {
        try {
          const j = window.location.pathname;
          await i(j);
        } catch (j) {
          console.error("Google auth error:", j),
            Xe.error("Authentication failed. Please try again.");
        }
      }, [i]),
      V = E.useCallback((j) => {
        m((Q) => (Q ? { ...Q, name: j } : null));
      }, []),
      N = E.useCallback(
        (j) => {
          g(j),
            j === 0 ? e.delete("asset") : e.set("asset", String(j + 1)),
            t(e, { replace: !0 });
        },
        [e, t]
      ),
      W = E.useCallback(
        async (j) => {
          const Q = o?.flask,
            M = o?.hasEditAccess;
          if (!(!Q || !M))
            try {
              await WI(Q.id, { access_level: j }),
                m((I) => (I ? { ...I, access_level: j } : null)),
                s.invalidateQueries({ queryKey: ["flask-access", n] }),
                Xe.success(`Flask is now ${j}`);
            } catch {
              Xe.error("Failed to update access level");
            }
        },
        [o, n, s]
      ),
      H = a || l || !o,
      z = o?.flask,
      B = o?.hasEditAccess || !1,
      q = o?.isOwner || !1,
      O = E.useCallback(() => {
        C(!0),
          setTimeout(() => {
            L(!0), setTimeout(() => _(!1), 1e3);
          }, 500);
      }, []),
      U = de.useMemo(
        () => ({
          flask: h,
          hasEditingPermissions: B,
          isCreator: q,
          onNameUpdate: V,
          onAccessLevelChange: W,
        }),
        [h, B, q, V, W]
      );
    return !H && o?.error
      ? u.jsx(J3, { error: o.error, accessLevel: o.accessLevel, onSignIn: P })
      : !H && !z
      ? u.jsx(J3, { error: "not-found", onSignIn: P })
      : u.jsxs(jDe, {
          children: [
            z && u.jsx(sV, { ...$ce(z.name, n) }),
            A &&
              u.jsx("div", {
                className: `fixed inset-0 z-[100] bg-card-background transition-transform duration-1000 ease-in-out ${
                  D ? "transform -translate-y-full" : "transform translate-y-0"
                }`,
                children: u.jsx(FDe, { flaskName: z?.name }),
              }),
            (z || H) &&
              u.jsxs(Iye, {
                flask: h || z,
                flaskId: n,
                hasEditingPermissions: B,
                isCreator: q,
                accessLevel: z?.access_level || null,
                onUpdateFlaskName: V,
                onUpdateFlaskAccessLevel: W,
                onUpdateFlaskThumbnail: () => {},
                currentAssetIndex: p,
                onAssetChange: N,
                children: [
                  u.jsx("div", {
                    className: "h-screen overflow-hidden text-white",
                    children:
                      z &&
                      u.jsx(HL, {
                        delayDuration: 0,
                        children: u.jsx(
                          MDe,
                          {
                            flaskId: n,
                            hasEditingPermissions: B,
                            flask: z,
                            onUpdateFlaskName: V,
                            onUpdateFlaskAccessLevel: W,
                            onUpdateFlaskThumbnail: () => {},
                            onReady: O,
                            sharedNavProps: U,
                          },
                          n
                        ),
                      }),
                  }),
                  u.jsx(S7, { isOpen: y, onClose: () => b(!1) }),
                ],
              }),
          ],
        });
  };
function $De() {
  return u.jsx(UDe, {});
}
const ar = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("div", {
    ref: t,
    className: Le(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      n
    ),
    ...e,
  })
);
ar.displayName = "Card";
const si = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("div", {
    ref: t,
    className: Le("flex flex-col space-y-1.5 p-6", n),
    ...e,
  })
);
si.displayName = "CardHeader";
const Ti = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("h3", {
    ref: t,
    className: Le("text-2xl font-semibold leading-none tracking-tight", n),
    ...e,
  })
);
Ti.displayName = "CardTitle";
const Ca = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("p", {
    ref: t,
    className: Le("text-sm text-muted-foreground", n),
    ...e,
  })
);
Ca.displayName = "CardDescription";
const or = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("div", { ref: t, className: Le("p-6 pt-0", n), ...e })
);
or.displayName = "CardContent";
const TI = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx("div", { ref: t, className: Le("flex items-center p-6 pt-0", n), ...e })
);
TI.displayName = "CardFooter";
function vg(n) {
  let e = n[0],
    t = n[1],
    s = n[2];
  return Math.sqrt(e * e + t * t + s * s);
}
function _I(n, e) {
  return (n[0] = e[0]), (n[1] = e[1]), (n[2] = e[2]), n;
}
function BDe(n, e, t, s) {
  return (n[0] = e), (n[1] = t), (n[2] = s), n;
}
function N5(n, e, t) {
  return (n[0] = e[0] + t[0]), (n[1] = e[1] + t[1]), (n[2] = e[2] + t[2]), n;
}
function O5(n, e, t) {
  return (n[0] = e[0] - t[0]), (n[1] = e[1] - t[1]), (n[2] = e[2] - t[2]), n;
}
function HDe(n, e, t) {
  return (n[0] = e[0] * t[0]), (n[1] = e[1] * t[1]), (n[2] = e[2] * t[2]), n;
}
function VDe(n, e, t) {
  return (n[0] = e[0] / t[0]), (n[1] = e[1] / t[1]), (n[2] = e[2] / t[2]), n;
}
function $A(n, e, t) {
  return (n[0] = e[0] * t), (n[1] = e[1] * t), (n[2] = e[2] * t), n;
}
function zDe(n, e) {
  let t = e[0] - n[0],
    s = e[1] - n[1],
    r = e[2] - n[2];
  return Math.sqrt(t * t + s * s + r * r);
}
function GDe(n, e) {
  let t = e[0] - n[0],
    s = e[1] - n[1],
    r = e[2] - n[2];
  return t * t + s * s + r * r;
}
function j5(n) {
  let e = n[0],
    t = n[1],
    s = n[2];
  return e * e + t * t + s * s;
}
function qDe(n, e) {
  return (n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), n;
}
function WDe(n, e) {
  return (n[0] = 1 / e[0]), (n[1] = 1 / e[1]), (n[2] = 1 / e[2]), n;
}
function AI(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = t * t + s * s + r * r;
  return (
    i > 0 && (i = 1 / Math.sqrt(i)),
    (n[0] = e[0] * i),
    (n[1] = e[1] * i),
    (n[2] = e[2] * i),
    n
  );
}
function XX(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function F5(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = t[0],
    o = t[1],
    l = t[2];
  return (
    (n[0] = r * l - i * o), (n[1] = i * a - s * l), (n[2] = s * o - r * a), n
  );
}
function KDe(n, e, t, s) {
  let r = e[0],
    i = e[1],
    a = e[2];
  return (
    (n[0] = r + s * (t[0] - r)),
    (n[1] = i + s * (t[1] - i)),
    (n[2] = a + s * (t[2] - a)),
    n
  );
}
function YDe(n, e, t, s, r) {
  const i = Math.exp(-s * r);
  let a = e[0],
    o = e[1],
    l = e[2];
  return (
    (n[0] = t[0] + (a - t[0]) * i),
    (n[1] = t[1] + (o - t[1]) * i),
    (n[2] = t[2] + (l - t[2]) * i),
    n
  );
}
function XDe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = t[3] * s + t[7] * r + t[11] * i + t[15];
  return (
    (a = a || 1),
    (n[0] = (t[0] * s + t[4] * r + t[8] * i + t[12]) / a),
    (n[1] = (t[1] * s + t[5] * r + t[9] * i + t[13]) / a),
    (n[2] = (t[2] * s + t[6] * r + t[10] * i + t[14]) / a),
    n
  );
}
function QDe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = t[3] * s + t[7] * r + t[11] * i + t[15];
  return (
    (a = a || 1),
    (n[0] = (t[0] * s + t[4] * r + t[8] * i) / a),
    (n[1] = (t[1] * s + t[5] * r + t[9] * i) / a),
    (n[2] = (t[2] * s + t[6] * r + t[10] * i) / a),
    n
  );
}
function ZDe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2];
  return (
    (n[0] = s * t[0] + r * t[3] + i * t[6]),
    (n[1] = s * t[1] + r * t[4] + i * t[7]),
    (n[2] = s * t[2] + r * t[5] + i * t[8]),
    n
  );
}
function JDe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = t[0],
    o = t[1],
    l = t[2],
    c = t[3],
    h = o * i - l * r,
    m = l * s - a * i,
    p = a * r - o * s,
    g = o * p - l * m,
    y = l * h - a * p,
    b = a * m - o * h,
    w = c * 2;
  return (
    (h *= w),
    (m *= w),
    (p *= w),
    (g *= 2),
    (y *= 2),
    (b *= 2),
    (n[0] = s + h + g),
    (n[1] = r + m + y),
    (n[2] = i + p + b),
    n
  );
}
const ePe = (function () {
  const n = [0, 0, 0],
    e = [0, 0, 0];
  return function (t, s) {
    _I(n, t), _I(e, s), AI(n, n), AI(e, e);
    let r = XX(n, e);
    return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r);
  };
})();
function tPe(n, e) {
  return n[0] === e[0] && n[1] === e[1] && n[2] === e[2];
}
class Da extends Array {
  constructor(e = 0, t = e, s = e) {
    return super(e, t, s), this;
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  set x(e) {
    this[0] = e;
  }
  set y(e) {
    this[1] = e;
  }
  set z(e) {
    this[2] = e;
  }
  set(e, t = e, s = e) {
    return e.length ? this.copy(e) : (BDe(this, e, t, s), this);
  }
  copy(e) {
    return _I(this, e), this;
  }
  add(e, t) {
    return t ? N5(this, e, t) : N5(this, this, e), this;
  }
  sub(e, t) {
    return t ? O5(this, e, t) : O5(this, this, e), this;
  }
  multiply(e) {
    return e.length ? HDe(this, this, e) : $A(this, this, e), this;
  }
  divide(e) {
    return e.length ? VDe(this, this, e) : $A(this, this, 1 / e), this;
  }
  inverse(e = this) {
    return WDe(this, e), this;
  }
  len() {
    return vg(this);
  }
  distance(e) {
    return e ? zDe(this, e) : vg(this);
  }
  squaredLen() {
    return j5(this);
  }
  squaredDistance(e) {
    return e ? GDe(this, e) : j5(this);
  }
  negate(e = this) {
    return qDe(this, e), this;
  }
  cross(e, t) {
    return t ? F5(this, e, t) : F5(this, this, e), this;
  }
  scale(e) {
    return $A(this, this, e), this;
  }
  normalize() {
    return AI(this, this), this;
  }
  dot(e) {
    return XX(this, e);
  }
  equals(e) {
    return tPe(this, e);
  }
  applyMatrix3(e) {
    return ZDe(this, this, e), this;
  }
  applyMatrix4(e) {
    return XDe(this, this, e), this;
  }
  scaleRotateMatrix4(e) {
    return QDe(this, this, e), this;
  }
  applyQuaternion(e) {
    return JDe(this, this, e), this;
  }
  angle(e) {
    return ePe(this, e);
  }
  lerp(e, t) {
    return KDe(this, this, e, t), this;
  }
  smoothLerp(e, t, s) {
    return YDe(this, this, e, t, s), this;
  }
  clone() {
    return new Da(this[0], this[1], this[2]);
  }
  fromArray(e, t = 0) {
    return (this[0] = e[t]), (this[1] = e[t + 1]), (this[2] = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), e;
  }
  transformDirection(e) {
    const t = this[0],
      s = this[1],
      r = this[2];
    return (
      (this[0] = e[0] * t + e[4] * s + e[8] * r),
      (this[1] = e[1] * t + e[5] * s + e[9] * r),
      (this[2] = e[2] * t + e[6] * s + e[10] * r),
      this.normalize()
    );
  }
}
const U5 = new Da();
let nPe = 1,
  sPe = 1,
  $5 = !1;
class rPe {
  constructor(e, t = {}) {
    e.canvas || console.error("gl not passed as first argument to Geometry"),
      (this.gl = e),
      (this.attributes = t),
      (this.id = nPe++),
      (this.VAOs = {}),
      (this.drawRange = { start: 0, count: 0 }),
      (this.instancedCount = 0),
      this.gl.renderer.bindVertexArray(null),
      (this.gl.renderer.currentGeometry = null),
      (this.glState = this.gl.renderer.state);
    for (let s in t) this.addAttribute(s, t[s]);
  }
  addAttribute(e, t) {
    if (
      ((this.attributes[e] = t),
      (t.id = sPe++),
      (t.size = t.size || 1),
      (t.type =
        t.type ||
        (t.data.constructor === Float32Array
          ? this.gl.FLOAT
          : t.data.constructor === Uint16Array
          ? this.gl.UNSIGNED_SHORT
          : this.gl.UNSIGNED_INT)),
      (t.target =
        e === "index" ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER),
      (t.normalized = t.normalized || !1),
      (t.stride = t.stride || 0),
      (t.offset = t.offset || 0),
      (t.count =
        t.count ||
        (t.stride ? t.data.byteLength / t.stride : t.data.length / t.size)),
      (t.divisor = t.instanced || 0),
      (t.needsUpdate = !1),
      (t.usage = t.usage || this.gl.STATIC_DRAW),
      t.buffer || this.updateAttribute(t),
      t.divisor)
    ) {
      if (
        ((this.isInstanced = !0),
        this.instancedCount && this.instancedCount !== t.count * t.divisor)
      )
        return (
          console.warn(
            "geometry has multiple instanced buffers of different length"
          ),
          (this.instancedCount = Math.min(
            this.instancedCount,
            t.count * t.divisor
          ))
        );
      this.instancedCount = t.count * t.divisor;
    } else
      e === "index"
        ? (this.drawRange.count = t.count)
        : this.attributes.index ||
          (this.drawRange.count = Math.max(this.drawRange.count, t.count));
  }
  updateAttribute(e) {
    const t = !e.buffer;
    t && (e.buffer = this.gl.createBuffer()),
      this.glState.boundBuffer !== e.buffer &&
        (this.gl.bindBuffer(e.target, e.buffer),
        (this.glState.boundBuffer = e.buffer)),
      t
        ? this.gl.bufferData(e.target, e.data, e.usage)
        : this.gl.bufferSubData(e.target, 0, e.data),
      (e.needsUpdate = !1);
  }
  setIndex(e) {
    this.addAttribute("index", e);
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  setInstancedCount(e) {
    this.instancedCount = e;
  }
  createVAO(e) {
    (this.VAOs[e.attributeOrder] = this.gl.renderer.createVertexArray()),
      this.gl.renderer.bindVertexArray(this.VAOs[e.attributeOrder]),
      this.bindAttributes(e);
  }
  bindAttributes(e) {
    e.attributeLocations.forEach((t, { name: s, type: r }) => {
      if (!this.attributes[s]) {
        console.warn(`active attribute ${s} not being supplied`);
        return;
      }
      const i = this.attributes[s];
      this.gl.bindBuffer(i.target, i.buffer),
        (this.glState.boundBuffer = i.buffer);
      let a = 1;
      r === 35674 && (a = 2), r === 35675 && (a = 3), r === 35676 && (a = 4);
      const o = i.size / a,
        l = a === 1 ? 0 : a * a * 4,
        c = a === 1 ? 0 : a * 4;
      for (let h = 0; h < a; h++)
        this.gl.vertexAttribPointer(
          t + h,
          o,
          i.type,
          i.normalized,
          i.stride + l,
          i.offset + h * c
        ),
          this.gl.enableVertexAttribArray(t + h),
          this.gl.renderer.vertexAttribDivisor(t + h, i.divisor);
    }),
      this.attributes.index &&
        this.gl.bindBuffer(
          this.gl.ELEMENT_ARRAY_BUFFER,
          this.attributes.index.buffer
        );
  }
  draw({ program: e, mode: t = this.gl.TRIANGLES }) {
    this.gl.renderer.currentGeometry !== `${this.id}_${e.attributeOrder}` &&
      (this.VAOs[e.attributeOrder] || this.createVAO(e),
      this.gl.renderer.bindVertexArray(this.VAOs[e.attributeOrder]),
      (this.gl.renderer.currentGeometry = `${this.id}_${e.attributeOrder}`)),
      e.attributeLocations.forEach((r, { name: i }) => {
        const a = this.attributes[i];
        a.needsUpdate && this.updateAttribute(a);
      });
    let s = 2;
    this.attributes.index?.type === this.gl.UNSIGNED_INT && (s = 4),
      this.isInstanced
        ? this.attributes.index
          ? this.gl.renderer.drawElementsInstanced(
              t,
              this.drawRange.count,
              this.attributes.index.type,
              this.attributes.index.offset + this.drawRange.start * s,
              this.instancedCount
            )
          : this.gl.renderer.drawArraysInstanced(
              t,
              this.drawRange.start,
              this.drawRange.count,
              this.instancedCount
            )
        : this.attributes.index
        ? this.gl.drawElements(
            t,
            this.drawRange.count,
            this.attributes.index.type,
            this.attributes.index.offset + this.drawRange.start * s
          )
        : this.gl.drawArrays(t, this.drawRange.start, this.drawRange.count);
  }
  getPosition() {
    const e = this.attributes.position;
    if (e.data) return e;
    if (!$5)
      return (
        console.warn("No position buffer data found to compute bounds"),
        ($5 = !0)
      );
  }
  computeBoundingBox(e) {
    e || (e = this.getPosition());
    const t = e.data,
      s = e.size;
    this.bounds ||
      (this.bounds = {
        min: new Da(),
        max: new Da(),
        center: new Da(),
        scale: new Da(),
        radius: 1 / 0,
      });
    const r = this.bounds.min,
      i = this.bounds.max,
      a = this.bounds.center,
      o = this.bounds.scale;
    r.set(1 / 0), i.set(-1 / 0);
    for (let l = 0, c = t.length; l < c; l += s) {
      const h = t[l],
        m = t[l + 1],
        p = t[l + 2];
      (r.x = Math.min(h, r.x)),
        (r.y = Math.min(m, r.y)),
        (r.z = Math.min(p, r.z)),
        (i.x = Math.max(h, i.x)),
        (i.y = Math.max(m, i.y)),
        (i.z = Math.max(p, i.z));
    }
    o.sub(i, r), a.add(r, i).divide(2);
  }
  computeBoundingSphere(e) {
    e || (e = this.getPosition());
    const t = e.data,
      s = e.size;
    this.bounds || this.computeBoundingBox(e);
    let r = 0;
    for (let i = 0, a = t.length; i < a; i += s)
      U5.fromArray(t, i),
        (r = Math.max(r, this.bounds.center.squaredDistance(U5)));
    this.bounds.radius = Math.sqrt(r);
  }
  remove() {
    for (let e in this.VAOs)
      this.gl.renderer.deleteVertexArray(this.VAOs[e]), delete this.VAOs[e];
    for (let e in this.attributes)
      this.gl.deleteBuffer(this.attributes[e].buffer),
        delete this.attributes[e];
  }
}
let iPe = 1;
const B5 = {};
class aPe {
  constructor(
    e,
    {
      vertex: t,
      fragment: s,
      uniforms: r = {},
      transparent: i = !1,
      cullFace: a = e.BACK,
      frontFace: o = e.CCW,
      depthTest: l = !0,
      depthWrite: c = !0,
      depthFunc: h = e.LEQUAL,
    } = {}
  ) {
    e.canvas || console.error("gl not passed as first argument to Program"),
      (this.gl = e),
      (this.uniforms = r),
      (this.id = iPe++),
      t || console.warn("vertex shader not supplied"),
      s || console.warn("fragment shader not supplied"),
      (this.transparent = i),
      (this.cullFace = a),
      (this.frontFace = o),
      (this.depthTest = l),
      (this.depthWrite = c),
      (this.depthFunc = h),
      (this.blendFunc = {}),
      (this.blendEquation = {}),
      (this.stencilFunc = {}),
      (this.stencilOp = {}),
      this.transparent &&
        !this.blendFunc.src &&
        (this.gl.renderer.premultipliedAlpha
          ? this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA)
          : this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA)),
      (this.vertexShader = e.createShader(e.VERTEX_SHADER)),
      (this.fragmentShader = e.createShader(e.FRAGMENT_SHADER)),
      (this.program = e.createProgram()),
      e.attachShader(this.program, this.vertexShader),
      e.attachShader(this.program, this.fragmentShader),
      this.setShaders({ vertex: t, fragment: s });
  }
  setShaders({ vertex: e, fragment: t }) {
    if (
      (e &&
        (this.gl.shaderSource(this.vertexShader, e),
        this.gl.compileShader(this.vertexShader),
        this.gl.getShaderInfoLog(this.vertexShader) !== "" &&
          console.warn(`${this.gl.getShaderInfoLog(this.vertexShader)}
Vertex Shader
${H5(e)}`)),
      t &&
        (this.gl.shaderSource(this.fragmentShader, t),
        this.gl.compileShader(this.fragmentShader),
        this.gl.getShaderInfoLog(this.fragmentShader) !== "" &&
          console.warn(`${this.gl.getShaderInfoLog(this.fragmentShader)}
Fragment Shader
${H5(t)}`)),
      this.gl.linkProgram(this.program),
      !this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS))
    )
      return console.warn(this.gl.getProgramInfoLog(this.program));
    this.uniformLocations = new Map();
    let s = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);
    for (let a = 0; a < s; a++) {
      let o = this.gl.getActiveUniform(this.program, a);
      this.uniformLocations.set(
        o,
        this.gl.getUniformLocation(this.program, o.name)
      );
      const l = o.name.match(/(\w+)/g);
      (o.uniformName = l[0]), (o.nameComponents = l.slice(1));
    }
    this.attributeLocations = new Map();
    const r = [],
      i = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
    for (let a = 0; a < i; a++) {
      const o = this.gl.getActiveAttrib(this.program, a),
        l = this.gl.getAttribLocation(this.program, o.name);
      l !== -1 && ((r[l] = o.name), this.attributeLocations.set(o, l));
    }
    this.attributeOrder = r.join("");
  }
  setBlendFunc(e, t, s, r) {
    (this.blendFunc.src = e),
      (this.blendFunc.dst = t),
      (this.blendFunc.srcAlpha = s),
      (this.blendFunc.dstAlpha = r),
      e && (this.transparent = !0);
  }
  setBlendEquation(e, t) {
    (this.blendEquation.modeRGB = e), (this.blendEquation.modeAlpha = t);
  }
  setStencilFunc(e, t, s) {
    (this.stencilRef = t),
      (this.stencilFunc.func = e),
      (this.stencilFunc.ref = t),
      (this.stencilFunc.mask = s);
  }
  setStencilOp(e, t, s) {
    (this.stencilOp.stencilFail = e),
      (this.stencilOp.depthFail = t),
      (this.stencilOp.depthPass = s);
  }
  applyState() {
    this.depthTest
      ? this.gl.renderer.enable(this.gl.DEPTH_TEST)
      : this.gl.renderer.disable(this.gl.DEPTH_TEST),
      this.cullFace
        ? this.gl.renderer.enable(this.gl.CULL_FACE)
        : this.gl.renderer.disable(this.gl.CULL_FACE),
      this.blendFunc.src
        ? this.gl.renderer.enable(this.gl.BLEND)
        : this.gl.renderer.disable(this.gl.BLEND),
      this.cullFace && this.gl.renderer.setCullFace(this.cullFace),
      this.gl.renderer.setFrontFace(this.frontFace),
      this.gl.renderer.setDepthMask(this.depthWrite),
      this.gl.renderer.setDepthFunc(this.depthFunc),
      this.blendFunc.src &&
        this.gl.renderer.setBlendFunc(
          this.blendFunc.src,
          this.blendFunc.dst,
          this.blendFunc.srcAlpha,
          this.blendFunc.dstAlpha
        ),
      this.gl.renderer.setBlendEquation(
        this.blendEquation.modeRGB,
        this.blendEquation.modeAlpha
      ),
      this.stencilFunc.func || this.stencilOp.stencilFail
        ? this.gl.renderer.enable(this.gl.STENCIL_TEST)
        : this.gl.renderer.disable(this.gl.STENCIL_TEST),
      this.gl.renderer.setStencilFunc(
        this.stencilFunc.func,
        this.stencilFunc.ref,
        this.stencilFunc.mask
      ),
      this.gl.renderer.setStencilOp(
        this.stencilOp.stencilFail,
        this.stencilOp.depthFail,
        this.stencilOp.depthPass
      );
  }
  use({ flipFaces: e = !1 } = {}) {
    let t = -1;
    this.gl.renderer.state.currentProgram === this.id ||
      (this.gl.useProgram(this.program),
      (this.gl.renderer.state.currentProgram = this.id)),
      this.uniformLocations.forEach((r, i) => {
        let a = this.uniforms[i.uniformName];
        for (const o of i.nameComponents) {
          if (!a) break;
          if (o in a) a = a[o];
          else {
            if (Array.isArray(a.value)) break;
            a = void 0;
            break;
          }
        }
        if (!a) return V5(`Active uniform ${i.name} has not been supplied`);
        if (a && a.value === void 0)
          return V5(`${i.name} uniform is missing a value parameter`);
        if (a.value.texture)
          return (t = t + 1), a.value.update(t), BA(this.gl, i.type, r, t);
        if (a.value.length && a.value[0].texture) {
          const o = [];
          return (
            a.value.forEach((l) => {
              (t = t + 1), l.update(t), o.push(t);
            }),
            BA(this.gl, i.type, r, o)
          );
        }
        BA(this.gl, i.type, r, a.value);
      }),
      this.applyState(),
      e &&
        this.gl.renderer.setFrontFace(
          this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW
        );
  }
  remove() {
    this.gl.deleteProgram(this.program);
  }
}
function BA(n, e, t, s) {
  s = s.length ? oPe(s) : s;
  const r = n.renderer.state.uniformLocations.get(t);
  if (s.length)
    if (r === void 0 || r.length !== s.length)
      n.renderer.state.uniformLocations.set(t, s.slice(0));
    else {
      if (lPe(r, s)) return;
      r.set ? r.set(s) : cPe(r, s), n.renderer.state.uniformLocations.set(t, r);
    }
  else {
    if (r === s) return;
    n.renderer.state.uniformLocations.set(t, s);
  }
  switch (e) {
    case 5126:
      return s.length ? n.uniform1fv(t, s) : n.uniform1f(t, s);
    case 35664:
      return n.uniform2fv(t, s);
    case 35665:
      return n.uniform3fv(t, s);
    case 35666:
      return n.uniform4fv(t, s);
    case 35670:
    case 5124:
    case 35678:
    case 36306:
    case 35680:
    case 36289:
      return s.length ? n.uniform1iv(t, s) : n.uniform1i(t, s);
    case 35671:
    case 35667:
      return n.uniform2iv(t, s);
    case 35672:
    case 35668:
      return n.uniform3iv(t, s);
    case 35673:
    case 35669:
      return n.uniform4iv(t, s);
    case 35674:
      return n.uniformMatrix2fv(t, !1, s);
    case 35675:
      return n.uniformMatrix3fv(t, !1, s);
    case 35676:
      return n.uniformMatrix4fv(t, !1, s);
  }
}
function H5(n) {
  let e = n.split(`
`);
  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
  return e.join(`
`);
}
function oPe(n) {
  const e = n.length,
    t = n[0].length;
  if (t === void 0) return n;
  const s = e * t;
  let r = B5[s];
  r || (B5[s] = r = new Float32Array(s));
  for (let i = 0; i < e; i++) r.set(n[i], i * t);
  return r;
}
function lPe(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, s = n.length; t < s; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function cPe(n, e) {
  for (let t = 0, s = n.length; t < s; t++) n[t] = e[t];
}
let HA = 0;
function V5(n) {
  HA > 100 ||
    (console.warn(n),
    HA++,
    HA > 100 &&
      console.warn("More than 100 program warnings - stopping logs."));
}
const VA = new Da();
let uPe = 1;
class dPe {
  constructor({
    canvas: e = document.createElement("canvas"),
    width: t = 300,
    height: s = 150,
    dpr: r = 1,
    alpha: i = !1,
    depth: a = !0,
    stencil: o = !1,
    antialias: l = !1,
    premultipliedAlpha: c = !1,
    preserveDrawingBuffer: h = !1,
    powerPreference: m = "default",
    autoClear: p = !0,
    webgl: g = 2,
  } = {}) {
    const y = {
      alpha: i,
      depth: a,
      stencil: o,
      antialias: l,
      premultipliedAlpha: c,
      preserveDrawingBuffer: h,
      powerPreference: m,
    };
    (this.dpr = r),
      (this.alpha = i),
      (this.color = !0),
      (this.depth = a),
      (this.stencil = o),
      (this.premultipliedAlpha = c),
      (this.autoClear = p),
      (this.id = uPe++),
      g === 2 && (this.gl = e.getContext("webgl2", y)),
      (this.isWebgl2 = !!this.gl),
      this.gl || (this.gl = e.getContext("webgl", y)),
      this.gl || console.error("unable to create webgl context"),
      (this.gl.renderer = this),
      this.setSize(t, s),
      (this.state = {}),
      (this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO }),
      (this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD }),
      (this.state.cullFace = !1),
      (this.state.frontFace = this.gl.CCW),
      (this.state.depthMask = !0),
      (this.state.depthFunc = this.gl.LEQUAL),
      (this.state.premultiplyAlpha = !1),
      (this.state.flipY = !1),
      (this.state.unpackAlignment = 4),
      (this.state.framebuffer = null),
      (this.state.viewport = { x: 0, y: 0, width: null, height: null }),
      (this.state.textureUnits = []),
      (this.state.activeTextureUnit = 0),
      (this.state.boundBuffer = null),
      (this.state.uniformLocations = new Map()),
      (this.state.currentProgram = null),
      (this.extensions = {}),
      this.isWebgl2
        ? (this.getExtension("EXT_color_buffer_float"),
          this.getExtension("OES_texture_float_linear"))
        : (this.getExtension("OES_texture_float"),
          this.getExtension("OES_texture_float_linear"),
          this.getExtension("OES_texture_half_float"),
          this.getExtension("OES_texture_half_float_linear"),
          this.getExtension("OES_element_index_uint"),
          this.getExtension("OES_standard_derivatives"),
          this.getExtension("EXT_sRGB"),
          this.getExtension("WEBGL_depth_texture"),
          this.getExtension("WEBGL_draw_buffers")),
      this.getExtension("WEBGL_compressed_texture_astc"),
      this.getExtension("EXT_texture_compression_bptc"),
      this.getExtension("WEBGL_compressed_texture_s3tc"),
      this.getExtension("WEBGL_compressed_texture_etc1"),
      this.getExtension("WEBGL_compressed_texture_pvrtc"),
      this.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      (this.vertexAttribDivisor = this.getExtension(
        "ANGLE_instanced_arrays",
        "vertexAttribDivisor",
        "vertexAttribDivisorANGLE"
      )),
      (this.drawArraysInstanced = this.getExtension(
        "ANGLE_instanced_arrays",
        "drawArraysInstanced",
        "drawArraysInstancedANGLE"
      )),
      (this.drawElementsInstanced = this.getExtension(
        "ANGLE_instanced_arrays",
        "drawElementsInstanced",
        "drawElementsInstancedANGLE"
      )),
      (this.createVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "createVertexArray",
        "createVertexArrayOES"
      )),
      (this.bindVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "bindVertexArray",
        "bindVertexArrayOES"
      )),
      (this.deleteVertexArray = this.getExtension(
        "OES_vertex_array_object",
        "deleteVertexArray",
        "deleteVertexArrayOES"
      )),
      (this.drawBuffers = this.getExtension(
        "WEBGL_draw_buffers",
        "drawBuffers",
        "drawBuffersWEBGL"
      )),
      (this.parameters = {}),
      (this.parameters.maxTextureUnits = this.gl.getParameter(
        this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS
      )),
      (this.parameters.maxAnisotropy = this.getExtension(
        "EXT_texture_filter_anisotropic"
      )
        ? this.gl.getParameter(
            this.getExtension("EXT_texture_filter_anisotropic")
              .MAX_TEXTURE_MAX_ANISOTROPY_EXT
          )
        : 0);
  }
  setSize(e, t) {
    (this.width = e),
      (this.height = t),
      (this.gl.canvas.width = e * this.dpr),
      (this.gl.canvas.height = t * this.dpr),
      this.gl.canvas.style &&
        Object.assign(this.gl.canvas.style, {
          width: e + "px",
          height: t + "px",
        });
  }
  setViewport(e, t, s = 0, r = 0) {
    (this.state.viewport.width === e && this.state.viewport.height === t) ||
      ((this.state.viewport.width = e),
      (this.state.viewport.height = t),
      (this.state.viewport.x = s),
      (this.state.viewport.y = r),
      this.gl.viewport(s, r, e, t));
  }
  setScissor(e, t, s = 0, r = 0) {
    this.gl.scissor(s, r, e, t);
  }
  enable(e) {
    this.state[e] !== !0 && (this.gl.enable(e), (this.state[e] = !0));
  }
  disable(e) {
    this.state[e] !== !1 && (this.gl.disable(e), (this.state[e] = !1));
  }
  setBlendFunc(e, t, s, r) {
    (this.state.blendFunc.src === e &&
      this.state.blendFunc.dst === t &&
      this.state.blendFunc.srcAlpha === s &&
      this.state.blendFunc.dstAlpha === r) ||
      ((this.state.blendFunc.src = e),
      (this.state.blendFunc.dst = t),
      (this.state.blendFunc.srcAlpha = s),
      (this.state.blendFunc.dstAlpha = r),
      s !== void 0
        ? this.gl.blendFuncSeparate(e, t, s, r)
        : this.gl.blendFunc(e, t));
  }
  setBlendEquation(e, t) {
    (e = e || this.gl.FUNC_ADD),
      !(
        this.state.blendEquation.modeRGB === e &&
        this.state.blendEquation.modeAlpha === t
      ) &&
        ((this.state.blendEquation.modeRGB = e),
        (this.state.blendEquation.modeAlpha = t),
        t !== void 0
          ? this.gl.blendEquationSeparate(e, t)
          : this.gl.blendEquation(e));
  }
  setCullFace(e) {
    this.state.cullFace !== e &&
      ((this.state.cullFace = e), this.gl.cullFace(e));
  }
  setFrontFace(e) {
    this.state.frontFace !== e &&
      ((this.state.frontFace = e), this.gl.frontFace(e));
  }
  setDepthMask(e) {
    this.state.depthMask !== e &&
      ((this.state.depthMask = e), this.gl.depthMask(e));
  }
  setDepthFunc(e) {
    this.state.depthFunc !== e &&
      ((this.state.depthFunc = e), this.gl.depthFunc(e));
  }
  setStencilMask(e) {
    this.state.stencilMask !== e &&
      ((this.state.stencilMask = e), this.gl.stencilMask(e));
  }
  setStencilFunc(e, t, s) {
    (this.state.stencilFunc === e &&
      this.state.stencilRef === t &&
      this.state.stencilFuncMask === s) ||
      ((this.state.stencilFunc = e || this.gl.ALWAYS),
      (this.state.stencilRef = t || 0),
      (this.state.stencilFuncMask = s || 0),
      this.gl.stencilFunc(e || this.gl.ALWAYS, t || 0, s || 0));
  }
  setStencilOp(e, t, s) {
    (this.state.stencilFail === e &&
      this.state.stencilDepthFail === t &&
      this.state.stencilDepthPass === s) ||
      ((this.state.stencilFail = e),
      (this.state.stencilDepthFail = t),
      (this.state.stencilDepthPass = s),
      this.gl.stencilOp(e, t, s));
  }
  activeTexture(e) {
    this.state.activeTextureUnit !== e &&
      ((this.state.activeTextureUnit = e),
      this.gl.activeTexture(this.gl.TEXTURE0 + e));
  }
  bindFramebuffer({ target: e = this.gl.FRAMEBUFFER, buffer: t = null } = {}) {
    this.state.framebuffer !== t &&
      ((this.state.framebuffer = t), this.gl.bindFramebuffer(e, t));
  }
  getExtension(e, t, s) {
    return t && this.gl[t]
      ? this.gl[t].bind(this.gl)
      : (this.extensions[e] || (this.extensions[e] = this.gl.getExtension(e)),
        t
          ? this.extensions[e]
            ? this.extensions[e][s].bind(this.extensions[e])
            : null
          : this.extensions[e]);
  }
  sortOpaque(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.program.id !== t.program.id
      ? e.program.id - t.program.id
      : e.zDepth !== t.zDepth
      ? e.zDepth - t.zDepth
      : t.id - e.id;
  }
  sortTransparent(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.zDepth !== t.zDepth
      ? t.zDepth - e.zDepth
      : t.id - e.id;
  }
  sortUI(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.program.id !== t.program.id
      ? e.program.id - t.program.id
      : t.id - e.id;
  }
  getRenderList({ scene: e, camera: t, frustumCull: s, sort: r }) {
    let i = [];
    if (
      (t && s && t.updateFrustum(),
      e.traverse((a) => {
        if (!a.visible) return !0;
        a.draw &&
          ((s && a.frustumCulled && t && !t.frustumIntersectsMesh(a)) ||
            i.push(a));
      }),
      r)
    ) {
      const a = [],
        o = [],
        l = [];
      i.forEach((c) => {
        c.program.transparent
          ? c.program.depthTest
            ? o.push(c)
            : l.push(c)
          : a.push(c),
          (c.zDepth = 0),
          !(c.renderOrder !== 0 || !c.program.depthTest || !t) &&
            (c.worldMatrix.getTranslation(VA),
            VA.applyMatrix4(t.projectionViewMatrix),
            (c.zDepth = VA.z));
      }),
        a.sort(this.sortOpaque),
        o.sort(this.sortTransparent),
        l.sort(this.sortUI),
        (i = a.concat(o, l));
    }
    return i;
  }
  render({
    scene: e,
    camera: t,
    target: s = null,
    update: r = !0,
    sort: i = !0,
    frustumCull: a = !0,
    clear: o,
  }) {
    s === null
      ? (this.bindFramebuffer(),
        this.setViewport(this.width * this.dpr, this.height * this.dpr))
      : (this.bindFramebuffer(s), this.setViewport(s.width, s.height)),
      (o || (this.autoClear && o !== !1)) &&
        (this.depth &&
          (!s || s.depth) &&
          (this.enable(this.gl.DEPTH_TEST), this.setDepthMask(!0)),
        (this.stencil || !s || s.stencil) &&
          (this.enable(this.gl.STENCIL_TEST), this.setStencilMask(255)),
        this.gl.clear(
          (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |
            (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |
            (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)
        )),
      r && e.updateMatrixWorld(),
      t && t.updateMatrixWorld(),
      this.getRenderList({
        scene: e,
        camera: t,
        frustumCull: a,
        sort: i,
      }).forEach((c) => {
        c.draw({ camera: t });
      });
  }
}
function hPe(n, e) {
  return (n[0] = e[0]), (n[1] = e[1]), (n[2] = e[2]), (n[3] = e[3]), n;
}
function fPe(n, e, t, s, r) {
  return (n[0] = e), (n[1] = t), (n[2] = s), (n[3] = r), n;
}
function mPe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = t * t + s * s + r * r + i * i;
  return (
    a > 0 && (a = 1 / Math.sqrt(a)),
    (n[0] = t * a),
    (n[1] = s * a),
    (n[2] = r * a),
    (n[3] = i * a),
    n
  );
}
function pPe(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] * e[3];
}
function gPe(n) {
  return (n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 1), n;
}
function vPe(n, e, t) {
  t = t * 0.5;
  let s = Math.sin(t);
  return (
    (n[0] = s * e[0]),
    (n[1] = s * e[1]),
    (n[2] = s * e[2]),
    (n[3] = Math.cos(t)),
    n
  );
}
function z5(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = t[0],
    l = t[1],
    c = t[2],
    h = t[3];
  return (
    (n[0] = s * h + a * o + r * c - i * l),
    (n[1] = r * h + a * l + i * o - s * c),
    (n[2] = i * h + a * c + s * l - r * o),
    (n[3] = a * h - s * o - r * l - i * c),
    n
  );
}
function yPe(n, e, t) {
  t *= 0.5;
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = s * l + a * o),
    (n[1] = r * l + i * o),
    (n[2] = i * l - r * o),
    (n[3] = a * l - s * o),
    n
  );
}
function bPe(n, e, t) {
  t *= 0.5;
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = s * l - i * o),
    (n[1] = r * l + a * o),
    (n[2] = i * l + s * o),
    (n[3] = a * l - r * o),
    n
  );
}
function xPe(n, e, t) {
  t *= 0.5;
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = s * l + r * o),
    (n[1] = r * l - s * o),
    (n[2] = i * l + a * o),
    (n[3] = a * l - i * o),
    n
  );
}
function wPe(n, e, t, s) {
  let r = e[0],
    i = e[1],
    a = e[2],
    o = e[3],
    l = t[0],
    c = t[1],
    h = t[2],
    m = t[3],
    p,
    g,
    y,
    b,
    w;
  return (
    (g = r * l + i * c + a * h + o * m),
    g < 0 && ((g = -g), (l = -l), (c = -c), (h = -h), (m = -m)),
    1 - g > 1e-6
      ? ((p = Math.acos(g)),
        (y = Math.sin(p)),
        (b = Math.sin((1 - s) * p) / y),
        (w = Math.sin(s * p) / y))
      : ((b = 1 - s), (w = s)),
    (n[0] = b * r + w * l),
    (n[1] = b * i + w * c),
    (n[2] = b * a + w * h),
    (n[3] = b * o + w * m),
    n
  );
}
function EPe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = t * t + s * s + r * r + i * i,
    o = a ? 1 / a : 0;
  return (n[0] = -t * o), (n[1] = -s * o), (n[2] = -r * o), (n[3] = i * o), n;
}
function SPe(n, e) {
  return (n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), (n[3] = e[3]), n;
}
function TPe(n, e) {
  let t = e[0] + e[4] + e[8],
    s;
  if (t > 0)
    (s = Math.sqrt(t + 1)),
      (n[3] = 0.5 * s),
      (s = 0.5 / s),
      (n[0] = (e[5] - e[7]) * s),
      (n[1] = (e[6] - e[2]) * s),
      (n[2] = (e[1] - e[3]) * s);
  else {
    let r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    let i = (r + 1) % 3,
      a = (r + 2) % 3;
    (s = Math.sqrt(e[r * 3 + r] - e[i * 3 + i] - e[a * 3 + a] + 1)),
      (n[r] = 0.5 * s),
      (s = 0.5 / s),
      (n[3] = (e[i * 3 + a] - e[a * 3 + i]) * s),
      (n[i] = (e[i * 3 + r] + e[r * 3 + i]) * s),
      (n[a] = (e[a * 3 + r] + e[r * 3 + a]) * s);
  }
  return n;
}
function _Pe(n, e, t = "YXZ") {
  let s = Math.sin(e[0] * 0.5),
    r = Math.cos(e[0] * 0.5),
    i = Math.sin(e[1] * 0.5),
    a = Math.cos(e[1] * 0.5),
    o = Math.sin(e[2] * 0.5),
    l = Math.cos(e[2] * 0.5);
  return (
    t === "XYZ"
      ? ((n[0] = s * a * l + r * i * o),
        (n[1] = r * i * l - s * a * o),
        (n[2] = r * a * o + s * i * l),
        (n[3] = r * a * l - s * i * o))
      : t === "YXZ"
      ? ((n[0] = s * a * l + r * i * o),
        (n[1] = r * i * l - s * a * o),
        (n[2] = r * a * o - s * i * l),
        (n[3] = r * a * l + s * i * o))
      : t === "ZXY"
      ? ((n[0] = s * a * l - r * i * o),
        (n[1] = r * i * l + s * a * o),
        (n[2] = r * a * o + s * i * l),
        (n[3] = r * a * l - s * i * o))
      : t === "ZYX"
      ? ((n[0] = s * a * l - r * i * o),
        (n[1] = r * i * l + s * a * o),
        (n[2] = r * a * o - s * i * l),
        (n[3] = r * a * l + s * i * o))
      : t === "YZX"
      ? ((n[0] = s * a * l + r * i * o),
        (n[1] = r * i * l + s * a * o),
        (n[2] = r * a * o - s * i * l),
        (n[3] = r * a * l - s * i * o))
      : t === "XZY" &&
        ((n[0] = s * a * l - r * i * o),
        (n[1] = r * i * l - s * a * o),
        (n[2] = r * a * o + s * i * l),
        (n[3] = r * a * l + s * i * o)),
    n
  );
}
const APe = hPe,
  RPe = fPe,
  kPe = pPe,
  CPe = mPe;
class IPe extends Array {
  constructor(e = 0, t = 0, s = 0, r = 1) {
    super(e, t, s, r), (this.onChange = () => {}), (this._target = this);
    const i = ["0", "1", "2", "3"];
    return new Proxy(this, {
      set(a, o) {
        const l = Reflect.set(...arguments);
        return l && i.includes(o) && a.onChange(), l;
      },
    });
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  get w() {
    return this[3];
  }
  set x(e) {
    (this._target[0] = e), this.onChange();
  }
  set y(e) {
    (this._target[1] = e), this.onChange();
  }
  set z(e) {
    (this._target[2] = e), this.onChange();
  }
  set w(e) {
    (this._target[3] = e), this.onChange();
  }
  identity() {
    return gPe(this._target), this.onChange(), this;
  }
  set(e, t, s, r) {
    return e.length
      ? this.copy(e)
      : (RPe(this._target, e, t, s, r), this.onChange(), this);
  }
  rotateX(e) {
    return yPe(this._target, this._target, e), this.onChange(), this;
  }
  rotateY(e) {
    return bPe(this._target, this._target, e), this.onChange(), this;
  }
  rotateZ(e) {
    return xPe(this._target, this._target, e), this.onChange(), this;
  }
  inverse(e = this._target) {
    return EPe(this._target, e), this.onChange(), this;
  }
  conjugate(e = this._target) {
    return SPe(this._target, e), this.onChange(), this;
  }
  copy(e) {
    return APe(this._target, e), this.onChange(), this;
  }
  normalize(e = this._target) {
    return CPe(this._target, e), this.onChange(), this;
  }
  multiply(e, t) {
    return (
      t ? z5(this._target, e, t) : z5(this._target, this._target, e),
      this.onChange(),
      this
    );
  }
  dot(e) {
    return kPe(this._target, e);
  }
  fromMatrix3(e) {
    return TPe(this._target, e), this.onChange(), this;
  }
  fromEuler(e, t) {
    return _Pe(this._target, e, e.order), t || this.onChange(), this;
  }
  fromAxisAngle(e, t) {
    return vPe(this._target, e, t), this.onChange(), this;
  }
  slerp(e, t) {
    return wPe(this._target, this._target, e, t), this.onChange(), this;
  }
  fromArray(e, t = 0) {
    return (
      (this._target[0] = e[t]),
      (this._target[1] = e[t + 1]),
      (this._target[2] = e[t + 2]),
      (this._target[3] = e[t + 3]),
      this.onChange(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this[0]),
      (e[t + 1] = this[1]),
      (e[t + 2] = this[2]),
      (e[t + 3] = this[3]),
      e
    );
  }
}
const LPe = 1e-6;
function DPe(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[3]),
    (n[4] = e[4]),
    (n[5] = e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    (n[9] = e[9]),
    (n[10] = e[10]),
    (n[11] = e[11]),
    (n[12] = e[12]),
    (n[13] = e[13]),
    (n[14] = e[14]),
    (n[15] = e[15]),
    n
  );
}
function PPe(n, e, t, s, r, i, a, o, l, c, h, m, p, g, y, b, w) {
  return (
    (n[0] = e),
    (n[1] = t),
    (n[2] = s),
    (n[3] = r),
    (n[4] = i),
    (n[5] = a),
    (n[6] = o),
    (n[7] = l),
    (n[8] = c),
    (n[9] = h),
    (n[10] = m),
    (n[11] = p),
    (n[12] = g),
    (n[13] = y),
    (n[14] = b),
    (n[15] = w),
    n
  );
}
function MPe(n) {
  return (
    (n[0] = 1),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = 1),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = 1),
    (n[11] = 0),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 0),
    (n[15] = 1),
    n
  );
}
function NPe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    h = e[8],
    m = e[9],
    p = e[10],
    g = e[11],
    y = e[12],
    b = e[13],
    w = e[14],
    S = e[15],
    A = t * o - s * a,
    _ = t * l - r * a,
    R = t * c - i * a,
    C = s * l - r * o,
    D = s * c - i * o,
    L = r * c - i * l,
    P = h * b - m * y,
    V = h * w - p * y,
    N = h * S - g * y,
    W = m * w - p * b,
    H = m * S - g * b,
    z = p * S - g * w,
    B = A * z - _ * H + R * W + C * N - D * V + L * P;
  return B
    ? ((B = 1 / B),
      (n[0] = (o * z - l * H + c * W) * B),
      (n[1] = (r * H - s * z - i * W) * B),
      (n[2] = (b * L - w * D + S * C) * B),
      (n[3] = (p * D - m * L - g * C) * B),
      (n[4] = (l * N - a * z - c * V) * B),
      (n[5] = (t * z - r * N + i * V) * B),
      (n[6] = (w * R - y * L - S * _) * B),
      (n[7] = (h * L - p * R + g * _) * B),
      (n[8] = (a * H - o * N + c * P) * B),
      (n[9] = (s * N - t * H - i * P) * B),
      (n[10] = (y * D - b * R + S * A) * B),
      (n[11] = (m * R - h * D - g * A) * B),
      (n[12] = (o * V - a * W - l * P) * B),
      (n[13] = (t * W - s * V + r * P) * B),
      (n[14] = (b * _ - y * C - w * A) * B),
      (n[15] = (h * C - m * _ + p * A) * B),
      n)
    : null;
}
function QX(n) {
  let e = n[0],
    t = n[1],
    s = n[2],
    r = n[3],
    i = n[4],
    a = n[5],
    o = n[6],
    l = n[7],
    c = n[8],
    h = n[9],
    m = n[10],
    p = n[11],
    g = n[12],
    y = n[13],
    b = n[14],
    w = n[15],
    S = e * a - t * i,
    A = e * o - s * i,
    _ = e * l - r * i,
    R = t * o - s * a,
    C = t * l - r * a,
    D = s * l - r * o,
    L = c * y - h * g,
    P = c * b - m * g,
    V = c * w - p * g,
    N = h * b - m * y,
    W = h * w - p * y,
    H = m * w - p * b;
  return S * H - A * W + _ * N + R * V - C * P + D * L;
}
function G5(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    h = e[7],
    m = e[8],
    p = e[9],
    g = e[10],
    y = e[11],
    b = e[12],
    w = e[13],
    S = e[14],
    A = e[15],
    _ = t[0],
    R = t[1],
    C = t[2],
    D = t[3];
  return (
    (n[0] = _ * s + R * o + C * m + D * b),
    (n[1] = _ * r + R * l + C * p + D * w),
    (n[2] = _ * i + R * c + C * g + D * S),
    (n[3] = _ * a + R * h + C * y + D * A),
    (_ = t[4]),
    (R = t[5]),
    (C = t[6]),
    (D = t[7]),
    (n[4] = _ * s + R * o + C * m + D * b),
    (n[5] = _ * r + R * l + C * p + D * w),
    (n[6] = _ * i + R * c + C * g + D * S),
    (n[7] = _ * a + R * h + C * y + D * A),
    (_ = t[8]),
    (R = t[9]),
    (C = t[10]),
    (D = t[11]),
    (n[8] = _ * s + R * o + C * m + D * b),
    (n[9] = _ * r + R * l + C * p + D * w),
    (n[10] = _ * i + R * c + C * g + D * S),
    (n[11] = _ * a + R * h + C * y + D * A),
    (_ = t[12]),
    (R = t[13]),
    (C = t[14]),
    (D = t[15]),
    (n[12] = _ * s + R * o + C * m + D * b),
    (n[13] = _ * r + R * l + C * p + D * w),
    (n[14] = _ * i + R * c + C * g + D * S),
    (n[15] = _ * a + R * h + C * y + D * A),
    n
  );
}
function OPe(n, e, t) {
  let s = t[0],
    r = t[1],
    i = t[2],
    a,
    o,
    l,
    c,
    h,
    m,
    p,
    g,
    y,
    b,
    w,
    S;
  return (
    e === n
      ? ((n[12] = e[0] * s + e[4] * r + e[8] * i + e[12]),
        (n[13] = e[1] * s + e[5] * r + e[9] * i + e[13]),
        (n[14] = e[2] * s + e[6] * r + e[10] * i + e[14]),
        (n[15] = e[3] * s + e[7] * r + e[11] * i + e[15]))
      : ((a = e[0]),
        (o = e[1]),
        (l = e[2]),
        (c = e[3]),
        (h = e[4]),
        (m = e[5]),
        (p = e[6]),
        (g = e[7]),
        (y = e[8]),
        (b = e[9]),
        (w = e[10]),
        (S = e[11]),
        (n[0] = a),
        (n[1] = o),
        (n[2] = l),
        (n[3] = c),
        (n[4] = h),
        (n[5] = m),
        (n[6] = p),
        (n[7] = g),
        (n[8] = y),
        (n[9] = b),
        (n[10] = w),
        (n[11] = S),
        (n[12] = a * s + h * r + y * i + e[12]),
        (n[13] = o * s + m * r + b * i + e[13]),
        (n[14] = l * s + p * r + w * i + e[14]),
        (n[15] = c * s + g * r + S * i + e[15])),
    n
  );
}
function jPe(n, e, t) {
  let s = t[0],
    r = t[1],
    i = t[2];
  return (
    (n[0] = e[0] * s),
    (n[1] = e[1] * s),
    (n[2] = e[2] * s),
    (n[3] = e[3] * s),
    (n[4] = e[4] * r),
    (n[5] = e[5] * r),
    (n[6] = e[6] * r),
    (n[7] = e[7] * r),
    (n[8] = e[8] * i),
    (n[9] = e[9] * i),
    (n[10] = e[10] * i),
    (n[11] = e[11] * i),
    (n[12] = e[12]),
    (n[13] = e[13]),
    (n[14] = e[14]),
    (n[15] = e[15]),
    n
  );
}
function FPe(n, e, t, s) {
  let r = s[0],
    i = s[1],
    a = s[2],
    o = Math.hypot(r, i, a),
    l,
    c,
    h,
    m,
    p,
    g,
    y,
    b,
    w,
    S,
    A,
    _,
    R,
    C,
    D,
    L,
    P,
    V,
    N,
    W,
    H,
    z,
    B,
    q;
  return Math.abs(o) < LPe
    ? null
    : ((o = 1 / o),
      (r *= o),
      (i *= o),
      (a *= o),
      (l = Math.sin(t)),
      (c = Math.cos(t)),
      (h = 1 - c),
      (m = e[0]),
      (p = e[1]),
      (g = e[2]),
      (y = e[3]),
      (b = e[4]),
      (w = e[5]),
      (S = e[6]),
      (A = e[7]),
      (_ = e[8]),
      (R = e[9]),
      (C = e[10]),
      (D = e[11]),
      (L = r * r * h + c),
      (P = i * r * h + a * l),
      (V = a * r * h - i * l),
      (N = r * i * h - a * l),
      (W = i * i * h + c),
      (H = a * i * h + r * l),
      (z = r * a * h + i * l),
      (B = i * a * h - r * l),
      (q = a * a * h + c),
      (n[0] = m * L + b * P + _ * V),
      (n[1] = p * L + w * P + R * V),
      (n[2] = g * L + S * P + C * V),
      (n[3] = y * L + A * P + D * V),
      (n[4] = m * N + b * W + _ * H),
      (n[5] = p * N + w * W + R * H),
      (n[6] = g * N + S * W + C * H),
      (n[7] = y * N + A * W + D * H),
      (n[8] = m * z + b * B + _ * q),
      (n[9] = p * z + w * B + R * q),
      (n[10] = g * z + S * B + C * q),
      (n[11] = y * z + A * B + D * q),
      e !== n &&
        ((n[12] = e[12]), (n[13] = e[13]), (n[14] = e[14]), (n[15] = e[15])),
      n);
}
function UPe(n, e) {
  return (n[0] = e[12]), (n[1] = e[13]), (n[2] = e[14]), n;
}
function ZX(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[4],
    a = e[5],
    o = e[6],
    l = e[8],
    c = e[9],
    h = e[10];
  return (
    (n[0] = Math.hypot(t, s, r)),
    (n[1] = Math.hypot(i, a, o)),
    (n[2] = Math.hypot(l, c, h)),
    n
  );
}
function $Pe(n) {
  let e = n[0],
    t = n[1],
    s = n[2],
    r = n[4],
    i = n[5],
    a = n[6],
    o = n[8],
    l = n[9],
    c = n[10];
  const h = e * e + t * t + s * s,
    m = r * r + i * i + a * a,
    p = o * o + l * l + c * c;
  return Math.sqrt(Math.max(h, m, p));
}
const JX = (function () {
  const n = [1, 1, 1];
  return function (e, t) {
    let s = n;
    ZX(s, t);
    let r = 1 / s[0],
      i = 1 / s[1],
      a = 1 / s[2],
      o = t[0] * r,
      l = t[1] * i,
      c = t[2] * a,
      h = t[4] * r,
      m = t[5] * i,
      p = t[6] * a,
      g = t[8] * r,
      y = t[9] * i,
      b = t[10] * a,
      w = o + m + b,
      S = 0;
    return (
      w > 0
        ? ((S = Math.sqrt(w + 1) * 2),
          (e[3] = 0.25 * S),
          (e[0] = (p - y) / S),
          (e[1] = (g - c) / S),
          (e[2] = (l - h) / S))
        : o > m && o > b
        ? ((S = Math.sqrt(1 + o - m - b) * 2),
          (e[3] = (p - y) / S),
          (e[0] = 0.25 * S),
          (e[1] = (l + h) / S),
          (e[2] = (g + c) / S))
        : m > b
        ? ((S = Math.sqrt(1 + m - o - b) * 2),
          (e[3] = (g - c) / S),
          (e[0] = (l + h) / S),
          (e[1] = 0.25 * S),
          (e[2] = (p + y) / S))
        : ((S = Math.sqrt(1 + b - o - m) * 2),
          (e[3] = (l - h) / S),
          (e[0] = (g + c) / S),
          (e[1] = (p + y) / S),
          (e[2] = 0.25 * S)),
      e
    );
  };
})();
function BPe(n, e, t, s) {
  let r = vg([n[0], n[1], n[2]]);
  const i = vg([n[4], n[5], n[6]]),
    a = vg([n[8], n[9], n[10]]);
  QX(n) < 0 && (r = -r), (t[0] = n[12]), (t[1] = n[13]), (t[2] = n[14]);
  const l = n.slice(),
    c = 1 / r,
    h = 1 / i,
    m = 1 / a;
  (l[0] *= c),
    (l[1] *= c),
    (l[2] *= c),
    (l[4] *= h),
    (l[5] *= h),
    (l[6] *= h),
    (l[8] *= m),
    (l[9] *= m),
    (l[10] *= m),
    JX(e, l),
    (s[0] = r),
    (s[1] = i),
    (s[2] = a);
}
function HPe(n, e, t, s) {
  const r = n,
    i = e[0],
    a = e[1],
    o = e[2],
    l = e[3],
    c = i + i,
    h = a + a,
    m = o + o,
    p = i * c,
    g = i * h,
    y = i * m,
    b = a * h,
    w = a * m,
    S = o * m,
    A = l * c,
    _ = l * h,
    R = l * m,
    C = s[0],
    D = s[1],
    L = s[2];
  return (
    (r[0] = (1 - (b + S)) * C),
    (r[1] = (g + R) * C),
    (r[2] = (y - _) * C),
    (r[3] = 0),
    (r[4] = (g - R) * D),
    (r[5] = (1 - (p + S)) * D),
    (r[6] = (w + A) * D),
    (r[7] = 0),
    (r[8] = (y + _) * L),
    (r[9] = (w - A) * L),
    (r[10] = (1 - (p + b)) * L),
    (r[11] = 0),
    (r[12] = t[0]),
    (r[13] = t[1]),
    (r[14] = t[2]),
    (r[15] = 1),
    r
  );
}
function VPe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = t + t,
    o = s + s,
    l = r + r,
    c = t * a,
    h = s * a,
    m = s * o,
    p = r * a,
    g = r * o,
    y = r * l,
    b = i * a,
    w = i * o,
    S = i * l;
  return (
    (n[0] = 1 - m - y),
    (n[1] = h + S),
    (n[2] = p - w),
    (n[3] = 0),
    (n[4] = h - S),
    (n[5] = 1 - c - y),
    (n[6] = g + b),
    (n[7] = 0),
    (n[8] = p + w),
    (n[9] = g - b),
    (n[10] = 1 - c - m),
    (n[11] = 0),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 0),
    (n[15] = 1),
    n
  );
}
function zPe(n, e, t, s, r) {
  let i = 1 / Math.tan(e / 2),
    a = 1 / (s - r);
  return (
    (n[0] = i / t),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = i),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = (r + s) * a),
    (n[11] = -1),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 2 * r * s * a),
    (n[15] = 0),
    n
  );
}
function GPe(n, e, t, s, r, i, a) {
  let o = 1 / (e - t),
    l = 1 / (s - r),
    c = 1 / (i - a);
  return (
    (n[0] = -2 * o),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = -2 * l),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = 2 * c),
    (n[11] = 0),
    (n[12] = (e + t) * o),
    (n[13] = (r + s) * l),
    (n[14] = (a + i) * c),
    (n[15] = 1),
    n
  );
}
function qPe(n, e, t, s) {
  let r = e[0],
    i = e[1],
    a = e[2],
    o = s[0],
    l = s[1],
    c = s[2],
    h = r - t[0],
    m = i - t[1],
    p = a - t[2],
    g = h * h + m * m + p * p;
  g === 0 ? (p = 1) : ((g = 1 / Math.sqrt(g)), (h *= g), (m *= g), (p *= g));
  let y = l * p - c * m,
    b = c * h - o * p,
    w = o * m - l * h;
  return (
    (g = y * y + b * b + w * w),
    g === 0 &&
      (c ? (o += 1e-6) : l ? (c += 1e-6) : (l += 1e-6),
      (y = l * p - c * m),
      (b = c * h - o * p),
      (w = o * m - l * h),
      (g = y * y + b * b + w * w)),
    (g = 1 / Math.sqrt(g)),
    (y *= g),
    (b *= g),
    (w *= g),
    (n[0] = y),
    (n[1] = b),
    (n[2] = w),
    (n[3] = 0),
    (n[4] = m * w - p * b),
    (n[5] = p * y - h * w),
    (n[6] = h * b - m * y),
    (n[7] = 0),
    (n[8] = h),
    (n[9] = m),
    (n[10] = p),
    (n[11] = 0),
    (n[12] = r),
    (n[13] = i),
    (n[14] = a),
    (n[15] = 1),
    n
  );
}
function q5(n, e, t) {
  return (
    (n[0] = e[0] + t[0]),
    (n[1] = e[1] + t[1]),
    (n[2] = e[2] + t[2]),
    (n[3] = e[3] + t[3]),
    (n[4] = e[4] + t[4]),
    (n[5] = e[5] + t[5]),
    (n[6] = e[6] + t[6]),
    (n[7] = e[7] + t[7]),
    (n[8] = e[8] + t[8]),
    (n[9] = e[9] + t[9]),
    (n[10] = e[10] + t[10]),
    (n[11] = e[11] + t[11]),
    (n[12] = e[12] + t[12]),
    (n[13] = e[13] + t[13]),
    (n[14] = e[14] + t[14]),
    (n[15] = e[15] + t[15]),
    n
  );
}
function W5(n, e, t) {
  return (
    (n[0] = e[0] - t[0]),
    (n[1] = e[1] - t[1]),
    (n[2] = e[2] - t[2]),
    (n[3] = e[3] - t[3]),
    (n[4] = e[4] - t[4]),
    (n[5] = e[5] - t[5]),
    (n[6] = e[6] - t[6]),
    (n[7] = e[7] - t[7]),
    (n[8] = e[8] - t[8]),
    (n[9] = e[9] - t[9]),
    (n[10] = e[10] - t[10]),
    (n[11] = e[11] - t[11]),
    (n[12] = e[12] - t[12]),
    (n[13] = e[13] - t[13]),
    (n[14] = e[14] - t[14]),
    (n[15] = e[15] - t[15]),
    n
  );
}
function WPe(n, e, t) {
  return (
    (n[0] = e[0] * t),
    (n[1] = e[1] * t),
    (n[2] = e[2] * t),
    (n[3] = e[3] * t),
    (n[4] = e[4] * t),
    (n[5] = e[5] * t),
    (n[6] = e[6] * t),
    (n[7] = e[7] * t),
    (n[8] = e[8] * t),
    (n[9] = e[9] * t),
    (n[10] = e[10] * t),
    (n[11] = e[11] * t),
    (n[12] = e[12] * t),
    (n[13] = e[13] * t),
    (n[14] = e[14] * t),
    (n[15] = e[15] * t),
    n
  );
}
class nE extends Array {
  constructor(
    e = 1,
    t = 0,
    s = 0,
    r = 0,
    i = 0,
    a = 1,
    o = 0,
    l = 0,
    c = 0,
    h = 0,
    m = 1,
    p = 0,
    g = 0,
    y = 0,
    b = 0,
    w = 1
  ) {
    return super(e, t, s, r, i, a, o, l, c, h, m, p, g, y, b, w), this;
  }
  get x() {
    return this[12];
  }
  get y() {
    return this[13];
  }
  get z() {
    return this[14];
  }
  get w() {
    return this[15];
  }
  set x(e) {
    this[12] = e;
  }
  set y(e) {
    this[13] = e;
  }
  set z(e) {
    this[14] = e;
  }
  set w(e) {
    this[15] = e;
  }
  set(e, t, s, r, i, a, o, l, c, h, m, p, g, y, b, w) {
    return e.length
      ? this.copy(e)
      : (PPe(this, e, t, s, r, i, a, o, l, c, h, m, p, g, y, b, w), this);
  }
  translate(e, t = this) {
    return OPe(this, t, e), this;
  }
  rotate(e, t, s = this) {
    return FPe(this, s, e, t), this;
  }
  scale(e, t = this) {
    return jPe(this, t, typeof e == "number" ? [e, e, e] : e), this;
  }
  add(e, t) {
    return t ? q5(this, e, t) : q5(this, this, e), this;
  }
  sub(e, t) {
    return t ? W5(this, e, t) : W5(this, this, e), this;
  }
  multiply(e, t) {
    return (
      e.length ? (t ? G5(this, e, t) : G5(this, this, e)) : WPe(this, this, e),
      this
    );
  }
  identity() {
    return MPe(this), this;
  }
  copy(e) {
    return DPe(this, e), this;
  }
  fromPerspective({ fov: e, aspect: t, near: s, far: r } = {}) {
    return zPe(this, e, t, s, r), this;
  }
  fromOrthogonal({ left: e, right: t, bottom: s, top: r, near: i, far: a }) {
    return GPe(this, e, t, s, r, i, a), this;
  }
  fromQuaternion(e) {
    return VPe(this, e), this;
  }
  setPosition(e) {
    return (this.x = e[0]), (this.y = e[1]), (this.z = e[2]), this;
  }
  inverse(e = this) {
    return NPe(this, e), this;
  }
  compose(e, t, s) {
    return HPe(this, e, t, s), this;
  }
  decompose(e, t, s) {
    return BPe(this, e, t, s), this;
  }
  getRotation(e) {
    return JX(e, this), this;
  }
  getTranslation(e) {
    return UPe(e, this), this;
  }
  getScaling(e) {
    return ZX(e, this), this;
  }
  getMaxScaleOnAxis() {
    return $Pe(this);
  }
  lookAt(e, t, s) {
    return qPe(this, e, t, s), this;
  }
  determinant() {
    return QX(this);
  }
  fromArray(e, t = 0) {
    return (
      (this[0] = e[t]),
      (this[1] = e[t + 1]),
      (this[2] = e[t + 2]),
      (this[3] = e[t + 3]),
      (this[4] = e[t + 4]),
      (this[5] = e[t + 5]),
      (this[6] = e[t + 6]),
      (this[7] = e[t + 7]),
      (this[8] = e[t + 8]),
      (this[9] = e[t + 9]),
      (this[10] = e[t + 10]),
      (this[11] = e[t + 11]),
      (this[12] = e[t + 12]),
      (this[13] = e[t + 13]),
      (this[14] = e[t + 14]),
      (this[15] = e[t + 15]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this[0]),
      (e[t + 1] = this[1]),
      (e[t + 2] = this[2]),
      (e[t + 3] = this[3]),
      (e[t + 4] = this[4]),
      (e[t + 5] = this[5]),
      (e[t + 6] = this[6]),
      (e[t + 7] = this[7]),
      (e[t + 8] = this[8]),
      (e[t + 9] = this[9]),
      (e[t + 10] = this[10]),
      (e[t + 11] = this[11]),
      (e[t + 12] = this[12]),
      (e[t + 13] = this[13]),
      (e[t + 14] = this[14]),
      (e[t + 15] = this[15]),
      e
    );
  }
}
function KPe(n, e, t = "YXZ") {
  return (
    t === "XYZ"
      ? ((n[1] = Math.asin(Math.min(Math.max(e[8], -1), 1))),
        Math.abs(e[8]) < 0.99999
          ? ((n[0] = Math.atan2(-e[9], e[10])),
            (n[2] = Math.atan2(-e[4], e[0])))
          : ((n[0] = Math.atan2(e[6], e[5])), (n[2] = 0)))
      : t === "YXZ"
      ? ((n[0] = Math.asin(-Math.min(Math.max(e[9], -1), 1))),
        Math.abs(e[9]) < 0.99999
          ? ((n[1] = Math.atan2(e[8], e[10])), (n[2] = Math.atan2(e[1], e[5])))
          : ((n[1] = Math.atan2(-e[2], e[0])), (n[2] = 0)))
      : t === "ZXY"
      ? ((n[0] = Math.asin(Math.min(Math.max(e[6], -1), 1))),
        Math.abs(e[6]) < 0.99999
          ? ((n[1] = Math.atan2(-e[2], e[10])),
            (n[2] = Math.atan2(-e[4], e[5])))
          : ((n[1] = 0), (n[2] = Math.atan2(e[1], e[0]))))
      : t === "ZYX"
      ? ((n[1] = Math.asin(-Math.min(Math.max(e[2], -1), 1))),
        Math.abs(e[2]) < 0.99999
          ? ((n[0] = Math.atan2(e[6], e[10])), (n[2] = Math.atan2(e[1], e[0])))
          : ((n[0] = 0), (n[2] = Math.atan2(-e[4], e[5]))))
      : t === "YZX"
      ? ((n[2] = Math.asin(Math.min(Math.max(e[1], -1), 1))),
        Math.abs(e[1]) < 0.99999
          ? ((n[0] = Math.atan2(-e[9], e[5])), (n[1] = Math.atan2(-e[2], e[0])))
          : ((n[0] = 0), (n[1] = Math.atan2(e[8], e[10]))))
      : t === "XZY" &&
        ((n[2] = Math.asin(-Math.min(Math.max(e[4], -1), 1))),
        Math.abs(e[4]) < 0.99999
          ? ((n[0] = Math.atan2(e[6], e[5])), (n[1] = Math.atan2(e[8], e[0])))
          : ((n[0] = Math.atan2(-e[9], e[10])), (n[1] = 0))),
    n
  );
}
const K5 = new nE();
class YPe extends Array {
  constructor(e = 0, t = e, s = e, r = "YXZ") {
    super(e, t, s),
      (this.order = r),
      (this.onChange = () => {}),
      (this._target = this);
    const i = ["0", "1", "2"];
    return new Proxy(this, {
      set(a, o) {
        const l = Reflect.set(...arguments);
        return l && i.includes(o) && a.onChange(), l;
      },
    });
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  set x(e) {
    (this._target[0] = e), this.onChange();
  }
  set y(e) {
    (this._target[1] = e), this.onChange();
  }
  set z(e) {
    (this._target[2] = e), this.onChange();
  }
  set(e, t = e, s = e) {
    return e.length
      ? this.copy(e)
      : ((this._target[0] = e),
        (this._target[1] = t),
        (this._target[2] = s),
        this.onChange(),
        this);
  }
  copy(e) {
    return (
      (this._target[0] = e[0]),
      (this._target[1] = e[1]),
      (this._target[2] = e[2]),
      this.onChange(),
      this
    );
  }
  reorder(e) {
    return (this._target.order = e), this.onChange(), this;
  }
  fromRotationMatrix(e, t = this.order) {
    return KPe(this._target, e, t), this.onChange(), this;
  }
  fromQuaternion(e, t = this.order, s) {
    return (
      K5.fromQuaternion(e),
      this._target.fromRotationMatrix(K5, t),
      s || this.onChange(),
      this
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._target[0] = e[t]),
      (this._target[1] = e[t + 1]),
      (this._target[2] = e[t + 2]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), e;
  }
}
class XPe {
  constructor() {
    (this.parent = null),
      (this.children = []),
      (this.visible = !0),
      (this.matrix = new nE()),
      (this.worldMatrix = new nE()),
      (this.matrixAutoUpdate = !0),
      (this.worldMatrixNeedsUpdate = !1),
      (this.position = new Da()),
      (this.quaternion = new IPe()),
      (this.scale = new Da(1)),
      (this.rotation = new YPe()),
      (this.up = new Da(0, 1, 0)),
      (this.rotation._target.onChange = () =>
        this.quaternion.fromEuler(this.rotation, !0)),
      (this.quaternion._target.onChange = () =>
        this.rotation.fromQuaternion(this.quaternion, void 0, !0));
  }
  setParent(e, t = !0) {
    this.parent && e !== this.parent && this.parent.removeChild(this, !1),
      (this.parent = e),
      t && e && e.addChild(this, !1);
  }
  addChild(e, t = !0) {
    ~this.children.indexOf(e) || this.children.push(e),
      t && e.setParent(this, !1);
  }
  removeChild(e, t = !0) {
    ~this.children.indexOf(e) &&
      this.children.splice(this.children.indexOf(e), 1),
      t && e.setParent(null, !1);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.worldMatrixNeedsUpdate || e) &&
        (this.parent === null
          ? this.worldMatrix.copy(this.matrix)
          : this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix),
        (this.worldMatrixNeedsUpdate = !1),
        (e = !0));
    for (let t = 0, s = this.children.length; t < s; t++)
      this.children[t].updateMatrixWorld(e);
  }
  updateMatrix() {
    this.matrix.compose(this.quaternion, this.position, this.scale),
      (this.worldMatrixNeedsUpdate = !0);
  }
  traverse(e) {
    if (!e(this))
      for (let t = 0, s = this.children.length; t < s; t++)
        this.children[t].traverse(e);
  }
  decompose() {
    this.matrix.decompose(this.quaternion._target, this.position, this.scale),
      this.rotation.fromQuaternion(this.quaternion);
  }
  lookAt(e, t = !1) {
    t
      ? this.matrix.lookAt(this.position, e, this.up)
      : this.matrix.lookAt(e, this.position, this.up),
      this.matrix.getRotation(this.quaternion._target),
      this.rotation.fromQuaternion(this.quaternion);
  }
}
function QPe(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[4]),
    (n[4] = e[5]),
    (n[5] = e[6]),
    (n[6] = e[8]),
    (n[7] = e[9]),
    (n[8] = e[10]),
    n
  );
}
function ZPe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = t + t,
    o = s + s,
    l = r + r,
    c = t * a,
    h = s * a,
    m = s * o,
    p = r * a,
    g = r * o,
    y = r * l,
    b = i * a,
    w = i * o,
    S = i * l;
  return (
    (n[0] = 1 - m - y),
    (n[3] = h - S),
    (n[6] = p + w),
    (n[1] = h + S),
    (n[4] = 1 - c - y),
    (n[7] = g - b),
    (n[2] = p - w),
    (n[5] = g + b),
    (n[8] = 1 - c - m),
    n
  );
}
function JPe(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[3]),
    (n[4] = e[4]),
    (n[5] = e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    n
  );
}
function eMe(n, e, t, s, r, i, a, o, l, c) {
  return (
    (n[0] = e),
    (n[1] = t),
    (n[2] = s),
    (n[3] = r),
    (n[4] = i),
    (n[5] = a),
    (n[6] = o),
    (n[7] = l),
    (n[8] = c),
    n
  );
}
function tMe(n) {
  return (
    (n[0] = 1),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 1),
    (n[5] = 0),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 1),
    n
  );
}
function nMe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    h = e[8],
    m = h * a - o * c,
    p = -h * i + o * l,
    g = c * i - a * l,
    y = t * m + s * p + r * g;
  return y
    ? ((y = 1 / y),
      (n[0] = m * y),
      (n[1] = (-h * s + r * c) * y),
      (n[2] = (o * s - r * a) * y),
      (n[3] = p * y),
      (n[4] = (h * t - r * l) * y),
      (n[5] = (-o * t + r * i) * y),
      (n[6] = g * y),
      (n[7] = (-c * t + s * l) * y),
      (n[8] = (a * t - s * i) * y),
      n)
    : null;
}
function Y5(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    h = e[7],
    m = e[8],
    p = t[0],
    g = t[1],
    y = t[2],
    b = t[3],
    w = t[4],
    S = t[5],
    A = t[6],
    _ = t[7],
    R = t[8];
  return (
    (n[0] = p * s + g * a + y * c),
    (n[1] = p * r + g * o + y * h),
    (n[2] = p * i + g * l + y * m),
    (n[3] = b * s + w * a + S * c),
    (n[4] = b * r + w * o + S * h),
    (n[5] = b * i + w * l + S * m),
    (n[6] = A * s + _ * a + R * c),
    (n[7] = A * r + _ * o + R * h),
    (n[8] = A * i + _ * l + R * m),
    n
  );
}
function sMe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    h = e[7],
    m = e[8],
    p = t[0],
    g = t[1];
  return (
    (n[0] = s),
    (n[1] = r),
    (n[2] = i),
    (n[3] = a),
    (n[4] = o),
    (n[5] = l),
    (n[6] = p * s + g * a + c),
    (n[7] = p * r + g * o + h),
    (n[8] = p * i + g * l + m),
    n
  );
}
function rMe(n, e, t) {
  let s = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    h = e[7],
    m = e[8],
    p = Math.sin(t),
    g = Math.cos(t);
  return (
    (n[0] = g * s + p * a),
    (n[1] = g * r + p * o),
    (n[2] = g * i + p * l),
    (n[3] = g * a - p * s),
    (n[4] = g * o - p * r),
    (n[5] = g * l - p * i),
    (n[6] = c),
    (n[7] = h),
    (n[8] = m),
    n
  );
}
function iMe(n, e, t) {
  let s = t[0],
    r = t[1];
  return (
    (n[0] = s * e[0]),
    (n[1] = s * e[1]),
    (n[2] = s * e[2]),
    (n[3] = r * e[3]),
    (n[4] = r * e[4]),
    (n[5] = r * e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    n
  );
}
function aMe(n, e) {
  let t = e[0],
    s = e[1],
    r = e[2],
    i = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    h = e[8],
    m = e[9],
    p = e[10],
    g = e[11],
    y = e[12],
    b = e[13],
    w = e[14],
    S = e[15],
    A = t * o - s * a,
    _ = t * l - r * a,
    R = t * c - i * a,
    C = s * l - r * o,
    D = s * c - i * o,
    L = r * c - i * l,
    P = h * b - m * y,
    V = h * w - p * y,
    N = h * S - g * y,
    W = m * w - p * b,
    H = m * S - g * b,
    z = p * S - g * w,
    B = A * z - _ * H + R * W + C * N - D * V + L * P;
  return B
    ? ((B = 1 / B),
      (n[0] = (o * z - l * H + c * W) * B),
      (n[1] = (l * N - a * z - c * V) * B),
      (n[2] = (a * H - o * N + c * P) * B),
      (n[3] = (r * H - s * z - i * W) * B),
      (n[4] = (t * z - r * N + i * V) * B),
      (n[5] = (s * N - t * H - i * P) * B),
      (n[6] = (b * L - w * D + S * C) * B),
      (n[7] = (w * R - y * L - S * _) * B),
      (n[8] = (y * D - b * R + S * A) * B),
      n)
    : null;
}
class oMe extends Array {
  constructor(e = 1, t = 0, s = 0, r = 0, i = 1, a = 0, o = 0, l = 0, c = 1) {
    return super(e, t, s, r, i, a, o, l, c), this;
  }
  set(e, t, s, r, i, a, o, l, c) {
    return e.length
      ? this.copy(e)
      : (eMe(this, e, t, s, r, i, a, o, l, c), this);
  }
  translate(e, t = this) {
    return sMe(this, t, e), this;
  }
  rotate(e, t = this) {
    return rMe(this, t, e), this;
  }
  scale(e, t = this) {
    return iMe(this, t, e), this;
  }
  multiply(e, t) {
    return t ? Y5(this, e, t) : Y5(this, this, e), this;
  }
  identity() {
    return tMe(this), this;
  }
  copy(e) {
    return JPe(this, e), this;
  }
  fromMatrix4(e) {
    return QPe(this, e), this;
  }
  fromQuaternion(e) {
    return ZPe(this, e), this;
  }
  fromBasis(e, t, s) {
    return this.set(e[0], e[1], e[2], t[0], t[1], t[2], s[0], s[1], s[2]), this;
  }
  inverse(e = this) {
    return nMe(this, e), this;
  }
  getNormalMatrix(e) {
    return aMe(this, e), this;
  }
}
let lMe = 0;
class cMe extends XPe {
  constructor(
    e,
    {
      geometry: t,
      program: s,
      mode: r = e.TRIANGLES,
      frustumCulled: i = !0,
      renderOrder: a = 0,
    } = {}
  ) {
    super(),
      e.canvas || console.error("gl not passed as first argument to Mesh"),
      (this.gl = e),
      (this.id = lMe++),
      (this.geometry = t),
      (this.program = s),
      (this.mode = r),
      (this.frustumCulled = i),
      (this.renderOrder = a),
      (this.modelViewMatrix = new nE()),
      (this.normalMatrix = new oMe()),
      (this.beforeRenderCallbacks = []),
      (this.afterRenderCallbacks = []);
  }
  onBeforeRender(e) {
    return this.beforeRenderCallbacks.push(e), this;
  }
  onAfterRender(e) {
    return this.afterRenderCallbacks.push(e), this;
  }
  draw({ camera: e } = {}) {
    e &&
      (this.program.uniforms.modelMatrix ||
        Object.assign(this.program.uniforms, {
          modelMatrix: { value: null },
          viewMatrix: { value: null },
          modelViewMatrix: { value: null },
          normalMatrix: { value: null },
          projectionMatrix: { value: null },
          cameraPosition: { value: null },
        }),
      (this.program.uniforms.projectionMatrix.value = e.projectionMatrix),
      (this.program.uniforms.cameraPosition.value = e.worldPosition),
      (this.program.uniforms.viewMatrix.value = e.viewMatrix),
      this.modelViewMatrix.multiply(e.viewMatrix, this.worldMatrix),
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix),
      (this.program.uniforms.modelMatrix.value = this.worldMatrix),
      (this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix),
      (this.program.uniforms.normalMatrix.value = this.normalMatrix)),
      this.beforeRenderCallbacks.forEach(
        (s) => s && s({ mesh: this, camera: e })
      );
    let t = this.program.cullFace && this.worldMatrix.determinant() < 0;
    this.program.use({ flipFaces: t }),
      this.geometry.draw({ mode: this.mode, program: this.program }),
      this.afterRenderCallbacks.forEach(
        (s) => s && s({ mesh: this, camera: e })
      );
  }
}
class uMe extends rPe {
  constructor(e, { attributes: t = {} } = {}) {
    Object.assign(t, {
      position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },
      uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },
    }),
      super(e, t);
  }
}
const dMe = "#ffffff",
  Ja = (n) => {
    const e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);
    return e
      ? [
          parseInt(e[1], 16) / 255,
          parseInt(e[2], 16) / 255,
          parseInt(e[3], 16) / 255,
        ]
      : [1, 1, 1];
  },
  X5 = (n, e, t) => {
    switch (n) {
      case "top-left":
        return { anchor: [0, -0.2 * t], dir: [0, 1] };
      case "top-right":
        return { anchor: [e, -0.2 * t], dir: [0, 1] };
      case "left":
        return { anchor: [-0.2 * e, 0.5 * t], dir: [1, 0] };
      case "right":
        return { anchor: [(1 + 0.2) * e, 0.5 * t], dir: [-1, 0] };
      case "bottom-left":
        return { anchor: [0, t], dir: [0, -1] };
      case "bottom-center":
        return { anchor: [0.5 * e, t], dir: [0, -1] };
      case "bottom-right":
        return { anchor: [e, t], dir: [0, -1] };
      default:
        return { anchor: [0.5 * e, -0.2 * t], dir: [0, 1] };
    }
  },
  eQ = ({
    raysOrigin: n = "top-center",
    raysColor: e = dMe,
    raysSpeed: t = 1,
    lightSpread: s = 1,
    rayLength: r = 2,
    pulsating: i = !1,
    fadeDistance: a = 1,
    saturation: o = 1,
    followMouse: l = !0,
    mouseInfluence: c = 0.1,
    noiseAmount: h = 0,
    distortion: m = 0,
    className: p = "",
    overlayImage: g = null,
    gradientColors: y = null,
    gradientStops: b = [0, 0.33, 0.66, 1],
    gradientScale: w = 0.1,
    gradientOpacity: S = 1,
    distortionPhase: A = 0.01,
    opacity: _ = 1,
  }) => {
    const R = E.useRef(null),
      C = E.useRef(null),
      D = E.useRef(null),
      L = E.useRef({ x: 0.5, y: 0.5 }),
      P = E.useRef({ x: 0.5, y: 0.5 }),
      V = E.useRef(null),
      N = E.useRef(null),
      W = E.useRef(null);
    return (
      E.useEffect(
        () =>
          R.current
            ? (W.current && (W.current(), (W.current = null)),
              D.current && (D.current = null),
              C.current && (C.current = null),
              N.current && (N.current = null),
              (async () => {
                if (
                  !R.current ||
                  (await new Promise((Y) => setTimeout(Y, 10)), !R.current)
                )
                  return;
                const z = new dPe({
                  dpr: Math.min(window.devicePixelRatio, 2),
                  alpha: !0,
                  premultipliedAlpha: !1,
                });
                D.current = z;
                const B = z.gl;
                for (
                  B.canvas.style.width = "100%",
                    B.canvas.style.height = "100%",
                    B.canvas.style.position = "absolute",
                    B.canvas.style.top = "0",
                    B.canvas.style.left = "0";
                  R.current.firstChild;

                )
                  R.current.removeChild(R.current.firstChild);
                R.current.appendChild(B.canvas);
                const q = `
attribute vec2 position;
varying vec2 vUv;
void main() {
  vUv = position * 0.5 + 0.5;
  gl_Position = vec4(position, 0.0, 1.0);
}`,
                  O = `precision highp float;

uniform float iTime;
uniform vec2  iResolution;

uniform vec2  rayPos;
uniform vec2  rayDir;
uniform vec3  raysColor;
uniform float raysSpeed;
uniform float lightSpread;
uniform float rayLength;
uniform float pulsating;
uniform float fadeDistance;
uniform float saturation;
uniform vec2  mousePos;
uniform float mouseInfluence;
uniform float noiseAmount;
uniform float distortion;
uniform float distortionPhase;

// Gradient uniforms
uniform float useGradient;
uniform vec3  gradientColor1;
uniform vec3  gradientColor2;
uniform vec3  gradientColor3;
uniform vec3  gradientColor4;
uniform vec4  gradientStops;
uniform float gradientScale;
uniform float gradientOpacity;
uniform float opacity;

varying vec2 vUv;

float noise(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

struct RayResult {
  float strength;
  float normalizedDistance;
};

RayResult rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,
                  float seedA, float seedB, float speed) {
  vec2 sourceToCoord = coord - raySource;
  vec2 dirNorm = normalize(sourceToCoord);
  float cosAngle = dot(dirNorm, rayRefDirection);

  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 - length(sourceToCoord) * distortionPhase) * 0.2;

  // Create a much tighter cone using exponential falloff from center
  float angleDeviation = 1.0 - distortedAngle;
  float spreadFactor = exp(-angleDeviation * angleDeviation / max(lightSpread * lightSpread * 0.01, 0.0001));

  float distance = length(sourceToCoord);
  float maxDistance = iResolution.x * rayLength;
  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);

  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);
  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;

  float baseStrength = clamp(
    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +
    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),
    0.0, 1.0
  );

  float strength = baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;

  // Normalized distance for gradient (0 at origin, 1 at max distance)
  // Use gradientScale to control how quickly colors transition
  float normalizedDistance = clamp(distance / (maxDistance * gradientScale), 0.0, 1.0);

  RayResult result;
  result.strength = strength;
  result.normalizedDistance = normalizedDistance;
  return result;
}

vec3 getGradientColor(float normalizedDistance) {
  vec3 color;

  if (normalizedDistance < gradientStops.y) {
    // Between color 1 and 2
    float t = (normalizedDistance - gradientStops.x) / (gradientStops.y - gradientStops.x);
    color = mix(gradientColor1, gradientColor2, smoothstep(0.0, 1.0, t));
  } else if (normalizedDistance < gradientStops.z) {
    // Between color 2 and 3
    float t = (normalizedDistance - gradientStops.y) / (gradientStops.z - gradientStops.y);
    color = mix(gradientColor2, gradientColor3, smoothstep(0.0, 1.0, t));
  } else {
    // Between color 3 and 4
    float t = (normalizedDistance - gradientStops.z) / (gradientStops.w - gradientStops.z);
    color = mix(gradientColor3, gradientColor4, smoothstep(0.0, 1.0, t));
  }

  return color;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);

  vec2 finalRayDir = rayDir;
  if (mouseInfluence > 0.0) {
    vec2 mouseScreenPos = mousePos * iResolution.xy;
    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);
    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));
  }

  RayResult ray1 = rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349, 1.5 * raysSpeed);
  RayResult ray2 = rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234, 1.1 * raysSpeed);

  // Combine ray strengths
  fragColor = vec4(1.0) * (ray1.strength * 0.5 + ray2.strength * 0.4);

  // Use the average normalized distance from both rays
  float avgNormalizedDistance = (ray1.normalizedDistance + ray2.normalizedDistance) * 0.5;

  if (noiseAmount > 0.0) {
    float n = noise(coord * 0.01 + iTime * 0.1);
    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);
  }

  if (saturation != 1.0) {
    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));
    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);
  }

  // Apply color (gradient or single color)
  if (useGradient > 0.5) {
    vec3 gradColor = getGradientColor(avgNormalizedDistance);
    // Mix gradient with base color using gradientOpacity
    // Default base color is #CFDEF6 (the outermost gradient color)
    vec3 baseColor = gradientColor4;
    vec3 finalColor = mix(baseColor, gradColor, gradientOpacity);
    fragColor.rgb *= finalColor;
  } else {
    fragColor.rgb *= raysColor;
  }

  // Apply overall opacity
  fragColor.a *= opacity;
}

void main() {
  vec4 color;
  mainImage(color, gl_FragCoord.xy);
  gl_FragColor  = color;
}`,
                  U = {
                    iTime: { value: 0 },
                    iResolution: { value: [1, 1] },
                    rayPos: { value: [0, 0] },
                    rayDir: { value: [0, 1] },
                    raysColor: { value: Ja(e) },
                    raysSpeed: { value: t },
                    lightSpread: { value: s },
                    rayLength: { value: r },
                    pulsating: { value: i ? 1 : 0 },
                    fadeDistance: { value: a },
                    saturation: { value: o },
                    mousePos: { value: [0.5, 0.5] },
                    mouseInfluence: { value: c },
                    noiseAmount: { value: h },
                    distortion: { value: m },
                    distortionPhase: { value: A },
                    useGradient: { value: y ? 1 : 0 },
                    gradientColor1: { value: y ? Ja(y[0]) : [1, 1, 1] },
                    gradientColor2: { value: y ? Ja(y[1]) : [1, 1, 1] },
                    gradientColor3: { value: y ? Ja(y[2]) : [1, 1, 1] },
                    gradientColor4: { value: y ? Ja(y[3]) : [1, 1, 1] },
                    gradientStops: { value: b },
                    gradientScale: { value: w },
                    gradientOpacity: { value: S },
                    opacity: { value: _ },
                  };
                C.current = U;
                const j = new uMe(B),
                  Q = new aPe(B, { vertex: q, fragment: O, uniforms: U }),
                  M = new cMe(B, { geometry: j, program: Q });
                N.current = M;
                const I = () => {
                    if (!R.current || !z) return;
                    z.dpr = Math.min(window.devicePixelRatio, 2);
                    const { clientWidth: Y, clientHeight: J } = R.current;
                    z.setSize(Y, J);
                    const X = z.dpr,
                      Z = Y * X,
                      te = J * X;
                    U.iResolution.value = [Z, te];
                    const { anchor: ce, dir: pe } = X5(n, Z, te);
                    (U.rayPos.value = ce), (U.rayDir.value = pe);
                  },
                  F = (Y) => {
                    if (!(!D.current || !C.current || !N.current)) {
                      (U.iTime.value = Y * 0.001),
                        l &&
                          c > 0 &&
                          ((P.current.x =
                            P.current.x * 0.92 + L.current.x * (1 - 0.92)),
                          (P.current.y =
                            P.current.y * 0.92 + L.current.y * (1 - 0.92)),
                          (U.mousePos.value = [P.current.x, P.current.y]));
                      try {
                        z.render({ scene: M }),
                          (V.current = requestAnimationFrame(F));
                      } catch (J) {
                        console.warn("WebGL rendering error:", J);
                        return;
                      }
                    }
                  };
                window.addEventListener("resize", I),
                  I(),
                  (V.current = requestAnimationFrame(F)),
                  (W.current = () => {
                    if (
                      (V.current &&
                        (cancelAnimationFrame(V.current), (V.current = null)),
                      window.removeEventListener("resize", I),
                      z && z.gl)
                    )
                      try {
                        const Y = z.gl,
                          J = Y.canvas;
                        N.current &&
                          N.current.geometry &&
                          N.current.geometry.remove(),
                          N.current &&
                            N.current.program &&
                            N.current.program.program &&
                            Y.deleteProgram(N.current.program.program);
                        const X = Y.getExtension("WEBGL_lose_context");
                        X && X.loseContext(),
                          J && J.parentNode && J.parentNode.removeChild(J);
                      } catch (Y) {
                        console.warn("Error during WebGL cleanup:", Y);
                      }
                    (D.current = null), (C.current = null), (N.current = null);
                  });
              })(),
              () => {
                W.current && (W.current(), (W.current = null));
              })
            : void 0,
        []
      ),
      E.useEffect(() => {
        if (!C.current || !R.current || !D.current) return;
        const H = C.current,
          z = D.current;
        (H.raysColor.value = Ja(e)),
          (H.raysSpeed.value = t),
          (H.lightSpread.value = s),
          (H.rayLength.value = r),
          (H.pulsating.value = i ? 1 : 0),
          (H.fadeDistance.value = a),
          (H.saturation.value = o),
          (H.mouseInfluence.value = c),
          (H.noiseAmount.value = h),
          (H.distortion.value = m),
          (H.distortionPhase.value = A),
          (H.opacity.value = _),
          (H.useGradient.value = y ? 1 : 0),
          y &&
            ((H.gradientColor1.value = Ja(y[0])),
            (H.gradientColor2.value = Ja(y[1])),
            (H.gradientColor3.value = Ja(y[2])),
            (H.gradientColor4.value = Ja(y[3])),
            (H.gradientStops.value = b),
            (H.gradientScale.value = w),
            (H.gradientOpacity.value = S));
        const { clientWidth: B, clientHeight: q } = R.current,
          O = z.dpr,
          { anchor: U, dir: j } = X5(n, B * O, q * O);
        (H.rayPos.value = U), (H.rayDir.value = j);
      }, [e, t, s, n, r, i, a, o, c, h, m, A, y, b, w, S, _]),
      E.useEffect(() => {
        const H = (z) => {
          if (!R.current || !D.current) return;
          const B = R.current.getBoundingClientRect(),
            q = (z.clientX - B.left) / B.width,
            O = (z.clientY - B.top) / B.height;
          L.current = { x: q, y: O };
        };
        if (l)
          return (
            window.addEventListener("mousemove", H),
            () => window.removeEventListener("mousemove", H)
          );
      }, [l]),
      u.jsxs("div", {
        style: {
          position: "relative",
          width: "100%",
          height: "100%",
          isolation: "isolate",
        },
        children: [
          g &&
            u.jsx("img", {
              src: g,
              alt: "",
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                objectFit: "cover",
                pointerEvents: "none",
                zIndex: 0,
              },
            }),
          u.jsx("div", {
            ref: R,
            className: `light-rays-container ${p}`.trim(),
            style: {
              position: "relative",
              width: "100%",
              height: "100%",
              mixBlendMode: g ? "screen" : "normal",
              zIndex: 1,
            },
          }),
        ],
      })
    );
  },
  hMe = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: eQ },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Wv = ({ gradientOpacity: n = 1, positioning: e = "fixed" }) => {
    const [t, s] = E.useState(!1);
    return (
      E.useEffect(() => {
        s(!0);
      }, []),
      u.jsxs("div", {
        className: `${
          e === "absolute" ? "absolute" : "fixed"
        } inset-0 overflow-hidden pointer-events-none`,
        style: { zIndex: 0 },
        children: [
          u.jsx("div", {
            className: "absolute inset-0",
            style: { background: "#09090B" },
          }),
          u.jsx("div", {
            className: "absolute inset-0",
            style: {
              backgroundImage: "url(/images/grainy.png)",
              backgroundSize: "100px 100px",
              backgroundRepeat: "repeat",
              backgroundPosition: "left top",
              mixBlendMode: "overlay",
              opacity: 0.3,
              pointerEvents: "none",
              zIndex: 10,
            },
          }),
          u.jsx("div", {
            style: {
              position: "absolute",
              bottom: "-20px",
              left: "0",
              width: "100%",
              height: "100vh",
              pointerEvents: "none",
              zIndex: 1,
              isolation: "isolate",
              opacity: t ? 1 : 0,
              transition: "opacity 1.5s ease-in",
            },
            children: u.jsx(eQ, {
              raysOrigin: "bottom-center",
              raysSpeed: 0.25,
              lightSpread: 7,
              opacity: 1,
              saturation: 2,
              rayLength: 2,
              followMouse: !1,
              mouseInfluence: 0,
              distortion: 0.1,
              distortionPhase: 0.3,
              className: "custom-rays",
              gradientColors: ["#D15DFF", "#F78264", "#EFD7A4", "#CFDEF6"],
              gradientStops: [0, 0.25, 0.5, 1],
              gradientScale: 0.1,
              gradientOpacity: 1,
            }),
          }),
        ],
      })
    );
  },
  fMe = ({
    variant: n = "compact",
    className: e = "",
    size: t = "default",
    redirectPath: s,
  }) => {
    const r = Dr(),
      i = s || r.pathname + r.search,
      a = `/login?returnUrl=${encodeURIComponent(i)}`,
      o = n === "expanded" ? "Log in to join team" : "Sign in";
    return u.jsx(br, {
      to: a,
      children: u.jsx(et, { size: t, className: e, children: o }),
    });
  };
function mMe() {
  const { inviteCode: n } = p6(),
    e = es(),
    { user: t } = ks(),
    [s, r] = E.useState(null),
    [i, a] = E.useState(!0),
    [o, l] = E.useState(!1),
    [c, h] = E.useState(null);
  E.useEffect(() => {
    if (!n) {
      e("/");
      return;
    }
    m();
  }, [n]);
  const m = async () => {
      try {
        const y = await yie(`/api/teams/invite/${n}`);
        if (!y.ok) {
          if (y.status === 404) h("Page not found");
          else {
            const w = await y.json().catch(() => ({ error: "Unknown error" }));
            h(w.error || "Failed to load invite");
          }
          return;
        }
        const b = await y.json();
        r(b.team);
      } catch (y) {
        console.error("Error fetching team info:", y),
          h("Failed to load invite");
      } finally {
        a(!1);
      }
    },
    p = async () => {
      if (t) {
        l(!0);
        try {
          const y = await Ut(`/api/teams/invite/${n}`, { method: "POST" });
          if (!y.ok) {
            const w = await y.json().catch(() => ({ error: "Unknown error" }));
            throw new Error(w.error || "Failed to join team");
          }
          const b = await y.json();
          Xe.success("Successfully joined team!"),
            (window.location.href = "/dash");
        } catch (y) {
          console.error("Error joining team:", y),
            Xe.error(y instanceof Error ? y.message : "Failed to join team");
        } finally {
          l(!1);
        }
      }
    },
    g = () =>
      c
        ? u.jsx(si, {
            className: "text-center",
            children: u.jsx(Ti, { children: c }),
          })
        : i
        ? u.jsxs(u.Fragment, {
            children: [
              u.jsxs(si, {
                className: "text-center",
                children: [
                  u.jsx("div", {
                    className: "mx-auto",
                    children: u.jsx(yo, { width: 192, height: 32 }),
                  }),
                  u.jsx("div", {
                    className: "mx-auto",
                    children: u.jsx(yo, { width: 256 }),
                  }),
                ],
              }),
              u.jsx(or, {
                className: "flex justify-center py-8",
                children: u.jsx(yo, { width: 128 }),
              }),
              u.jsx(TI, {
                className: "justify-center",
                children: u.jsx(yo, { width: 128, height: 40 }),
              }),
            ],
          })
        : u.jsxs(u.Fragment, {
            children: [
              u.jsxs(si, {
                className: "text-center",
                children: [
                  u.jsx(Ti, {
                    className: "text-2xl",
                    children: "Team Invitation",
                  }),
                  u.jsxs(Ca, {
                    children: [
                      s?.creator_name || "Someone",
                      " has invited you to join",
                    ],
                  }),
                ],
              }),
              u.jsx(or, {
                className: "text-center",
                children: u.jsx("div", {
                  className:
                    "py-4 bg-card-background border-b border-border/50 rounded-3xl",
                  children: u.jsx("h3", {
                    className: "text-xl font-semibold",
                    children: s?.name,
                  }),
                }),
              }),
              u.jsx(TI, {
                className: "justify-center",
                children: t
                  ? u.jsx(et, {
                      onClick: p,
                      size: "lg",
                      disabled: o,
                      className: "button-primary",
                      children: o ? "Joining..." : "Join Team",
                    })
                  : u.jsx(fMe, { variant: "expanded", size: "lg" }),
              }),
            ],
          });
  return u.jsxs(u.Fragment, {
    children: [
      u.jsx(Wv, {}),
      u.jsx("div", {
        className:
          "min-h-screen relative z-10 flex items-center justify-center p-4",
        children: u.jsxs(ar, {
          className:
            "w-full max-w-md rounded-3xl bg-element-background shadow-2xl shadow-black ",
          children: [
            u.jsx("div", {
              className:
                "text-center pt-6 flex justify-center mb-4 -mt-0.5 border-t border-white/30 rounded-t-3xl",
              children: u.jsx(gL, {}),
            }),
            g(),
          ],
        }),
      }),
    ],
  });
}
function pMe() {
  return u.jsxs(u.Fragment, {
    children: [
      u.jsx("div", { className: "opacity-50", children: u.jsx(Wv, {}) }),
      u.jsx("div", {
        className: "min-h-screen text-white relative overflow-x-hidden",
        children: u.jsxs("div", {
          className:
            "container mx-auto max-w-6xl px-4 md:px-8 py-12 relative z-10 font-mono",
          children: [
            u.jsx("div", {
              className: "mb-8",
              children: u.jsx(br, {
                to: "/",
                children: u.jsx(et, { variant: "outline", children: " Back" }),
              }),
            }),
            u.jsx("div", {
              className: "w-full max-w-40 md:max-w-72 mx-auto mb-8",
              children: u.jsx("img", {
                src: "/images/paul.png",
                alt: "Paul Mccartney",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Both Paul McCartney and your local musician know how to play guitar and write on notepads.",
            }),
            u.jsx("div", {
              className: "w-full max-w-40 md:max-w-72 mx-auto mb-8",
              children: u.jsx("img", {
                src: "/images/jony.png",
                alt: "Jony Ive",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Both Jony Ive and a Junior Industrial Designer know how to sketch and use 3D modeling tools.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children: "However, one's work is loved 1000x more,",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children: "has 1000x greater societal impact",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-32",
              children: "and 1000x higher economic value than the other.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md text-center",
              children: "What's the one difference between them then?",
            }),
            u.jsx("div", {
              className: "w-full max-w-54 mx-auto mb-24",
              children: u.jsx("img", {
                src: "/images/illustration-taste.png",
                alt: "Taste illustration",
                className: "w-full max-w-md",
              }),
            }),
            u.jsxs("p", {
              className: "text-md md:text-md mb-8",
              children: [
                "Taste is the appreciation of what's possible",
                " ",
                u.jsx("span", {
                  className: "italic",
                  children:
                    '(i.e. "What does the best version of this looks like?")',
                }),
              ],
            }),
            u.jsx("div", {
              className: "w-full max-w-2xl mx-auto mb-16",
              children: u.jsx("img", {
                src: "/images/illustration-microdecisions.png",
                alt: "Microdecisions illustration",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Any microdecision you have to make in the creative process passes through the filter of your taste. The sum of all these microdecisions is what defines the quality of your output.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "The quality of any creative output is determined in small measure by the tool, and in way larger measure from one's taste.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "This is what leads to the highly concentrated nature of creative industries, where the small subset of people that have extraordinary taste are able to create (and capture) much of the economic value.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "An innovative, usable and intuitive app design generates billions in incremental revenue from user retention. The designers behind it are therefore highly sought after by companies, that pay them a disproportionally higher salary.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "A great video on social media generates millions of organic views, can make a business successful, enable a career for a creator. An average one is inconsequential.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "The top 1000 songs on Spotify average of 1B+ streams vs. 135 streams, the median # of streams of the 70M+ songs on Spotify.",
            }),
            u.jsx("h2", {
              className: "text-center font-bold text-sm md:text-xl mb-8",
              children: "The only differentiating factor",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Creative tools are built to close the gap between what one can imagine and reality (this is Figma's actual vision statement).",
            }),
            u.jsx("div", {
              className: "w-full max-w-2xl mx-auto mb-16 max-w-md",
              children: u.jsx("img", {
                src: "/images/illustration-gap.png",
                alt: "Gap between imagination and reality",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "A new wave of creative tools is coming to market, built with cloud+collaboration from the getgo (e.g. Figma) and AI native tools (e.g. Midjourney, v0, Heygen).",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Thanks to modern tools + AI the gap between what you can imagine (your taste) and reality will eventually collapse to 0.",
            }),
            u.jsx("div", {
              className: "w-full max-w-2xl mx-auto mb-16 max-w-md",
              children: u.jsx("img", {
                src: "/images/illustration-reality.png",
                alt: "Gap between imagination and reality",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Simple technical ability to use tools will become irrelevant, and taste will become the only determining factor behind top 1% creative output (and the disproportionate economic value it generates).",
            }),
            u.jsx("h2", {
              className: "text-sm md:text-xl text-center font-bold mb-8",
              children: "Building taste",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Taste is not something you're born with, you build and refine it your entire life. There are 3 components to building taste:",
            }),
            u.jsx("h3", {
              className: "text-md md:text-lg mb-4 font-bold",
              children: "1. Exposure",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Nothing is created in isolation. Being exposed to great work is key to building taste (realizing what's possible).",
            }),
            u.jsx("img", {
              src: "/images/illustration-inspiration.png",
              alt: "Grid of aesthetic images",
              className: "w-full mb-16",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-4",
              children: "Today, exposure is achieved with:",
            }),
            u.jsxs("ul", {
              className: "list-disc pl-6 mb-8 space-y-2 text-md md:text-md",
              children: [
                u.jsx("li", {
                  children:
                    "General purpose online platforms (YouTube, Instagram, Spotify, TikTok)",
                }),
                u.jsx("li", {
                  children:
                    "Specialized inspiration platforms (Pinterest, Dribbble, Behance, SoundCloud, Mobbin, awwwards)",
                }),
                u.jsx("li", {
                  children: "Curation tools (mymind, Pinterest, Cosmos)",
                }),
              ],
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "It's easier than ever to discover great creative work.",
            }),
            u.jsx("h3", {
              className: "text-md md:text-lg mb-4 font-bold",
              children: "2. Understanding Why",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Mere exposure to great work, however, leaves us completely clueless about why it's great. Not knowing this makes us unable to refine our taste for our own work.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Watching Inception doesn't make you as good a director as Christopher Nolan.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "To do that we have to understand the components, techniques used, best practices and references to other work. We have to understand why something works.",
            }),
            u.jsx("div", {
              className:
                "relative left-1/2 -translate-x-1/2 w-screen max-w-[120%] px-4 md:max-w-[160%] mb-16",
              children: u.jsx("img", {
                src: "/images/why-great.png",
                alt: "something is great, why something is great",
                className: "w-full",
              }),
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "This information is gatekept by the creator and those with the experience and taste to decode why something works.",
            }),
            u.jsxs("p", {
              className: "text-md md:text-md mb-4",
              children: [
                "Today those with taste may try to share it via theoretical courses (e.g.",
                " ",
                u.jsx("span", {
                  className: "italic",
                  children: '"Basics of UX Design: Heuristics"',
                }),
                ") or technical tutorials (e.g.",
                " ",
                u.jsx("span", {
                  className: "italic",
                  children: '"The Complete Figma Course"',
                }),
                ").",
              ],
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Both are suboptimal ways of sharing and absorbing taste, but they are the only ones used because there is currently no medium to convey creative taste.",
            }),
            u.jsx("h3", {
              className: "text-md md:text-lg mb-4 font-bold",
              children: "3. Feedback",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Working with people with good taste is the best way to acquire it yourself. In teams, the way this happens is through feedback.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-16",
              children:
                "Most creative tools make you use text comments for feedback. This is a terrible medium to share creative feedback. Try to write down why exactly your favorite song works so well. It's incredibly hard.",
            }),
            u.jsx("img", {
              src: "/images/illustration-quotes.png",
              alt: "I don't like this why? I don't know I just don't",
              className: "w-full mb-16",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mb-8",
              children:
                "Creatives working in teams have to resort to providing feedback through a convoluted mix of text comments, links to references, recalling best practices and theoretical concepts and video recordings, scattered through different tools.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mt-16",
              children:
                "Sharing creative feedback is a nebulous process because there is no medium to effectively do it.",
            }),
            u.jsx("p", {
              className: "text-md md:text-md mt-2",
              children: "Let's fix that.",
            }),
          ],
        }),
      }),
    ],
  });
}
function gMe() {
  return u.jsxs(u.Fragment, {
    children: [
      u.jsx(Wv, {}),
      u.jsx("div", {
        className: "min-h-screen text-white relative overflow-x-hidden",
        children: u.jsxs("div", {
          className: "container mx-auto max-w-4xl px-6 py-12 relative z-10",
          children: [
            u.jsx("div", {
              className: "mb-8",
              children: u.jsx(br, {
                to: "/",
                children: u.jsx(et, { variant: "outline", children: " Back" }),
              }),
            }),
            u.jsxs("article", {
              className: "prose prose-invert prose-lg max-w-none",
              children: [
                u.jsx("h1", {
                  className: "text-3xl font-bold mb-6",
                  children: "PRIVACY NOTICE",
                }),
                u.jsx("p", {
                  className: "mb-8",
                  children: u.jsx("strong", {
                    children: "Last updated: May 29, 2025",
                  }),
                }),
                u.jsxs("p", {
                  children: [
                    "Thank you for choosing to be part of our community at Flask (Company, we, us, our). We are committed to protecting your personal information and your right to privacy. If you have any questions or concerns about this privacy notice or our practices with regard to your personal information, please contact us at",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    ".",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "This privacy notice describes how we might use your information if you:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "Visit our website at flask.do" }),
                    u.jsx("li", {
                      children:
                        "Engage with us in other related ways  including any sales, marketing, or events",
                    }),
                  ],
                }),
                u.jsx("p", {
                  children: "In this privacy notice, if we refer to:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Website, we are referring to any website of ours that references or links to this policy",
                    }),
                    u.jsx("li", {
                      children:
                        "Services, we are referring to our Website, and other related services, including any sales, marketing, or events",
                    }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "The purpose of this privacy notice is to explain to you in the clearest way possible what information we collect, how we use it, and what rights you have in relation to it. If there are any terms in this privacy notice that you do not agree with, please discontinue use of our Services immediately.",
                }),
                u.jsx("p", {
                  children:
                    "Please read this privacy notice carefully, as it will help you understand what we do with the information that we collect.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mb-6",
                  children: "TABLE OF CONTENTS",
                }),
                u.jsxs("ol", {
                  className: "list-decimal list-inside mb-12 space-y-2",
                  children: [
                    u.jsx("li", {
                      children: "WHAT INFORMATION DO WE COLLECT?",
                    }),
                    u.jsx("li", {
                      children: "HOW DO WE PROCESS YOUR INFORMATION?",
                    }),
                    u.jsx("li", {
                      children:
                        "WHAT LEGAL BASES DO WE RELY ON TO PROCESS YOUR INFORMATION?",
                    }),
                    u.jsx("li", {
                      children:
                        "WHEN AND WITH WHOM DO WE SHARE YOUR PERSONAL INFORMATION?",
                    }),
                    u.jsx("li", { children: "GOOGLE API DATA" }),
                    u.jsx("li", {
                      children:
                        "DO WE OFFER ARTIFICIAL INTELLIGENCE-BASED PRODUCTS?",
                    }),
                    u.jsx("li", {
                      children: "HOW DO WE HANDLE YOUR SOCIAL LOGINS?",
                    }),
                    u.jsx("li", {
                      children:
                        "IS YOUR INFORMATION TRANSFERRED INTERNATIONALLY?",
                    }),
                    u.jsx("li", {
                      children: "HOW LONG DO WE KEEP YOUR INFORMATION?",
                    }),
                    u.jsx("li", {
                      children: "HOW DO WE KEEP YOUR INFORMATION SAFE?",
                    }),
                    u.jsx("li", {
                      children: "DO WE COLLECT INFORMATION FROM MINORS?",
                    }),
                    u.jsx("li", { children: "WHAT ARE YOUR PRIVACY RIGHTS?" }),
                    u.jsx("li", {
                      children: "CONTROLS FOR DO-NOT-TRACK FEATURES",
                    }),
                    u.jsx("li", {
                      children:
                        "DO CALIFORNIA RESIDENTS HAVE SPECIFIC PRIVACY RIGHTS?",
                    }),
                    u.jsx("li", {
                      children: "DO WE MAKE UPDATES TO THIS NOTICE?",
                    }),
                    u.jsx("li", {
                      children: "HOW CAN YOU CONTACT US ABOUT THIS NOTICE?",
                    }),
                    u.jsx("li", {
                      children:
                        "HOW CAN YOU REVIEW, UPDATE, OR DELETE THE DATA WE COLLECT FROM YOU?",
                    }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-1",
                  children: "1. WHAT INFORMATION DO WE COLLECT?",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Personal information you disclose to us",
                }),
                u.jsx("p", {
                  children:
                    "We collect personal information that you voluntarily provide to us when you register on the Website, express an interest in obtaining information about us or our products and Services, when you participate in activities on the Website or otherwise when you contact us.",
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", {
                      children: "Personal Information Provided by You.",
                    }),
                    " The personal information that we collect depends on the context of your interactions with us and the Website, the choices you make, and the products and features you use. The personal information we collect may include the following:",
                  ],
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "names" }),
                    u.jsx("li", { children: "phone numbers" }),
                    u.jsx("li", { children: "email addresses" }),
                    u.jsx("li", { children: "mailing addresses" }),
                    u.jsx("li", { children: "job titles" }),
                    u.jsx("li", { children: "usernames" }),
                    u.jsx("li", { children: "passwords" }),
                    u.jsx("li", { children: "contact preferences" }),
                    u.jsx("li", { children: "contact or authentication data" }),
                    u.jsx("li", { children: "billing addresses" }),
                    u.jsx("li", { children: "debit/credit card numbers" }),
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", { children: "Sensitive Information." }),
                    " We do not process sensitive information.",
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", { children: "Payment Data." }),
                    " We may collect data necessary to process your payment if you make purchases, such as your payment instrument number (such as a credit card number), and the security code associated with your payment instrument. All payment data is stored by Stripe. You may find their privacy notice here:",
                    " ",
                    u.jsx("a", {
                      href: "https://stripe.com/privacy",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: "https://stripe.com/privacy",
                    }),
                    ".",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "All personal information that you provide to us must be true, complete, and accurate, and you must notify us of any changes to such personal information.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Information automatically collected",
                }),
                u.jsx("p", {
                  children:
                    "We automatically collect certain information when you visit, use, or navigate the Website. This information does not reveal your specific identity (like your name or contact information) but may include device and usage information, such as your IP address, browser and device characteristics, operating system, language preferences, referring URLs, device name, country, location, information about how and when you use our Website and other technical information. This information is primarily needed to maintain the security and operation of our Website, and for our internal analytics and reporting purposes.",
                }),
                u.jsx("p", {
                  children: "The information we collect includes:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "Log and Usage Data." }),
                    u.jsx("li", { children: "Device Data." }),
                    u.jsx("li", { children: "Location Data." }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-2",
                  children: "2. HOW DO WE PROCESS YOUR INFORMATION?",
                }),
                u.jsx("p", {
                  children:
                    "We process your personal information for a variety of reasons, depending on how you interact with our Website, including:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "To facilitate account creation and authentication and otherwise manage user accounts.",
                    }),
                    u.jsx("li", {
                      children:
                        "To deliver and facilitate delivery of services to the user.",
                    }),
                    u.jsx("li", {
                      children:
                        "To respond to user inquiries/offer support to users.",
                    }),
                    u.jsx("li", {
                      children: "To send administrative information to you.",
                    }),
                    u.jsx("li", {
                      children:
                        "To send you marketing communications, product updates, feature announcements, and other promotional materials about Flask.",
                    }),
                    u.jsx("li", {
                      children: "To fulfill and manage your orders.",
                    }),
                    u.jsx("li", {
                      children: "To enable user-to-user communications.",
                    }),
                    u.jsx("li", { children: "To request feedback." }),
                    u.jsx("li", { children: "To protect our Services." }),
                    u.jsx("li", {
                      children:
                        "To enforce our terms, conditions, and policies for business purposes, to comply with legal and regulatory requirements or in connection with our contract.",
                    }),
                    u.jsx("li", {
                      children:
                        "To respond to legal requests and prevent harm.",
                    }),
                    u.jsx("li", { children: "To manage user accounts." }),
                    u.jsx("li", {
                      children: "To deliver targeted advertising to you.",
                    }),
                    u.jsx("li", {
                      children: "To administer prize draws and competitions.",
                    }),
                    u.jsx("li", {
                      children: "To comply with our legal obligations.",
                    }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-3",
                  children:
                    "3. WHAT LEGAL BASES DO WE RELY ON TO PROCESS YOUR INFORMATION?",
                }),
                u.jsx("p", {
                  children:
                    "If you are located in the EU or UK, this section applies to you.",
                }),
                u.jsx("p", {
                  children:
                    "The General Data Protection Regulation (GDPR) and UK GDPR require us to explain the valid legal bases we rely on in order to process your personal information. As such, we may rely on the following legal bases to process your personal information:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "Consent." }),
                    u.jsx("li", { children: "Performance of a Contract." }),
                    u.jsx("li", { children: "Legal Obligations." }),
                    u.jsx("li", { children: "Vital Interests." }),
                    u.jsx("li", { children: "Legitimate Interests." }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "If you are based in Canada, this section applies to you.",
                }),
                u.jsx("p", {
                  children:
                    "We may process your information if you have given us specific permission (i.e., express consent) to use your personal information for a specific purpose, or in situations where your permission can be inferred (i.e., implied consent). You can withdraw your consent at any time.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-4",
                  children:
                    "4. WHEN AND WITH WHOM DO WE SHARE YOUR PERSONAL INFORMATION?",
                }),
                u.jsx("p", {
                  children:
                    "We may need to share your personal information in the following situations:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "Business Transfers." }),
                    u.jsx("li", { children: "Affiliates." }),
                    u.jsx("li", { children: "Business Partners." }),
                    u.jsx("li", { children: "Other Users." }),
                    u.jsx("li", { children: "Offer Wall." }),
                    u.jsx("li", {
                      children:
                        "Vendors, Consultants, and Other Third-Party Service Providers.",
                    }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-5",
                  children: "5. GOOGLE API DATA",
                }),
                u.jsx("p", {
                  children:
                    "If you choose to connect your Google account with Flask, we may access certain information from your Google account, such as your name, email address, and profile picture, strictly for the purpose of providing and improving our services. We do not sell, rent, or share your Google user data with third parties for their own uses. We retain your Google user data only as long as necessary to provide our services or as required by law.",
                }),
                u.jsxs("p", {
                  children: [
                    "Our use and transfer to any other app of information received from Google APIs will adhere to the",
                    " ",
                    u.jsx("a", {
                      href: "https://developers.google.com/terms/api-services-user-data-policy",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: "Google API Services User Data Policy",
                    }),
                    ", including the Limited Use requirements.",
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "If you wish to delete your Google account data from Flask, please contact us at ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    " and we will promptly remove your information as required.",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-6",
                  children:
                    "6. DO WE OFFER ARTIFICIAL INTELLIGENCE-BASED PRODUCTS?",
                }),
                u.jsxs("p", {
                  children: [
                    "We may offer products or features that use artificial intelligence (AI). If you use these features, we may process your information as described in this privacy notice. For more information, please contact us at ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    ".",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-7",
                  children: "7. HOW DO WE HANDLE YOUR SOCIAL LOGINS?",
                }),
                u.jsx("p", {
                  children:
                    "Our Website offers you the ability to register and log in using your third-party social media account details (like your Google, Facebook, or Twitter logins). Where you choose to do this, we will receive certain profile information about you from your social media provider. The profile information we receive may vary depending on the social media provider concerned, but will often include your name, email address, friends list, and profile picture, as well as other information you choose to make public on such a social media platform.",
                }),
                u.jsx("p", {
                  children:
                    "We will use the information we receive only for the purposes that are described in this privacy notice or that are otherwise made clear to you on the relevant Website. Please note that we do not control, and are not responsible for, other uses of your personal information by your third-party social media provider.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-8",
                  children:
                    "8. IS YOUR INFORMATION TRANSFERRED INTERNATIONALLY?",
                }),
                u.jsx("p", {
                  children:
                    "Our servers are located in the US. If you are accessing our Website from outside the US, please be aware that your information may be transferred to, stored, and processed by us in our facilities and by those third parties with whom we may share your personal information (see WHEN AND WITH WHOM DO WE SHARE YOUR PERSONAL INFORMATION? above).",
                }),
                u.jsx("p", {
                  children:
                    "If you are a resident in the European Economic Area (EEA), United Kingdom (UK), or Switzerland, then these countries may not necessarily have data protection laws or other similar laws as comprehensive as those in your country. We will however take all necessary measures to protect your personal information in accordance with this privacy notice and applicable law.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-9",
                  children: "9. HOW LONG DO WE KEEP YOUR INFORMATION?",
                }),
                u.jsx("p", {
                  children:
                    "We will only keep your personal information for as long as it is necessary for the purposes set out in this privacy notice, unless a longer retention period is required or permitted by law (such as tax, accounting, or other legal requirements).",
                }),
                u.jsx("p", {
                  children:
                    "When we have no ongoing legitimate business need to process your personal information, we will either delete or anonymize such information, or, if this is not possible (for example, because your personal information has been stored in backup archives), then we will securely store your personal information and isolate it from any further processing until deletion is possible.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-10",
                  children: "10. HOW DO WE KEEP YOUR INFORMATION SAFE?",
                }),
                u.jsx("p", {
                  children:
                    "We have implemented appropriate and reasonable technical and organizational security measures designed to protect the security of any personal information we process. However, despite our safeguards and efforts to secure your information, no electronic transmission over the Internet or information storage technology can be guaranteed to be 100% secure, so we cannot promise or guarantee that hackers, cybercriminals, or other unauthorized third parties will not be able to defeat our security and improperly collect, access, steal, or modify your information.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-11",
                  children: "11. DO WE COLLECT INFORMATION FROM MINORS?",
                }),
                u.jsx("p", {
                  children:
                    "We do not knowingly solicit data from or market to children under 18 years of age. By using the Website, you represent that you are at least 18 or that you are the parent or guardian of such a minor and consent to such minor dependent's use of the Website. If we learn that personal information from users less than 18 years of age has been collected, we will deactivate the account and take reasonable measures to promptly delete such data from our records.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-12",
                  children: "12. WHAT ARE YOUR PRIVACY RIGHTS?",
                }),
                u.jsx("p", {
                  children:
                    "In some regions (like the EEA, UK, and Canada), you have rights that allow you greater access to and control over your personal information. These may include the right to:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Request access and obtain a copy of your personal information",
                    }),
                    u.jsx("li", {
                      children: "Request rectification or erasure",
                    }),
                    u.jsx("li", {
                      children:
                        "Restrict the processing of your personal information",
                    }),
                    u.jsx("li", {
                      children: "Data portability (if applicable)",
                    }),
                    u.jsx("li", {
                      children:
                        "Object to the processing of your personal information in certain circumstances",
                    }),
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "If you wish to exercise any of these rights, please contact us at",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    ". We will consider and act upon any request in accordance with applicable data protection laws.",
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Email Communications and Opt-Out",
                }),
                u.jsx("p", {
                  children:
                    "By creating an account with Flask, you agree to receive email communications from us, including:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Transactional emails (receipts, password resets, account notifications)",
                    }),
                    u.jsx("li", {
                      children: "Product updates and feature announcements",
                    }),
                    u.jsx("li", {
                      children:
                        "Marketing communications and promotional materials",
                    }),
                    u.jsx("li", {
                      children: "Newsletters and educational content",
                    }),
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", {
                      children:
                        "You may opt out of marketing emails at any time",
                    }),
                    ' by clicking the "unsubscribe" link at the bottom of any marketing email we send you. Please note that even if you opt out of marketing emails, you will still receive transactional emails necessary for operating your Flask account (such as password resets, receipts, and critical service notifications).',
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "To opt out of all non-essential communications, please contact us at",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    ".",
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "If you are a resident in the EEA or UK and you believe we are unlawfully processing your personal information, you also have the right to complain to your local data protection supervisory authority. You can find their contact details here:",
                    " ",
                    u.jsx("a", {
                      href: "https://ec.europa.eu/justice/data-protection/bodies/authorities/index_en.htm",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children:
                        "https://ec.europa.eu/justice/data-protection/bodies/authorities/index_en.htm",
                    }),
                    ".",
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "If you are a resident in Switzerland, the contact details for the data protection authorities are available here:",
                    " ",
                    u.jsx("a", {
                      href: "https://www.edoeb.admin.ch/edoeb/en/home.html",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: "https://www.edoeb.admin.ch/edoeb/en/home.html",
                    }),
                    ".",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-13",
                  children: "13. CONTROLS FOR DO-NOT-TRACK FEATURES",
                }),
                u.jsx("p", {
                  children:
                    'Most web browsers and some mobile operating systems and mobile applications include a Do-Not-Track ("DNT") feature or setting you can activate to signal your privacy preference not to have data about your online browsing activities monitored and collected. At this stage no uniform technology standard for recognizing and implementing DNT signals has been finalized. As such, we do not currently respond to DNT browser signals or any other mechanism that automatically communicates your choice not to be tracked online. If a standard for online tracking is adopted that we must follow in the future, we will inform you about that practice in a revised version of this privacy notice.',
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-14",
                  children:
                    "14. DO CALIFORNIA RESIDENTS HAVE SPECIFIC PRIVACY RIGHTS?",
                }),
                u.jsx("p", {
                  children:
                    "California Civil Code Section 1798.83, also known as the Shine The Light law, permits our users who are California residents to request and obtain from us, once a year and free of charge, information about categories of personal information (if any) we disclosed to third parties for direct marketing purposes and the names and addresses of all third parties with which we shared personal information in the immediately preceding calendar year. If you are a California resident and would like to make such a request, please submit your request in writing to us using the contact information provided below.",
                }),
                u.jsx("p", {
                  children:
                    "If you are under 18 years of age, reside in California, and have a registered account with the Website, you have the right to request removal of unwanted data that you publicly post on the Website. To request removal of such data, please contact us using the contact information provided below, and include the email address associated with your account and a statement that you reside in California. We will make sure the data is not publicly displayed on the Website, but please be aware that the data may not be completely or comprehensively removed from all our systems (e.g., backups, etc.).",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-15",
                  children: "15. DO WE MAKE UPDATES TO THIS NOTICE?",
                }),
                u.jsx("p", {
                  children:
                    "We may update this privacy notice from time to time. The updated version will be indicated by an updated Revised date and the updated version will be effective as soon as it is accessible. If we make material changes to this privacy notice, we may notify you either by prominently posting a notice of such changes or by directly sending you a notification. We encourage you to review this privacy notice frequently to be informed of how we are protecting your information.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-16",
                  children: "16. HOW CAN YOU CONTACT US ABOUT THIS NOTICE?",
                }),
                u.jsxs("p", {
                  children: [
                    "If you have questions or comments about this notice, you may email us at ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    " or by post to:",
                  ],
                }),
                u.jsxs("address", {
                  className: "not-italic",
                  children: [
                    "Flask",
                    u.jsx("br", {}),
                    "124 City Road",
                    u.jsx("br", {}),
                    "London, EC1V 2NX",
                    u.jsx("br", {}),
                    "United Kingdom",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-17",
                  children:
                    "17. HOW CAN YOU REVIEW, UPDATE, OR DELETE THE DATA WE COLLECT FROM YOU?",
                }),
                u.jsxs("p", {
                  children: [
                    "Based on the applicable laws of your country, you may have the right to request access to the personal information we collect from you, change that information, or delete it in some circumstances. To request to review, update, or delete your personal information, please email us at:",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      children: "hello@flask.to",
                    }),
                    ".",
                  ],
                }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
}
function vMe() {
  return u.jsxs(u.Fragment, {
    children: [
      u.jsx(Wv, {}),
      u.jsx("div", {
        className: "min-h-screen text-white relative overflow-x-hidden",
        children: u.jsxs("div", {
          className: "container mx-auto max-w-4xl px-6 py-12 relative z-10",
          children: [
            u.jsx("div", {
              className: "mb-8",
              children: u.jsx(br, {
                to: "/",
                children: u.jsx(et, { variant: "outline", children: " Back" }),
              }),
            }),
            u.jsxs("article", {
              className: "prose prose-invert prose-lg max-w-none list-disc",
              children: [
                u.jsx("h1", {
                  className: "text-3xl font-bold mb-6",
                  children: "TERMS OF SERVICE",
                }),
                u.jsx("p", {
                  className: "mb-8",
                  children: u.jsx("strong", {
                    children: "Last updated: Oct 7, 2025",
                  }),
                }),
                u.jsx("p", {
                  children: `Welcome to Flask. These Terms of Service ("Terms") govern your access to and use of Flask's video collaboration platform, website, and services (collectively, the "Service"). Please read these Terms carefully before using Flask.`,
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mb-6",
                  children: "TABLE OF CONTENTS",
                }),
                u.jsxs("ol", {
                  className: "list-decimal list-inside mb-12 space-y-2",
                  children: [
                    u.jsx("li", { children: "About Flask" }),
                    u.jsx("li", { children: "Eligibility" }),
                    u.jsx("li", {
                      children: "Account Registration and Security",
                    }),
                    u.jsx("li", {
                      children: "Service Plans: Free and Flask Pro",
                    }),
                    u.jsx("li", {
                      children: "Your Content and Intellectual Property",
                    }),
                    u.jsx("li", {
                      children: "Flask's Intellectual Property Rights",
                    }),
                    u.jsx("li", {
                      children: "AI Processing and Third-Party Services",
                    }),
                    u.jsx("li", { children: "Analytics and Tracking" }),
                    u.jsx("li", {
                      children: "Acceptable Use and Prohibited Activities",
                    }),
                    u.jsx("li", {
                      children: "Termination and Account Deletion",
                    }),
                    u.jsx("li", { children: "Payment Terms and Refunds" }),
                    u.jsx("li", {
                      children: "Disclaimers and Limitation of Liability",
                    }),
                    u.jsx("li", { children: "Indemnification" }),
                    u.jsx("li", { children: "Changes to Terms" }),
                    u.jsx("li", {
                      children: "Governing Law and Dispute Resolution",
                    }),
                    u.jsx("li", { children: "Contact Information" }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-1",
                  children: "1. ABOUT FLASK",
                }),
                u.jsxs("p", {
                  children: [
                    "Flask is provided by ",
                    u.jsx("strong", { children: "Enritarta Ltd" }),
                    ", a company registered in England and Wales (company registration details available upon request), with a registered address at:",
                  ],
                }),
                u.jsxs("address", {
                  className: "not-italic ml-4",
                  children: [
                    "124 City Road",
                    u.jsx("br", {}),
                    "London, EC1V 2NX",
                    u.jsx("br", {}),
                    "United Kingdom",
                  ],
                }),
                u.jsx("p", {
                  className: "mt-4",
                  children:
                    "Flask is a video collaboration platform designed for creative teams to record, share, organize, and collaborate on video feedback.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-2",
                  children: "2. ELIGIBILITY",
                }),
                u.jsxs("p", {
                  children: [
                    "You must be at least ",
                    u.jsx("strong", { children: "18 years of age" }),
                    " to use Flask. By using the Service, you represent and warrant that you meet this age requirement.",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "If you are using Flask on behalf of an organization, you represent that you have the authority to bind that organization to these Terms.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-3",
                  children: "3. ACCOUNT REGISTRATION AND SECURITY",
                }),
                u.jsxs("p", {
                  children: [
                    "You may register using third-party authentication services (such as Google). When you do so, you authorize Flask to access certain information from that service as described in our",
                    " ",
                    u.jsx(br, {
                      to: "/privacy-policy",
                      className: "text-blue-400 hover:underline",
                      children: "Privacy Policy",
                    }),
                    ".",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-4",
                  children: "4. SERVICE PLANS: FREE AND FLASK PRO",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Free Plan",
                }),
                u.jsx("p", {
                  children:
                    "Flask offers a free plan with unlimited video collaboration. Free plan users upload videos to YouTube, and videos are embedded within Flask's platform. Free plan recordings are subject to YouTube's Terms of Service and content policies.",
                }),
                u.jsx("p", {
                  children:
                    "Flask reserves the right to monitor and terminate free accounts that demonstrate abusive behavior, including but not limited to: automated bot activity, unreasonable volumes of recordings or comments suggesting commercial or non-personal use, or other patterns inconsistent with individual creative collaboration.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Flask Pro",
                }),
                u.jsx("p", {
                  children:
                    "Flask Pro is a paid subscription plan that includes:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children: "Direct uploads to Flask (no YouTube required)",
                    }),
                    u.jsx("li", { children: "Shared team workspaces" }),
                    u.jsx("li", {
                      children: "Up to 5TB of storage per account",
                    }),
                    u.jsx("li", {
                      children: "Additional collaboration features",
                    }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "Flask Pro subscriptions are billed monthly or annually as selected during purchase. Payment is processed through Stripe. By subscribing to Flask Pro, you authorize Flask to charge your payment method on a recurring basis until you cancel.",
                }),
                u.jsx("p", {
                  children:
                    "Higher-tier plans with increased storage limits are currently under development and will be available in the future.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-5",
                  children: "5. YOUR CONTENT AND INTELLECTUAL PROPERTY",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Ownership",
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", { children: "You retain full ownership" }),
                    ' of all content you upload, create, or share through Flask, including videos, recordings, comments, annotations, and other materials (collectively, "Your Content").',
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "License to Flask",
                }),
                u.jsx("p", {
                  children:
                    "To operate the Service, you grant Flask a limited, worldwide, non-exclusive, royalty-free license to host, store, display, and transmit Your Content solely for the purpose of providing the Service to you and your collaborators.",
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", {
                      children:
                        "Flask will not use Your Content for marketing purposes, advertising, or any purpose beyond providing the Service to you.",
                    }),
                    " Your uploaded videos are not used to train AI models or shared with third parties except as explicitly described in these Terms.",
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Responsibility",
                }),
                u.jsx("p", {
                  children:
                    "You are solely responsible for Your Content and the consequences of sharing it. You represent and warrant that:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "You own or have the necessary rights to Your Content",
                    }),
                    u.jsx("li", {
                      children:
                        "Your Content does not violate any third-party rights, including intellectual property, privacy, or publicity rights",
                    }),
                    u.jsx("li", {
                      children:
                        "Your Content complies with these Terms and applicable laws",
                    }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-6",
                  children: "6. FLASK'S INTELLECTUAL PROPERTY RIGHTS",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Ownership of Flask",
                }),
                u.jsx("p", {
                  children:
                    "All rights, title, and interest in and to the Flask Service, including but not limited to the following, are owned exclusively by Enritarta Ltd and are protected by copyright, trademark, patent, trade secret, and other intellectual property laws:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "The Flask software, platform, and application (including source code, object code, and underlying technology)",
                    }),
                    u.jsx("li", {
                      children:
                        "Flask's proprietary algorithms, features, functionality, and user interface",
                    }),
                    u.jsx("li", {
                      children:
                        "The Flask name, logo, branding, trademarks, and service marks",
                    }),
                    u.jsx("li", {
                      children:
                        "All visual designs, graphics, user interface elements, and design systems",
                    }),
                    u.jsx("li", {
                      children:
                        "Flask's proprietary technology, infrastructure, and technical innovations",
                    }),
                    u.jsx("li", {
                      children:
                        "Documentation, tutorials, help content, and other materials provided by Flask",
                    }),
                    u.jsx("li", {
                      children:
                        "Any updates, modifications, or derivative works of the above",
                    }),
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Limited License to Use Flask",
                }),
                u.jsx("p", {
                  children:
                    "Subject to your compliance with these Terms, Flask grants you a limited, non-exclusive, non-transferable, non-sublicensable, revocable license to access and use the Service for your personal or internal business purposes only.",
                }),
                u.jsx("p", {
                  children: "This license does not grant you any rights to:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Copy, modify, distribute, sell, or lease any part of the Service",
                    }),
                    u.jsx("li", {
                      children:
                        "Reverse engineer, decompile, or attempt to extract the source code of Flask",
                    }),
                    u.jsx("li", {
                      children:
                        "Remove, alter, or obscure any proprietary notices (copyright, trademark, etc.) on the Service",
                    }),
                    u.jsx("li", {
                      children:
                        "Use Flask's branding, trademarks, or logos without prior written permission",
                    }),
                    u.jsx("li", {
                      children:
                        "Create derivative works or competing products based on Flask",
                    }),
                    u.jsx("li", {
                      children:
                        "Frame or mirror any part of the Service without express written permission",
                    }),
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Feedback and Suggestions",
                }),
                u.jsx("p", {
                  children: `If you provide Flask with any feedback, suggestions, or ideas about the Service ("Feedback"), you acknowledge and agree that Flask may use such Feedback without any obligation to you, including without limitation to incorporate Feedback into the Service. You hereby grant Flask a perpetual, worldwide, royalty-free, irrevocable license to use, modify, and incorporate Feedback into Flask's products and services.`,
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Trademark Notice",
                }),
                u.jsx("p", {
                  children:
                    '"Flask" and the Flask logo are trademarks of Enritarta Ltd. You may not use these trademarks without prior written permission from Enritarta Ltd. All other trademarks, service marks, and trade names referenced in the Service are the property of their respective owners.',
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-7",
                  children: "7. AI PROCESSING AND THIRD-PARTY SERVICES",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "AI-Generated Summaries",
                }),
                u.jsx("p", {
                  children:
                    "Flask offers AI-powered features, including automatic transcription and summarization of recordings made within Flask canvases. When you use these features:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Only recordings created within Flask are processed by third-party AI services (Google Gemini)",
                    }),
                    u.jsxs("li", {
                      children: [
                        "Uploaded videos (whether via YouTube or direct upload) are",
                        " ",
                        u.jsx("strong", { children: "not" }),
                        " sent to AI services",
                      ],
                    }),
                    u.jsx("li", {
                      children:
                        "AI processing is used solely to generate summaries and insights for your use",
                    }),
                    u.jsx("li", {
                      children:
                        "Your recordings are not used to train AI models",
                    }),
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Third-Party Services",
                }),
                u.jsx("p", {
                  children:
                    "Flask integrates with the following third-party services:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Supabase:" }),
                        " Database and authentication",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Mux:" }),
                        " Video processing and streaming (Flask Pro)",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "YouTube:" }),
                        " Video hosting (Free plan)",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Stripe:" }),
                        " Payment processing",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Vercel:" }),
                        " Hosting infrastructure",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Google Gemini:" }),
                        " AI transcription and summarization",
                      ],
                    }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "Your use of Flask may be subject to the terms of service and privacy policies of these third-party providers. Flask is not responsible for the practices or performance of third-party services.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-8",
                  children: "8. ANALYTICS AND TRACKING",
                }),
                u.jsx("p", {
                  children:
                    "Flask uses analytics and tracking technologies to improve the Service and understand how users interact with our platform. We use:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "Google Analytics:" }),
                        " To track page views, user behavior, and site performance",
                      ],
                    }),
                    u.jsxs("li", {
                      children: [
                        u.jsx("strong", { children: "PostHog:" }),
                        " For product analytics, feature usage tracking, and user experience optimization",
                      ],
                    }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "These services collect information such as your IP address, browser type, device information, pages visited, features used, and interaction patterns.",
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", {
                      children:
                        "By using Flask, you consent to this tracking and analytics as a necessary part of operating and improving the Service.",
                    }),
                    " ",
                    "Analytics data is used solely to enhance Flask's product and user experience. We do not sell analytics data to third parties.",
                  ],
                }),
                u.jsxs("p", {
                  children: [
                    "For more information about data collection, please see our",
                    " ",
                    u.jsx(br, {
                      to: "/privacy-policy",
                      className: "text-blue-400 hover:underline",
                      children: "Privacy Policy",
                    }),
                    ".",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-9",
                  children: "9. ACCEPTABLE USE AND PROHIBITED ACTIVITIES",
                }),
                u.jsx("p", { children: "You agree not to use Flask to:" }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "Violate any applicable laws, regulations, or third-party rights",
                    }),
                    u.jsx("li", {
                      children:
                        "Upload, share, or transmit illegal, harmful, threatening, abusive, harassing, defamatory, or otherwise objectionable content",
                    }),
                    u.jsx("li", {
                      children:
                        "Infringe upon intellectual property rights, including copyrights, trademarks, or trade secrets",
                    }),
                    u.jsx("li", {
                      children:
                        "Use automated systems (bots, scrapers, crawlers) to access or interact with the Service without authorization",
                    }),
                    u.jsx("li", {
                      children:
                        "Attempt to gain unauthorized access to Flask's systems, networks, or user accounts",
                    }),
                    u.jsx("li", {
                      children:
                        "Interfere with or disrupt the Service, servers, or networks connected to Flask",
                    }),
                    u.jsx("li", {
                      children:
                        "Use the Service for commercial purposes inconsistent with your account type (e.g., operating a commercial service on a Free plan)",
                    }),
                    u.jsx("li", {
                      children:
                        "Reverse engineer, decompile, or attempt to extract source code from Flask",
                    }),
                    u.jsx("li", {
                      children:
                        "Impersonate any person or entity, or misrepresent your affiliation with any person or entity",
                    }),
                  ],
                }),
                u.jsx("p", {
                  children:
                    "Flask reserves the right to investigate and take appropriate action against anyone who violates these Terms, including removing content, suspending or terminating accounts, and reporting to law enforcement authorities.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-10",
                  children: "10. TERMINATION AND ACCOUNT DELETION",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Termination by You",
                }),
                u.jsxs("p", {
                  children: [
                    "You may delete your Flask account at any time through your account settings or by contacting us at",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      className: "text-blue-400 hover:underline",
                      children: "hello@flask.to",
                    }),
                    ".",
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Termination by Flask",
                }),
                u.jsx("p", {
                  children:
                    "Flask reserves the right to suspend or terminate your account if you violate these Terms or engage in conduct that Flask determines to be harmful to the Service or other users. Where possible, we will provide notice before termination, except in cases of serious violations or legal requirements.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Data Retention After Termination",
                }),
                u.jsxs("p", {
                  children: [
                    "Upon account deletion or termination, your data will be retained for ",
                    u.jsx("strong", { children: "30 days" }),
                    " before permanent deletion. During this period, you may contact us to request account restoration. After 30 days, Your Content and account data will be permanently deleted from Flask's systems, except where retention is required by law or for legitimate business purposes (such as resolving disputes or enforcing these Terms).",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-11",
                  children: "11. PAYMENT TERMS AND REFUNDS",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Pricing",
                }),
                u.jsx("p", {
                  children:
                    "Flask Pro subscription pricing is displayed on our website at the time of purchase. All prices are in the currency specified at checkout. Flask reserves the right to change pricing with notice to existing subscribers.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Billing",
                }),
                u.jsx("p", {
                  children:
                    "Flask Pro subscriptions automatically renew at the end of each billing cycle (monthly or annually) unless canceled. You will be charged on the renewal date using your payment method on file.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Cancellation",
                }),
                u.jsx("p", {
                  children:
                    "You may cancel your Flask Pro subscription at any time through your account settings. Cancellation takes effect at the end of your current billing period. You will retain access to Flask Pro features until that date.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Refund Policy",
                }),
                u.jsxs("p", {
                  children: [
                    "Flask offers a ",
                    u.jsx("strong", { children: "30-day refund policy" }),
                    " for Flask Pro subscriptions. If you are not satisfied with Flask Pro within 30 days of your initial purchase or renewal, contact us at",
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      className: "text-blue-400 hover:underline",
                      children: "hello@flask.to",
                    }),
                    " ",
                    "to request a full refund. Refunds are issued to the original payment method.",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "After 30 days, no refunds will be provided for subscription fees, and cancellations will take effect at the end of the current billing period.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-12",
                  children: "12. DISCLAIMERS AND LIMITATION OF LIABILITY",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "No Warranties",
                }),
                u.jsx("p", {
                  children:
                    'Flask is provided "as is" and "as available" without warranties of any kind, whether express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose, or non-infringement.',
                }),
                u.jsx("p", { children: "Flask does not warrant that:" }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", {
                      children:
                        "The Service will be uninterrupted, secure, or error-free",
                    }),
                    u.jsx("li", {
                      children:
                        "The Service will meet your requirements or expectations",
                    }),
                    u.jsx("li", {
                      children: "Any errors or defects will be corrected",
                    }),
                    u.jsx("li", {
                      children:
                        "The Service or servers are free of viruses or harmful components",
                    }),
                  ],
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Best Effort Service",
                }),
                u.jsxs("p", {
                  children: [
                    "Flask is provided on a ",
                    u.jsx("strong", { children: "best effort basis" }),
                    ". We do not guarantee any specific uptime or availability of the Service. Flask may experience downtime, interruptions, or performance issues due to maintenance, technical difficulties, third-party service failures, or other factors beyond our control.",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "We reserve the right to modify, suspend, or discontinue any part of the Service at any time, with or without notice, for any reason, including but not limited to maintenance, updates, or improvements.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Limitation of Liability",
                }),
                u.jsx("p", {
                  children:
                    "To the fullest extent permitted by law, Flask, its officers, directors, employees, and affiliates shall not be liable for any indirect, incidental, special, consequential, or punitive damages, including but not limited to loss of profits, data, use, or goodwill, arising out of or related to your use of or inability to use the Service, even if Flask has been advised of the possibility of such damages.",
                }),
                u.jsx("p", {
                  children:
                    "In no event shall Flask's total liability to you for all claims arising out of or relating to these Terms or the Service exceed the amount you paid to Flask in the 12 months preceding the claim, or 100, whichever is greater.",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Third-Party Services",
                }),
                u.jsx("p", {
                  children:
                    "Flask is not responsible for the performance, availability, or content of third-party services (including YouTube, Mux, Stripe, and others). Any issues with third-party services should be directed to those providers.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-13",
                  children: "13. INDEMNIFICATION",
                }),
                u.jsx("p", {
                  children:
                    "You agree to indemnify, defend, and hold harmless Flask and its officers, directors, employees, and affiliates from and against any claims, liabilities, damages, losses, costs, or expenses (including reasonable attorneys' fees) arising out of or related to:",
                }),
                u.jsxs("ul", {
                  children: [
                    u.jsx("li", { children: "Your use of the Service" }),
                    u.jsx("li", { children: "Your Content" }),
                    u.jsx("li", { children: "Your violation of these Terms" }),
                    u.jsx("li", {
                      children:
                        "Your violation of any third-party rights, including intellectual property, privacy, or publicity rights",
                    }),
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-14",
                  children: "14. CHANGES TO TERMS",
                }),
                u.jsx("p", {
                  children:
                    'Flask reserves the right to modify these Terms at any time. When we make changes, the updated Terms will be posted on this page with a revised "Last updated" date at the top.',
                }),
                u.jsxs("p", {
                  children: [
                    u.jsx("strong", {
                      children:
                        "This page is the authoritative source for the current Terms of Service.",
                    }),
                    " We will not send email notifications for updates to these Terms. It is your responsibility to review this page periodically for any changes.",
                  ],
                }),
                u.jsx("p", {
                  children:
                    "Your continued use of Flask after the effective date of the updated Terms constitutes your acceptance of the changes. If you do not agree to the modified Terms, you must stop using the Service and may delete your account.",
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-15",
                  children: "15. GOVERNING LAW AND DISPUTE RESOLUTION",
                }),
                u.jsx("h3", {
                  className: "text-xl font-semibold mt-8 mb-2",
                  children: "Governing Law",
                }),
                u.jsxs("p", {
                  children: [
                    "These Terms are governed by and construed in accordance with the laws of ",
                    u.jsx("strong", { children: "Italy" }),
                    ", without regard to conflict of law principles.",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
                u.jsx("h2", {
                  className: "text-2xl font-bold mt-12 mb-4",
                  id: "section-16",
                  children: "16. CONTACT INFORMATION",
                }),
                u.jsx("p", {
                  children:
                    "If you have any questions, concerns, or feedback about these Terms, please contact us at:",
                }),
                u.jsxs("address", {
                  className: "not-italic ml-4",
                  children: [
                    u.jsx("strong", { children: "Email:" }),
                    " ",
                    u.jsx("a", {
                      href: "mailto:hello@flask.to",
                      className: "text-blue-400 hover:underline",
                      children: "hello@flask.to",
                    }),
                    u.jsx("br", {}),
                    u.jsx("strong", { children: "Address:" }),
                    u.jsx("br", {}),
                    "Enritarta Ltd",
                    u.jsx("br", {}),
                    "124 City Road",
                    u.jsx("br", {}),
                    "London, EC1V 2NX",
                    u.jsx("br", {}),
                    "United Kingdom",
                  ],
                }),
                u.jsx("hr", { className: "border-gray-700 my-8" }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
}
function yMe() {
  const n = es(),
    [e] = od(),
    { user: t } = ks(),
    { fetchUserTeams: s, updateTeamName: r } = _b(),
    [i, a] = E.useState("loading"),
    [o, l] = E.useState(""),
    [c, h] = E.useState(!1),
    [m, p] = E.useState(null),
    [g, y] = E.useState(!1),
    [b, w] = E.useState(null);
  E.useEffect(() => {
    if (!t) {
      const D = encodeURIComponent("/newteam");
      n(`/login?returnUrl=${D}`);
      return;
    }
    e.get("session_id") ? S() : n("/#pricing");
  }, [t, n, e]);
  const S = async (C) => {
      try {
        await new Promise((V) => setTimeout(V, 2e3));
        const D = await Ut("/api/teams");
        if (!D.ok) throw new Error("Failed to fetch teams");
        const { teams: L } = await D.json(),
          P = L.filter((V) => V.team_type === "pro_team").sort(
            (V, N) =>
              new Date(N.created_at).getTime() -
              new Date(V.created_at).getTime()
          )[0];
        if (P) w(P.id), p(P), l(P.name), a("rename");
        else throw new Error("Team not found after payment");
      } catch (D) {
        console.error("Error fetching team after checkout:", D),
          Xe.error("Failed to load your new team. Please refresh the page."),
          a("rename");
      }
    },
    A = async () => {
      if (!o.trim() || !b) {
        Xe.error("Please enter a team name");
        return;
      }
      h(!0);
      try {
        await r(b, o.trim());
        const C = await Ut(`/api/teams/${b}`);
        if (C.ok) {
          const D = await C.json();
          p(D.team);
        }
        a("success"), t && (await s(t.id));
      } catch (C) {
        console.error("Error renaming team:", C),
          Xe.error(C instanceof Error ? C.message : "Failed to rename team");
      } finally {
        h(!1);
      }
    },
    _ = async () => {
      if (!m) return;
      const C = `${window.location.origin}/invite/${m.invite_code}`;
      try {
        await navigator.clipboard.writeText(C),
          y(!0),
          Xe.success("Invite link copied to clipboard!"),
          setTimeout(() => y(!1), 2e3);
      } catch (D) {
        console.error("Failed to copy:", D), Xe.error("Failed to copy link");
      }
    },
    R = () => {
      n("/");
    };
  return t
    ? u.jsxs(u.Fragment, {
        children: [
          u.jsx(Wv, {}),
          u.jsxs("div", {
            className:
              "min-h-screen relative z-10 flex items-center justify-center p-4",
            children: [
              i === "loading" &&
                u.jsx(ar, {
                  className:
                    "w-full max-w-md bg-element-background border-border",
                  children: u.jsx(or, {
                    className: "p-8",
                    children: u.jsxs("div", {
                      className: "flex flex-col items-center space-y-6",
                      children: [
                        u.jsx(wo, {
                          className: "h-8 w-8 animate-spin text-primary",
                        }),
                        u.jsxs("div", {
                          className: "text-center space-y-2",
                          children: [
                            u.jsx("h2", {
                              className:
                                "text-xl font-semibold text-text-primary",
                              children: "Setting up your team...",
                            }),
                            u.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children:
                                "Please wait while we configure your new team",
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                }),
              i === "rename" &&
                u.jsx(ar, {
                  className:
                    "w-full max-w-md bg-element-background border-border",
                  children: u.jsx(or, {
                    className: "p-8",
                    children: u.jsxs("div", {
                      className: "flex flex-col items-center space-y-6",
                      children: [
                        u.jsx("img", {
                          src: "/images/LogoTextSmall.png",
                          alt: "Flask Logo",
                          className: "w-20 h-16 object-contain",
                        }),
                        u.jsxs("div", {
                          className: "text-center space-y-2",
                          children: [
                            u.jsx("h2", {
                              className:
                                "text-2xl font-semibold text-text-primary",
                              children: "Name Your Team",
                            }),
                            u.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children: "Choose a name for your new Pro team",
                            }),
                          ],
                        }),
                        u.jsxs("div", {
                          className: "w-full space-y-4",
                          children: [
                            u.jsx("div", {
                              className: "space-y-2",
                              children: u.jsx(ta, {
                                id: "team-name",
                                type: "text",
                                placeholder: "Team name",
                                value: o,
                                onChange: (C) => l(C.target.value),
                                onKeyDown: (C) => {
                                  C.key === "Enter" && !c && A();
                                },
                                disabled: c,
                                autoFocus: !0,
                                className: "h-12 text-base",
                              }),
                            }),
                            u.jsx(et, {
                              onClick: A,
                              size: "lg",
                              disabled: c || !o.trim(),
                              className: "w-full h-12 text-base",
                              children: c ? "Updating..." : "Continue",
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                }),
              i === "success" &&
                m &&
                u.jsx(ar, {
                  className:
                    "w-full max-w-md bg-element-background border-border",
                  children: u.jsx(or, {
                    className: "p-8",
                    children: u.jsxs("div", {
                      className: "flex flex-col items-center space-y-6",
                      children: [
                        u.jsxs("div", {
                          className: "flex flex-col items-center space-y-4",
                          children: [
                            u.jsx("div", {
                              className:
                                "w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center",
                              children: u.jsx(zs, {
                                className: "h-8 w-8 text-primary",
                              }),
                            }),
                            u.jsxs("div", {
                              className: "text-center space-y-2",
                              children: [
                                u.jsx("h2", {
                                  className:
                                    "text-2xl font-semibold text-text-primary",
                                  children: "Team Created!",
                                }),
                                u.jsxs("p", {
                                  className: "text-sm text-muted-foreground",
                                  children: [
                                    m.name,
                                    " is ready for collaboration",
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                        u.jsxs("div", {
                          className: "w-full space-y-4",
                          children: [
                            u.jsxs("div", {
                              className: "space-y-2",
                              children: [
                                u.jsx("p", {
                                  className:
                                    "text-sm font-medium text-text-secondary",
                                  children:
                                    "Share this link to invite team members",
                                }),
                                u.jsxs("div", {
                                  className: "flex items-center gap-2",
                                  children: [
                                    u.jsx(ta, {
                                      type: "text",
                                      value: `${window.location.origin}/invite/${m.invite_code}`,
                                      readOnly: !0,
                                      className:
                                        "h-12 font-mono text-sm bg-background/50",
                                    }),
                                    u.jsx(et, {
                                      size: "lg",
                                      variant: "outline",
                                      onClick: _,
                                      className: "h-12 px-4",
                                      children: g
                                        ? u.jsx(zs, { className: "h-4 w-4" })
                                        : u.jsx(LH, { className: "h-4 w-4" }),
                                    }),
                                  ],
                                }),
                              ],
                            }),
                            u.jsx(et, {
                              onClick: R,
                              size: "lg",
                              className: "w-full h-12 text-base",
                              children: "Go to Team",
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                }),
            ],
          }),
        ],
      })
    : null;
}
const bMe = () => {
  const n = es();
  return u.jsx("div", {
    className:
      "min-h-screen flex items-center justify-center bg-black text-white",
    children: u.jsxs("div", {
      className: "text-center",
      children: [
        u.jsx("h1", { className: "text-4xl font-bold mb-4", children: "404" }),
        u.jsx("p", {
          className: "text-white/60 mb-6",
          children: "Page not found",
        }),
        u.jsx(et, {
          onClick: () => n("/"),
          variant: "link",
          className: "text-white/80",
          children: "Go home",
        }),
      ],
    }),
  });
};
function xMe() {
  return u.jsx(bMe, {});
}
function wMe() {
  const n = es(),
    [e] = od(),
    { user: t, isLoading: s, isInitialized: r } = ks();
  return (
    E.useEffect(() => {
      (async () => {
        Object.fromEntries(e.entries()), t?.id;
        const a =
            e.get("redirectTo") ||
            e.get("redirect_to") ||
            e.get("returnUrl") ||
            e.get("next") ||
            "/dash",
          o = e.get("error"),
          l = e.get("error_description");
        if (o) {
          console.error("[AuthCallback] OAuth error:", {
            error: o,
            errorDescription: l,
          }),
            n(`/login?error=${o}`);
          return;
        }
        r &&
          (t && !s
            ? n(a, { replace: !0 })
            : s || n(`/login?returnUrl=${encodeURIComponent(a)}`));
      })();
    }, [e, t, s, r, n]),
    u.jsx("div", {
      className:
        "min-h-screen bg-card-background flex items-center justify-center",
      children: u.jsx("div", {
        className: "text-text-primary",
        children: "Completing sign in...",
      }),
    })
  );
}
function EMe() {
  return (
    E.useEffect(() => {
      window.location.href =
        "https://enritarta.notion.site/288abb4f34b78048aa86ce13d3534b81?pvs=105";
    }, []),
    u.jsx("div", {
      className:
        "flex items-center justify-center h-screen bg-background text-foreground",
      children: u.jsx("div", {
        className: "text-sm",
        children: "Redirecting...",
      }),
    })
  );
}
var SMe = "Label",
  tQ = E.forwardRef((n, e) =>
    u.jsx(Et.label, {
      ...n,
      ref: e,
      onMouseDown: (t) => {
        t.target.closest("button, input, select, textarea") ||
          (n.onMouseDown?.(t),
          !t.defaultPrevented && t.detail > 1 && t.preventDefault());
      },
    })
  );
tQ.displayName = SMe;
var nQ = tQ;
const TMe = vL(
    "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
  ),
  vo = E.forwardRef(({ className: n, ...e }, t) =>
    u.jsx(nQ, { ref: t, className: Le(TMe(), n), ...e })
  );
vo.displayName = nQ.displayName;
function _Me() {
  const { user: n } = ks(),
    e = Pt((j) => j.switchTeam),
    s = n?.id === "ec650580-972b-4642-ba53-fdc643ff70dc",
    [r, i] = E.useState(""),
    [a, o] = E.useState(""),
    [l, c] = E.useState(!1),
    [h, m] = E.useState(!1),
    [p, g] = E.useState(null),
    [y, b] = E.useState(null),
    [w, S] = E.useState(""),
    [A, _] = E.useState(!1),
    [R, C] = E.useState(""),
    [D, L] = E.useState(null),
    [P, V] = E.useState(!1),
    [N, W] = E.useState(!1),
    [H, z] = E.useState(null),
    B = async () => {
      if (!r.trim()) {
        Xe.error("Please enter customer email");
        return;
      }
      c(!0), g(null), b(null);
      try {
        const j = await Ut("/api/admin/users/check-email", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ email: r.trim() }),
        });
        if (!j.ok) {
          const M = await j.json();
          throw new Error(M.error || "Failed to check email");
        }
        const Q = await j.json();
        Q.exists
          ? (g(!0), Xe.success(`User found: ${Q.email}`))
          : (g(!1), Xe.error("User not found - ask them to sign up first"));
      } catch (j) {
        console.error("Error checking email:", j),
          Xe.error(j instanceof Error ? j.message : "Failed to check email");
      } finally {
        c(!1);
      }
    },
    q = async () => {
      if (!r.trim()) {
        Xe.error("Please enter customer email");
        return;
      }
      if (!a.trim()) {
        Xe.error("Please enter team name");
        return;
      }
      if (!p) {
        Xe.error("Please check if user exists first");
        return;
      }
      m(!0), b(null);
      try {
        const j = await Ut("/api/admin/teams/activate-trial", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            customer_email: r.trim(),
            team_name: a.trim(),
          }),
        });
        if (!j.ok) {
          const M = await j.json();
          throw new Error(M.error || "Failed to activate trial");
        }
        const Q = await j.json();
        if ((b(Q.team), Q.team?.id))
          try {
            await e(Q.team.id),
              Xe.success("Trial activated and team switched successfully!");
          } catch (M) {
            console.error("Error switching to new team:", M),
              Xe.success(
                "Trial activated! Please refresh to see your new team."
              );
          }
        else Xe.success("Trial activated successfully!");
      } catch (j) {
        console.error("Error activating trial:", j),
          Xe.error(j instanceof Error ? j.message : "Failed to activate trial");
      } finally {
        m(!1);
      }
    },
    O = async () => {
      if (!w.trim()) {
        Xe.error("Please enter test email address");
        return;
      }
      _(!0), L(null);
      try {
        const j = await Ut("/api/admin/test-email-notifications", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ testEmail: w.trim() }),
        });
        if (!j.ok) {
          const M = await j.json();
          throw new Error(M.error || "Failed to test email notifications");
        }
        const Q = await j.json();
        L(Q),
          Q.summary.emailsSent > 0
            ? Xe.success(
                `Successfully sent ${Q.summary.emailsSent} test email(s) to ${w}`
              )
            : Xe.info("No emails sent - no users with new activity found");
      } catch (j) {
        console.error("Error testing email notifications:", j),
          Xe.error(
            j instanceof Error
              ? j.message
              : "Failed to test email notifications"
          );
      } finally {
        _(!1);
      }
    },
    U = async () => {
      W(!0), z(null), V(!1);
      try {
        if (!R.trim()) throw new Error("Please enter the cron secret");
        const j = await Ut("/api/cron/send-notifications", {
          method: "GET",
          headers: { Authorization: `Bearer ${R}` },
        });
        if (!j.ok) {
          const M = await j.json();
          throw new Error(M.error || "Failed to send notifications");
        }
        const Q = await j.json();
        z({
          success: Q.success,
          summary: {
            totalUsersChecked: Q.processed || 0,
            emailsSent: Q.sent || 0,
            emailsFailed: Q.errors?.length || 0,
            usersWithActivity: Q.processed || 0,
          },
          details:
            Q.errors?.map((M) => ({
              userId: "",
              userEmail: M,
              success: !1,
              flaskCount: 0,
              error: M,
            })) || [],
        }),
          Q.sent > 0
            ? Xe.success(
                `Successfully sent ${Q.sent} notification email(s) to real users!`
              )
            : Xe.info("No emails sent - no users with new activity found");
      } catch (j) {
        console.error("Error sending all notifications:", j),
          Xe.error(
            j instanceof Error ? j.message : "Failed to send notifications"
          );
      } finally {
        W(!1);
      }
    };
  return n
    ? s
      ? u.jsxs("div", {
          className:
            "min-h-screen bg-black flex flex-col items-center justify-start p-4 space-y-6 py-8",
          children: [
            u.jsxs(ar, {
              className: "w-full max-w-2xl bg-zinc-900 border-zinc-800",
              children: [
                u.jsxs(si, {
                  children: [
                    u.jsxs("div", {
                      className: "flex items-center gap-2",
                      children: [
                        u.jsx(ole, { className: "h-6 w-6 text-yellow-500" }),
                        u.jsx(Ti, {
                          className: "text-white",
                          children:
                            "King of Flask - One-Click Trial Activation",
                        }),
                      ],
                    }),
                    u.jsx(Ca, {
                      className: "text-zinc-400",
                      children:
                        "Instantly activate 7-day trial for sales calls - no link, no checkout, no waiting",
                    }),
                  ],
                }),
                u.jsxs(or, {
                  className: "space-y-6",
                  children: [
                    u.jsxs("div", {
                      className: "space-y-3",
                      children: [
                        u.jsxs("div", {
                          className: "flex items-center gap-2",
                          children: [
                            u.jsx("div", {
                              className:
                                "flex items-center justify-center w-6 h-6 rounded-full bg-zinc-800 text-xs text-zinc-400",
                              children: "1",
                            }),
                            u.jsx(vo, {
                              htmlFor: "customer-email",
                              className: "text-white",
                              children: "Customer Email",
                            }),
                          ],
                        }),
                        u.jsxs("div", {
                          className: "flex gap-2",
                          children: [
                            u.jsx(ta, {
                              id: "customer-email",
                              type: "email",
                              placeholder: "customer@company.com",
                              value: r,
                              onChange: (j) => {
                                i(j.target.value), g(null), b(null);
                              },
                              disabled: l || h,
                              className:
                                "bg-zinc-800 border-zinc-700 text-white placeholder:text-zinc-500",
                            }),
                            u.jsx(et, {
                              onClick: B,
                              disabled: l || !r.trim(),
                              variant: "outline",
                              className:
                                "bg-zinc-800 border-zinc-700 text-white hover:bg-zinc-700",
                              children: l
                                ? u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx(wo, {
                                        className: "w-4 h-4 mr-2 animate-spin",
                                      }),
                                      "Checking...",
                                    ],
                                  })
                                : "Check Email",
                            }),
                          ],
                        }),
                        p !== null &&
                          u.jsx("div", {
                            className: `flex items-center gap-2 p-3 rounded-lg ${
                              p
                                ? "bg-green-500/10 border border-green-500/20"
                                : "bg-red-500/10 border border-red-500/20"
                            }`,
                            children: p
                              ? u.jsxs(u.Fragment, {
                                  children: [
                                    u.jsx(ip, {
                                      className: "w-4 h-4 text-green-400",
                                    }),
                                    u.jsx("span", {
                                      className: "text-sm text-green-400",
                                      children: "User exists in database",
                                    }),
                                  ],
                                })
                              : u.jsxs(u.Fragment, {
                                  children: [
                                    u.jsx(TU, {
                                      className: "w-4 h-4 text-red-400",
                                    }),
                                    u.jsx("span", {
                                      className: "text-sm text-red-400",
                                      children:
                                        "User not found - ask them to sign up at flask.do/login first",
                                    }),
                                  ],
                                }),
                          }),
                      ],
                    }),
                    p &&
                      u.jsxs("div", {
                        className: "space-y-3",
                        children: [
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              u.jsx("div", {
                                className:
                                  "flex items-center justify-center w-6 h-6 rounded-full bg-zinc-800 text-xs text-zinc-400",
                                children: "2",
                              }),
                              u.jsx(vo, {
                                htmlFor: "team-name",
                                className: "text-white",
                                children: "Team Name",
                              }),
                            ],
                          }),
                          u.jsx(ta, {
                            id: "team-name",
                            placeholder: "Acme Corp Trial",
                            value: a,
                            onChange: (j) => {
                              o(j.target.value), b(null);
                            },
                            disabled: h,
                            className:
                              "bg-zinc-800 border-zinc-700 text-white placeholder:text-zinc-500",
                          }),
                        ],
                      }),
                    p &&
                      u.jsxs("div", {
                        className: "space-y-3",
                        children: [
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              u.jsx("div", {
                                className:
                                  "flex items-center justify-center w-6 h-6 rounded-full bg-zinc-800 text-xs text-zinc-400",
                                children: "3",
                              }),
                              u.jsx(vo, {
                                className: "text-white",
                                children: "Activate Trial",
                              }),
                            ],
                          }),
                          u.jsx(et, {
                            onClick: q,
                            disabled: h || !a.trim(),
                            className:
                              "w-full bg-yellow-600 hover:bg-yellow-700 text-white",
                            children: h
                              ? u.jsxs(u.Fragment, {
                                  children: [
                                    u.jsx(wo, {
                                      className: "w-4 h-4 mr-2 animate-spin",
                                    }),
                                    "Activating Trial...",
                                  ],
                                })
                              : u.jsxs(u.Fragment, {
                                  children: [
                                    u.jsx(Ile, { className: "w-4 h-4 mr-2" }),
                                    "Activate Trial Now",
                                  ],
                                }),
                          }),
                        ],
                      }),
                    y &&
                      u.jsxs("div", {
                        className:
                          "space-y-3 p-4 bg-green-500/10 border border-green-500/20 rounded-lg",
                        children: [
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              u.jsx(ip, {
                                className: "w-5 h-5 text-green-400",
                              }),
                              u.jsx("p", {
                                className: "font-semibold text-green-400",
                                children: "Trial Activated Successfully!",
                              }),
                            ],
                          }),
                          u.jsxs("div", {
                            className: "space-y-2 text-sm text-zinc-300",
                            children: [
                              u.jsxs("p", {
                                children: [
                                  u.jsx("strong", {
                                    className: "text-white",
                                    children: "Team:",
                                  }),
                                  " ",
                                  y.name,
                                ],
                              }),
                              u.jsxs("p", {
                                children: [
                                  u.jsx("strong", {
                                    className: "text-white",
                                    children: "Status:",
                                  }),
                                  " 7-day trial active",
                                ],
                              }),
                              y.trial_ends &&
                                u.jsxs("p", {
                                  children: [
                                    u.jsx("strong", {
                                      className: "text-white",
                                      children: "Trial ends:",
                                    }),
                                    " ",
                                    new Date(y.trial_ends).toLocaleDateString(),
                                  ],
                                }),
                              u.jsxs("p", {
                                children: [
                                  u.jsx("strong", {
                                    className: "text-white",
                                    children: "Customer email:",
                                  }),
                                  " ",
                                  r,
                                ],
                              }),
                            ],
                          }),
                          u.jsxs("div", {
                            className:
                              "text-xs text-zinc-400 space-y-1 pt-2 border-t border-zinc-800",
                            children: [
                              u.jsx("p", {
                                children: " Team created and ready to use",
                              }),
                              u.jsx("p", {
                                children:
                                  " Customer can log in immediately at flask.do/login",
                              }),
                              u.jsx("p", {
                                children:
                                  " No credit card required during trial",
                              }),
                              u.jsx("p", {
                                children:
                                  " 20% discount applied to first payment after trial",
                              }),
                            ],
                          }),
                        ],
                      }),
                    u.jsxs("div", {
                      className:
                        "pt-4 border-t border-zinc-800 text-xs text-zinc-500",
                      children: [
                        u.jsx("p", {
                          className: "mb-2",
                          children: u.jsx("strong", {
                            className: "text-zinc-400",
                            children: "How it works:",
                          }),
                        }),
                        u.jsxs("ol", {
                          className: "list-decimal list-inside space-y-1",
                          children: [
                            u.jsx("li", {
                              children:
                                "Enter customer email and check if they have an account",
                            }),
                            u.jsx("li", {
                              children:
                                'If yes, enter team name and click "Activate Trial Now"',
                            }),
                            u.jsx("li", {
                              children:
                                "Trial is instantly activated - no Stripe checkout, no waiting",
                            }),
                            u.jsx("li", {
                              children:
                                "Customer logs in at flask.do/login and sees their team ready to use",
                            }),
                            u.jsx("li", {
                              children:
                                "Perfect for sales calls - activate while you're talking to them!",
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            u.jsxs(ar, {
              className: "w-full max-w-2xl bg-zinc-900 border-zinc-800",
              children: [
                u.jsxs(si, {
                  children: [
                    u.jsxs("div", {
                      className: "flex items-center gap-2",
                      children: [
                        u.jsx(MH, { className: "h-6 w-6 text-blue-500" }),
                        u.jsx(Ti, {
                          className: "text-white",
                          children: "Email Notification Testing",
                        }),
                      ],
                    }),
                    u.jsx(Ca, {
                      className: "text-zinc-400",
                      children:
                        "Manually trigger email notifications for testing and debugging",
                    }),
                  ],
                }),
                u.jsxs(or, {
                  className: "space-y-6",
                  children: [
                    u.jsxs("div", {
                      className: "space-y-3",
                      children: [
                        u.jsx(vo, {
                          htmlFor: "test-email",
                          className: "text-white",
                          children: "Test Email Address",
                        }),
                        u.jsxs("div", {
                          className: "flex gap-2",
                          children: [
                            u.jsx(ta, {
                              id: "test-email",
                              type: "email",
                              placeholder: "your-test-email@gmail.com",
                              value: w,
                              onChange: (j) => {
                                S(j.target.value), L(null);
                              },
                              disabled: A,
                              className:
                                "bg-zinc-800 border-zinc-700 text-white placeholder:text-zinc-500",
                            }),
                            u.jsx(et, {
                              onClick: O,
                              disabled: A || !w.trim(),
                              className:
                                "bg-blue-600 hover:bg-blue-700 text-white",
                              children: A
                                ? u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx(wo, {
                                        className: "w-4 h-4 mr-2 animate-spin",
                                      }),
                                      "Testing...",
                                    ],
                                  })
                                : u.jsxs(u.Fragment, {
                                    children: [
                                      u.jsx(OH, { className: "w-4 h-4 mr-2" }),
                                      "Send Test Emails",
                                    ],
                                  }),
                            }),
                          ],
                        }),
                        u.jsx("p", {
                          className: "text-xs text-zinc-500",
                          children:
                            "This runs the same notification logic as the cron job, but sends all emails to your test address instead of the actual users",
                        }),
                      ],
                    }),
                    D &&
                      u.jsxs("div", {
                        className:
                          "space-y-4 p-4 bg-zinc-800 border border-zinc-700 rounded-lg",
                        children: [
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              u.jsx(ip, { className: "w-5 h-5 text-blue-400" }),
                              u.jsx("p", {
                                className: "font-semibold text-blue-400",
                                children: "Email Test Complete",
                              }),
                            ],
                          }),
                          u.jsxs("div", {
                            className: "space-y-2 text-sm",
                            children: [
                              u.jsx("p", {
                                className: "text-white font-medium",
                                children: "Summary:",
                              }),
                              u.jsxs("div", {
                                className:
                                  "grid grid-cols-2 gap-2 text-zinc-300",
                                children: [
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Total users checked:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold",
                                        children: D.summary.totalUsersChecked,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Users with activity:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold",
                                        children: D.summary.usersWithActivity,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Emails sent:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className:
                                          "font-semibold text-green-400",
                                        children: D.summary.emailsSent,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Emails failed:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold text-red-400",
                                        children: D.summary.emailsFailed,
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                              u.jsxs("p", {
                                className: "text-xs text-zinc-500 pt-2",
                                children: [
                                  "All emails sent to: ",
                                  u.jsx("span", {
                                    className: "font-mono text-zinc-400",
                                    children: D.testEmail,
                                  }),
                                ],
                              }),
                            ],
                          }),
                          D.details.length > 0 &&
                            u.jsxs("div", {
                              className: "space-y-2",
                              children: [
                                u.jsx("p", {
                                  className: "text-white font-medium text-sm",
                                  children: "Details:",
                                }),
                                u.jsx("div", {
                                  className:
                                    "max-h-64 overflow-y-auto space-y-2",
                                  children: D.details.map((j, Q) =>
                                    u.jsx(
                                      "div",
                                      {
                                        className: `p-3 rounded text-xs ${
                                          j.success
                                            ? "bg-green-500/10 border border-green-500/20"
                                            : "bg-red-500/10 border border-red-500/20"
                                        }`,
                                        children: u.jsxs("div", {
                                          className:
                                            "flex items-start justify-between gap-2",
                                          children: [
                                            u.jsxs("div", {
                                              className: "space-y-1 flex-1",
                                              children: [
                                                u.jsxs("p", {
                                                  className: "text-zinc-300",
                                                  children: [
                                                    u.jsx("span", {
                                                      className:
                                                        "text-zinc-400",
                                                      children: "User:",
                                                    }),
                                                    " ",
                                                    u.jsx("span", {
                                                      className: "font-mono",
                                                      children: j.userEmail,
                                                    }),
                                                  ],
                                                }),
                                                u.jsxs("p", {
                                                  className: "text-zinc-300",
                                                  children: [
                                                    u.jsx("span", {
                                                      className:
                                                        "text-zinc-400",
                                                      children:
                                                        "Flasks with activity:",
                                                    }),
                                                    " ",
                                                    u.jsx("span", {
                                                      className:
                                                        "font-semibold",
                                                      children: j.flaskCount,
                                                    }),
                                                  ],
                                                }),
                                                j.error &&
                                                  u.jsxs("p", {
                                                    className: "text-red-400",
                                                    children: [
                                                      u.jsx("span", {
                                                        className:
                                                          "text-zinc-400",
                                                        children: "Error:",
                                                      }),
                                                      " ",
                                                      j.error,
                                                    ],
                                                  }),
                                              ],
                                            }),
                                            u.jsx("div", {
                                              children: j.success
                                                ? u.jsx(ip, {
                                                    className:
                                                      "w-4 h-4 text-green-400",
                                                  })
                                                : u.jsx(TU, {
                                                    className:
                                                      "w-4 h-4 text-red-400",
                                                  }),
                                            }),
                                          ],
                                        }),
                                      },
                                      Q
                                    )
                                  ),
                                }),
                              ],
                            }),
                        ],
                      }),
                    u.jsxs("div", {
                      className:
                        "pt-4 border-t border-zinc-800 text-xs text-zinc-500",
                      children: [
                        u.jsx("p", {
                          className: "mb-2",
                          children: u.jsx("strong", {
                            className: "text-zinc-400",
                            children: "How it works:",
                          }),
                        }),
                        u.jsxs("ul", {
                          className: "list-disc list-inside space-y-1",
                          children: [
                            u.jsx("li", {
                              children:
                                "Runs the same notification query logic as the cron job",
                            }),
                            u.jsx("li", {
                              children:
                                "Finds all users with new unread activity on their flasks",
                            }),
                            u.jsx("li", {
                              children:
                                "Sends emails to your test address instead of actual users",
                            }),
                            u.jsx("li", {
                              children:
                                "Shows detailed feedback on emails sent and any errors",
                            }),
                            u.jsx("li", {
                              children:
                                "Useful for debugging notification logic and email templates",
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            u.jsxs(ar, {
              className: "w-full max-w-2xl bg-zinc-900 border-zinc-800",
              children: [
                u.jsxs(si, {
                  children: [
                    u.jsxs("div", {
                      className: "flex items-center gap-2",
                      children: [
                        u.jsx(ZR, { className: "h-6 w-6 text-orange-500" }),
                        u.jsx(Ti, {
                          className: "text-white",
                          children: "Send All Notifications",
                        }),
                      ],
                    }),
                    u.jsx(Ca, {
                      className: "text-zinc-400",
                      children:
                        "Manually trigger the notification cron job to send emails to ALL users with new activity",
                    }),
                  ],
                }),
                u.jsxs(or, {
                  className: "space-y-6",
                  children: [
                    u.jsxs("div", {
                      className:
                        "flex items-start gap-3 p-4 bg-orange-500/10 border border-orange-500/20 rounded-lg",
                      children: [
                        u.jsx(Tle, {
                          className:
                            "w-5 h-5 text-orange-400 flex-shrink-0 mt-0.5",
                        }),
                        u.jsxs("div", {
                          className: "space-y-1 text-sm",
                          children: [
                            u.jsx("p", {
                              className: "text-orange-400 font-semibold",
                              children: "This sends REAL emails to REAL users",
                            }),
                            u.jsx("p", {
                              className: "text-zinc-400",
                              children:
                                "Use this button carefully. It will find all users with new activity and send them actual notification emails to their real email addresses.",
                            }),
                          ],
                        }),
                      ],
                    }),
                    u.jsxs("div", {
                      className: "space-y-2",
                      children: [
                        u.jsx(vo, {
                          htmlFor: "cronSecret",
                          className: "text-zinc-300",
                          children: "Cron Secret",
                        }),
                        u.jsx(ta, {
                          id: "cronSecret",
                          type: "password",
                          value: R,
                          onChange: (j) => C(j.target.value),
                          placeholder: "Paste the CRON_SECRET here",
                          className:
                            "bg-zinc-800 border-zinc-700 text-white placeholder:text-zinc-500",
                        }),
                        u.jsx("p", {
                          className: "text-xs text-zinc-500",
                          children: "Required to authorize the cron endpoint",
                        }),
                      ],
                    }),
                    u.jsx("div", {
                      className: "space-y-3",
                      children: u.jsx(et, {
                        onClick: () => V(!0),
                        disabled: N || !R.trim(),
                        className:
                          "w-full bg-orange-600 hover:bg-orange-700 text-white disabled:opacity-50",
                        children: N
                          ? u.jsxs(u.Fragment, {
                              children: [
                                u.jsx(wo, {
                                  className: "w-4 h-4 mr-2 animate-spin",
                                }),
                                "Sending Notifications...",
                              ],
                            })
                          : u.jsxs(u.Fragment, {
                              children: [
                                u.jsx(ZR, { className: "w-4 h-4 mr-2" }),
                                "Send All Notifications Now",
                              ],
                            }),
                      }),
                    }),
                    H &&
                      u.jsxs("div", {
                        className:
                          "space-y-4 p-4 bg-zinc-800 border border-zinc-700 rounded-lg",
                        children: [
                          u.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [
                              u.jsx(ip, {
                                className: "w-5 h-5 text-green-400",
                              }),
                              u.jsx("p", {
                                className: "font-semibold text-green-400",
                                children: "Notifications Sent",
                              }),
                            ],
                          }),
                          u.jsxs("div", {
                            className: "space-y-2 text-sm",
                            children: [
                              u.jsx("p", {
                                className: "text-white font-medium",
                                children: "Summary:",
                              }),
                              u.jsxs("div", {
                                className:
                                  "grid grid-cols-2 gap-2 text-zinc-300",
                                children: [
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Users processed:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold",
                                        children: H.summary.totalUsersChecked,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Users with activity:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold",
                                        children: H.summary.usersWithActivity,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Emails sent:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className:
                                          "font-semibold text-green-400",
                                        children: H.summary.emailsSent,
                                      }),
                                    ],
                                  }),
                                  u.jsxs("div", {
                                    className: "p-2 bg-zinc-900 rounded",
                                    children: [
                                      u.jsx("span", {
                                        className: "text-zinc-400",
                                        children: "Emails failed:",
                                      }),
                                      " ",
                                      u.jsx("span", {
                                        className: "font-semibold text-red-400",
                                        children: H.summary.emailsFailed,
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                            ],
                          }),
                          H.details.length > 0 &&
                            u.jsxs("div", {
                              className: "space-y-2",
                              children: [
                                u.jsx("p", {
                                  className: "text-white font-medium text-sm",
                                  children: "Errors:",
                                }),
                                u.jsx("div", {
                                  className:
                                    "max-h-48 overflow-y-auto space-y-2",
                                  children: H.details.map((j, Q) =>
                                    u.jsx(
                                      "div",
                                      {
                                        className:
                                          "p-3 rounded text-xs bg-red-500/10 border border-red-500/20",
                                        children: u.jsx("p", {
                                          className: "text-red-400",
                                          children: j.error,
                                        }),
                                      },
                                      Q
                                    )
                                  ),
                                }),
                              ],
                            }),
                        ],
                      }),
                    u.jsxs("div", {
                      className:
                        "pt-4 border-t border-zinc-800 text-xs text-zinc-500",
                      children: [
                        u.jsx("p", {
                          className: "mb-2",
                          children: u.jsx("strong", {
                            className: "text-zinc-400",
                            children: "How it works:",
                          }),
                        }),
                        u.jsxs("ul", {
                          className: "list-disc list-inside space-y-1",
                          children: [
                            u.jsx("li", {
                              children:
                                "Triggers the same cron job endpoint that runs every 4 hours",
                            }),
                            u.jsx("li", {
                              children:
                                "Finds all users with notifications enabled who have new activity",
                            }),
                            u.jsx("li", {
                              children:
                                "Respects the 24-hour rate limit (won't send if emailed in last 24h)",
                            }),
                            u.jsx("li", {
                              children:
                                "Sends emails to actual user email addresses",
                            }),
                            u.jsx("li", {
                              children:
                                "Useful for testing the full notification flow in production",
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            u.jsx(AW, {
              open: P,
              onOpenChange: V,
              children: u.jsxs(ZD, {
                className: "bg-zinc-900 border-zinc-800",
                children: [
                  u.jsxs(JD, {
                    children: [
                      u.jsx(tP, {
                        className: "text-white",
                        children: "Send Notifications to All Users?",
                      }),
                      u.jsxs(nP, {
                        className: "text-zinc-400",
                        children: [
                          "This will trigger the notification cron job and send REAL emails to ALL users with new activity.",
                          u.jsx("br", {}),
                          u.jsx("br", {}),
                          "Are you sure you want to proceed?",
                        ],
                      }),
                    ],
                  }),
                  u.jsxs(eP, {
                    children: [
                      u.jsx(rP, {
                        className:
                          "bg-zinc-800 border-zinc-700 text-white hover:bg-zinc-700",
                        children: "Cancel",
                      }),
                      u.jsx(sP, {
                        onClick: U,
                        className:
                          "bg-orange-600 hover:bg-orange-700 text-white",
                        children: "Yes, Send Notifications",
                      }),
                    ],
                  }),
                ],
              }),
            }),
          ],
        })
      : u.jsx("div", {
          className:
            "min-h-screen bg-black flex items-center justify-center p-4",
          children: u.jsxs(ar, {
            className: "w-full max-w-md bg-zinc-900 border-zinc-800",
            children: [
              u.jsxs(si, {
                children: [
                  u.jsx(Ti, {
                    className: "text-white",
                    children: "Access Denied",
                  }),
                  u.jsx(Ca, {
                    className: "text-zinc-400",
                    children: "Only the King of Flask can access this page",
                  }),
                ],
              }),
              u.jsx(or, {
                className: "text-sm text-zinc-500",
                children: u.jsxs("p", {
                  children: [
                    "You are logged in as: ",
                    u.jsx("span", {
                      className: "font-mono text-zinc-400",
                      children: n.email,
                    }),
                  ],
                }),
              }),
            ],
          }),
        })
    : u.jsx("div", {
        className: "min-h-screen bg-black flex items-center justify-center p-4",
        children: u.jsx(ar, {
          className: "w-full max-w-md bg-zinc-900 border-zinc-800",
          children: u.jsxs(si, {
            children: [
              u.jsx(Ti, { className: "text-white", children: "Please Log In" }),
              u.jsx(Ca, {
                className: "text-zinc-400",
                children: "You must be logged in to access this page",
              }),
            ],
          }),
        }),
      });
}
let zA = null;
const AMe = () => {
    const n = E.useRef(!1),
      e = hn((t) => t.user);
    return (
      X0e(e?.id),
      E.useEffect(() => {
        if (n.current) return;
        (n.current = !0),
          (async () => {
            const s = hn.getState();
            s.isInitialized || (zA || (zA = s.initialize()), await zA);
          })();
      }, []),
      null
    );
  },
  RMe = () => {
    const n = E.useRef(null),
      e = E.useRef(null),
      [t, s] = E.useState(!0),
      [r, i] = E.useState(0),
      [a, o] = E.useState(0),
      [l, c] = E.useState(!1),
      [h, m] = E.useState(!1),
      p = Be((O) => O.activeRecordingUrl),
      g = Be((O) => O.isRecordingPlaying),
      y = Be((O) => O.recordingPlaybackRate),
      b = Be((O) => O.isRecordingFullscreen),
      w = Be((O) => O.recordingSyncTime),
      S = Be((O) => O.toggleRecordingPlayback),
      A = Be((O) => O.setIsRecordingPlaying),
      _ = Be((O) => O.setRecordingPlaybackRate),
      R = Be((O) => O.setRecordingFullscreen),
      C = Be((O) => O.setRecordingCurrentTime),
      D = E.useCallback(() => {
        R(!1);
      }, [R]),
      L = E.useCallback(
        (O) => {
          O.target === O.currentTarget && D();
        },
        [D]
      ),
      P = E.useCallback(() => {
        S();
      }, [S]),
      V = E.useCallback(() => {
        const U = (Z_.indexOf(y) + 1) % Z_.length;
        _(Z_[U]);
      }, [y, _]),
      N = E.useCallback(
        (O) => {
          if (!n.current || !a || !e.current) return;
          const U = e.current.getBoundingClientRect(),
            Q = (O.clientX - U.left) / U.width;
          n.current.currentTime = Q * a;
        },
        [a]
      ),
      W = E.useCallback(
        (O) => {
          m(!0), N(O);
        },
        [N]
      ),
      H = E.useCallback(
        (O) => {
          if (!h || !n.current || !a || !e.current) return;
          const U = e.current.getBoundingClientRect(),
            Q = Math.max(0, Math.min(O.clientX - U.left, U.width)) / U.width;
          n.current.currentTime = Q * a;
        },
        [h, a]
      ),
      z = E.useCallback(() => {
        m(!1);
      }, []);
    E.useEffect(() => {
      const O = (U) => {
        U.key === "Escape" && b && D();
      };
      return (
        b &&
          (document.addEventListener("keydown", O),
          (document.body.style.overflow = "hidden")),
        () => {
          document.removeEventListener("keydown", O),
            (document.body.style.overflow = "");
        }
      );
    }, [b, D]),
      E.useEffect(() => {
        const O = n.current;
        if (!O || !p || !b) return;
        const U = () => {
            s(!1), g && O.play().catch(console.error);
          },
          j = () => A(!0),
          Q = () => A(!1),
          M = (Y) => {
            console.error("[FullscreenRecordingPlayer] Video error:", Y), s(!1);
          },
          I = () => {
            i(O.currentTime), C(O.currentTime);
          },
          F = () => {
            o(O.duration), (O.playbackRate = y), w > 0 && (O.currentTime = w);
          };
        return (
          O.addEventListener("canplay", U),
          O.addEventListener("play", j),
          O.addEventListener("pause", Q),
          O.addEventListener("error", M),
          O.addEventListener("timeupdate", I),
          O.addEventListener("loadedmetadata", F),
          "src" in O && (O.src = p),
          () => {
            O.removeEventListener("canplay", U),
              O.removeEventListener("play", j),
              O.removeEventListener("pause", Q),
              O.removeEventListener("error", M),
              O.removeEventListener("timeupdate", I),
              O.removeEventListener("loadedmetadata", F);
          }
        );
      }, [p, A, C, y, b, g, w]),
      E.useEffect(() => {
        n.current && (n.current.playbackRate = y);
      }, [y]),
      E.useEffect(() => {
        n.current &&
          (g && n.current.paused
            ? n.current.play().catch(console.error)
            : !g && !n.current.paused && n.current.pause());
      }, [g]),
      E.useEffect(() => {
        if (h)
          return (
            document.addEventListener("mousemove", H),
            document.addEventListener("mouseup", z),
            () => {
              document.removeEventListener("mousemove", H),
                document.removeEventListener("mouseup", z);
            }
          );
      }, [h, H, z]);
    const B = E.useCallback((O) => {
        const U = Math.floor(O / 60),
          j = Math.floor(O % 60);
        return `${U}:${j.toString().padStart(2, "0")}`;
      }, []),
      q = a > 0 ? (r / a) * 100 : 0;
    return !b || !p
      ? null
      : ri.createPortal(
          u.jsx("div", {
            className: `fixed inset-0 z-[9999] bg-transparent backdrop-blur-sm flex items-center justify-center transition-all duration-300 ${
              b ? "opacity-100" : "opacity-0 pointer-events-none"
            }`,
            onClick: L,
            children: u.jsx("div", {
              className: "w-[90%] max-w-screen-2xl",
              children: u.jsx("div", {
                className: `relative bg-card-background border-t border-text-primary/30 rounded-3xl shadow-2xl transition-all duration-500 transform ${
                  b
                    ? "translate-y-0 scale-100 opacity-100"
                    : "translate-y-8 scale-95 opacity-0"
                }`,
                onClick: (O) => O.stopPropagation(),
                onMouseEnter: () => c(!0),
                onMouseLeave: () => c(!1),
                children: u.jsx("div", {
                  className: "relative p-4",
                  children: u.jsxs("div", {
                    className:
                      "relative aspect-video bg-black rounded-2xl overflow-hidden border border-border",
                    children: [
                      de.createElement("hls-video", {
                        ref: n,
                        className: "w-full h-full object-contain",
                        controls: !1,
                        playsInline: !0,
                        autoPlay: !1,
                        muted: !1,
                        onLoadStart: () => s(!0),
                      }),
                      t &&
                        u.jsx("div", {
                          className:
                            "absolute inset-0 flex items-center justify-center bg-black/50",
                          children: u.jsx("div", {
                            className:
                              "animate-spin rounded-full h-12 w-12 border-3 border-white border-t-transparent",
                          }),
                        }),
                      u.jsx("div", {
                        className: `absolute inset-0 flex items-center justify-center transition-opacity duration-200 ${
                          l ? "opacity-100" : "opacity-0"
                        }`,
                        children: u.jsx("button", {
                          onClick: P,
                          className:
                            "p-4 bg-black/50 hover:bg-black/60 rounded-full backdrop-blur-sm transition-all",
                          "aria-label": g ? "Pause" : "Play",
                          children: g
                            ? u.jsx(uL, { size: 32, className: "text-white" })
                            : u.jsx(Pg, {
                                size: 32,
                                className: "text-white ml-1",
                              }),
                        }),
                      }),
                      u.jsxs("div", {
                        className: `absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 to-transparent p-4 transition-opacity duration-200 rounded-b-2xl ${
                          l ? "opacity-100" : "opacity-0"
                        }`,
                        children: [
                          u.jsxs("div", {
                            ref: e,
                            className:
                              "relative h-1 bg-white/20 rounded-full cursor-pointer mb-4 group",
                            onMouseDown: W,
                            children: [
                              u.jsx("div", {
                                className:
                                  "absolute top-0 left-0 h-full bg-text-primary rounded-full transition-all duration-100",
                                style: { width: `${q}%` },
                              }),
                              u.jsx("div", {
                                className:
                                  "absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-text-primary rounded-full shadow-lg transition-all duration-100 group-hover:scale-125",
                                style: { left: `${q}%`, marginLeft: "-6px" },
                              }),
                            ],
                          }),
                          u.jsxs("div", {
                            className:
                              "flex items-center justify-between gap-3",
                            children: [
                              u.jsxs("div", {
                                className:
                                  "flex items-center h-[36px] bg-element-background border-t border-white/40 rounded-full shadow-[0_2px_8px_rgba(0,0,0,0.5)] overflow-hidden",
                                children: [
                                  u.jsx("button", {
                                    onClick: P,
                                    className:
                                      "flex items-center justify-center h-full flex-1 px-3 hover:bg-border/30 transition-colors group",
                                    "aria-label": g ? "Pause" : "Play",
                                    children: g
                                      ? u.jsx("svg", {
                                          className:
                                            "w-4 h-4 text-text-secondary group-hover:text-text-primary transition-colors duration-100",
                                          fill: "currentColor",
                                          viewBox: "0 0 24 24",
                                          children: u.jsx("path", {
                                            d: "M6 4h4v16H6V4zm8 0h4v16h-4V4z",
                                          }),
                                        })
                                      : u.jsx("svg", {
                                          className:
                                            "w-4 h-4 text-text-secondary group-hover:text-text-primary transition-colors duration-100 ml-0.5",
                                          fill: "currentColor",
                                          viewBox: "0 0 24 24",
                                          children: u.jsx("path", {
                                            d: "M8 5v14l11-7z",
                                          }),
                                        }),
                                  }),
                                  u.jsxs("div", {
                                    className:
                                      "flex items-center justify-center h-full px-3 border-l border-white/10 text-text-primary text-xs font-mono whitespace-nowrap",
                                    children: [B(r), " / ", B(a)],
                                  }),
                                  u.jsx("button", {
                                    onClick: V,
                                    className:
                                      "flex items-center justify-center h-full px-3 hover:bg-border/30 transition-colors group border-l border-white/10",
                                    children: u.jsxs("span", {
                                      className:
                                        "text-text-secondary group-hover:text-text-primary text-xs font-medium transition-colors duration-100",
                                      children: [y, "x"],
                                    }),
                                  }),
                                ],
                              }),
                              u.jsxs("button", {
                                onClick: D,
                                className:
                                  "flex items-center gap-3 h-[36px] px-4 bg-element-background border-t border-white/40 rounded-full shadow-[0_2px_8px_rgba(0,0,0,0.5)] hover:bg-border/30 transition-colors",
                                "aria-label": "Close fullscreen",
                                children: [
                                  u.jsx(mn, {
                                    className: "text-text-secondary",
                                    children: "ESC",
                                  }),
                                  u.jsx("span", {
                                    className: "text-text-secondary text-sm",
                                    children: "Close Player",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
              }),
            }),
          }),
          document.body
        );
  };
function kMe({ children: n }) {
  return u.jsxs(Br, { children: [u.jsx(AMe, {}), n, u.jsx(RMe, {})] });
}
var vS = "Switch",
  [CMe, p2e] = Pr(vS),
  [IMe, LMe] = CMe(vS),
  sQ = E.forwardRef((n, e) => {
    const {
        __scopeSwitch: t,
        name: s,
        checked: r,
        defaultChecked: i,
        required: a,
        disabled: o,
        value: l = "on",
        onCheckedChange: c,
        form: h,
        ...m
      } = n,
      [p, g] = E.useState(null),
      y = Nt(e, (_) => g(_)),
      b = E.useRef(!1),
      w = p ? h || !!p.closest("form") : !0,
      [S, A] = ci({ prop: r, defaultProp: i ?? !1, onChange: c, caller: vS });
    return u.jsxs(IMe, {
      scope: t,
      checked: S,
      disabled: o,
      children: [
        u.jsx(Et.button, {
          type: "button",
          role: "switch",
          "aria-checked": S,
          "aria-required": a,
          "data-state": oQ(S),
          "data-disabled": o ? "" : void 0,
          disabled: o,
          value: l,
          ...m,
          ref: y,
          onClick: qe(n.onClick, (_) => {
            A((R) => !R),
              w &&
                ((b.current = _.isPropagationStopped()),
                b.current || _.stopPropagation());
          }),
        }),
        w &&
          u.jsx(aQ, {
            control: p,
            bubbles: !b.current,
            name: s,
            value: l,
            checked: S,
            required: a,
            disabled: o,
            form: h,
            style: { transform: "translateX(-100%)" },
          }),
      ],
    });
  });
sQ.displayName = vS;
var rQ = "SwitchThumb",
  iQ = E.forwardRef((n, e) => {
    const { __scopeSwitch: t, ...s } = n,
      r = LMe(rQ, t);
    return u.jsx(Et.span, {
      "data-state": oQ(r.checked),
      "data-disabled": r.disabled ? "" : void 0,
      ...s,
      ref: e,
    });
  });
iQ.displayName = rQ;
var DMe = "SwitchBubbleInput",
  aQ = E.forwardRef(
    (
      { __scopeSwitch: n, control: e, checked: t, bubbles: s = !0, ...r },
      i
    ) => {
      const a = E.useRef(null),
        o = Nt(a, i),
        l = GE(t),
        c = IE(e);
      return (
        E.useEffect(() => {
          const h = a.current;
          if (!h) return;
          const m = window.HTMLInputElement.prototype,
            g = Object.getOwnPropertyDescriptor(m, "checked").set;
          if (l !== t && g) {
            const y = new Event("click", { bubbles: s });
            g.call(h, t), h.dispatchEvent(y);
          }
        }, [l, t, s]),
        u.jsx("input", {
          type: "checkbox",
          "aria-hidden": !0,
          defaultChecked: t,
          ...r,
          tabIndex: -1,
          ref: o,
          style: {
            ...r.style,
            ...c,
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0,
          },
        })
      );
    }
  );
aQ.displayName = DMe;
function oQ(n) {
  return n ? "checked" : "unchecked";
}
var lQ = sQ,
  PMe = iQ;
const RI = E.forwardRef(({ className: n, ...e }, t) =>
  u.jsx(lQ, {
    className: Le(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      n
    ),
    ...e,
    ref: t,
    children: u.jsx(PMe, {
      className: Le(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      ),
    }),
  })
);
RI.displayName = lQ.displayName;
const MMe = vL(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: { variant: "default" },
  }
);
function GA({ className: n, variant: e, ...t }) {
  return u.jsx("div", { className: Le(MMe({ variant: e }), n), ...t });
}
const NMe = ({
    open: n,
    onOpenChange: e,
    currentTeam: t,
    defaultTab: s = "team",
    onTabChange: r,
    isLoadingTeam: i = !1,
  }) => {
    const { user: a } = ks(),
      o = Pt((Z) => Z.currentTeam),
      l = Pt((Z) => Z.refreshCurrentTeam),
      c = Pt((Z) => Z.updateTeamName),
      h = Pt((Z) => Z.updateInviteEnabled),
      m = Pt((Z) => Z.removeMember),
      p = Pt((Z) => Z.isTeamAdmin),
      [g, y] = E.useState(o),
      [b, w] = E.useState(s),
      [S, A] = E.useState(!1),
      [_, R] = E.useState(!1),
      [C, D] = E.useState(""),
      [L, P] = E.useState(!0),
      [V, N] = E.useState(null),
      [W, H] = E.useState(!1),
      [z, B] = E.useState(!1),
      [q, O] = E.useState(!1),
      [U, j] = E.useState(!1);
    E.useEffect(() => {
      w(s);
    }, [s]),
      E.useEffect(() => {
        o && (y(o), D(o.name), P(o.invite_enabled || !1));
      }, [o]),
      E.useEffect(() => {
        n && a && l();
      }, [n, a, l]),
      E.useEffect(() => {
        (async () => {
          if (!(!n || !a))
            try {
              j(!0);
              const { data: te, error: ce } = await Ds.from("profiles")
                .select("email_notifications_enabled")
                .eq("user_id", a.id)
                .single();
              if (ce) throw ce;
              O(te?.email_notifications_enabled ?? !1);
            } catch (te) {
              console.error("Error fetching notification settings:", te);
            } finally {
              j(!1);
            }
        })();
      }, [n, a]);
    const Q = async () => {
        if (!(!g || !a || !p(a.id)))
          try {
            R(!0),
              C !== g.name &&
                (await c(g.id, C), Xe.success("Team settings updated"));
          } catch (Z) {
            console.error("Error updating team:", Z),
              Xe.error("Failed to update team settings");
          } finally {
            R(!1);
          }
      },
      M = async () => {
        if (!(!V || !g))
          try {
            H(!0),
              await m(g.id, V.id),
              Xe.success(`Removed ${V.name} from team`),
              N(null);
          } catch (Z) {
            console.error("Error removing member:", Z);
          } finally {
            H(!1);
          }
      },
      I = async (Z) => {
        if (a)
          try {
            O(Z);
            const { error: te } = await Ds.from("profiles")
              .update({ email_notifications_enabled: Z })
              .eq("user_id", a.id);
            if (te) throw te;
            Xe.success(
              Z ? "Email notifications enabled" : "Email notifications disabled"
            );
          } catch (te) {
            console.error("Error updating notification settings:", te),
              O(!Z),
              Xe.error("Failed to update notification settings");
          }
      },
      F = async () => {
        if (!(!g || g.team_type !== "pro_team"))
          try {
            B(!0);
            const Z = await Ut(`/api/teams/${g.id}/portal`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ return_url: window.location.href }),
            });
            if (!Z.ok) throw new Error("Failed to open billing portal");
            const { url: te } = await Z.json();
            window.open(te, "_blank");
          } catch (Z) {
            console.error("Error opening team portal:", Z),
              Xe.error("Failed to open billing portal");
          } finally {
            B(!1);
          }
      },
      Y = () => {
        if (!g) return;
        const Z = `${window.location.origin}/invite/${g.invite_code}`;
        navigator.clipboard.writeText(Z),
          Xe.success("Invite link copied to clipboard");
      },
      J = () => (g ? `${window.location.origin}/invite/${g.invite_code}` : ""),
      X = ({ value: Z, icon: te, label: ce }) =>
        u.jsxs("button", {
          onClick: () => {
            w(Z), r && r(Z);
          },
          className: Le(
            "w-full flex items-center gap-3 px-3 py-2.5 rounded-md transition-colors",
            "hover:bg-background/50",
            b === Z && "bg-background shadow-sm"
          ),
          children: [
            u.jsx(te, { className: "h-4 w-4" }),
            u.jsx("span", { className: "text-sm font-medium", children: ce }),
          ],
        });
    return u.jsxs(os, {
      open: n,
      onOpenChange: e,
      children: [
        u.jsx(Jn, {
          className: "max-w-5xl max-h-[90vh] min-h-[600px] p-0 overflow-hidden",
          children: u.jsxs("div", {
            className: "flex h-full",
            children: [
              u.jsxs("div", {
                className: "w-64 bg-muted/30 p-6 border-r flex flex-col",
                children: [
                  i
                    ? u.jsxs("div", {
                        className: "mb-6 pb-6 border-b",
                        children: [
                          u.jsx("h3", {
                            className:
                              "text-lg font-semibold text-text-primary",
                            children: u.jsx(yo, { width: 128 }),
                          }),
                          u.jsx("div", {
                            className: "text-sm text-text-secondary",
                            children: u.jsx(yo, { width: 80 }),
                          }),
                        ],
                      })
                    : g
                    ? u.jsxs("div", {
                        className: "mb-6 pb-6 border-b min-w-0",
                        children: [
                          u.jsx("h3", {
                            className: "font-semibold text-lg mb-2 truncate",
                            children: g.name,
                          }),
                          u.jsx(GA, {
                            variant:
                              g.team_type === "pro_team"
                                ? "default"
                                : "secondary",
                            children:
                              g.team_type === "pro_team"
                                ? "Pro Team"
                                : "Free Team",
                          }),
                        ],
                      })
                    : null,
                  u.jsxs("nav", {
                    className: "space-y-1 mb-6",
                    children: [
                      u.jsx(X, { value: "team", icon: Rle, label: "Team" }),
                      u.jsx(X, {
                        value: "notifications",
                        icon: ZR,
                        label: "Notifications",
                      }),
                      g?.team_type === "pro_team" &&
                        g?.current_user_role === "admin" &&
                        u.jsx(X, {
                          value: "billing",
                          icon: ale,
                          label: "Billing",
                        }),
                    ],
                  }),
                  g?.team_type !== "pro_team" &&
                    u.jsxs("div", {
                      className:
                        "bg-card-background/50 border-t shadow-xl border-text-primary/30 p-4 rounded-3xl",
                      children: [
                        u.jsx("h3", {
                          className:
                            "text-sm font-semibold text-foreground mb-3",
                          children: "Flask Pro",
                        }),
                        u.jsxs("div", {
                          className: "space-y-2 mb-4",
                          children: [
                            u.jsxs("div", {
                              className:
                                "flex items-center gap-2 text-xs text-text-secondary",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-1 h-1 rounded-full bg-text-secondary",
                                }),
                                u.jsx("span", {
                                  children: "Upload videos from device",
                                }),
                              ],
                            }),
                            u.jsxs("div", {
                              className:
                                "flex items-center gap-2 text-xs text-text-secondary",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-1 h-1 rounded-full bg-text-secondary",
                                }),
                                u.jsx("span", {
                                  children: "Shared workspaces",
                                }),
                              ],
                            }),
                            u.jsxs("div", {
                              className:
                                "flex items-center gap-2 text-xs text-text-secondary",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-1 h-1 rounded-full bg-text-secondary",
                                }),
                                u.jsx("span", {
                                  children:
                                    "Multiple assets/versions per flask",
                                }),
                              ],
                            }),
                            u.jsxs("div", {
                              className:
                                "flex items-center gap-2 text-xs text-text-secondary",
                              children: [
                                u.jsx("div", {
                                  className:
                                    "w-1 h-1 rounded-full bg-text-secondary",
                                }),
                                u.jsx("span", {
                                  children: "Remove flask branding",
                                }),
                              ],
                            }),
                          ],
                        }),
                        u.jsx("button", {
                          onClick: () => window.open("/#pricing", "_blank"),
                          className:
                            "button-primary w-full flex items-center justify-center px-4 py-3 transition-all duration-200 font-semibold cursor-pointer rounded-xl",
                          children: u.jsx("span", {
                            className: "text-sm font-medium",
                            children: "Upgrade",
                          }),
                        }),
                      ],
                    }),
                ],
              }),
              u.jsx("div", {
                className: "flex-1 overflow-y-auto",
                children: u.jsxs("div", {
                  className: "p-6",
                  children: [
                    b === "team" &&
                      u.jsxs("div", {
                        className: "space-y-6",
                        children: [
                          u.jsxs("div", {
                            children: [
                              u.jsx("h2", {
                                className: "text-2xl font-semibold mb-1",
                                children: "Team Settings",
                              }),
                              u.jsx("p", {
                                className: "text-muted-foreground",
                                children: "Manage your team and members",
                              }),
                            ],
                          }),
                          S
                            ? u.jsxs("div", {
                                className: "space-y-4",
                                children: [
                                  u.jsx(ar, {
                                    children: u.jsx(or, {
                                      className: "p-6",
                                      children: u.jsx(yo, { count: 3 }),
                                    }),
                                  }),
                                  u.jsx(ar, {
                                    children: u.jsx(or, {
                                      className: "p-6",
                                      children: u.jsx(yo, { count: 5 }),
                                    }),
                                  }),
                                ],
                              })
                            : g
                            ? u.jsxs(u.Fragment, {
                                children: [
                                  u.jsxs(ar, {
                                    children: [
                                      u.jsx(si, {
                                        children: u.jsx(Ti, {
                                          children: "General",
                                        }),
                                      }),
                                      u.jsx(or, {
                                        className: "space-y-4",
                                        children: u.jsxs("div", {
                                          className: "space-y-2",
                                          children: [
                                            u.jsx(vo, {
                                              htmlFor: "team-name",
                                              children: "Team Name",
                                            }),
                                            u.jsxs("div", {
                                              className: "flex gap-2",
                                              children: [
                                                u.jsx(ta, {
                                                  id: "team-name",
                                                  value: C,
                                                  onChange: (Z) =>
                                                    D(Z.target.value),
                                                  disabled:
                                                    g.current_user_role !==
                                                    "admin",
                                                }),
                                                g.current_user_role ===
                                                  "admin" &&
                                                  u.jsx(et, {
                                                    onClick: Q,
                                                    disabled: _ || C === g.name,
                                                    children: _
                                                      ? "Saving..."
                                                      : "Save",
                                                  }),
                                              ],
                                            }),
                                          ],
                                        }),
                                      }),
                                    ],
                                  }),
                                  u.jsxs(ar, {
                                    children: [
                                      u.jsxs(si, {
                                        children: [
                                          u.jsx(Ti, { children: "Members" }),
                                          u.jsxs(Ca, {
                                            children: [
                                              g.member_count,
                                              " member",
                                              g.member_count !== 1 ? "s" : "",
                                            ],
                                          }),
                                        ],
                                      }),
                                      u.jsxs(or, {
                                        children: [
                                          g.team_type === "pro_team" &&
                                            g.current_user_role === "admin" &&
                                            u.jsxs("div", {
                                              className:
                                                "space-y-4 pb-4 mb-4 border-b",
                                              children: [
                                                u.jsxs("div", {
                                                  className:
                                                    "flex items-center justify-between",
                                                  children: [
                                                    u.jsxs("div", {
                                                      className: "space-y-0.5",
                                                      children: [
                                                        u.jsx(vo, {
                                                          htmlFor:
                                                            "invite-toggle",
                                                          children:
                                                            "Enable Invite Link",
                                                        }),
                                                        u.jsx("p", {
                                                          className:
                                                            "text-sm text-muted-foreground",
                                                          children:
                                                            "Allow new members to join via invite link",
                                                        }),
                                                      ],
                                                    }),
                                                    u.jsx(RI, {
                                                      id: "invite-toggle",
                                                      checked: L,
                                                      onCheckedChange: async (
                                                        Z
                                                      ) => {
                                                        P(Z);
                                                        try {
                                                          await h(g.id, Z),
                                                            Xe.success(
                                                              Z
                                                                ? "Invite link enabled"
                                                                : "Invite link disabled"
                                                            );
                                                        } catch (te) {
                                                          P(!Z),
                                                            Xe.error(
                                                              "Failed to update invite settings"
                                                            ),
                                                            console.error(
                                                              "Error updating invite settings:",
                                                              te
                                                            );
                                                        }
                                                      },
                                                    }),
                                                  ],
                                                }),
                                                L &&
                                                  u.jsxs("div", {
                                                    className: "space-y-2",
                                                    children: [
                                                      u.jsx(vo, {
                                                        children: "Invite Link",
                                                      }),
                                                      u.jsxs("div", {
                                                        className: "flex gap-2",
                                                        children: [
                                                          u.jsx(ta, {
                                                            value: J(),
                                                            readOnly: !0,
                                                            className:
                                                              "font-mono text-sm",
                                                          }),
                                                          u.jsx(et, {
                                                            size: "icon",
                                                            variant: "outline",
                                                            onClick: Y,
                                                            children: u.jsx(
                                                              LH,
                                                              {
                                                                className:
                                                                  "h-4 w-4",
                                                              }
                                                            ),
                                                          }),
                                                        ],
                                                      }),
                                                    ],
                                                  }),
                                              ],
                                            }),
                                          u.jsx("div", {
                                            className: "space-y-2",
                                            children: g.members?.map((Z) =>
                                              u.jsxs(
                                                "div",
                                                {
                                                  className:
                                                    "flex items-center justify-between p-3 rounded-lg border",
                                                  children: [
                                                    u.jsxs("div", {
                                                      className:
                                                        "flex items-center gap-3",
                                                      children: [
                                                        u.jsx(Ng, {
                                                          user: {
                                                            id: Z.user_id,
                                                            full_name:
                                                              Z.user
                                                                ?.full_name ||
                                                              Z.display_name,
                                                            avatar_url:
                                                              Z.user
                                                                ?.avatar_url ||
                                                              Z.avatar_url,
                                                            email:
                                                              Z.user?.email ||
                                                              Z.email,
                                                          },
                                                          size: "sm",
                                                        }),
                                                        u.jsxs("div", {
                                                          children: [
                                                            u.jsx("p", {
                                                              className:
                                                                "font-medium",
                                                              children:
                                                                Z.user
                                                                  ?.full_name ||
                                                                Z.display_name ||
                                                                Z.user?.email ||
                                                                Z.email ||
                                                                "Team Member",
                                                            }),
                                                            u.jsx("p", {
                                                              className:
                                                                "text-sm text-muted-foreground",
                                                              children:
                                                                Z.user?.email ||
                                                                Z.email,
                                                            }),
                                                          ],
                                                        }),
                                                      ],
                                                    }),
                                                    u.jsxs("div", {
                                                      className:
                                                        "flex items-center gap-2",
                                                      children: [
                                                        Z.role === "admin" &&
                                                          u.jsxs(GA, {
                                                            variant:
                                                              "secondary",
                                                            children: [
                                                              u.jsx(Sle, {
                                                                className:
                                                                  "h-3 w-3 mr-1",
                                                              }),
                                                              "Admin",
                                                            ],
                                                          }),
                                                        g.current_user_role ===
                                                          "admin" &&
                                                          Z.user_id !== a?.id &&
                                                          Z.role !== "admin" &&
                                                          u.jsx(et, {
                                                            variant: "ghost",
                                                            size: "sm",
                                                            onClick: () =>
                                                              N({
                                                                id: Z.id,
                                                                name:
                                                                  Z.user
                                                                    ?.full_name ||
                                                                  Z.user
                                                                    ?.email ||
                                                                  Z.email ||
                                                                  "Team Member",
                                                              }),
                                                            children: u.jsx(
                                                              Ale,
                                                              {
                                                                className:
                                                                  "h-4 w-4",
                                                              }
                                                            ),
                                                          }),
                                                      ],
                                                    }),
                                                  ],
                                                },
                                                Z.id
                                              )
                                            ),
                                          }),
                                        ],
                                      }),
                                    ],
                                  }),
                                ],
                              })
                            : u.jsx("div", {
                                className: "text-center py-8",
                                children: u.jsx("p", {
                                  className: "text-muted-foreground",
                                  children: "No team selected",
                                }),
                              }),
                        ],
                      }),
                    b === "billing" &&
                      u.jsxs("div", {
                        className: "space-y-6",
                        children: [
                          u.jsxs("div", {
                            children: [
                              u.jsx("h2", {
                                className: "text-2xl font-semibold mb-1",
                                children: "Billing",
                              }),
                              u.jsx("p", {
                                className: "text-muted-foreground",
                                children:
                                  "Manage team subscription and billing",
                              }),
                            ],
                          }),
                          g
                            ? u.jsx(u.Fragment, {
                                children:
                                  g.team_type === "pro_team"
                                    ? u.jsxs(u.Fragment, {
                                        children: [
                                          u.jsxs(ar, {
                                            children: [
                                              u.jsxs(si, {
                                                children: [
                                                  u.jsx(Ti, {
                                                    children:
                                                      "Team Subscription",
                                                  }),
                                                  u.jsx(Ca, {
                                                    children:
                                                      "Manage your team's Pro subscription",
                                                  }),
                                                ],
                                              }),
                                              u.jsx(or, {
                                                children: u.jsxs("div", {
                                                  className: "space-y-4",
                                                  children: [
                                                    u.jsxs("div", {
                                                      className:
                                                        "grid grid-cols-2 gap-4",
                                                      children: [
                                                        u.jsxs("div", {
                                                          children: [
                                                            u.jsx("p", {
                                                              className:
                                                                "text-sm text-muted-foreground",
                                                              children: "Plan",
                                                            }),
                                                            u.jsx("p", {
                                                              className:
                                                                "font-medium",
                                                              children:
                                                                "Flask Pro",
                                                            }),
                                                          ],
                                                        }),
                                                        u.jsxs("div", {
                                                          children: [
                                                            u.jsx("p", {
                                                              className:
                                                                "text-sm text-muted-foreground",
                                                              children:
                                                                "Status",
                                                            }),
                                                            u.jsx(GA, {
                                                              variant:
                                                                g.subscription_status ===
                                                                "active"
                                                                  ? "default"
                                                                  : "secondary",
                                                              children:
                                                                g.subscription_status ||
                                                                "Inactive",
                                                            }),
                                                          ],
                                                        }),
                                                        u.jsxs("div", {
                                                          children: [
                                                            u.jsx("p", {
                                                              className:
                                                                "text-sm text-muted-foreground",
                                                              children: "Seats",
                                                            }),
                                                            u.jsxs("p", {
                                                              className:
                                                                "font-medium",
                                                              children: [
                                                                g.seat_count ||
                                                                  0,
                                                                " users",
                                                              ],
                                                            }),
                                                          ],
                                                        }),
                                                        u.jsxs("div", {
                                                          children: [
                                                            u.jsx("p", {
                                                              className:
                                                                "text-sm text-muted-foreground",
                                                              children:
                                                                "Billing Period",
                                                            }),
                                                            u.jsx("p", {
                                                              className:
                                                                "font-medium capitalize",
                                                              children:
                                                                g.billing_period ||
                                                                "N/A",
                                                            }),
                                                          ],
                                                        }),
                                                      ],
                                                    }),
                                                    g.current_period_end &&
                                                      u.jsxs("div", {
                                                        className:
                                                          "pt-4 border-t",
                                                        children: [
                                                          u.jsx("p", {
                                                            className:
                                                              "text-sm text-muted-foreground",
                                                            children:
                                                              "Next billing date",
                                                          }),
                                                          u.jsx("p", {
                                                            className:
                                                              "font-medium",
                                                            children: new Date(
                                                              g.current_period_end
                                                            ).toLocaleDateString(),
                                                          }),
                                                        ],
                                                      }),
                                                    g.current_user_role ===
                                                      "admin" &&
                                                      u.jsx("div", {
                                                        className:
                                                          "pt-4 border-t",
                                                        children: u.jsx(et, {
                                                          onClick: F,
                                                          disabled: z,
                                                          className: "w-full",
                                                          children: z
                                                            ? u.jsxs(
                                                                u.Fragment,
                                                                {
                                                                  children: [
                                                                    u.jsx(wo, {
                                                                      className:
                                                                        "h-4 w-4 mr-2 animate-spin",
                                                                    }),
                                                                    "Opening Portal...",
                                                                  ],
                                                                }
                                                              )
                                                            : u.jsxs(
                                                                u.Fragment,
                                                                {
                                                                  children: [
                                                                    u.jsx(DH, {
                                                                      className:
                                                                        "h-4 w-4 mr-2",
                                                                    }),
                                                                    "Manage Billing",
                                                                  ],
                                                                }
                                                              ),
                                                        }),
                                                      }),
                                                  ],
                                                }),
                                              }),
                                            ],
                                          }),
                                          g.current_user_role === "admin" &&
                                            u.jsxs("div", {
                                              className: "space-y-4",
                                              children: [
                                                u.jsx("div", {
                                                  className: "border-t pt-6",
                                                }),
                                                u.jsxs("div", {
                                                  className:
                                                    "rounded-lg border border-red-900/20 dark:border-red-900/50 bg-background p-4",
                                                  children: [
                                                    u.jsx("h4", {
                                                      className:
                                                        "text-red-500 dark:text-red-400 font-medium mb-2",
                                                      children: "Delete Team",
                                                    }),
                                                    u.jsxs("div", {
                                                      className:
                                                        "space-y-2 text-sm",
                                                      children: [
                                                        u.jsx("p", {
                                                          children:
                                                            "To delete this team, you need to cancel your subscription through the billing portal.",
                                                        }),
                                                        u.jsxs("p", {
                                                          className: "text-sm",
                                                          children: [
                                                            u.jsx("strong", {
                                                              children:
                                                                "Warning:",
                                                            }),
                                                            " Canceling your subscription will:",
                                                          ],
                                                        }),
                                                        u.jsxs("ul", {
                                                          className:
                                                            "text-sm list-disc list-inside ml-2 space-y-1",
                                                          children: [
                                                            u.jsx("li", {
                                                              children:
                                                                "Remove all team members except you",
                                                            }),
                                                            u.jsx("li", {
                                                              children:
                                                                "Revert the team to a free plan",
                                                            }),
                                                            u.jsx("li", {
                                                              children:
                                                                "Keep your flasks and data intact",
                                                            }),
                                                            u.jsx("li", {
                                                              children:
                                                                "Take effect at the end of your current billing period",
                                                            }),
                                                          ],
                                                        }),
                                                      ],
                                                    }),
                                                  ],
                                                }),
                                              ],
                                            }),
                                        ],
                                      })
                                    : u.jsxs(ar, {
                                        children: [
                                          u.jsxs(si, {
                                            children: [
                                              u.jsx(Ti, {
                                                children: "Free Team",
                                              }),
                                              u.jsx(Ca, {
                                                children:
                                                  "You're on the free plan",
                                              }),
                                            ],
                                          }),
                                          u.jsxs(or, {
                                            children: [
                                              u.jsx("p", {
                                                className:
                                                  "text-sm text-muted-foreground mb-4",
                                                children:
                                                  "Upgrade to Pro to unlock unlimited flasks, team collaboration, and more.",
                                              }),
                                              u.jsx(et, {
                                                onClick: () =>
                                                  (window.location.href =
                                                    "/#pricing"),
                                                className: "w-full",
                                                children: "Upgrade to Pro",
                                              }),
                                            ],
                                          }),
                                        ],
                                      }),
                              })
                            : u.jsx(ar, {
                                children: u.jsx(or, {
                                  className: "py-8",
                                  children: u.jsx("p", {
                                    className:
                                      "text-center text-muted-foreground",
                                    children: "No team selected",
                                  }),
                                }),
                              }),
                        ],
                      }),
                    b === "notifications" &&
                      u.jsxs("div", {
                        className: "space-y-6",
                        children: [
                          u.jsxs("div", {
                            children: [
                              u.jsx("h2", {
                                className: "text-2xl font-semibold mb-1",
                                children: "Notifications",
                              }),
                              u.jsx("p", {
                                className: "text-muted-foreground",
                                children:
                                  "Manage your notification preferences",
                              }),
                            ],
                          }),
                          u.jsxs(ar, {
                            children: [
                              u.jsxs(si, {
                                children: [
                                  u.jsx(Ti, {
                                    children: "Email Notifications",
                                  }),
                                  u.jsx(Ca, {
                                    children:
                                      "Get notified about activity on your flasks",
                                  }),
                                ],
                              }),
                              u.jsx(or, {
                                children: u.jsxs("div", {
                                  className:
                                    "flex items-center justify-between",
                                  children: [
                                    u.jsxs("div", {
                                      className: "space-y-0.5",
                                      children: [
                                        u.jsx(vo, {
                                          htmlFor: "email-notifications",
                                          children: "Email Notifications",
                                        }),
                                        u.jsx("p", {
                                          className:
                                            "text-sm text-muted-foreground",
                                          children:
                                            "Receive email notifications when others comment on your flasks",
                                        }),
                                      ],
                                    }),
                                    u.jsx(RI, {
                                      id: "email-notifications",
                                      checked: q,
                                      disabled: U,
                                      onCheckedChange: I,
                                    }),
                                  ],
                                }),
                              }),
                            ],
                          }),
                        ],
                      }),
                  ],
                }),
              }),
            ],
          }),
        }),
        u.jsx(os, {
          open: !!V,
          onOpenChange: () => N(null),
          children: u.jsxs(Jn, {
            children: [
              u.jsxs(bs, {
                children: [
                  u.jsx(xs, { children: "Remove Team Member" }),
                  u.jsxs(Cl, {
                    children: [
                      "Are you sure you want to remove ",
                      V?.name,
                      " from the team? They will lose access to all team resources.",
                    ],
                  }),
                ],
              }),
              u.jsxs(xr, {
                children: [
                  u.jsx(et, {
                    variant: "outline",
                    onClick: () => N(null),
                    children: "Cancel",
                  }),
                  u.jsx(et, {
                    variant: "destructive",
                    onClick: M,
                    disabled: W,
                    children: W ? "Removing..." : "Remove Member",
                  }),
                ],
              }),
            ],
          }),
        }),
      ],
    });
  },
  OMe = () => {
    const [n, e] = od();
    es();
    const { user: t } = ks();
    Sv(t?.id);
    const s = Pt((p) => p.currentTeam),
      r = Pt((p) => p.isLoadingTeams),
      i = Pt((p) => p.refreshCurrentTeam),
      [a, o] = E.useState(!1),
      [l, c] = E.useState("team");
    E.useEffect(() => {
      if (n.get("session_id")) {
        const g = new URLSearchParams(n);
        g.delete("session_id"), e(g, { replace: !0 });
      }
    }, []),
      E.useEffect(() => {
        const p = n.get("settings");
        p
          ? (o(!0),
            c(
              ["team", "account", "billing", "notifications"].includes(p)
                ? p
                : "team"
            ),
            t && !r && i())
          : o(!1);
      }, [n, t, i, r]);
    const h = E.useCallback(
        (p) => {
          c(p);
          const g = new URLSearchParams(n);
          g.set("settings", p), e(g, { replace: !0 });
        },
        [n, e]
      ),
      m = (p) => {
        if (!p) {
          const g = new URLSearchParams(n);
          g.delete("settings"), e(g, { replace: !0 });
        }
        o(p);
      };
    return (
      E.useEffect(() => {
        (async () => {
          if (n.get("from_checkout") === "true" && t && !s) {
            let y = 0;
            const b = 10,
              w = async () => {
                y >= b || (y++, await i(), !s && y < b && setTimeout(w, 1e3));
              };
            await w();
            const S = new URLSearchParams(n);
            S.delete("from_checkout"), e(S, { replace: !0 });
          }
        })();
      }, [n, t, s, i]),
      a
        ? u.jsx(NMe, {
            open: a,
            onOpenChange: m,
            currentTeam: s ? { id: s.id, name: s.name } : null,
            defaultTab: l,
            onTabChange: h,
            isLoadingTeam: r,
          })
        : null
    );
  },
  Q5 = ({ children: n }) => {
    const { user: e, isLoading: t, isInitialized: s } = ks(),
      r = Dr();
    if (!s || t)
      return u.jsx("div", {
        className: "min-h-screen bg-card-background relative",
      });
    if (!e) {
      if (r.pathname === "/login") return u.jsx(u.Fragment, { children: n });
      const i = r.pathname === "/dash" ? "/dash" : r.pathname + r.search;
      return u.jsx(Vee, {
        to: `/login?returnUrl=${encodeURIComponent(i)}`,
        replace: !0,
      });
    }
    return u.jsx(u.Fragment, { children: n });
  },
  jMe = new Vte({
    defaultOptions: {
      queries: { staleTime: 1e3 * 60 * 5, refetchOnWindowFocus: !1 },
    },
  });
function FMe() {
  const n = Dr();
  return (
    E.useEffect(() => {
      typeof window < "u" && Sc && Sc.capture("$pageview");
    }, [n]),
    null
  );
}
function UMe() {
  return typeof window < "u" && window.location.hostname === "app.flask.do"
    ? (window.location.replace(
        `https://flask.do${window.location.pathname}${window.location.search}${window.location.hash}`
      ),
      null)
    : u.jsx(Wte, {
        client: jMe,
        children: u.jsxs(pte, {
          children: [
            u.jsx(FMe, {}),
            u.jsx(Pne, {
              baseColor: "rgba(255, 255, 255, 0.1)",
              highlightColor: "rgba(255, 255, 255, 0.2)",
              children: u.jsxs(kMe, {
                children: [
                  u.jsxs(Gee, {
                    children: [
                      u.jsx(Yr, { path: "/", element: u.jsx(_ue, {}) }),
                      u.jsx(Yr, {
                        path: "/dash",
                        element: u.jsx(Q5, { children: u.jsx(T0e, {}) }),
                      }),
                      u.jsx(Yr, { path: "/login", element: u.jsx(R0e, {}) }),
                      u.jsx(Yr, {
                        path: "/auth/callback",
                        element: u.jsx(wMe, {}),
                      }),
                      u.jsx(Yr, {
                        path: "/flask/:id",
                        element: u.jsx($De, {}),
                      }),
                      u.jsx(Yr, {
                        path: "/invite/:inviteCode",
                        element: u.jsx(mMe, {}),
                      }),
                      u.jsx(Yr, {
                        path: "/manifesto",
                        element: u.jsx(pMe, {}),
                      }),
                      u.jsx(Yr, {
                        path: "/privacy-policy",
                        element: u.jsx(gMe, {}),
                      }),
                      u.jsx(Yr, {
                        path: "/terms-of-service",
                        element: u.jsx(vMe, {}),
                      }),
                      u.jsx(Yr, { path: "/newteam", element: u.jsx(yMe, {}) }),
                      u.jsx(Yr, { path: "/launch", element: u.jsx(EMe, {}) }),
                      u.jsx(Yr, {
                        path: "/kingofflask",
                        element: u.jsx(Q5, { children: u.jsx(_Me, {}) }),
                      }),
                      u.jsx(Yr, { path: "*", element: u.jsx(xMe, {}) }),
                    ],
                  }),
                  u.jsx(OMe, {}),
                  u.jsx(Lne, {
                    position: "bottom-left",
                    theme: "dark",
                    toastOptions: {
                      style: {
                        background: "#09090B",
                        color: "rgb(244, 244, 245)",
                        border: "1px solid hsl(240 3.7% 15.9%)",
                        borderRadius: "9999px",
                        fontSize: "14px",
                        padding: "12px 20px",
                      },
                    },
                  }),
                ],
              }),
            }),
          ],
        }),
      });
}
RJ.createRoot(document.getElementById("root")).render(
  u.jsx(a6, { children: u.jsx(UMe, {}) })
);
